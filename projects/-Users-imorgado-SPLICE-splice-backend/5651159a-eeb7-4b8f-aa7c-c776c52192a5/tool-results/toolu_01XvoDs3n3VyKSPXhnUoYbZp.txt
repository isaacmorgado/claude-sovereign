     1→/**
     2→ * Settings Management
     3→ *
     4→ * Persists user preferences to localStorage
     5→ * v3.5: Added Persistent Token support for media folder access
     6→ */
     7→
     8→const uxpFs = require('uxp').storage.localFileSystem;
     9→
    10→// =============================================================================
    11→// CUSTOM PRESETS STORAGE (v3.5+)
    12→// =============================================================================
    13→
    14→const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';
    15→
    16→/**
    17→ * Default structure for custom presets storage
    18→ */
    19→const DEFAULT_CUSTOM_PRESETS = {
    20→  version: 1,
    21→  presets: {},
    22→  order: []
    23→};
    24→
    25→/**
    26→ * Load custom presets from localStorage
    27→ * @returns {Object} Custom presets data structure
    28→ */
    29→function loadCustomPresets() {
    30→  try {
    31→    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    32→    if (saved) {
    33→      const parsed = JSON.parse(saved);
    34→      // Validate structure
    35→      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
    36→        // Return deep copy to avoid mutation issues
    37→        return {
    38→          version: parsed.version || 1,
    39→          presets: { ...parsed.presets },
    40→          order: [...(parsed.order || [])]
    41→        };
    42→      }
    43→    }
    44→  } catch (e) {
    45→    console.warn('[SPLICE] Could not load custom presets:', e);
    46→  }
    47→  // Return fresh objects to avoid mutation of defaults
    48→  return {
    49→    version: 1,
    50→    presets: {},
    51→    order: []
    52→  };
    53→}
    54→
    55→/**
    56→ * Save custom presets to localStorage
    57→ * @param {Object} data - Custom presets data structure
    58→ * @returns {boolean} Success status
    59→ */
    60→function saveCustomPresets(data) {
    61→  try {
    62→    if (!data || typeof data !== 'object') {
    63→      console.warn('[SPLICE] Invalid custom presets data');
    64→      return false;
    65→    }
    66→    // Ensure required fields
    67→    const toSave = {
    68→      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
    69→      presets: data.presets || {},
    70→      order: data.order || []
    71→    };
    72→    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    73→    return true;
    74→  } catch (e) {
    75→    console.warn('[SPLICE] Could not save custom presets:', e);
    76→    return false;
    77→  }
    78→}
    79→
    80→/**
    81→ * Generate a slugified ID from a preset name
    82→ * @param {string} name - Preset name
    83→ * @returns {string} Slugified ID
    84→ */
    85→function slugifyPresetName(name) {
    86→  return name
    87→    .toLowerCase()
    88→    .trim()
    89→    .replace(/[^a-z0-9]+/g, '-')
    90→    .replace(/^-+|-+$/g, '')
    91→    .substring(0, 50) || 'preset';
    92→}
    93→
    94→/**
    95→ * Generate a unique ID for a custom preset
    96→ * @param {string} baseName - Base name to slugify
    97→ * @param {Object} existingPresets - Current presets object
    98→ * @returns {string} Unique ID
    99→ */
   100→function generateUniquePresetId(baseName, existingPresets) {
   101→  const baseId = slugifyPresetName(baseName);
   102→  let id = baseId;
   103→  let counter = 1;
   104→
   105→  while (existingPresets[id]) {
   106→    id = `${baseId}-${counter}`;
   107→    counter++;
   108→  }
   109→
   110→  return id;
   111→}
   112→
   113→/**
   114→ * Create a new custom preset
   115→ * @param {Object} preset - Preset data
   116→ * @param {string} preset.name - Preset name (required)
   117→ * @param {string} [preset.description] - Preset description
   118→ * @param {string} [preset.icon] - Icon name (default: 'settings')
   119→ * @param {Object} [preset.settings] - Preset settings (uses current if not provided)
   120→ * @returns {{success: boolean, id?: string, error?: string}}
   121→ */
   122→function createCustomPreset(preset) {
   123→  // Validate input
   124→  if (!preset || typeof preset !== 'object') {
   125→    return { success: false, error: 'Invalid preset data' };
   126→  }
   127→
   128→  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {
   129→    return { success: false, error: 'Preset name is required' };
   130→  }
   131→
   132→  const name = preset.name.trim();
   133→
   134→  // Load current data
   135→  const data = loadCustomPresets();
   136→
   137→  // Generate unique ID
   138→  const id = generateUniquePresetId(name, data.presets);
   139→
   140→  // Get settings from preset or current settings
   141→  const settings = preset.settings && typeof preset.settings === 'object'
   142→    ? { ...preset.settings }
   143→    : getCurrentPresetSettings();
   144→
   145→  // Validate settings
   146→  if (!settings || typeof settings !== 'object') {
   147→    return { success: false, error: 'Invalid settings' };
   148→  }
   149→
   150→  // Create the preset object
   151→  const newPreset = {
   152→    id,
   153→    name,
   154→    description: preset.description || '',
   155→    icon: preset.icon || 'settings',
   156→    createdAt: new Date().toISOString(),
   157→    settings
   158→  };
   159→
   160→  // Add to presets and order
   161→  data.presets[id] = newPreset;
   162→  data.order.push(id);
   163→
   164→  // Save
   165→  const saved = saveCustomPresets(data);
   166→  if (!saved) {
   167→    return { success: false, error: 'Failed to save preset' };
   168→  }
   169→
   170→  console.log(`[SPLICE] Created custom preset: ${name} (${id})`);
   171→
   172→  // Refresh preset dropdown if available
   173→  if (typeof populatePresetDropdown === 'function') {
   174→    populatePresetDropdown(id);
   175→  }
   176→
   177→  return { success: true, id };
   178→}
   179→
   180→/**
   181→ * Get current settings suitable for a preset
   182→ * @returns {Object} Current preset-compatible settings
   183→ */
   184→function getCurrentPresetSettings() {
   185→  const current = typeof getSettings === 'function' ? getSettings() : {};
   186→  return {
   187→    sensitivity: current.sensitivity || 50,
   188→    threshold: current.threshold || -32,
   189→    minSilenceLength: current.minSilenceLength || 0.5,
   190→    paddingStart: current.paddingStart || 0.1,
   191→    paddingEnd: current.paddingEnd || 0.1,
   192→    autoMarkBest: current.autoMarkBest !== false,
   193→    enableTakesDetection: current.enableTakesDetection !== false
   194→  };
   195→}
   196→
   197→/**
   198→ * Update an existing custom preset
   199→ * @param {string} id - Preset ID to update
   200→ * @param {Object} updates - Fields to update
   201→ * @param {string} [updates.name] - New name
   202→ * @param {string} [updates.description] - New description
   203→ * @param {string} [updates.icon] - New icon
   204→ * @param {Object} [updates.settings] - New settings (merged with existing)
   205→ * @returns {{success: boolean, error?: string}}
   206→ */
   207→function updateCustomPreset(id, updates) {
   208→  // Validate input
   209→  if (!id || typeof id !== 'string') {
   210→    return { success: false, error: 'Preset ID is required' };
   211→  }
   212→
   213→  if (!updates || typeof updates !== 'object') {
   214→    return { success: false, error: 'Updates must be an object' };
   215→  }
   216→
   217→  // Load current data
   218→  const data = loadCustomPresets();
   219→
   220→  // Check if preset exists
   221→  if (!data.presets[id]) {
   222→    return { success: false, error: 'Preset not found' };
   223→  }
   224→
   225→  const existing = data.presets[id];
   226→
   227→  // Apply updates (preserve fields not being updated)
   228→  const updated = {
   229→    ...existing,
   230→    updatedAt: new Date().toISOString()
   231→  };
   232→
   233→  // Update name (with validation)
   234→  if (updates.name !== undefined) {
   235→    if (typeof updates.name !== 'string' || !updates.name.trim()) {
   236→      return { success: false, error: 'Name must be a non-empty string' };
   237→    }
   238→    updated.name = updates.name.trim();
   239→  }
   240→
   241→  // Update description
   242→  if (updates.description !== undefined) {
   243→    updated.description = String(updates.description);
   244→  }
   245→
   246→  // Update icon
   247→  if (updates.icon !== undefined) {
   248→    updated.icon = String(updates.icon);
   249→  }
   250→
   251→  // Update settings (merge with existing)
   252→  if (updates.settings !== undefined) {
   253→    if (typeof updates.settings !== 'object') {
   254→      return { success: false, error: 'Settings must be an object' };
   255→    }
   256→    updated.settings = {
   257→      ...existing.settings,
   258→      ...updates.settings
   259→    };
   260→  }
   261→
   262→  // Save updated preset
   263→  data.presets[id] = updated;
   264→
   265→  const saved = saveCustomPresets(data);
   266→  if (!saved) {
   267→    return { success: false, error: 'Failed to save preset' };
   268→  }
   269→
   270→  console.log(`[SPLICE] Updated custom preset: ${updated.name} (${id})`);
   271→  return { success: true };
   272→}
   273→
   274→/**
   275→ * Get a custom preset by ID
   276→ * @param {string} id - Preset ID
   277→ * @returns {Object|null} Preset object or null if not found
   278→ */
   279→function getCustomPreset(id) {
   280→  if (!id || typeof id !== 'string') {
   281→    return null;
   282→  }
   283→
   284→  const data = loadCustomPresets();
   285→  return data.presets[id] || null;
   286→}
   287→
   288→/**
   289→ * Duplicate a custom preset
   290→ * @param {string} id - Preset ID to duplicate
   291→ * @returns {{success: boolean, id?: string, error?: string}}
   292→ */
   293→function duplicatePreset(id) {
   294→  // Validate input
   295→  if (!id || typeof id !== 'string') {
   296→    return { success: false, error: 'Preset ID is required' };
   297→  }
   298→
   299→  // Get the original preset
   300→  const original = getPresetById(id);
   301→  if (!original) {
   302→    return { success: false, error: 'Preset not found' };
   303→  }
   304→
   305→  // Generate new name with copy suffix
   306→  let copyName = `${original.name} (Copy)`;
   307→
   308→  // Check if copy name already exists and increment if needed
   309→  const data = loadCustomPresets();
   310→  let copyNumber = 1;
   311→  let testId = slugifyPresetName(copyName);
   312→  while (data.presets[testId]) {
   313→    copyNumber++;
   314→    copyName = `${original.name} (Copy ${copyNumber})`;
   315→    testId = slugifyPresetName(copyName);
   316→  }
   317→
   318→  // Create the duplicate
   319→  return createCustomPreset({
   320→    name: copyName,
   321→    description: original.description || '',
   322→    icon: original.icon || 'settings',
   323→    settings: original.settings ? { ...original.settings } : getCurrentPresetSettings()
   324→  });
   325→}
   326→
   327→/**
   328→ * Export all custom presets to JSON string
   329→ * @returns {{success: boolean, data?: string, count?: number, error?: string}}
   330→ */
   331→function exportPresets() {
   332→  try {
   333→    const data = loadCustomPresets();
   334→    const customPresets = data.order.map(id => data.presets[id]).filter(Boolean);
   335→
   336→    if (customPresets.length === 0) {
   337→      return { success: false, error: 'No custom presets to export' };
   338→    }
   339→
   340→    const exportData = {
   341→      version: 1,
   342→      exportedAt: new Date().toISOString(),
   343→      presets: customPresets
   344→    };
   345→
   346→    return {
   347→      success: true,
   348→      data: JSON.stringify(exportData, null, 2),
   349→      count: customPresets.length
   350→    };
   351→  } catch (e) {
   352→    return { success: false, error: 'Failed to export presets: ' + e.message };
   353→  }
   354→}
   355→
   356→/**
   357→ * Import presets from JSON string
   358→ * @param {string} jsonString - JSON string containing presets
   359→ * @param {boolean} merge - If true, merge with existing; if false, skip duplicates
   360→ * @returns {{success: boolean, imported?: number, skipped?: number, error?: string}}
   361→ */
   362→function importPresets(jsonString, merge = true) {
   363→  try {
   364→    // Parse JSON
   365→    const imported = JSON.parse(jsonString);
   366→
   367→    // Validate structure
   368→    if (!imported || !imported.presets || !Array.isArray(imported.presets)) {
   369→      return { success: false, error: 'Invalid preset file format' };
   370→    }
   371→
   372→    let importedCount = 0;
   373→    let skippedCount = 0;
   374→
   375→    for (const preset of imported.presets) {
   376→      // Validate each preset has required fields
   377→      if (!preset.name || typeof preset.name !== 'string') {
   378→        skippedCount++;
   379→        continue;
   380→      }
   381→
   382→      // Check if a preset with this name already exists
   383→      const existingId = slugifyPresetName(preset.name);
   384→      const existing = getCustomPreset(existingId);
   385→
   386→      if (existing && !merge) {
   387→        // Skip existing if not merging
   388→        skippedCount++;
   389→        continue;
   390→      }
   391→
   392→      // If existing and merge mode, create with unique name
   393→      if (existing && merge) {
   394→        let newName = `${preset.name} (Imported)`;
   395→        let counter = 1;
   396→        while (getCustomPreset(slugifyPresetName(newName))) {
   397→          counter++;
   398→          newName = `${preset.name} (Imported ${counter})`;
   399→        }
   400→        preset.name = newName;
   401→      }
   402→
   403→      // Create the preset
   404→      const result = createCustomPreset({
   405→        name: preset.name,
   406→        description: preset.description || '',
   407→        icon: preset.icon || 'settings',
   408→        settings: preset.settings || getCurrentPresetSettings()
   409→      });
   410→
   411→      if (result.success) {
   412→        importedCount++;
   413→      } else {
   414→        skippedCount++;
   415→      }
   416→    }
   417→
   418→    if (importedCount === 0 && skippedCount > 0) {
   419→      return { success: false, error: 'All presets already exist or were invalid', skipped: skippedCount };
   420→    }
   421→
   422→    return {
   423→      success: true,
   424→      imported: importedCount,
   425→      skipped: skippedCount
   426→    };
   427→  } catch (e) {
   428→    if (e instanceof SyntaxError) {
   429→      return { success: false, error: 'Invalid JSON format' };
   430→    }
   431→    return { success: false, error: 'Failed to import presets: ' + e.message };
   432→  }
   433→}
   434→
   435→/**
   436→ * Delete a custom preset
   437→ * @param {string} id - Preset ID to delete
   438→ * @returns {{success: boolean, error?: string}}
   439→ */
   440→function deleteCustomPreset(id) {
   441→  // Validate input
   442→  if (!id || typeof id !== 'string') {
   443→    return { success: false, error: 'Preset ID is required' };
   444→  }
   445→
   446→  // Load current data
   447→  const data = loadCustomPresets();
   448→
   449→  // Check if preset exists
   450→  if (!data.presets[id]) {
   451→    return { success: false, error: 'Preset not found' };
   452→  }
   453→
   454→  const presetName = data.presets[id].name;
   455→
   456→  // Remove from presets object
   457→  delete data.presets[id];
   458→
   459→  // Remove from order array
   460→  const orderIndex = data.order.indexOf(id);
   461→  if (orderIndex !== -1) {
   462→    data.order.splice(orderIndex, 1);
   463→  }
   464→
   465→  // Save
   466→  const saved = saveCustomPresets(data);
   467→  if (!saved) {
   468→    return { success: false, error: 'Failed to save after deletion' };
   469→  }
   470→
   471→  console.log(`[SPLICE] Deleted custom preset: ${presetName} (${id})`);
   472→
   473→  // Refresh preset dropdown if available
   474→  if (typeof populatePresetDropdown === 'function') {
   475→    // Reset to custom if deleted preset was selected
   476→    const settings = getSettings();
   477→    const selectedPreset = settings.activePreset === id ? 'custom' : settings.activePreset;
   478→    populatePresetDropdown(selectedPreset);
   479→  }
   480→
   481→  return { success: true };
   482→}
   483→
   484→/**
   485→ * List of built-in preset IDs (cannot be modified or deleted)
   486→ */
   487→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];
   488→
   489→/**
   490→ * Check if a preset is a built-in preset
   491→ * @param {string} id - Preset ID to check
   492→ * @returns {boolean} True if built-in, false if custom
   493→ */
   494→function isBuiltInPreset(id) {
   495→  return BUILT_IN_PRESET_IDS.includes(id);
   496→}
   497→
   498→/**
   499→ * Get all presets (built-in + custom merged)
   500→ * Built-in presets appear first, then custom presets in their creation order.
   501→ * Each preset has isBuiltIn flag added.
   502→ *
   503→ * @returns {Array<Object>} Array of preset objects with metadata
   504→ */
   505→function getAllPresets() {
   506→  // Get built-in presets
   507→  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {
   508→    const preset = PRESETS[id];
   509→    return {
   510→      id,
   511→      name: preset.name,
   512→      description: preset.description,
   513→      icon: preset.icon,
   514→      settings: preset.settings,
   515→      isBuiltIn: true
   516→    };
   517→  });
   518→
   519→  // Get custom presets
   520→  const customData = loadCustomPresets();
   521→  const customPresets = customData.order.map(id => {
   522→    const preset = customData.presets[id];
   523→    if (!preset) return null;
   524→    return {
   525→      ...preset,
   526→      isBuiltIn: false
   527→    };
   528→  }).filter(Boolean);
   529→
   530→  // Merge: built-in first, then custom
   531→  return [...builtInPresets, ...customPresets];
   532→}
   533→
   534→/**
   535→ * Get all preset IDs (built-in + custom)
   536→ * @returns {Array<string>} Array of preset IDs
   537→ */
   538→function getAllPresetIds() {
   539→  const customData = loadCustomPresets();
   540→  return [...BUILT_IN_PRESET_IDS, ...customData.order];
   541→}
   542→
   543→/**
   544→ * Get a preset by ID (built-in or custom)
   545→ * @param {string} id - Preset ID
   546→ * @returns {Object|null} Preset object or null if not found
   547→ */
   548→function getPresetById(id) {
   549→  if (!id || typeof id !== 'string') {
   550→    return null;
   551→  }
   552→
   553→  // Check built-in first
   554→  if (isBuiltInPreset(id)) {
   555→    const preset = PRESETS[id];
   556→    return {
   557→      id,
   558→      name: preset.name,
   559→      description: preset.description,
   560→      icon: preset.icon,
   561→      settings: preset.settings,
   562→      isBuiltIn: true
   563→    };
   564→  }
   565→
   566→  // Check custom presets
   567→  const custom = getCustomPreset(id);
   568→  if (custom) {
   569→    return {
   570→      ...custom,
   571→      isBuiltIn: false
   572→    };
   573→  }
   574→
   575→  return null;
   576→}
   577→
   578→const DEFAULT_SETTINGS = {
   579→  sensitivity: 50,
   580→  audioSource: 'original',
   581→  autoMarkBest: true,
   582→  enableTakesDetection: true,
   583→  rememberOptions: false,
   584→  optionsExpanded: false,
   585→  customerId: null,          // Stripe customer ID for billing
   586→  mediaFolderToken: null,    // Persistent token for media folder access
   587→  mediaFolderPath: null,     // Path to the media folder (for display)
   588→  activePreset: 'custom'     // Currently active preset
   589→};
   590→
   591→// =============================================================================
   592→// PRESET PROFILES
   593→// =============================================================================
   594→
   595→/**
   596→ * Detection presets for different content types.
   597→ * Each preset defines optimal settings for a specific use case.
   598→ */
   599→const PRESETS = {
   600→  // Custom - user-defined settings (default)
   601→  custom: {
   602→    name: 'Custom',
   603→    description: 'Your custom settings',
   604→    icon: 'settings',
   605→    settings: null // Uses current user settings
   606→  },
   607→
   608→  // Podcast - longer pauses are natural, be conservative
   609→  // J-Cut enabled by default for natural audio transitions
   610→  podcast: {
   611→    name: 'Podcast',
   612→    description: 'Longer natural pauses, J-Cuts enabled',
   613→    icon: 'mic',
   614→    settings: {
   615→      sensitivity: 35,           // Lower sensitivity (fewer cuts)
   616→      threshold: -35,            // Higher threshold (only deep silence)
   617→      minSilenceLength: 0.8,     // Longer minimum silence
   618→      paddingStart: 0.15,        // More padding for natural transitions
   619→      paddingEnd: 0.15,
   620→      mergeDistance: 0.3,        // Merge nearby silences
   621→      autoMarkBest: false,       // Don't auto-mark (manual review)
   622→      enableTakesDetection: true,
   623→      // Phase 1: J-Cut settings for natural audio transitions
   624→      enableJCut: true,
   625→      jCutLeadIn: 0.3,           // Audio leads 0.3s before video
   626→      jCutLeadOut: 0.2           // Audio extends 0.2s after video
   627→    }
   628→  },
   629→
   630→  // Interview - balanced, respects speaker pauses
   631→  // J-Cut enabled for smooth speaker transitions
   632→  interview: {
   633→    name: 'Interview',
   634→    description: 'Balanced cuts, J-Cuts for smooth transitions',
   635→    icon: 'people',
   636→    settings: {
   637→      sensitivity: 50,           // Medium sensitivity
   638→      threshold: -32,            // Moderate threshold
   639→      minSilenceLength: 0.5,     // Standard minimum silence
   640→      paddingStart: 0.12,        // Moderate padding
   641→      paddingEnd: 0.08,
   642→      mergeDistance: 0.2,
   643→      autoMarkBest: true,
   644→      enableTakesDetection: true,
   645→      // Phase 1: J-Cut settings for speaker transitions
   646→      enableJCut: true,
   647→      jCutLeadIn: 0.25,          // Audio leads 0.25s before video
   648→      jCutLeadOut: 0.15          // Audio extends 0.15s after video
   649→    }
   650→  },
   651→
   652→  // Reaction video - fast pacing, quick cuts
   653→  // J-Cut disabled - tight cuts for energy
   654→  reaction: {
   655→    name: 'Reaction',
   656→    description: 'Fast-paced, tight cuts for energy',
   657→    icon: 'bolt',
   658→    settings: {
   659→      sensitivity: 70,           // Higher sensitivity (more cuts)
   660→      threshold: -28,            // Lower threshold (catches more silence)
   661→      minSilenceLength: 0.3,     // Short minimum silence
   662→      paddingStart: 0.05,        // Minimal padding for snappy edits
   663→      paddingEnd: 0.03,
   664→      mergeDistance: 0.15,
   665→      autoMarkBest: true,
   666→      enableTakesDetection: false, // Usually single-take content
   667→      // Phase 1: J-Cut disabled for tight cuts
   668→      enableJCut: false,
   669→      jCutLeadIn: 0,
   670→      jCutLeadOut: 0
   671→    }
   672→  },
   673→
   674→  // Tutorial/Educational - preserve thinking pauses
   675→  // J-Cut enabled for natural teaching pace
   676→  tutorial: {
   677→    name: 'Tutorial',
   678→    description: 'Preserves teaching pace, J-Cuts enabled',
   679→    icon: 'school',
   680→    settings: {
   681→      sensitivity: 30,           // Low sensitivity
   682→      threshold: -38,            // Only deep silence
   683→      minSilenceLength: 1.0,     // Long minimum (preserve demo pauses)
   684→      paddingStart: 0.2,         // Extra padding for clarity
   685→      paddingEnd: 0.15,
   686→      mergeDistance: 0.4,
   687→      autoMarkBest: false,
   688→      enableTakesDetection: true,
   689→      // Phase 1: J-Cut settings for natural teaching flow
   690→      enableJCut: true,
   691→      jCutLeadIn: 0.35,          // Audio leads 0.35s before video
   692→      jCutLeadOut: 0.25          // Audio extends 0.25s after video
   693→    }
   694→  },
   695→
   696→  // Vlog/YouTube - punchy edits, engagement-focused
   697→  // J-Cut disabled for punchy cuts
   698→  vlog: {
   699→    name: 'Vlog',
   700→    description: 'Punchy edits for YouTube engagement',
   701→    icon: 'videocam',
   702→    settings: {
   703→      sensitivity: 65,           // Higher sensitivity
   704→      threshold: -30,            // Moderate-low threshold
   705→      minSilenceLength: 0.35,    // Short silences
   706→      paddingStart: 0.08,        // Quick transitions
   707→      paddingEnd: 0.05,
   708→      mergeDistance: 0.2,
   709→      autoMarkBest: true,
   710→      enableTakesDetection: true,
   711→      // Phase 1: J-Cut disabled for punchy cuts
   712→      enableJCut: false,
   713→      jCutLeadIn: 0,
   714→      jCutLeadOut: 0
   715→    }
   716→  }
   717→};
   718→
   719→/**
   720→ * Get all available presets
   721→ * @returns {Object} All preset definitions
   722→ */
   723→function getPresets() {
   724→  return { ...PRESETS };
   725→}
   726→
   727→/**
   728→ * Get a specific preset by name
   729→ * @param {string} presetName - Name of the preset
   730→ * @returns {Object|null} Preset definition or null if not found
   731→ */
   732→function getPreset(presetName) {
   733→  return PRESETS[presetName] || null;
   734→}
   735→
   736→/**
   737→ * Get preset names as array (for UI)
   738→ * @returns {Array<string>} Array of preset names
   739→ */
   740→function getPresetNames() {
   741→  return Object.keys(PRESETS);
   742→}
   743→
   744→/**
   745→ * Apply a preset to current settings
   746→ * @param {string} presetName - Name of the preset to apply
   747→ * @returns {Object} The applied settings
   748→ */
   749→function applyPreset(presetName) {
   750→  const preset = PRESETS[presetName];
   751→
   752→  if (!preset) {
   753→    console.warn(`[SPLICE] Unknown preset: ${presetName}`);
   754→    return getSettings();
   755→  }
   756→
   757→  // Custom preset uses current settings
   758→  if (presetName === 'custom' || !preset.settings) {
   759→    saveSettings({ activePreset: 'custom' });
   760→    return getSettings();
   761→  }
   762→
   763→  // Apply preset settings
   764→  const newSettings = {
   765→    ...preset.settings,
   766→    activePreset: presetName
   767→  };
   768→
   769→  saveSettings(newSettings);
   770→  console.log(`[SPLICE] Applied preset: ${preset.name}`);
   771→
   772→  return getSettings();
   773→}
   774→
   775→/**
   776→ * Get the currently active preset
   777→ * @returns {string} Active preset name
   778→ */
   779→function getActivePreset() {
   780→  const settings = getSettings();
   781→  return settings.activePreset || 'custom';
   782→}
   783→
   784→/**
   785→ * Check if current settings match a preset
   786→ * @param {string} presetName - Preset to compare against
   787→ * @returns {boolean} True if settings match the preset
   788→ */
   789→function settingsMatchPreset(presetName) {
   790→  const preset = PRESETS[presetName];
   791→  if (!preset || !preset.settings) return presetName === 'custom';
   792→
   793→  const current = getSettings();
   794→
   795→  // Compare relevant settings
   796→  return Object.keys(preset.settings).every(key => {
   797→    if (key === 'activePreset') return true;
   798→    return current[key] === preset.settings[key];
   799→  });
   800→}
   801→
   802→let currentSettings = { ...DEFAULT_SETTINGS };
   803→
   804→/**
   805→ * Load settings from localStorage
   806→ */
   807→function loadSettings() {
   808→  try {
   809→    const saved = localStorage.getItem('spliceSettings');
   810→    if (saved) {
   811→      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
   812→    }
   813→  } catch (e) {
   814→    console.warn('[SPLICE] Could not load settings:', e);
   815→    currentSettings = { ...DEFAULT_SETTINGS };
   816→  }
   817→  return currentSettings;
   818→}
   819→
   820→/**
   821→ * Save settings to localStorage
   822→ */
   823→function saveSettings(settings) {
   824→  try {
   825→    currentSettings = { ...currentSettings, ...settings };
   826→    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
   827→  } catch (e) {
   828→    console.warn('[SPLICE] Could not save settings:', e);
   829→  }
   830→}
   831→
   832→/**
   833→ * Get current settings
   834→ */
   835→function getSettings() {
   836→  return { ...currentSettings };
   837→}
   838→
   839→/**
   840→ * Reset settings to defaults
   841→ */
   842→function resetSettings() {
   843→  currentSettings = { ...DEFAULT_SETTINGS };
   844→  try {
   845→    localStorage.removeItem('spliceSettings');
   846→  } catch (e) {
   847→    console.warn('[SPLICE] Could not clear settings:', e);
   848→  }
   849→}
   850→
   851→/**
   852→ * Initialize settings UI components
   853→ */
   854→function initSettingsUI() {
   855→  const settings = loadSettings();
   856→
   857→  // Apply saved sensitivity to slider
   858→  const sensitivitySlider = document.getElementById('sensitivitySlider');
   859→  if (sensitivitySlider) {
   860→    sensitivitySlider.value = settings.sensitivity;
   861→  }
   862→
   863→  // Apply saved audio source
   864→  const sourceOriginal = document.getElementById('sourceOriginal');
   865→  const sourceIsolated = document.getElementById('sourceIsolated');
   866→  if (sourceOriginal && sourceIsolated) {
   867→    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';
   868→    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';
   869→  }
   870→
   871→  // Apply auto-mark best setting
   872→  const autoMarkBest = document.getElementById('autoMarkBest');
   873→  if (autoMarkBest) {
   874→    autoMarkBest.checked = settings.autoMarkBest;
   875→  }
   876→
   877→  // Apply takes detection setting
   878→  const enableTakesDetection = document.getElementById('enableTakesDetection');
   879→  if (enableTakesDetection) {
   880→    enableTakesDetection.checked = settings.enableTakesDetection;
   881→  }
   882→
   883→  // Apply remember options setting
   884→  const rememberOptions = document.getElementById('rememberOptions');
   885→  if (rememberOptions) {
   886→    rememberOptions.checked = settings.rememberOptions;
   887→  }
   888→
   889→  // Restore expanded state if remember is enabled
   890→  if (settings.rememberOptions && settings.optionsExpanded) {
   891→    toggleOptionsPanel(true);
   892→  }
   893→}
   894→
   895→/**
   896→ * Toggle options panel visibility (unified panel)
   897→ */
   898→function toggleOptionsPanel(forceState) {
   899→  const toggle = document.getElementById('optionsToggle');
   900→  const panel = document.getElementById('optionsPanel');
   901→
   902→  if (!toggle || !panel) return;
   903→
   904→  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');
   905→
   906→  if (shouldExpand) {
   907→    panel.classList.remove('collapsed');
   908→    toggle.classList.add('expanded');
   909→  } else {
   910→    panel.classList.add('collapsed');
   911→    toggle.classList.remove('expanded');
   912→  }
   913→
   914→  // Save state if remember is enabled
   915→  const settings = getSettings();
   916→  if (settings.rememberOptions) {
   917→    saveSettings({ optionsExpanded: shouldExpand });
   918→  }
   919→}
   920→
   921→/**
   922→ * Initialize settings modal
   923→ */
   924→function initSettingsModal() {
   925→  const settingsBtn = document.getElementById('settingsBtn');
   926→  const modal = document.getElementById('settingsModal');
   927→  const closeBtn = document.getElementById('closeSettingsBtn');
   928→  const defaultSensitivity = document.getElementById('defaultSensitivity');
   929→  const rememberOptions = document.getElementById('rememberOptions');
   930→
   931→  if (settingsBtn && modal) {
   932→    settingsBtn.addEventListener('click', () => {
   933→      modal.classList.remove('hidden');
   934→      // Sync modal values with current settings
   935→      const settings = getSettings();
   936→      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;
   937→      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;
   938→    });
   939→  }
   940→
   941→  if (closeBtn && modal) {
   942→    closeBtn.addEventListener('click', () => {
   943→      modal.classList.add('hidden');
   944→    });
   945→  }
   946→
   947→  // Close on backdrop click
   948→  if (modal) {
   949→    modal.addEventListener('click', (e) => {
   950→      if (e.target === modal) {
   951→        modal.classList.add('hidden');
   952→      }
   953→    });
   954→  }
   955→
   956→  // Save default sensitivity when changed
   957→  if (defaultSensitivity) {
   958→    defaultSensitivity.addEventListener('change', () => {
   959→      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });
   960→      // Also update the main slider
   961→      const mainSlider = document.getElementById('sensitivitySlider');
   962→      if (mainSlider) mainSlider.value = defaultSensitivity.value;
   963→    });
   964→  }
   965→
   966→  // Save remember options when changed
   967→  if (rememberOptions) {
   968→    rememberOptions.addEventListener('change', () => {
   969→      saveSettings({ rememberOptions: rememberOptions.checked });
   970→    });
   971→  }
   972→}
   973→
   974→/**
   975→ * Initialize options toggle (unified panel)
   976→ */
   977→function initOptionsToggles() {
   978→  const toggle = document.getElementById('optionsToggle');
   979→
   980→  if (toggle) {
   981→    toggle.addEventListener('click', () => toggleOptionsPanel());
   982→  }
   983→}
   984→
   985→/**
   986→ * Populate preset selector dropdown with built-in and custom presets
   987→ * @param {string} [selectedId] - ID of preset to select after population
   988→ */
   989→function populatePresetDropdown(selectedId) {
   990→  const presetSelector = document.getElementById('presetSelector');
   991→  if (!presetSelector) return;
   992→
   993→  // Get all presets (built-in + custom)
   994→  const allPresets = getAllPresets();
   995→
   996→  // Clear existing options
   997→  presetSelector.innerHTML = '';
   998→
   999→  // Add built-in presets first
  1000→  const builtInGroup = document.createElement('optgroup');
  1001→  builtInGroup.label = 'Built-in Presets';
  1002→
  1003→  allPresets
  1004→    .filter(p => p.isBuiltIn)
  1005→    .forEach(preset => {
  1006→      const option = document.createElement('option');
  1007→      option.value = preset.id;
  1008→      option.textContent = preset.name;
  1009→      builtInGroup.appendChild(option);
  1010→    });
  1011→
  1012→  presetSelector.appendChild(builtInGroup);
  1013→
  1014→  // Add custom presets if any exist
  1015→  const customPresets = allPresets.filter(p => !p.isBuiltIn);
  1016→  if (customPresets.length > 0) {
  1017→    const customGroup = document.createElement('optgroup');
  1018→    customGroup.label = 'Custom Presets';
  1019→
  1020→    customPresets.forEach(preset => {
  1021→      const option = document.createElement('option');
  1022→      option.value = preset.id;
  1023→      option.textContent = preset.name;
  1024→      customGroup.appendChild(option);
  1025→    });
  1026→
  1027→    presetSelector.appendChild(customGroup);
  1028→  }
  1029→
  1030→  // Set selected value
  1031→  if (selectedId) {
  1032→    presetSelector.value = selectedId;
  1033→  }
  1034→}
  1035→
  1036→/**
  1037→ * Initialize preset selector
  1038→ */
  1039→function initPresetSelector() {
  1040→  const presetSelector = document.getElementById('presetSelector');
  1041→  const sensitivitySlider = document.getElementById('sensitivitySlider');
  1042→
  1043→  if (!presetSelector) return;
  1044→
  1045→  // Populate dropdown with all presets (built-in + custom)
  1046→  const settings = getSettings();
  1047→  populatePresetDropdown(settings.activePreset || 'custom');
  1048→
  1049→  // Handle preset change (supports both built-in and custom presets)
  1050→  presetSelector.addEventListener('change', () => {
  1051→    const presetId = presetSelector.value;
  1052→
  1053→    // Get preset info (works for both built-in and custom)
  1054→    const preset = getPresetById(presetId);
  1055→    if (!preset) {
  1056→      console.warn(`[SPLICE] Preset not found: ${presetId}`);
  1057→      return;
  1058→    }
  1059→
  1060→    let appliedSettings;
  1061→
  1062→    if (preset.isBuiltIn) {
  1063→      // Built-in preset: use the existing applyPreset function
  1064→      appliedSettings = applyPreset(presetId);
  1065→    } else {
  1066→      // Custom preset: apply stored settings
  1067→      appliedSettings = preset.settings || {};
  1068→      saveSettings({ activePreset: presetId, ...appliedSettings });
  1069→    }
  1070→
  1071→    // Update sensitivity slider to match preset
  1072→    if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {
  1073→      sensitivitySlider.value = appliedSettings.sensitivity;
  1074→    }
  1075→
  1076→    // Update takes detection checkbox
  1077→    const enableTakesDetection = document.getElementById('enableTakesDetection');
  1078→    if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {
  1079→      enableTakesDetection.checked = appliedSettings.enableTakesDetection;
  1080→    }
  1081→
  1082→    // Update auto-mark best checkbox
  1083→    const autoMarkBest = document.getElementById('autoMarkBest');
  1084→    if (autoMarkBest && appliedSettings.autoMarkBest !== undefined) {
  1085→      autoMarkBest.checked = appliedSettings.autoMarkBest;
  1086→    }
  1087→
  1088→    if (typeof setStatus === 'function') {
  1089→      const desc = preset.description ? ` - ${preset.description}` : '';
  1090→      setStatus(`Preset: ${preset.name}${desc}`);
  1091→    }
  1092→  });
  1093→
  1094→  // Switch to custom when user manually changes sensitivity
  1095→  if (sensitivitySlider) {
  1096→    sensitivitySlider.addEventListener('change', () => {
  1097→      if (presetSelector.value !== 'custom') {
  1098→        presetSelector.value = 'custom';
  1099→        saveSettings({ activePreset: 'custom' });
  1100→      }
  1101→    });
  1102→  }
  1103→}
  1104→
  1105→/**
  1106→ * Initialize help button
  1107→ */
  1108→function initHelpButton() {
  1109→  const helpBtn = document.getElementById('helpBtn');
  1110→  if (helpBtn) {
  1111→    helpBtn.addEventListener('click', () => {
  1112→      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');
  1113→    });
  1114→  }
  1115→}
  1116→
  1117→// =============================================================================
  1118→// PERSISTENT TOKEN MANAGEMENT (v3.5)
  1119→// =============================================================================
  1120→
  1121→/**
  1122→ * Media folder entry (cached after selection)
  1123→ * @type {Object|null}
  1124→ */
  1125→let mediaFolderEntry = null;
  1126→
  1127→/**
  1128→ * Prompt user to select a media folder and create a persistent token.
  1129→ * This allows silent file access without repeated permission prompts.
  1130→ *
  1131→ * @returns {Promise<{success: boolean, path?: string, error?: string}>}
  1132→ */
  1133→async function setupMediaFolder() {
  1134→  try {
  1135→    // Open folder picker dialog
  1136→    const folder = await uxpFs.getFolder();
  1137→
  1138→    if (!folder) {
  1139→      return { success: false, error: 'No folder selected' };
  1140→    }
  1141→
  1142→    // Create a persistent token for this folder
  1143→    const token = await uxpFs.createPersistentToken(folder);
  1144→
  1145→    if (!token) {
  1146→      return { success: false, error: 'Failed to create persistent token' };
  1147→    }
  1148→
  1149→    // Get the folder path for display
  1150→    const folderPath = folder.nativePath || folder.name;
  1151→
  1152→    // Save to settings
  1153→    saveSettings({
  1154→      mediaFolderToken: token,
  1155→      mediaFolderPath: folderPath
  1156→    });
  1157→
  1158→    // Cache the folder entry
  1159→    mediaFolderEntry = folder;
  1160→
  1161→    console.log(`[SPLICE] Media folder set: ${folderPath}`);
  1162→
  1163→    return {
  1164→      success: true,
  1165→      path: folderPath,
  1166→      token
  1167→    };
  1168→  } catch (err) {
  1169→    console.error('[SPLICE] Error setting up media folder:', err);
  1170→    return { success: false, error: err.message };
  1171→  }
  1172→}
  1173→
  1174→/**
  1175→ * Get the media folder entry using the stored persistent token.
  1176→ * Falls back to prompting if token is invalid.
  1177→ *
  1178→ * @returns {Promise<Object|null>} The folder entry or null
  1179→ */
  1180→async function getMediaFolder() {
  1181→  // Return cached entry if available
  1182→  if (mediaFolderEntry) {
  1183→    return mediaFolderEntry;
  1184→  }
  1185→
  1186→  const settings = getSettings();
  1187→
  1188→  // Try to restore from persistent token
  1189→  if (settings.mediaFolderToken) {
  1190→    try {
  1191→      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);
  1192→      if (folder) {
  1193→        mediaFolderEntry = folder;
  1194→        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);
  1195→        return folder;
  1196→      }
  1197→    } catch (err) {
  1198→      console.warn('[SPLICE] Could not restore media folder from token:', err.message);
  1199→      // Clear invalid token
  1200→      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });
  1201→    }
  1202→  }
  1203→
  1204→  return null;
  1205→}
  1206→
  1207→/**
  1208→ * Check if a media folder is configured
  1209→ * @returns {boolean}
  1210→ */
  1211→function hasMediaFolder() {
  1212→  const settings = getSettings();
  1213→  return !!settings.mediaFolderToken;
  1214→}
  1215→
  1216→/**
  1217→ * Get the configured media folder path (for display)
  1218→ * @returns {string|null}
  1219→ */
  1220→function getMediaFolderPath() {
  1221→  const settings = getSettings();
  1222→  return settings.mediaFolderPath;
  1223→}
  1224→
  1225→/**
  1226→ * Clear the media folder configuration
  1227→ */
  1228→function clearMediaFolder() {
  1229→  mediaFolderEntry = null;
  1230→  saveSettings({
  1231→    mediaFolderToken: null,
  1232→    mediaFolderPath: null
  1233→  });
  1234→  console.log('[SPLICE] Media folder cleared');
  1235→}
  1236→
  1237→/**
  1238→ * Read a file from the media folder
  1239→ * @param {string} filename - Name of the file to read
  1240→ * @returns {Promise<ArrayBuffer|null>} File contents or null
  1241→ */
  1242→async function readMediaFile(filename) {
  1243→  const folder = await getMediaFolder();
  1244→  if (!folder) {
  1245→    console.warn('[SPLICE] No media folder configured');
  1246→    return null;
  1247→  }
  1248→
  1249→  try {
  1250→    const file = await folder.getEntry(filename);
  1251→    if (!file) {
  1252→      console.warn(`[SPLICE] File not found in media folder: ${filename}`);
  1253→      return null;
  1254→    }
  1255→
  1256→    const contents = await file.read({ format: uxpFs.formats.binary });
  1257→    return contents;
  1258→  } catch (err) {
  1259→    console.error(`[SPLICE] Error reading file ${filename}:`, err);
  1260→    return null;
  1261→  }
  1262→}
  1263→
  1264→// =============================================================================
  1265→// LOGIN MODAL
  1266→// =============================================================================
  1267→
  1268→/**
  1269→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX
  1270→ * @param {string} key - License key to validate
  1271→ * @returns {boolean} True if format is valid
  1272→ */
  1273→function isValidLicenseKeyFormat(key) {
  1274→  if (!key || typeof key !== 'string') return false;
  1275→  const normalized = key.toUpperCase().trim();
  1276→  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;
  1277→  return pattern.test(normalized);
  1278→}
  1279→
  1280→/**
  1281→ * Initialize login modal handlers
  1282→ */
  1283→function initLoginModal() {
  1284→  const loginModal = document.getElementById('loginModal');
  1285→  const closeLoginBtn = document.getElementById('closeLoginBtn');
  1286→  const saveLoginBtn = document.getElementById('saveLoginBtn');
  1287→  const licenseKeyInput = document.getElementById('licenseKeyInput');
  1288→  const loginError = document.getElementById('loginError');
  1289→  const creditBadge = document.getElementById('creditBadge');
  1290→
  1291→  // Handle credit badge click - retry on error, or show login modal
  1292→  if (creditBadge) {
  1293→    creditBadge.addEventListener('click', async () => {
  1294→      // If in error state, retry fetching credits
  1295→      if (creditBadge.classList.contains('error')) {
  1296→        creditBadge.textContent = '...';
  1297→        if (typeof refreshCredits === 'function') {
  1298→          await refreshCredits();
  1299→        }
  1300→        return;
  1301→      }
  1302→      // Otherwise show login modal
  1303→      showLoginModal();
  1304→    });
  1305→  }
  1306→
  1307→  // Close login modal
  1308→  if (closeLoginBtn && loginModal) {
  1309→    closeLoginBtn.addEventListener('click', () => {
  1310→      loginModal.classList.add('hidden');
  1311→    });
  1312→  }
  1313→
  1314→  // Close on backdrop click
  1315→  if (loginModal) {
  1316→    loginModal.addEventListener('click', (e) => {
  1317→      if (e.target === loginModal) {
  1318→        loginModal.classList.add('hidden');
  1319→      }
  1320→    });
  1321→  }
  1322→
  1323→  // Activate license key
  1324→  if (saveLoginBtn) {
  1325→    saveLoginBtn.addEventListener('click', async () => {
  1326→      const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();
  1327→
  1328→      if (!licenseKey) {
  1329→        showLoginError('Please enter your license key');
  1330→        return;
  1331→      }
  1332→
  1333→      if (!isValidLicenseKeyFormat(licenseKey)) {
  1334→        showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');
  1335→        return;
  1336→      }
  1337→
  1338→      // Show loading state
  1339→      saveLoginBtn.disabled = true;
  1340→      saveLoginBtn.textContent = 'Activating...';
  1341→
  1342→      try {
  1343→        // Call license activation API (uses fetchWithTimeout from config.js)
  1344→        const response = await fetchWithTimeout(`${getBackendUrl()}/license/activate`, {
  1345→          method: 'POST',
  1346→          headers: { 'Content-Type': 'application/json' },
  1347→          body: JSON.stringify({ key: licenseKey })
  1348→        }, FETCH_TIMEOUT_DEFAULT);
  1349→
  1350→        const result = await response.json();
  1351→
  1352→        if (!result.success) {
  1353→          showLoginError(result.error || 'Activation failed');
  1354→          return;
  1355→        }
  1356→
  1357→        // Save customer ID from activation response
  1358→        saveSettings({ customerId: result.customerId });
  1359→
  1360→        // Hide modal
  1361→        loginModal?.classList.add('hidden');
  1362→
  1363→        // Refresh credits display
  1364→        if (typeof refreshCredits === 'function') {
  1365→          await refreshCredits();
  1366→        }
  1367→
  1368→        if (typeof setStatus === 'function') {
  1369→          setStatus(`License activated! ${result.tierName} tier - ${result.hoursRemaining.toFixed(1)}h remaining`);
  1370→        }
  1371→      } catch (err) {
  1372→        console.error('[SPLICE] License activation error:', err);
  1373→        showLoginError('Connection error. Check server is running.');
  1374→      } finally {
  1375→        saveLoginBtn.disabled = false;
  1376→        saveLoginBtn.textContent = 'Activate';
  1377→      }
  1378→    });
  1379→  }
  1380→
  1381→  // Email-based license lookup
  1382→  const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');
  1383→  const lookupEmailInput = document.getElementById('lookupEmailInput');
  1384→  const lookupResult = document.getElementById('lookupResult');
  1385→  const foundLicenseKey = document.getElementById('foundLicenseKey');
  1386→
  1387→  if (lookupLicenseBtn) {
  1388→    lookupLicenseBtn.addEventListener('click', async () => {
  1389→      const email = lookupEmailInput?.value?.trim()?.toLowerCase();
  1390→
  1391→      if (!email) {
  1392→        showLoginError('Please enter your email address');
  1393→        return;
  1394→      }
  1395→
  1396→      // Basic email validation
  1397→      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  1398→      if (!emailRegex.test(email)) {
  1399→        showLoginError('Please enter a valid email address');
  1400→        return;
  1401→      }
  1402→
  1403→      // Hide previous results/errors
  1404→      if (loginError) loginError.style.display = 'none';
  1405→      if (lookupResult) lookupResult.style.display = 'none';
  1406→
  1407→      // Show loading state
  1408→      lookupLicenseBtn.disabled = true;
  1409→      lookupLicenseBtn.textContent = 'Looking up...';
  1410→
  1411→      try {
  1412→        const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {
  1413→          method: 'POST',
  1414→          headers: { 'Content-Type': 'application/json' },
  1415→          body: JSON.stringify({ email })
  1416→        }, 30000);
  1417→
  1418→        const result = await response.json();
  1419→
  1420→        if (result.success && result.key) {
  1421→          // Show the found license key
  1422→          if (foundLicenseKey) foundLicenseKey.textContent = result.key;
  1423→          if (lookupResult) lookupResult.style.display = 'block';
  1424→          // Auto-fill the license key input
  1425→          if (licenseKeyInput) licenseKeyInput.value = result.key;
  1426→        } else {
  1427→          showLoginError(result.error || result.message || 'No license found for this email');
  1428→        }
  1429→      } catch (err) {
  1430→        console.error('[SPLICE] License lookup error:', err);
  1431→        showLoginError('Failed to look up license. Please try again.');
  1432→      } finally {
  1433→        lookupLicenseBtn.disabled = false;
  1434→        lookupLicenseBtn.textContent = 'Find My License';
  1435→      }
  1436→    });
  1437→  }
  1438→
  1439→  // Clear input on modal open (don't show old value for security)
  1440→  // Customer ID is stored but license key is not displayed
  1441→}
  1442→
  1443→/**
  1444→ * Show login modal
  1445→ */
  1446→function showLoginModal() {
  1447→  const loginModal = document.getElementById('loginModal');
  1448→  const loginError = document.getElementById('loginError');
  1449→  const loginSuccess = document.getElementById('loginSuccess');
  1450→  const lookupResult = document.getElementById('lookupResult');
  1451→
  1452→  // Clear previous states
  1453→  if (loginError) loginError.style.display = 'none';
  1454→  if (loginSuccess) loginSuccess.style.display = 'none';
  1455→  if (lookupResult) lookupResult.style.display = 'none';
  1456→
  1457→  if (loginModal) {
  1458→    loginModal.classList.remove('hidden');
  1459→  }
  1460→}
  1461→
  1462→/**
  1463→ * Show login error message
  1464→ */
  1465→function showLoginError(message) {
  1466→  const loginError = document.getElementById('loginError');
  1467→  if (loginError) {
  1468→    loginError.textContent = message;
  1469→    loginError.style.display = 'block';
  1470→  }
  1471→}
  1472→
  1473→/**
  1474→ * Check if user is logged in
  1475→ * @returns {boolean}
  1476→ */
  1477→function isLoggedIn() {
  1478→  const settings = getSettings();
  1479→  return !!settings.customerId;
  1480→}
  1481→
  1482→/**
  1483→ * Get customer ID
  1484→ * @returns {string|null}
  1485→ */
  1486→function getCustomerId() {
  1487→  const settings = getSettings();
  1488→  return settings.customerId || null;
  1489→}
  1490→
  1491→/**
  1492→ * Logout - clear customer ID and credits cache
  1493→ */
  1494→function logout() {
  1495→  saveSettings({ customerId: null });
  1496→
  1497→  // Clear credits cache (defined in credits.js)
  1498→  if (typeof clearCreditsCache === 'function') {
  1499→    clearCreditsCache();
  1500→  }
  1501→
  1502→  // Update credit badge to show login state
  1503→  if (typeof updateCreditDisplay === 'function') {
  1504→    updateCreditDisplay(null);
  1505→  }
  1506→
  1507→  if (typeof setStatus === 'function') {
  1508→    setStatus('Logged out');
  1509→  }
  1510→}
  1511→
  1512→// =============================================================================
  1513→// PROFANITY SETTINGS (Feature 5)
  1514→// =============================================================================
  1515→
  1516→const PROFANITY_SETTINGS_KEY = 'spliceProfanitySettings';
  1517→
  1518→/**
  1519→ * Default profanity settings
  1520→ */
  1521→const DEFAULT_PROFANITY_SETTINGS = {
  1522→  enabled: false,
  1523→  language: 'en',
  1524→  customBlocklist: [],
  1525→  customAllowlist: [],
  1526→  bleepType: 'standard'
  1527→};
  1528→
  1529→/**
  1530→ * Get profanity settings from localStorage
  1531→ * @returns {Object} Profanity settings
  1532→ */
  1533→function getProfanitySettings() {
  1534→  try {
  1535→    const saved = localStorage.getItem(PROFANITY_SETTINGS_KEY);
  1536→    if (saved) {
  1537→      const parsed = JSON.parse(saved);
  1538→      return {
  1539→        ...DEFAULT_PROFANITY_SETTINGS,
  1540→        ...parsed
  1541→      };
  1542→    }
  1543→  } catch (e) {
  1544→    console.warn('[SPLICE] Could not load profanity settings:', e);
  1545→  }
  1546→  return { ...DEFAULT_PROFANITY_SETTINGS };
  1547→}
  1548→
  1549→/**
  1550→ * Save profanity settings to localStorage
  1551→ * @param {Object} settings - Profanity settings to save
  1552→ * @returns {boolean} Success status
  1553→ */
  1554→function saveProfanitySettings(settings) {
  1555→  try {
  1556→    const toSave = {
  1557→      ...getProfanitySettings(),
  1558→      ...settings
  1559→    };
  1560→    localStorage.setItem(PROFANITY_SETTINGS_KEY, JSON.stringify(toSave));
  1561→    return true;
  1562→  } catch (e) {
  1563→    console.warn('[SPLICE] Could not save profanity settings:', e);
  1564→    return false;
  1565→  }
  1566→}
  1567→
  1568→/**
  1569→ * Parse comma-separated word list into array
  1570→ * @param {string} text - Comma or newline separated words
  1571→ * @returns {Array<string>} Array of trimmed words
  1572→ */
  1573→function parseWordList(text) {
  1574→  if (!text || typeof text !== 'string') return [];
  1575→  return text
  1576→    .split(/[,\n]/)
  1577→    .map(word => word.trim().toLowerCase())
  1578→    .filter(word => word.length > 0);
  1579→}
  1580→
  1581→/**
  1582→ * Format array of words as comma-separated string
  1583→ * @param {Array<string>} words - Array of words
  1584→ * @returns {string} Comma-separated string
  1585→ */
  1586→function formatWordList(words) {
  1587→  if (!Array.isArray(words)) return '';
  1588→  return words.join(', ');
  1589→}
  1590→
  1591→/**
  1592→ * Initialize profanity settings UI
  1593→ * Wires up UI elements to settings
  1594→ */
  1595→function initProfanitySettingsUI() {
  1596→  const enableCheckbox = document.getElementById('enableProfanity');
  1597→  const settingsPanel = document.getElementById('profanitySettings');
  1598→  const languageSelect = document.getElementById('profanityLanguage');
  1599→  const blocklistTextarea = document.getElementById('profanityBlocklist');
  1600→  const allowlistTextarea = document.getElementById('profanityAllowlist');
  1601→  const bleepTypeSelect = document.getElementById('bleepType');
  1602→
  1603→  if (!enableCheckbox || !settingsPanel) {
  1604→    console.log('[SPLICE] Profanity UI elements not found');
  1605→    return;
  1606→  }
  1607→
  1608→  // Load saved settings
  1609→  const saved = getProfanitySettings();
  1610→
  1611→  // Apply saved values to UI
  1612→  enableCheckbox.checked = saved.enabled;
  1613→  if (saved.enabled) {
  1614→    settingsPanel.classList.remove('collapsed');
  1615→  }
  1616→
  1617→  if (languageSelect) languageSelect.value = saved.language || 'en';
  1618→  if (blocklistTextarea) blocklistTextarea.value = formatWordList(saved.customBlocklist);
  1619→  if (allowlistTextarea) allowlistTextarea.value = formatWordList(saved.customAllowlist);
  1620→  if (bleepTypeSelect) bleepTypeSelect.value = saved.bleepType || 'standard';
  1621→
  1622→  // Toggle settings panel visibility
  1623→  enableCheckbox.addEventListener('change', () => {
  1624→    if (enableCheckbox.checked) {
  1625→      settingsPanel.classList.remove('collapsed');
  1626→    } else {
  1627→      settingsPanel.classList.add('collapsed');
  1628→    }
  1629→    saveProfanitySettings({ enabled: enableCheckbox.checked });
  1630→  });
  1631→
  1632→  // Save on change
  1633→  if (languageSelect) {
  1634→    languageSelect.addEventListener('change', () => {
  1635→      saveProfanitySettings({ language: languageSelect.value });
  1636→    });
  1637→  }
  1638→
  1639→  if (blocklistTextarea) {
  1640→    blocklistTextarea.addEventListener('blur', () => {
  1641→      const words = parseWordList(blocklistTextarea.value);
  1642→      saveProfanitySettings({ customBlocklist: words });
  1643→      // Re-format to clean up input
  1644→      blocklistTextarea.value = formatWordList(words);
  1645→    });
  1646→  }
  1647→
  1648→  if (allowlistTextarea) {
  1649→    allowlistTextarea.addEventListener('blur', () => {
  1650→      const words = parseWordList(allowlistTextarea.value);
  1651→      saveProfanitySettings({ customAllowlist: words });
  1652→      // Re-format to clean up input
  1653→      allowlistTextarea.value = formatWordList(words);
  1654→    });
  1655→  }
  1656→
  1657→  if (bleepTypeSelect) {
  1658→    bleepTypeSelect.addEventListener('change', () => {
  1659→      saveProfanitySettings({ bleepType: bleepTypeSelect.value });
  1660→    });
  1661→  }
  1662→
  1663→  console.log('[SPLICE] Profanity settings UI initialized');
  1664→}
  1665→
  1666→// Load settings on script load
  1667→loadSettings();
  1668→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
