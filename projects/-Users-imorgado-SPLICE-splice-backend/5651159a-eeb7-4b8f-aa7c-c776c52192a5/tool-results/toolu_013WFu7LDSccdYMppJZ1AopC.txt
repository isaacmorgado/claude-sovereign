     1→/**
     2→ * SPLICE CEP Panel Configuration
     3→ * Backend URLs, paths, and utility functions
     4→ */
     5→
     6→// ============================================================================
     7→// BACKEND CONFIGURATION
     8→// ============================================================================
     9→const SPLICE_CONFIG = {
    10→    VERSION: '4.0.0',
    11→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',
    12→    BACKEND_DEV: 'https://127.0.0.1:3847',
    13→    FETCH_TIMEOUT: 120000, // 2 minutes
    14→    RETRY_ATTEMPTS: 3,
    15→    RETRY_DELAY: 1000
    16→};
    17→
    18→/**
    19→ * Get the backend URL based on environment
    20→ */
    21→function getBackendUrl() {
    22→    // Check for development mode
    23→    const isDev = window.location.protocol === 'file:' ||
    24→                  window.location.hostname === 'localhost' ||
    25→                  window.location.hostname === '127.0.0.1';
    26→
    27→    // Allow override via localStorage
    28→    const customUrl = localStorage.getItem('spliceBackendUrl');
    29→    if (customUrl) return customUrl;
    30→
    31→    return isDev ? SPLICE_CONFIG.BACKEND_DEV : SPLICE_CONFIG.BACKEND_PROD;
    32→}
    33→
    34→// ============================================================================
    35→// JSX BRIDGE - Communicate with Premiere Pro
    36→// ============================================================================
    37→const jsx = {
    38→    cs: null,
    39→    _initPromise: null,
    40→    _initialized: false,
    41→
    42→    /**
    43→     * Initialize the CSInterface
    44→     * Returns a promise that resolves when ready
    45→     */
    46→    init: function() {
    47→        if (this._initPromise) return this._initPromise;
    48→
    49→        this._initPromise = new Promise((resolve) => {
    50→            if (typeof CSInterface !== 'undefined') {
    51→                this.cs = new CSInterface();
    52→                this._initialized = true;
    53→                console.log('[JSX] CSInterface initialized successfully');
    54→            } else {
    55→                console.warn('[JSX] CSInterface not available');
    56→            }
    57→            resolve(this._initialized);
    58→        });
    59→
    60→        return this._initPromise;
    61→    },
    62→
    63→    /**
    64→     * Ensure JSX is initialized before making calls
    65→     */
    66→    ensureInitialized: async function() {
    67→        if (!this._initialized) {
    68→            await this.init();
    69→        }
    70→        if (!this.cs) {
    71→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');
    72→        }
    73→    },
    74→
    75→    /**
    76→     * Execute ExtendScript in Premiere Pro
    77→     * @param {string} script - ExtendScript to execute
    78→     * @returns {Promise<any>} - Parsed result
    79→     */
    80→    evalScript: async function(script) {
    81→        await this.ensureInitialized();
    82→
    83→        return new Promise((resolve, reject) => {
    84→            this.cs.evalScript(script, (result) => {
    85→                if (result === 'undefined' || result === undefined) {
    86→                    resolve(null);
    87→                    return;
    88→                }
    89→
    90→                // Check for EvalScript error
    91→                if (typeof result === 'string' && result.indexOf('EvalScript error') !== -1) {
    92→                    reject(new Error(result));
    93→                    return;
    94→                }
    95→
    96→                // Try to parse JSON
    97→                try {
    98→                    const parsed = JSON.parse(result);
    99→                    if (parsed.error) {
   100→                        reject(new Error(parsed.error));
   101→                    } else {
   102→                        resolve(parsed);
   103→                    }
   104→                } catch (e) {
   105→                    // Return as-is if not JSON
   106→                    resolve(result);
   107→                }
   108→            });
   109→        });
   110→    },
   111→
   112→    /**
   113→     * Call a JSX function with arguments
   114→     * @param {string} funcName - Function name
   115→     * @param {...any} args - Arguments to pass
   116→     * @returns {Promise<any>}
   117→     */
   118→    call: async function(funcName, ...args) {
   119→        await this.ensureInitialized();
   120→
   121→        const escapedArgs = args.map(arg => {
   122→            if (arg === null || arg === undefined) return 'null';
   123→            if (typeof arg === 'string') return `'${arg.replace(/'/g, "\\'").replace(/\n/g, '\\n')}'`;
   124→            if (typeof arg === 'object') return `'${JSON.stringify(arg).replace(/'/g, "\\'")}'`;
   125→            return String(arg);
   126→        });
   127→
   128→        const script = `${funcName}(${escapedArgs.join(', ')})`;
   129→        return this.evalScript(script);
   130→    }
   131→};
   132→
   133→// ============================================================================
   134→// FETCH UTILITIES
   135→// ============================================================================
   136→
   137→/**
   138→ * Fetch with timeout support
   139→ * @param {string} url - URL to fetch
   140→ * @param {object} options - Fetch options
   141→ * @param {number} timeout - Timeout in ms
   142→ */
   143→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {
   144→    const controller = new AbortController();
   145→    const timeoutId = setTimeout(() => controller.abort(), timeout);
   146→
   147→    try {
   148→        const response = await fetch(url, {
   149→            ...options,
   150→            signal: controller.signal
   151→        });
   152→        clearTimeout(timeoutId);
   153→        return response;
   154→    } catch (error) {
   155→        clearTimeout(timeoutId);
   156→        if (error.name === 'AbortError') {
   157→            throw new Error(`Request timeout after ${timeout}ms`);
   158→        }
   159→        throw error;
   160→    }
   161→}
   162→
   163→/**
   164→ * Parse error response from backend
   165→ * @param {Response} response - Fetch response
   166→ */
   167→async function parseErrorResponse(response) {
   168→    try {
   169→        const data = await response.json();
   170→        return data.error || data.message || `HTTP ${response.status}`;
   171→    } catch {
   172→        return `HTTP ${response.status}: ${response.statusText}`;
   173→    }
   174→}
   175→
   176→/**
   177→ * Get auth headers for API requests
   178→ */
   179→function getAuthHeaders() {
   180→    const headers = { 'Content-Type': 'application/json' };
   181→    const settings = getSettings();
   182→
   183→    if (settings.customerId) {
   184→        headers['x-stripe-customer-id'] = settings.customerId;
   185→    }
   186→    if (settings.licenseKey) {
   187→        headers['x-license-key'] = settings.licenseKey;
   188→    }
   189→
   190→    return headers;
   191→}
   192→
   193→// ============================================================================
   194→// SETTINGS MANAGEMENT
   195→// ============================================================================
   196→
   197→const DEFAULT_SETTINGS = {
   198→    sensitivity: 50,
   199→    minSilenceLength: 0.5,
   200→    sourceIsolated: false,
   201→    enableTakesDetection: true,
   202→    enableJCut: false,
   203→    jcutLeadIn: 0.3,
   204→    jcutLeadOut: 0.2,
   205→    enableZoom: false,
   206→    zoomFrequency: 'medium',
   207→    zoomPreset: 'medium',
   208→    zoomPlacement: 'sentence_start',
   209→    enableChapters: false,
   210→    maxChapters: 10,
   211→    minChapterLength: 60,
   212→    enableProfanity: false,
   213→    profanityLanguage: 'en',
   214→    bleepType: 'standard',
   215→    customerId: null,
   216→    licenseKey: null,
   217→    expandedOptions: false,
   218→    activePreset: 'podcast',
   219→    rememberOptions: false
   220→};
   221→
   222→/**
   223→ * Get settings from localStorage
   224→ */
   225→function getSettings() {
   226→    try {
   227→        const stored = localStorage.getItem('spliceSettings');
   228→        if (stored) {
   229→            return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };
   230→        }
   231→    } catch (e) {
   232→        console.warn('[Config] Error loading settings:', e);
   233→    }
   234→    return { ...DEFAULT_SETTINGS };
   235→}
   236→
   237→/**
   238→ * Save settings to localStorage
   239→ */
   240→function saveSettings(settings) {
   241→    try {
   242→        const merged = { ...getSettings(), ...settings };
   243→        localStorage.setItem('spliceSettings', JSON.stringify(merged));
   244→        return true;
   245→    } catch (e) {
   246→        console.warn('[Config] Error saving settings:', e);
   247→        return false;
   248→    }
   249→}
   250→
   251→/**
   252→ * Clear specific setting
   253→ */
   254→function clearSetting(key) {
   255→    const settings = getSettings();
   256→    delete settings[key];
   257→    localStorage.setItem('spliceSettings', JSON.stringify(settings));
   258→}
   259→
   260→// ============================================================================
   261→// OFFLINE DETECTION
   262→// ============================================================================
   263→
   264→let isOnlineState = true;
   265→let offlineCheckInterval = null;
   266→
   267→/**
   268→ * Check if online
   269→ */
   270→function isOnline() {
   271→    return isOnlineState && navigator.onLine;
   272→}
   273→
   274→/**
   275→ * Initialize offline detection
   276→ */
   277→function initOfflineDetection() {
   278→    // Browser events
   279→    window.addEventListener('online', () => {
   280→        isOnlineState = true;
   281→        updateOfflineUI(true);
   282→    });
   283→
   284→    window.addEventListener('offline', () => {
   285→        isOnlineState = false;
   286→        updateOfflineUI(false);
   287→    });
   288→
   289→    // Periodic check
   290→    offlineCheckInterval = setInterval(async () => {
   291→        try {
   292→            const response = await fetchWithTimeout(
   293→                `${getBackendUrl()}/health`,
   294→                { method: 'GET' },
   295→                5000
   296→            );
   297→            isOnlineState = response.ok;
   298→        } catch {
   299→            isOnlineState = false;
   300→        }
   301→        updateOfflineUI(isOnlineState);
   302→    }, 30000);
   303→}
   304→
   305→/**
   306→ * Update UI based on online state
   307→ */
   308→function updateOfflineUI(online) {
   309→    const goBtn = document.getElementById('goBtn');
   310→    const status = document.getElementById('status');
   311→
   312→    if (goBtn) {
   313→        goBtn.disabled = !online;
   314→    }
   315→
   316→    if (status) {
   317→        if (!online) {
   318→            status.textContent = 'Offline - Check your connection';
   319→            status.style.color = '#dc3545';
   320→        } else {
   321→            // Reset status when back online
   322→            status.textContent = 'Ready';
   323→            status.style.color = '#888';
   324→        }
   325→    }
   326→}
   327→
   328→// ============================================================================
   329→// UTILITY FUNCTIONS
   330→// ============================================================================
   331→
   332→/**
   333→ * Format time in MM:SS or HH:MM:SS
   334→ */
   335→function formatTime(seconds) {
   336→    if (isNaN(seconds) || seconds < 0) return '0:00';
   337→
   338→    const hours = Math.floor(seconds / 3600);
   339→    const minutes = Math.floor((seconds % 3600) / 60);
   340→    const secs = Math.floor(seconds % 60);
   341→
   342→    if (hours > 0) {
   343→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
   344→    }
   345→    return `${minutes}:${secs.toString().padStart(2, '0')}`;
   346→}
   347→
   348→/**
   349→ * Set status message
   350→ */
   351→function setStatus(message, isError = false) {
   352→    const status = document.getElementById('status');
   353→    if (status) {
   354→        status.textContent = message;
   355→        status.style.color = isError ? '#dc3545' : '#888';
   356→    }
   357→}
   358→
   359→/**
   360→ * Debounce function calls
   361→ */
   362→function debounce(func, wait) {
   363→    let timeout;
   364→    return function executedFunction(...args) {
   365→        const later = () => {
   366→            clearTimeout(timeout);
   367→            func(...args);
   368→        };
   369→        clearTimeout(timeout);
   370→        timeout = setTimeout(later, wait);
   371→    };
   372→}
   373→
   374→// Initialize JSX bridge when loaded
   375→document.addEventListener('DOMContentLoaded', () => {
   376→    jsx.init();
   377→});
   378→
   379→// Export for modules
   380→window.SPLICE_CONFIG = SPLICE_CONFIG;
   381→window.getBackendUrl = getBackendUrl;
   382→window.fetchWithTimeout = fetchWithTimeout;
   383→window.parseErrorResponse = parseErrorResponse;
   384→window.getAuthHeaders = getAuthHeaders;
   385→window.getSettings = getSettings;
   386→window.saveSettings = saveSettings;
   387→window.isOnline = isOnline;
   388→window.initOfflineDetection = initOfflineDetection;
   389→window.formatTime = formatTime;
   390→window.setStatus = setStatus;
   391→window.jsx = jsx;
   392→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
