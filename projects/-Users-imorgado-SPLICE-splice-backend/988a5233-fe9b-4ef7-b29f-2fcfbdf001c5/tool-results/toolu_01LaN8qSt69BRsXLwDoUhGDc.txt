     1→/**
     2→ * SPLICE Plugin Main Entry Point
     3→ *
     4→ * Initializes all functionality when the plugin loads.
     5→ * v3.4 - Timeline Markers + Unified Take-Aware Workflow.
     6→ */
     7→
     8→// Initialize Premiere Pro API
     9→const ppro = require('premierepro');
    10→
    11→// ============================================================================
    12→// CACHED DOM ELEMENTS (Performance: avoid repeated getElementById calls)
    13→// ============================================================================
    14→const ui = {};
    15→
    16→function cacheUIElements() {
    17→  ui.status = document.getElementById('status');
    18→
    19→  // Main GO button (unified workflow)
    20→  ui.goBtn = document.getElementById('goBtn');
    21→  ui.optionsToggle = document.getElementById('optionsToggle');
    22→  ui.optionsPanel = document.getElementById('optionsPanel');
    23→
    24→  // Sliders and options
    25→  ui.sensitivitySlider = document.getElementById('sensitivitySlider');
    26→  ui.sourceOriginal = document.getElementById('sourceOriginal');
    27→  ui.sourceIsolated = document.getElementById('sourceIsolated');
    28→
    29→  // Settings checkboxes
    30→  ui.enableTakesDetection = document.getElementById('enableTakesDetection');
    31→  ui.autoMarkBest = document.getElementById('autoMarkBest');
    32→
    33→  // Progress
    34→  ui.progressContainer = document.getElementById('progressContainer');
    35→  ui.progressText = document.getElementById('progressText');
    36→  ui.resultsEmpty = document.getElementById('resultsEmpty');
    37→
    38→  // Combined Preview
    39→  ui.combinedPreview = document.getElementById('combinedPreview');
    40→  ui.previewList = document.getElementById('previewList');
    41→  ui.silenceCountDisplay = document.getElementById('silenceCount');
    42→  ui.takeCountDisplay = document.getElementById('takeCount');
    43→  ui.selectedCount = document.getElementById('selectedCount');
    44→  ui.selectAllSilences = document.getElementById('selectAllSilences');
    45→  ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
    46→  ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
    47→  ui.invertSelectionBtn = document.getElementById('invertSelectionBtn');
    48→  ui.reRunDetectionBtn = document.getElementById('reRunDetectionBtn');
    49→
    50→  // Results
    51→  ui.silenceResults = document.getElementById('silenceResults');
    52→  ui.resultsCount = document.getElementById('resultsCount');
    53→  ui.timeSaved = document.getElementById('timeSaved');
    54→  ui.clipsModified = document.getElementById('clipsModified');
    55→
    56→  // Build Sequence button (v3.5)
    57→  ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');
    58→
    59→  // Buttons
    60→  ui.undoBtn = document.getElementById('undoBtn');
    61→  ui.advancedSection = document.getElementById('advancedSection');
    62→
    63→  // Settings modal
    64→  ui.settingsBtn = document.getElementById('settingsBtn');
    65→  ui.settingsModal = document.getElementById('settingsModal');
    66→  ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
    67→
    68→  // Media folder (v3.5)
    69→  ui.mediaFolderDisplay = document.getElementById('mediaFolderDisplay');
    70→  ui.setMediaFolderBtn = document.getElementById('setMediaFolderBtn');
    71→  ui.clearMediaFolderBtn = document.getElementById('clearMediaFolderBtn');
    72→
    73→  // Custom Presets (v3.5)
    74→  ui.savePresetBtn = document.getElementById('savePresetBtn');
    75→  ui.managePresetsBtn = document.getElementById('managePresetsBtn');
    76→  ui.presetModal = document.getElementById('presetModal');
    77→  ui.presetModalTitle = document.getElementById('presetModalTitle');
    78→  ui.closePresetModalBtn = document.getElementById('closePresetModalBtn');
    79→  ui.presetNameInput = document.getElementById('presetNameInput');
    80→  ui.presetDescInput = document.getElementById('presetDescInput');
    81→  ui.presetIconPicker = document.getElementById('presetIconPicker');
    82→  ui.presetEditId = document.getElementById('presetEditId');
    83→  ui.presetSelectedIcon = document.getElementById('presetSelectedIcon');
    84→  ui.savePresetConfirmBtn = document.getElementById('savePresetConfirmBtn');
    85→  ui.presetModalError = document.getElementById('presetModalError');
    86→  ui.managePresetsModal = document.getElementById('managePresetsModal');
    87→  ui.closeManagePresetsBtn = document.getElementById('closeManagePresetsBtn');
    88→  ui.presetsList = document.getElementById('presetsList');
    89→  ui.noCustomPresets = document.getElementById('noCustomPresets');
    90→  ui.presetSelector = document.getElementById('presetSelector');
    91→
    92→  // Preset settings inputs (Phase 3)
    93→  ui.presetSensitivity = document.getElementById('presetSensitivity');
    94→  ui.presetSensitivityValue = document.getElementById('presetSensitivityValue');
    95→  ui.presetThreshold = document.getElementById('presetThreshold');
    96→
    97→  // Export/Import buttons (Phase 3)
    98→  ui.exportPresetsBtn = document.getElementById('exportPresetsBtn');
    99→  ui.importPresetsBtn = document.getElementById('importPresetsBtn');
   100→
   101→  // Confirmation modal (UXP-compatible)
   102→  ui.confirmModal = document.getElementById('confirmModal');
   103→  ui.confirmModalTitle = document.getElementById('confirmModalTitle');
   104→  ui.confirmModalMessage = document.getElementById('confirmModalMessage');
   105→  ui.confirmModalConfirmBtn = document.getElementById('confirmModalConfirmBtn');
   106→  ui.confirmModalCancelBtn = document.getElementById('confirmModalCancelBtn');
   107→  ui.closeConfirmModalBtn = document.getElementById('closeConfirmModalBtn');
   108→}
   109→
   110→// ============================================================================
   111→// CONFIRMATION MODAL (UXP-compatible replacement for confirm())
   112→// ============================================================================
   113→let confirmModalCallback = null;
   114→
   115→/**
   116→ * Show a confirmation modal dialog (UXP-compatible replacement for confirm())
   117→ * @param {string} title - Modal title
   118→ * @param {string} message - Confirmation message
   119→ * @param {Function} onConfirm - Callback when confirmed
   120→ * @param {Function} [onCancel] - Optional callback when cancelled
   121→ * @param {Object} [options] - Optional customization { confirmText, cancelText, confirmStyle }
   122→ */
   123→function showConfirmModal(title, message, onConfirm, onCancel = null, options = {}) {
   124→  if (!ui.confirmModal) return;
   125→
   126→  // Set content
   127→  if (ui.confirmModalTitle) ui.confirmModalTitle.textContent = title;
   128→  if (ui.confirmModalMessage) ui.confirmModalMessage.textContent = message;
   129→
   130→  // Customize button text if provided
   131→  if (ui.confirmModalConfirmBtn) {
   132→    ui.confirmModalConfirmBtn.textContent = options.confirmText || 'Confirm';
   133→    ui.confirmModalConfirmBtn.style.background = options.confirmStyle || '#dc3545';
   134→  }
   135→  if (ui.confirmModalCancelBtn) {
   136→    ui.confirmModalCancelBtn.textContent = options.cancelText || 'Cancel';
   137→  }
   138→
   139→  // Store callbacks
   140→  confirmModalCallback = { onConfirm, onCancel };
   141→
   142→  // Show modal
   143→  ui.confirmModal.classList.remove('hidden');
   144→
   145→  // Focus cancel button for safety (user must explicitly confirm)
   146→  if (ui.confirmModalCancelBtn) ui.confirmModalCancelBtn.focus();
   147→}
   148→
   149→function hideConfirmModal(confirmed = false) {
   150→  if (!ui.confirmModal) return;
   151→
   152→  ui.confirmModal.classList.add('hidden');
   153→
   154→  // Execute callback
   155→  if (confirmModalCallback) {
   156→    if (confirmed && confirmModalCallback.onConfirm) {
   157→      confirmModalCallback.onConfirm();
   158→    } else if (!confirmed && confirmModalCallback.onCancel) {
   159→      confirmModalCallback.onCancel();
   160→    }
   161→    confirmModalCallback = null;
   162→  }
   163→}
   164→
   165→function initConfirmModal() {
   166→  // Confirm button
   167→  if (ui.confirmModalConfirmBtn) {
   168→    ui.confirmModalConfirmBtn.addEventListener('click', () => {
   169→      hideConfirmModal(true);
   170→    });
   171→  }
   172→
   173→  // Cancel button
   174→  if (ui.confirmModalCancelBtn) {
   175→    ui.confirmModalCancelBtn.addEventListener('click', () => {
   176→      hideConfirmModal(false);
   177→    });
   178→  }
   179→
   180→  // Close button (X)
   181→  if (ui.closeConfirmModalBtn) {
   182→    ui.closeConfirmModalBtn.addEventListener('click', () => {
   183→      hideConfirmModal(false);
   184→    });
   185→  }
   186→
   187→  // Close on backdrop click
   188→  if (ui.confirmModal) {
   189→    ui.confirmModal.addEventListener('click', (e) => {
   190→      if (e.target === ui.confirmModal) {
   191→        hideConfirmModal(false);
   192→      }
   193→    });
   194→  }
   195→
   196→  // Keyboard support
   197→  document.addEventListener('keydown', (e) => {
   198→    if (!ui.confirmModal || ui.confirmModal.classList.contains('hidden')) return;
   199→
   200→    if (e.key === 'Escape') {
   201→      e.preventDefault();
   202→      hideConfirmModal(false);
   203→    } else if (e.key === 'Enter') {
   204→      e.preventDefault();
   205→      hideConfirmModal(true);
   206→    }
   207→  });
   208→}
   209→
   210→// ============================================================================
   211→// STATE MANAGEMENT
   212→// ============================================================================
   213→let previewSilences = [];         // All detected silences
   214→let safeSilences = [];            // Silences that don't overlap takes (safe to remove)
   215→let protectedSilences = [];       // Silences that overlap takes (protected)
   216→let previewTakes = [];            // Detected takes (for display)
   217→let selectedSilenceIndices = new Set();
   218→let isOperationInProgress = false;
   219→let pendingUIUpdate = null;
   220→
   221→// Export preview state for other modules (Razor integration)
   222→window.splicePreviewState = {
   223→  getSelectedSilences: () => safeSilences.filter((_, i) => selectedSilenceIndices.has(i)),
   224→  getSelectedTakes: () => previewTakes,
   225→  hasPreview: () => safeSilences.length > 0 || previewTakes.length > 0
   226→};
   227→
   228→// ============================================================================
   229→// INITIALIZATION
   230→// ============================================================================
   231→document.addEventListener('DOMContentLoaded', async () => {
   232→  // Cache all DOM elements first
   233→  cacheUIElements();
   234→
   235→  // Initialize file paths (cross-platform support)
   236→  // Must be done early before any audio export operations
   237→  try {
   238→    await initPaths();
   239→    console.log('[SPLICE] File paths initialized');
   240→  } catch (err) {
   241→    console.warn('[SPLICE] Path initialization warning:', err.message);
   242→    // Continue anyway - fallback paths will be used
   243→  }
   244→
   245→  // Settings & UI
   246→  initSettingsUI();
   247→  initSettingsModal();
   248→  initLoginModal();
   249→  initConfirmModal();
   250→  initOptionsToggles();
   251→  initPresetSelector();
   252→  initHelpButton();
   253→
   254→  // Credits display
   255→  initCredits();
   256→
   257→  // Offline detection
   258→  if (typeof initOfflineDetection === 'function') {
   259→    initOfflineDetection();
   260→  }
   261→
   262→  // Unified workflow (silences + takes)
   263→  initUnifiedWorkflow();
   264→
   265→  // Preview handlers (event delegation)
   266→  initPreviewHandlers();
   267→
   268→  // Undo handlers
   269→  initUndoHandlers();
   270→
   271→  // Keyboard shortcuts
   272→  initKeyboardShortcuts();
   273→
   274→  // Advanced features (Razor - legacy)
   275→  initSlice9();
   276→
   277→  // Batch processing
   278→  initBatchHandlers();
   279→
   280→  // Media folder (v3.5)
   281→  initMediaFolderHandlers();
   282→
   283→  // Custom Presets UI (v3.5)
   284→  initCustomPresetsUI();
   285→
   286→  console.log('[SPLICE] Plugin initialized v3.5 (Direct DOM Reconstruction)');
   287→});
   288→
   289→// ============================================================================
   290→// DEBOUNCED UI UPDATES (Performance: batch DOM updates)
   291→// ============================================================================
   292→function scheduleUIUpdate(callback) {
   293→  if (pendingUIUpdate) {
   294→    cancelAnimationFrame(pendingUIUpdate);
   295→  }
   296→  pendingUIUpdate = requestAnimationFrame(() => {
   297→    callback();
   298→    pendingUIUpdate = null;
   299→  });
   300→}
   301→
   302→function updateSelectionCounts() {
   303→  scheduleUIUpdate(() => {
   304→    if (ui.selectedCount) {
   305→      ui.selectedCount.textContent = selectedSilenceIndices.size;
   306→    }
   307→    updateApplyButton();
   308→    updateSelectAllCheckbox();
   309→  });
   310→}
   311→
   312→// ============================================================================
   313→// KEYBOARD SHORTCUTS
   314→// ============================================================================
   315→function initKeyboardShortcuts() {
   316→  document.addEventListener('keydown', (e) => {
   317→    // Only handle when combined preview is visible
   318→    const previewVisible = ui.combinedPreview?.style.display !== 'none' &&
   319→                           ui.combinedPreview?.style.display !== '';
   320→
   321→    if (!previewVisible) return;
   322→
   323→    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
   324→    const cmdKey = isMac ? e.metaKey : e.ctrlKey;
   325→
   326→    // Enter - Apply selected
   327→    if (e.key === 'Enter' && !e.shiftKey) {
   328→      e.preventDefault();
   329→      if (selectedSilenceIndices.size > 0) {
   330→        ui.applyPreviewBtn?.click();
   331→      }
   332→    }
   333→
   334→    // Escape - Cancel
   335→    if (e.key === 'Escape') {
   336→      e.preventDefault();
   337→      ui.cancelPreviewBtn?.click();
   338→    }
   339→
   340→    // Cmd/Ctrl+A - Select all
   341→    if (e.key === 'a' && cmdKey) {
   342→      e.preventDefault();
   343→      if (ui.selectAllSilences) {
   344→        ui.selectAllSilences.checked = true;
   345→        selectAllSilences(true);
   346→      }
   347→    }
   348→
   349→    // Cmd/Ctrl+D - Deselect all
   350→    if (e.key === 'd' && cmdKey) {
   351→      e.preventDefault();
   352→      if (ui.selectAllSilences) {
   353→        ui.selectAllSilences.checked = false;
   354→        selectAllSilences(false);
   355→      }
   356→    }
   357→
   358→    // Cmd/Ctrl+I - Invert selection
   359→    if (e.key === 'i' && cmdKey) {
   360→      e.preventDefault();
   361→      invertSilenceSelection();
   362→    }
   363→  });
   364→}
   365→
   366→// ============================================================================
   367→// UNIFIED WORKFLOW (Silence Detection + Takes Detection)
   368→// ============================================================================
   369→function initUnifiedWorkflow() {
   370→  if (!ui.goBtn) return;
   371→
   372→  ui.goBtn.addEventListener('click', async () => {
   373→    // Prevent double-click
   374→    if (isOperationInProgress) {
   375→      setStatus('Operation in progress...');
   376→      return;
   377→    }
   378→
   379→    // Check online status before proceeding
   380→    if (typeof isOnline === 'function' && !isOnline()) {
   381→      setStatus('⚠ Offline - Check your connection and try again');
   382→      return;
   383→    }
   384→
   385→    isOperationInProgress = true;
   386→    ui.goBtn.disabled = true;
   387→
   388→    try {
   389→      showProgress('Preparing audio...');
   390→
   391→      // Step 1: Export audio
   392→      const exportSuccess = await exportAudioInternal();
   393→      if (!exportSuccess) {
   394→        throw new Error('Audio export failed');
   395→      }
   396→
   397→      // Step 2: Get settings
   398→      const sensitivity = parseInt(ui.sensitivitySlider?.value || 50);
   399→      const useIsolated = ui.sourceIsolated?.checked ?? false;
   400→      const detectTakes = ui.enableTakesDetection?.checked ?? true;
   401→
   402→      // Get initialized paths (cross-platform)
   403→      const paths = await getPaths();
   404→
   405→      // Step 3: Vocal isolation if needed
   406→      let audioPath = paths.wavPath;
   407→      if (useIsolated) {
   408→        // Check isolation access before proceeding
   409→        const credits = getCurrentCredits();
   410→        if (!credits || !credits.hasIsolationAccess) {
   411→          throw new Error('Vocal isolation requires Pro or Team tier. Upgrade to access this feature.');
   412→        }
   413→
   414→        // Show overage warning if applicable
   415→        const isolationMins = credits.isolationHoursRemaining * 60;
   416→        if (isolationMins <= 0) {
   417→          const overageRate = credits.isolationOverageRate || 0.08;
   418→          showProgress(`Isolating vocals (overage: $${overageRate}/min)...`);
   419→        } else {
   420→          showProgress(`Isolating vocals (${isolationMins.toFixed(0)} min remaining)...`);
   421→        }
   422→
   423→        const isolateResult = await isolateVocals();
   424→        if (isolateResult.success) {
   425→          audioPath = isolateResult.outputPath;
   426→          // Update credits display after isolation
   427→          await refreshCredits();
   428→        } else {
   429→          throw new Error(isolateResult.error || 'Vocal isolation failed');
   430→        }
   431→      }
   432→
   433→      // Step 4: Run detection (parallel if takes enabled)
   434→      const params = mapSensitivity(sensitivity);
   435→      let silences = [];
   436→      let takes = [];
   437→
   438→      if (detectTakes) {
   439→        // Parallel detection for performance
   440→        showProgress('Detecting silences and analyzing takes...');
   441→        const [silenceResult, transcriptResult] = await Promise.all([
   442→          detectSilences(audioPath, params),
   443→          transcribeAudio()
   444→        ]);
   445→
   446→        silences = silenceResult;
   447→
   448→        // Extract takes from transcript result
   449→        if (transcriptResult.success && transcriptResult.takes) {
   450→          if (transcriptResult.takes.takes) {
   451→            takes = transcriptResult.takes.takes;
   452→          } else if (Array.isArray(transcriptResult.takes)) {
   453→            takes = transcriptResult.takes;
   454→          }
   455→        }
   456→
   457→        // Store transcript for reference
   458→        window.currentTranscript = transcriptResult.transcript;
   459→      } else {
   460→        // Just detect silences
   461→        showProgress('Detecting silences...');
   462→        silences = await detectSilences(audioPath, params);
   463→      }
   464→
   465→      if (silences.length === 0) {
   466→        showEmptyState();
   467→        setStatus('No silences detected. Try increasing sensitivity.');
   468→        return;
   469→      }
   470→
   471→      // Step 5: Filter silences by takes (protect speech)
   472→      const filtered = filterSilencesByTakes(silences, takes);
   473→
   474→      // Step 6: Add timeline markers (clear old ones first)
   475→      showProgress('Adding timeline markers...');
   476→      await clearSpliceMarkers();
   477→      const markerResult = await addTimelineMarkers(filtered.safe, filtered.protected, takes);
   478→
   479→      // Step 7: Show combined preview
   480→      showCombinedPreview(filtered.safe, filtered.protected, takes);
   481→
   482→      const markerInfo = markerResult.added > 0 ? ` (${markerResult.added} markers added)` : '';
   483→      const statusMsg = takes.length > 0
   484→        ? `Found ${silences.length} silences, ${filtered.protected.length} protected by ${takes.length} takes${markerInfo}`
   485→        : `Found ${silences.length} silence(s) - review and apply${markerInfo}`;
   486→      setStatus(statusMsg);
   487→
   488→    } catch (err) {
   489→      showEmptyState();
   490→      setStatus('Error: ' + err.message);
   491→      console.error('[SPLICE] Unified workflow error:', err);
   492→    } finally {
   493→      isOperationInProgress = false;
   494→      ui.goBtn.disabled = false;
   495→    }
   496→  });
   497→}
   498→
   499→// ============================================================================
   500→// TAKE-AWARE SILENCE FILTERING
   501→// ============================================================================
   502→/**
   503→ * Filter silences to protect those that overlap with takes (speech segments).
   504→ * Returns { safe: [], protected: [] }
   505→ */
   506→function filterSilencesByTakes(silences, takes) {
   507→  if (!takes || takes.length === 0) {
   508→    // No takes = all silences are safe to remove
   509→    return { safe: silences, protected: [] };
   510→  }
   511→
   512→  const safe = [];
   513→  const protected_ = [];
   514→
   515→  silences.forEach(silence => {
   516→    // Check if this silence overlaps with any take
   517→    const overlaps = takes.some(take => {
   518→      const takeStart = take.startTime || take.start;
   519→      const takeEnd = take.endTime || take.end;
   520→      // Overlap exists if silence starts before take ends AND silence ends after take starts
   521→      return silence.start < takeEnd && silence.end > takeStart;
   522→    });
   523→
   524→    if (overlaps) {
   525→      protected_.push(silence);
   526→    } else {
   527→      safe.push(silence);
   528→    }
   529→  });
   530→
   531→  console.log(`[SPLICE] Filtered silences: ${safe.length} safe, ${protected_.length} protected`);
   532→  return { safe, protected: protected_ };
   533→}
   534→
   535→// ============================================================================
   536→// TIMELINE MARKERS (Visual indicators on Premiere Pro timeline)
   537→// ============================================================================
   538→/**
   539→ * Add colored markers to the timeline for silences and takes.
   540→ * - Red markers: silences safe to remove
   541→ * - Yellow markers: silences protected by takes
   542→ * - Blue markers: takes (speech segments)
   543→ *
   544→ * @param {Array} safeToRemove - Silences safe to remove
   545→ * @param {Array} protectedSilences - Silences overlapping speech
   546→ * @param {Array} takes - Detected speech segments
   547→ * @returns {Promise<{added: number, errors: number}>}
   548→ */
   549→async function addTimelineMarkers(safeToRemove, protectedSilences, takes) {
   550→  const results = { added: 0, errors: 0 };
   551→
   552→  try {
   553→    const context = await getActiveSequence();
   554→    if (!context) {
   555→      console.warn('[SPLICE] No sequence available for markers');
   556→      return results;
   557→    }
   558→
   559→    const { sequence, project } = context;
   560→
   561→    // Get markers object for the sequence
   562→    const markers = await ppro.Markers.getMarkers(sequence);
   563→    if (!markers) {
   564→      console.warn('[SPLICE] Markers API not available');
   565→      return results;
   566→    }
   567→
   568→    // Collect all marker actions
   569→    const markerActions = [];
   570→
   571→    // Red markers for safe-to-remove silences
   572→    for (const silence of safeToRemove) {
   573→      try {
   574→        const duration = silence.end - silence.start;
   575→
   576→        // Use TickTime API directly (no TICKS_PER_SECOND needed)
   577→        const startTime = ppro.TickTime.createWithSeconds(silence.start);
   578→        const durationTime = ppro.TickTime.createWithSeconds(duration);
   579→
   580→        const action = markers.createAddMarkerAction(
   581→          `SPLICE: Remove (${duration.toFixed(2)}s)`,
   582→          ppro.Marker.MARKER_TYPE_COMMENT,
   583→          startTime,
   584→          durationTime,
   585→          `Silence to remove: ${formatTime(silence.start)} - ${formatTime(silence.end)}`
   586→        );
   587→        markerActions.push({ action, colorIndex: 1, type: 'silence' }); // Red = index 1
   588→      } catch (err) {
   589→        console.error('[SPLICE] Error creating silence marker:', err);
   590→        results.errors++;
   591→      }
   592→    }
   593→
   594→    // Yellow markers for protected silences
   595→    for (const silence of protectedSilences) {
   596→      try {
   597→        const duration = silence.end - silence.start;
   598→
   599→        // Use TickTime API directly (no TICKS_PER_SECOND needed)
   600→        const startTime = ppro.TickTime.createWithSeconds(silence.start);
   601→        const durationTime = ppro.TickTime.createWithSeconds(duration);
   602→
   603→        const action = markers.createAddMarkerAction(
   604→          `SPLICE: Protected (${duration.toFixed(2)}s)`,
   605→          ppro.Marker.MARKER_TYPE_COMMENT,
   606→          startTime,
   607→          durationTime,
   608→          `Protected silence (overlaps speech): ${formatTime(silence.start)} - ${formatTime(silence.end)}`
   609→        );
   610→        markerActions.push({ action, colorIndex: 4, type: 'protected' }); // Yellow = index 4
   611→      } catch (err) {
   612→        console.error('[SPLICE] Error creating protected marker:', err);
   613→        results.errors++;
   614→      }
   615→    }
   616→
   617→    // Blue markers for takes (speech segments)
   618→    for (const take of takes) {
   619→      try {
   620→        const start = take.startTime || take.start;
   621→        const end = take.endTime || take.end;
   622→        const duration = end - start;
   623→        const textPreview = take.text?.substring(0, 30) || 'Speech';
   624→
   625→        // Use TickTime API directly (no TICKS_PER_SECOND needed)
   626→        const startTime = ppro.TickTime.createWithSeconds(start);
   627→        const durationTime = ppro.TickTime.createWithSeconds(duration);
   628→
   629→        const action = markers.createAddMarkerAction(
   630→          `SPLICE: Take`,
   631→          ppro.Marker.MARKER_TYPE_COMMENT,
   632→          startTime,
   633→          durationTime,
   634→          `Speech segment: ${textPreview}${take.text?.length > 30 ? '...' : ''}`
   635→        );
   636→        markerActions.push({ action, colorIndex: 5, type: 'take' }); // Blue = index 5
   637→      } catch (err) {
   638→        console.error('[SPLICE] Error creating take marker:', err);
   639→        results.errors++;
   640→      }
   641→    }
   642→
   643→    // Execute all marker actions in a single transaction
   644→    if (markerActions.length > 0) {
   645→      await project.lockedAccess(async () => {
   646→        await project.executeTransaction((compoundAction) => {
   647→          for (const { action } of markerActions) {
   648→            compoundAction.addAction(action);
   649→          }
   650→        }, 'SPLICE: Add Timeline Markers');
   651→      });
   652→
   653→      results.added = markerActions.length;
   654→      console.log(`[SPLICE] Added ${results.added} timeline markers`);
   655→    }
   656→
   657→  } catch (err) {
   658→    console.error('[SPLICE] Timeline markers error:', err);
   659→    results.errors++;
   660→  }
   661→
   662→  return results;
   663→}
   664→
   665→/**
   666→ * Read current SPLICE marker positions from timeline.
   667→ * This allows users to manually adjust markers before applying.
   668→ * Returns silences based on current marker positions (not original detection).
   669→ */
   670→async function readMarkersAssilences() {
   671→  const silences = [];
   672→
   673→  try {
   674→    const context = await getActiveSequence();
   675→    if (!context) return silences;
   676→
   677→    const { sequence } = context;
   678→    const markers = await ppro.Markers.getMarkers(sequence);
   679→    if (!markers) return silences;
   680→
   681→    const allMarkers = await markers.getMarkers();
   682→    if (!allMarkers || allMarkers.length === 0) return silences;
   683→
   684→    for (const marker of allMarkers) {
   685→      const name = await marker.getName();
   686→
   687→      // Only read "Remove" markers (red ones that will be cut)
   688→      if (name && name.startsWith('SPLICE: Remove')) {
   689→        const startTickTime = await marker.getStart();
   690→        const durationTickTime = await marker.getDuration();
   691→
   692→        // Use TickTime.seconds property to get seconds directly (no TICKS_PER_SECOND needed)
   693→        const start = startTickTime.seconds;
   694→        const duration = durationTickTime.seconds;
   695→        const end = start + duration;
   696→
   697→        silences.push({
   698→          start,
   699→          end,
   700→          duration,
   701→          fromMarker: true  // Flag to indicate this came from marker adjustment
   702→        });
   703→      }
   704→    }
   705→
   706→    // Sort by start time
   707→    silences.sort((a, b) => a.start - b.start);
   708→    console.log(`[SPLICE] Read ${silences.length} silences from adjusted markers`);
   709→
   710→  } catch (err) {
   711→    console.error('[SPLICE] Error reading markers:', err);
   712→  }
   713→
   714→  return silences;
   715→}
   716→
   717→/**
   718→ * Remove all SPLICE markers from the timeline.
   719→ * Call this before adding new markers to avoid duplicates.
   720→ */
   721→async function clearSpliceMarkers() {
   722→  try {
   723→    const context = await getActiveSequence();
   724→    if (!context) return 0;
   725→
   726→    const { sequence, project } = context;
   727→    const markers = await ppro.Markers.getMarkers(sequence);
   728→    if (!markers) return 0;
   729→
   730→    // Get all markers
   731→    const allMarkers = await markers.getMarkers();
   732→    if (!allMarkers || allMarkers.length === 0) return 0;
   733→
   734→    // Filter SPLICE markers
   735→    const spliceMarkers = [];
   736→    for (const marker of allMarkers) {
   737→      const name = await marker.getName();
   738→      if (name && name.startsWith('SPLICE:')) {
   739→        spliceMarkers.push(marker);
   740→      }
   741→    }
   742→
   743→    if (spliceMarkers.length === 0) return 0;
   744→
   745→    // Remove all SPLICE markers in a single transaction
   746→    await project.lockedAccess(async () => {
   747→      await project.executeTransaction((compoundAction) => {
   748→        for (const marker of spliceMarkers) {
   749→          const removeAction = markers.createRemoveMarkerAction(marker);
   750→          compoundAction.addAction(removeAction);
   751→        }
   752→      }, 'SPLICE: Clear Markers');
   753→    });
   754→
   755→    console.log(`[SPLICE] Cleared ${spliceMarkers.length} previous markers`);
   756→    return spliceMarkers.length;
   757→
   758→  } catch (err) {
   759→    console.error('[SPLICE] Error clearing markers:', err);
   760→    return 0;
   761→  }
   762→}
   763→
   764→// ============================================================================
   765→// COMBINED PREVIEW (Silences + Takes with colored markers)
   766→// ============================================================================
   767→/**
   768→ * Show combined preview with:
   769→ * - Red markers: silences safe to remove
   770→ * - Yellow markers: silences protected by takes (won't be removed)
   771→ * - Blue markers: takes (for reference)
   772→ */
   773→function showCombinedPreview(safeToRemove, protectedSilences, takes) {
   774→  // Update global state
   775→  safeSilences = safeToRemove;
   776→  previewSilences = [...safeToRemove, ...protectedSilences];
   777→  previewTakes = takes;
   778→  selectedSilenceIndices = new Set(safeToRemove.map((_, i) => i));
   779→
   780→  // Hide other views
   781→  hideAllViews();
   782→
   783→  // Update summary counts
   784→  if (ui.silenceCountDisplay) ui.silenceCountDisplay.textContent = safeToRemove.length;
   785→  if (ui.takeCountDisplay) ui.takeCountDisplay.textContent = takes.length;
   786→  if (ui.selectedCount) ui.selectedCount.textContent = safeToRemove.length;
   787→
   788→  // Build combined items list (sorted by time)
   789→  const items = [
   790→    ...safeToRemove.map((s, i) => ({ type: 'silence', index: i, start: s.start, end: s.end, data: s })),
   791→    ...protectedSilences.map(s => ({ type: 'protected', start: s.start, end: s.end, data: s })),
   792→    ...takes.map(t => ({ type: 'take', start: t.startTime || t.start, end: t.endTime || t.end, data: t }))
   793→  ].sort((a, b) => a.start - b.start);
   794→
   795→  // Build preview list using DocumentFragment
   796→  const fragment = document.createDocumentFragment();
   797→
   798→  items.forEach((item) => {
   799→    const duration = item.end - item.start;
   800→    const div = document.createElement('div');
   801→
   802→    if (item.type === 'silence') {
   803→      // Safe to remove - red marker with checkbox
   804→      div.className = 'preview-item silence-marker';
   805→      div.dataset.index = item.index;
   806→      div.innerHTML = `
   807→        <input type="checkbox" class="preview-item-check" checked data-index="${item.index}">
   808→        <div class="preview-item-info">
   809→          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
   810→          <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
   811→        </div>
   812→        <button class="preview-item-seek" data-time="${item.start}" title="Seek to this silence">&gt;</button>
   813→      `;
   814→    } else if (item.type === 'protected') {
   815→      // Protected by take - yellow marker, no checkbox
   816→      div.className = 'preview-item protected-silence';
   817→      div.innerHTML = `
   818→        <div style="width: 20px; margin-right: 10px;"></div>
   819→        <div class="preview-item-info">
   820→          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
   821→          <div class="preview-item-duration">${duration.toFixed(2)}s (overlaps speech)</div>
   822→        </div>
   823→        <button class="preview-item-seek" data-time="${item.start}" title="Seek">&gt;</button>
   824→      `;
   825→    } else if (item.type === 'take') {
   826→      // Take (speech segment) - blue marker, no checkbox
   827→      div.className = 'preview-item take-marker';
   828→      const textPreview = item.data.text?.substring(0, 40) || 'Speech segment';
   829→      div.innerHTML = `
   830→        <div style="width: 20px; margin-right: 10px;"></div>
   831→        <div class="preview-item-info">
   832→          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
   833→          <div class="preview-item-duration">${textPreview}${item.data.text?.length > 40 ? '...' : ''}</div>
   834→        </div>
   835→        <button class="preview-item-seek" data-time="${item.start}" title="Seek to take">&gt;</button>
   836→      `;
   837→    }
   838→
   839→    fragment.appendChild(div);
   840→  });
   841→
   842→  if (ui.previewList) {
   843→    ui.previewList.textContent = '';
   844→    ui.previewList.appendChild(fragment);
   845→  }
   846→
   847→  // Reset UI state
   848→  if (ui.selectAllSilences) ui.selectAllSilences.checked = true;
   849→  updateApplyButton();
   850→
   851→  // Show combined preview section
   852→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'block';
   853→}
   854→
   855→function initPreviewHandlers() {
   856→  // EVENT DELEGATION: Single listener on parent instead of many on children
   857→  if (ui.previewList) {
   858→    // Handle checkbox changes
   859→    ui.previewList.addEventListener('change', (e) => {
   860→      if (e.target.classList.contains('preview-item-check')) {
   861→        const index = parseInt(e.target.dataset.index);
   862→        const item = e.target.closest('.preview-item');
   863→
   864→        if (e.target.checked) {
   865→          selectedSilenceIndices.add(index);
   866→          item?.classList.remove('excluded');
   867→        } else {
   868→          selectedSilenceIndices.delete(index);
   869→          item?.classList.add('excluded');
   870→        }
   871→        updateSelectionCounts();
   872→      }
   873→    });
   874→
   875→    // Handle seek button clicks
   876→    ui.previewList.addEventListener('click', async (e) => {
   877→      if (e.target.classList.contains('preview-item-seek')) {
   878→        e.stopPropagation();
   879→        const btn = e.target;
   880→        const time = parseFloat(btn.dataset.time);
   881→
   882→        // Show loading state
   883→        btn.classList.add('loading');
   884→        btn.textContent = '...';
   885→
   886→        try {
   887→          await seekToTime(time);
   888→        } finally {
   889→          btn.classList.remove('loading');
   890→          btn.textContent = '>';
   891→        }
   892→      }
   893→    });
   894→  }
   895→
   896→  // Apply button
   897→  if (ui.applyPreviewBtn) {
   898→    ui.applyPreviewBtn.addEventListener('click', async () => {
   899→      if (isOperationInProgress) return;
   900→      isOperationInProgress = true;
   901→      ui.applyPreviewBtn.disabled = true;
   902→
   903→      const originalText = ui.applyPreviewBtn.textContent;
   904→      ui.applyPreviewBtn.textContent = 'Applying...';
   905→
   906→      try {
   907→        await applySelectedSilences();
   908→      } catch (err) {
   909→        setStatus('Error: ' + err.message);
   910→        console.error('[SPLICE] Apply error:', err);
   911→      } finally {
   912→        ui.applyPreviewBtn.textContent = originalText;
   913→        ui.applyPreviewBtn.disabled = false;
   914→        isOperationInProgress = false;
   915→      }
   916→    });
   917→  }
   918→
   919→  // Cancel button
   920→  if (ui.cancelPreviewBtn) {
   921→    ui.cancelPreviewBtn.addEventListener('click', async () => {
   922→      await cancelPreview();
   923→    });
   924→  }
   925→
   926→  // Select all checkbox
   927→  if (ui.selectAllSilences) {
   928→    ui.selectAllSilences.addEventListener('change', (e) => {
   929→      selectAllSilences(e.target.checked);
   930→    });
   931→  }
   932→
   933→  // Invert selection button
   934→  if (ui.invertSelectionBtn) {
   935→    ui.invertSelectionBtn.addEventListener('click', () => {
   936→      invertSilenceSelection();
   937→    });
   938→  }
   939→
   940→  // Duration filter buttons
   941→  document.querySelectorAll('.preview-filters .filter-btn[data-min]').forEach(btn => {
   942→    btn.addEventListener('click', () => {
   943→      const min = parseFloat(btn.dataset.min);
   944→      const max = parseFloat(btn.dataset.max);
   945→      selectByDuration(min, max);
   946→    });
   947→  });
   948→
   949→  // Re-run detection button
   950→  if (ui.reRunDetectionBtn) {
   951→    ui.reRunDetectionBtn.addEventListener('click', () => {
   952→      // Hide preview, show options, let user adjust sensitivity
   953→      if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
   954→      if (ui.optionsPanel) ui.optionsPanel.classList.remove('collapsed');
   955→      if (ui.optionsToggle) ui.optionsToggle.classList.add('expanded');
   956→      showEmptyState();
   957→      setStatus('Adjust sensitivity and click GO again');
   958→    });
   959→  }
   960→
   961→  // Build Sequence button (v3.5 - direct DOM reconstruction)
   962→  if (ui.buildSequenceBtn) {
   963→    ui.buildSequenceBtn.addEventListener('click', async () => {
   964→      if (isOperationInProgress) return;
   965→
   966→      // Check if we have detection data
   967→      if (safeSilences.length === 0 && previewTakes.length === 0) {
   968→        setStatus('No detection data. Run analysis first.');
   969→        return;
   970→      }
   971→
   972→      isOperationInProgress = true;
   973→      ui.buildSequenceBtn.disabled = true;
   974→      const originalText = ui.buildSequenceBtn.textContent;
   975→      ui.buildSequenceBtn.textContent = 'Building...';
   976→
   977→      try {
   978→        showProgress('Building new sequence...');
   979→
   980→        const result = await buildSequenceWithCutList();
   981→
   982→        if (result.success) {
   983→          // Hide preview and show success
   984→          if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
   985→          showEmptyState();
   986→
   987→          const metadata = result.metadata || {};
   988→          setStatus(`New sequence created: ${metadata.silencesRemoved || 0} silences removed, ${metadata.takesDetected || 0} takes detected`);
   989→
   990→          // Clear markers after successful build
   991→          await clearSpliceMarkers();
   992→
   993→          // Clear preview state
   994→          previewSilences = [];
   995→          safeSilences = [];
   996→          protectedSilences = [];
   997→          previewTakes = [];
   998→          selectedSilenceIndices.clear();
   999→        } else {
  1000→          // User-friendly error messages
  1001→          const errorMsg = result.error || 'Unknown error';
  1002→          setStatus('Build failed: ' + formatBuildError(errorMsg));
  1003→        }
  1004→
  1005→      } catch (err) {
  1006→        console.error('[SPLICE] Build sequence error:', err);
  1007→        // User-friendly error messages with recovery hints
  1008→        setStatus('Build error: ' + formatBuildError(err.message));
  1009→      } finally {
  1010→        ui.buildSequenceBtn.textContent = originalText;
  1011→        ui.buildSequenceBtn.disabled = false;
  1012→        isOperationInProgress = false;
  1013→      }
  1014→    });
  1015→  }
  1016→}
  1017→
  1018→function selectAllSilences(checked) {
  1019→  selectedSilenceIndices.clear();
  1020→
  1021→  if (checked) {
  1022→    safeSilences.forEach((_, i) => selectedSilenceIndices.add(i));
  1023→  }
  1024→
  1025→  // Batch update DOM (only silence-marker items have checkboxes)
  1026→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
  1027→    const index = parseInt(checkbox.dataset.index);
  1028→    checkbox.checked = checked;
  1029→    const item = checkbox.closest('.preview-item');
  1030→    if (checked) {
  1031→      item?.classList.remove('excluded');
  1032→    } else {
  1033→      item?.classList.add('excluded');
  1034→    }
  1035→  });
  1036→
  1037→  updateSelectionCounts();
  1038→}
  1039→
  1040→function invertSilenceSelection() {
  1041→  const allIndices = new Set(safeSilences.map((_, i) => i));
  1042→  const newSelection = new Set([...allIndices].filter(i => !selectedSilenceIndices.has(i)));
  1043→  selectedSilenceIndices = newSelection;
  1044→
  1045→  // Update DOM
  1046→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
  1047→    const index = parseInt(checkbox.dataset.index);
  1048→    const isSelected = selectedSilenceIndices.has(index);
  1049→    checkbox.checked = isSelected;
  1050→    const item = checkbox.closest('.preview-item');
  1051→    if (isSelected) {
  1052→      item?.classList.remove('excluded');
  1053→    } else {
  1054→      item?.classList.add('excluded');
  1055→    }
  1056→  });
  1057→
  1058→  updateSelectionCounts();
  1059→}
  1060→
  1061→function selectByDuration(minSec, maxSec) {
  1062→  selectedSilenceIndices.clear();
  1063→
  1064→  safeSilences.forEach((silence, index) => {
  1065→    const duration = silence.end - silence.start;
  1066→    if (duration >= minSec && duration < maxSec) {
  1067→      selectedSilenceIndices.add(index);
  1068→    }
  1069→  });
  1070→
  1071→  // Update DOM
  1072→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
  1073→    const index = parseInt(checkbox.dataset.index);
  1074→    const isSelected = selectedSilenceIndices.has(index);
  1075→    checkbox.checked = isSelected;
  1076→    const item = checkbox.closest('.preview-item');
  1077→    if (isSelected) {
  1078→      item?.classList.remove('excluded');
  1079→    } else {
  1080→      item?.classList.add('excluded');
  1081→    }
  1082→  });
  1083→
  1084→  updateSelectionCounts();
  1085→  setStatus(`Selected ${selectedSilenceIndices.size} silences (${minSec}s - ${maxSec}s)`);
  1086→}
  1087→
  1088→async function cancelPreview() {
  1089→  // Keep silences available for Razor if detected
  1090→  const hadSilences = safeSilences.length > 0;
  1091→
  1092→  previewSilences = [];
  1093→  safeSilences = [];
  1094→  protectedSilences = [];
  1095→  previewTakes = [];
  1096→  selectedSilenceIndices.clear();
  1097→  showEmptyState();
  1098→
  1099→  // Clear timeline markers
  1100→  const cleared = await clearSpliceMarkers();
  1101→  const markerInfo = cleared > 0 ? ` (${cleared} markers removed)` : '';
  1102→  setStatus('Preview cancelled' + markerInfo);
  1103→
  1104→  // Show Razor section if silences were detected
  1105→  if (hadSilences && ui.advancedSection) {
  1106→    ui.advancedSection.classList.remove('hidden');
  1107→  }
  1108→}
  1109→
  1110→async function applySelectedSilences() {
  1111→  if (selectedSilenceIndices.size === 0) {
  1112→    setStatus('No silences selected');
  1113→    return;
  1114→  }
  1115→
  1116→  showProgress('Reading marker positions...');
  1117→
  1118→  // Read current marker positions from timeline
  1119→  // This allows users to manually adjust markers before applying
  1120→  const markerSilences = await readMarkersAssilences();
  1121→
  1122→  let silencesToApply;
  1123→  let adjustedCount = 0;
  1124→
  1125→  if (markerSilences.length > 0) {
  1126→    // Use marker positions (may have been adjusted by user)
  1127→    silencesToApply = markerSilences;
  1128→    adjustedCount = markerSilences.length;
  1129→    console.log(`[SPLICE] Using ${adjustedCount} silences from adjusted markers`);
  1130→  } else {
  1131→    // Fallback to original detection data
  1132→    silencesToApply = safeSilences.filter((_, i) => selectedSilenceIndices.has(i));
  1133→    console.log(`[SPLICE] Using ${silencesToApply.length} silences from original detection`);
  1134→  }
  1135→
  1136→  if (silencesToApply.length === 0) {
  1137→    setStatus('No silences to apply');
  1138→    return;
  1139→  }
  1140→
  1141→  // Update global silences for the apply function
  1142→  setCurrentSilences(silencesToApply);
  1143→
  1144→  showProgress('Applying changes...');
  1145→
  1146→  // Apply to timeline
  1147→  const result = await removeSilencesFromTimeline();
  1148→
  1149→  // Clear markers after applying
  1150→  await clearSpliceMarkers();
  1151→
  1152→  // Hide preview
  1153→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
  1154→
  1155→  // Show results
  1156→  showSilenceResults({
  1157→    count: silencesToApply.length,
  1158→    timeSaved: silencesToApply.reduce((sum, s) => sum + (s.end - s.start), 0),
  1159→    clipsModified: result
  1160→  });
  1161→
  1162→  // Show advanced section
  1163→  if (ui.advancedSection) ui.advancedSection.classList.remove('hidden');
  1164→
  1165→  const adjustedInfo = adjustedCount > 0 ? ' (from adjusted markers)' : '';
  1166→  setStatus(`Removed ${silencesToApply.length} silence(s) - ${result} clip(s) modified${adjustedInfo}`);
  1167→
  1168→  // Refresh credits (await to prevent race conditions)
  1169→  try {
  1170→    await refreshCredits();
  1171→  } catch (err) {
  1172→    console.warn('[SPLICE] Credits refresh failed:', err);
  1173→  }
  1174→
  1175→  // Clear preview state
  1176→  previewSilences = [];
  1177→  safeSilences = [];
  1178→  protectedSilences = [];
  1179→  previewTakes = [];
  1180→  selectedSilenceIndices.clear();
  1181→}
  1182→
  1183→// ============================================================================
  1184→// UI HELPERS
  1185→// ============================================================================
  1186→function updateApplyButton() {
  1187→  if (ui.applyPreviewBtn) {
  1188→    const count = selectedSilenceIndices.size;
  1189→    ui.applyPreviewBtn.disabled = count === 0;
  1190→    ui.applyPreviewBtn.textContent = count === 0 ? 'Select silences' : `Apply ${count} Selected`;
  1191→  }
  1192→}
  1193→
  1194→function updateSelectAllCheckbox() {
  1195→  if (ui.selectAllSilences) {
  1196→    ui.selectAllSilences.checked = selectedSilenceIndices.size === safeSilences.length && safeSilences.length > 0;
  1197→  }
  1198→}
  1199→
  1200→function hideAllViews() {
  1201→  if (ui.progressContainer) ui.progressContainer.style.display = 'none';
  1202→  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'none';
  1203→  if (ui.silenceResults) ui.silenceResults.style.display = 'none';
  1204→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
  1205→}
  1206→
  1207→function showProgress(message) {
  1208→  hideAllViews();
  1209→  if (ui.progressContainer) ui.progressContainer.style.display = 'block';
  1210→  if (ui.progressText) ui.progressText.textContent = message;
  1211→}
  1212→
  1213→function showEmptyState() {
  1214→  hideAllViews();
  1215→  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'block';
  1216→  if (ui.advancedSection) ui.advancedSection.classList.add('hidden');
  1217→}
  1218→
  1219→function showSilenceResults({ count, timeSaved, clipsModified }) {
  1220→  hideAllViews();
  1221→
  1222→  // Update the results display
  1223→  if (ui.resultsCount) ui.resultsCount.textContent = count;
  1224→  if (ui.timeSaved) ui.timeSaved.textContent = timeSaved.toFixed(1) + 's';
  1225→  if (ui.clipsModified) ui.clipsModified.textContent = clipsModified;
  1226→
  1227→  if (ui.silenceResults) ui.silenceResults.style.display = 'block';
  1228→}
  1229→
  1230→// formatTime is defined in utils.js - using centralized version with NaN check
  1231→
  1232→/**
  1233→ * Format build errors into user-friendly messages
  1234→ * @param {string} error - Raw error message
  1235→ * @returns {string} User-friendly error message
  1236→ */
  1237→function formatBuildError(error) {
  1238→  if (!error) return 'Unknown error occurred';
  1239→
  1240→  // Map technical errors to user-friendly messages
  1241→  const errorMap = {
  1242→    'Builder not initialized': 'Builder module failed to load. Try restarting the plugin.',
  1243→    'No active project': 'No project is open. Please open or create a project first.',
  1244→    'No media items found': 'No media files in project. Import media before building.',
  1245→    'No detection data': 'Run analysis first (click GO button).',
  1246→    'Failed to generate cut list': 'Server error generating cuts. Check your connection.',
  1247→    'Failed to build sequence': 'Premiere Pro sequence build failed. Try again.',
  1248→    'fetch failed': 'Network error. Check if backend server is running.',
  1249→    'NetworkError': 'Cannot connect to server. Check your internet connection.',
  1250→    'Insufficient credits': 'Out of credits. Upgrade your plan to continue.',
  1251→    'Authentication required': 'Login required. Click the credits badge to log in.'
  1252→  };
  1253→
  1254→  // Check for matching error patterns
  1255→  for (const [pattern, friendly] of Object.entries(errorMap)) {
  1256→    if (error.includes(pattern)) {
  1257→      return friendly;
  1258→    }
  1259→  }
  1260→
  1261→  // Return original if no match (already reasonably clear)
  1262→  return error;
  1263→}
  1264→
  1265→// setStatus is defined in utils.js - using centralized version with null check
  1266→// Local override uses cached ui.status for performance
  1267→function setStatus(message) {
  1268→  const statusEl = ui.status || document.getElementById('status');
  1269→  if (statusEl) statusEl.textContent = message;
  1270→}
  1271→
  1272→// ============================================================================
  1273→// UNDO HANDLERS
  1274→// ============================================================================
  1275→function initUndoHandlers() {
  1276→  if (ui.undoBtn) {
  1277→    ui.undoBtn.addEventListener('click', () => {
  1278→      try {
  1279→        ppro.app.executeCommand('Edit.Undo');
  1280→        showEmptyState();
  1281→        setStatus('Changes undone');
  1282→      } catch (e) {
  1283→        setStatus('Undo failed - use Cmd+Z');
  1284→      }
  1285→    });
  1286→  }
  1287→}
  1288→
  1289→// ============================================================================
  1290→// MEDIA FOLDER HANDLERS (v3.5)
  1291→// ============================================================================
  1292→function initMediaFolderHandlers() {
  1293→  // Update display on load
  1294→  updateMediaFolderDisplay();
  1295→
  1296→  // Set media folder button
  1297→  if (ui.setMediaFolderBtn) {
  1298→    ui.setMediaFolderBtn.addEventListener('click', async () => {
  1299→      ui.setMediaFolderBtn.disabled = true;
  1300→      ui.setMediaFolderBtn.textContent = 'Selecting...';
  1301→
  1302→      try {
  1303→        const result = await setupMediaFolder();
  1304→        if (result.success) {
  1305→          updateMediaFolderDisplay();
  1306→          setStatus(`Media folder set: ${result.path}`);
  1307→        } else {
  1308→          setStatus(result.error || 'Failed to set media folder');
  1309→        }
  1310→      } catch (err) {
  1311→        setStatus('Error: ' + err.message);
  1312→      } finally {
  1313→        ui.setMediaFolderBtn.disabled = false;
  1314→        ui.setMediaFolderBtn.textContent = 'Set Folder';
  1315→      }
  1316→    });
  1317→  }
  1318→
  1319→  // Clear media folder button
  1320→  if (ui.clearMediaFolderBtn) {
  1321→    ui.clearMediaFolderBtn.addEventListener('click', () => {
  1322→      clearMediaFolder();
  1323→      updateMediaFolderDisplay();
  1324→      setStatus('Media folder cleared');
  1325→    });
  1326→  }
  1327→}
  1328→
  1329→function updateMediaFolderDisplay() {
  1330→  if (ui.mediaFolderDisplay) {
  1331→    const path = getMediaFolderPath();
  1332→    if (path) {
  1333→      // Truncate long paths for display
  1334→      const displayPath = path.length > 40
  1335→        ? '...' + path.slice(-37)
  1336→        : path;
  1337→      ui.mediaFolderDisplay.textContent = displayPath;
  1338→      ui.mediaFolderDisplay.title = path; // Full path on hover
  1339→      ui.mediaFolderDisplay.style.color = '#4a9eff';
  1340→    } else {
  1341→      ui.mediaFolderDisplay.textContent = 'Not configured';
  1342→      ui.mediaFolderDisplay.title = '';
  1343→      ui.mediaFolderDisplay.style.color = '#888';
  1344→    }
  1345→  }
  1346→}
  1347→
  1348→// ============================================================================
  1349→// BUILD SEQUENCE (v3.5 - Direct DOM Reconstruction)
  1350→// ============================================================================
  1351→
  1352→// 1. ROBUST CONSTANTS (Fixes 'undefined' error)
  1353→// We define these integers explicitly because UXP API versions vary on where they store Enums.
  1354→const ProjectItemType = {
  1355→    CLIP: 1,
  1356→    BIN: 2,
  1357→    ROOT: 3,
  1358→    FILE: 4
  1359→};
  1360→
  1361→/**
  1362→ * Find the first media item in the project bin (recursively)
  1363→ * @param {Object} item - ProjectItem (usually rootItem)
  1364→ * @returns {Promise<Object|null>} First media item found or null
  1365→ */
  1366→async function findFirstMediaItem(item) {
  1367→  if (!item) return null;
  1368→
  1369→  // Fix: Use local Constant instead of app.Constants.ProjectItemType
  1370→  if (item.type === ProjectItemType.CLIP) {
  1371→    return item;
  1372→  }
  1373→
  1374→  // Search Children (Bin or Root)
  1375→  // Note: item.children is a collection, check numItems
  1376→  if (item.children && item.children.numItems > 0) {
  1377→    for (let i = 0; i < item.children.numItems; i++) {
  1378→      const child = item.children[i];
  1379→      const found = await findFirstMediaItem(child);
  1380→      if (found) return found;
  1381→    }
  1382→  }
  1383→
  1384→  return null;
  1385→}
  1386→
  1387→/**
  1388→ * Build a sequence from detection data locally
  1389→ * Used for testing via console: await buildSequenceV35(silences)
  1390→ */
  1391→async function buildSequenceV35(silences, takes = []) {
  1392→    if (!window.spliceBuilder) {
  1393→        throw new Error('Builder not initialized. Check if builder.js is loaded.');
  1394→    }
  1395→
  1396→    const app = require('premierepro');
  1397→    const project = await app.Project.getActiveProject();
  1398→    if (!project) throw new Error("No active project found.");
  1399→
  1400→    const rootItem = await project.getRootItem();
  1401→    const sourceProjectItem = await findFirstMediaItem(rootItem);
  1402→
  1403→    if (!sourceProjectItem) {
  1404→        throw new Error('No media items found in project bin.');
  1405→    }
  1406→
  1407→    console.log(`[SPLICE] Found source media: ${sourceProjectItem.name}`);
  1408→
  1409→    return await window.spliceBuilder.buildSequenceFromDetection(silences, takes, sourceProjectItem);
  1410→}
  1411→
  1412→/**
  1413→ * Request a cut list from the backend and build the sequence.
  1414→ * Full v3.5 workflow.
  1415→ */
  1416→async function buildSequenceWithCutList() {
  1417→  if (!window.spliceBuilder) {
  1418→    throw new Error('Builder not initialized');
  1419→  }
  1420→
  1421→  // Use centralized URL function (uses 127.0.0.1, not localhost - UXP requirement)
  1422→  const apiUrl = getBackendUrl();
  1423→
  1424→  if (typeof showProgress === 'function') showProgress('Getting source clip info...');
  1425→
  1426→  const app = require('premierepro');
  1427→  const project = await app.Project.getActiveProject();
  1428→  if (!project) throw new Error("No active project.");
  1429→
  1430→  const rootItem = await project.getRootItem();
  1431→  const sourceProjectItem = await findFirstMediaItem(rootItem);
  1432→
  1433→  if (!sourceProjectItem) {
  1434→    throw new Error('No media items found in project. Please import a media file first.');
  1435→  }
  1436→
  1437→  // Use properties strictly
  1438→  const sourceName = sourceProjectItem.name;
  1439→  const sourcePath = sourceProjectItem.treePath;
  1440→
  1441→  const durationObj = await sourceProjectItem.getDuration();
  1442→  const duration = durationObj ? durationObj.seconds : 0;
  1443→
  1444→  // Retrieve Globals
  1445→  const silences = window.splicePreviewState?.getSelectedSilences() || (typeof safeSilences !== 'undefined' ? safeSilences : []);
  1446→  const takes = (typeof previewTakes !== 'undefined' ? previewTakes : []);
  1447→
  1448→  if (silences.length === 0 && (!takes || takes.length === 0)) {
  1449→     throw new Error('No detection data found. Run analysis first.');
  1450→  }
  1451→
  1452→  if (typeof showProgress === 'function') showProgress('Generating cut list...');
  1453→
  1454→  const response = await fetchWithTimeout(`${apiUrl}/cut-list`, {
  1455→    method: 'POST',
  1456→    headers: getAuthHeaders(),
  1457→    body: JSON.stringify({
  1458→      sourceName,
  1459→      sourcePath,
  1460→      duration,
  1461→      silences,
  1462→      takes
  1463→    })
  1464→  }, FETCH_TIMEOUT_PROCESSING);
  1465→
  1466→  if (!response.ok) {
  1467→    const errorMsg = await parseErrorResponse(response);
  1468→    throw new Error(errorMsg);
  1469→  }
  1470→
  1471→  const data = await response.json();
  1472→  const cutList = data.cutList;
  1473→
  1474→  if (typeof showProgress === 'function') showProgress('Building sequence...');
  1475→
  1476→  const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, sourceProjectItem);
  1477→
  1478→  if (!result.success) {
  1479→    throw new Error(result.error || 'Failed to build sequence');
  1480→  }
  1481→
  1482→  return {
  1483→    success: true,
  1484→    clipsAdded: result.clipsAdded,
  1485→    metadata: cutList.metadata
  1486→  };
  1487→}
  1488→
  1489→// Expose functions globally for UI and testing
  1490→if (typeof window !== 'undefined') {
  1491→    window.buildSequenceV35 = buildSequenceV35;
  1492→    window.buildSequenceWithCutList = buildSequenceWithCutList;
  1493→    window.findFirstMediaItem = findFirstMediaItem;
  1494→}
  1495→
  1496→// ============================================================================
  1497→// TIMELINE SEEK (with proper error handling)
  1498→// ============================================================================
  1499→async function seekToTime(seconds) {
  1500→  // Validate input
  1501→  if (typeof seconds !== 'number' || isNaN(seconds) || !isFinite(seconds)) {
  1502→    setStatus('Invalid seek time');
  1503→    return;
  1504→  }
  1505→
  1506→  if (seconds < 0) {
  1507→    seconds = 0;
  1508→  }
  1509→
  1510→  try {
  1511→    const context = await getActiveSequence();
  1512→    if (!context) {
  1513→      setStatus('No sequence available');
  1514→      return;
  1515→    }
  1516→
  1517→    const { sequence } = context;
  1518→
  1519→    // Use TickTime API to convert seconds to the format needed
  1520→    const position = ppro.TickTime.createWithSeconds(seconds);
  1521→
  1522→    await sequence.setPlayerPosition(position);
  1523→    setStatus(`Seeked to ${formatTime(seconds)}`);
  1524→  } catch (err) {
  1525→    console.error('[SPLICE] Seek error:', err);
  1526→    setStatus('Seek failed: ' + (err.message || 'Unknown error'));
  1527→  }
  1528→}
  1529→
  1530→// ============================================================================
  1531→// AUTH HEADERS HELPER
  1532→// ============================================================================
  1533→/**
  1534→ * Build request headers with authentication
  1535→ * @returns {Object} Headers object with Content-Type and x-stripe-customer-id
  1536→ */
  1537→function getAuthHeaders() {
  1538→  const headers = { 'Content-Type': 'application/json' };
  1539→  const settings = getSettings();
  1540→  if (settings.customerId) {
  1541→    headers['x-stripe-customer-id'] = settings.customerId;
  1542→  }
  1543→  return headers;
  1544→}
  1545→
  1546→// ============================================================================
  1547→// AUDIO EXPORT & BACKEND CALLS
  1548→// ============================================================================
  1549→async function exportAudioInternal() {
  1550→  try {
  1551→    const context = await getActiveSequence();
  1552→    if (!context) {
  1553→      throw new Error('No project or sequence open');
  1554→    }
  1555→
  1556→    const { sequence } = context;
  1557→    const encoderManager = ppro.EncoderManager.getManager();
  1558→    if (!encoderManager) {
  1559→      throw new Error('EncoderManager not available');
  1560→    }
  1561→
  1562→    // Get initialized paths (cross-platform)
  1563→    const paths = await getPaths();
  1564→    if (!paths.wavPath) {
  1565→      throw new Error('Audio export path not initialized');
  1566→    }
  1567→
  1568→    const result = await encoderManager.exportSequence(
  1569→      sequence,
  1570→      ppro.EncoderManager.EXPORT_IMMEDIATELY,
  1571→      paths.wavPath,
  1572→      paths.presetPath,
  1573→      true
  1574→    );
  1575→
  1576→    return result;
  1577→  } catch (err) {
  1578→    console.error('[SPLICE] Export error:', err);
  1579→    return false;
  1580→  }
  1581→}
  1582→
  1583→async function isolateVocals() {
  1584→  // Get initialized paths (cross-platform)
  1585→  const paths = await getPaths();
  1586→
  1587→  const response = await fetchWithTimeout(`${getBackendUrl()}/isolate-vocals`, {
  1588→    method: 'POST',
  1589→    headers: getAuthHeaders(),
  1590→    body: JSON.stringify({ audioPath: paths.wavPath })
  1591→  }, FETCH_TIMEOUT_PROCESSING);
  1592→
  1593→  if (!response.ok) {
  1594→    const errorMsg = await parseErrorResponse(response);
  1595→    return { success: false, error: errorMsg };
  1596→  }
  1597→
  1598→  return await response.json();
  1599→}
  1600→
  1601→async function detectSilences(audioPath, params) {
  1602→  const response = await fetchWithTimeout(`${getBackendUrl()}/silences-audio`, {
  1603→    method: 'POST',
  1604→    headers: getAuthHeaders(),
  1605→    body: JSON.stringify({
  1606→      wavPath: audioPath,
  1607→      threshold: params.dbThreshold,
  1608→      minDuration: params.minDuration,
  1609→      padding: params.padding
  1610→    })
  1611→  }, FETCH_TIMEOUT_PROCESSING);
  1612→
  1613→  if (!response.ok) {
  1614→    const errorMsg = await parseErrorResponse(response);
  1615→    throw new Error(errorMsg);
  1616→  }
  1617→
  1618→  const data = await response.json();
  1619→  if (!data.success) {
  1620→    throw new Error(data.error || 'Silence detection failed');
  1621→  }
  1622→
  1623→  // Store silences globally for razor workflow
  1624→  currentSilences = data.silences;
  1625→
  1626→  return data.silences;
  1627→}
  1628→
  1629→async function transcribeAudio() {
  1630→  // Get initialized paths (cross-platform)
  1631→  const paths = await getPaths();
  1632→
  1633→  const response = await fetchWithTimeout(`${getBackendUrl()}/analyze`, {
  1634→    method: 'POST',
  1635→    headers: getAuthHeaders(),
  1636→    body: JSON.stringify({ wavPath: paths.wavPath })
  1637→  }, FETCH_TIMEOUT_PROCESSING);
  1638→
  1639→  if (!response.ok) {
  1640→    const errorMsg = await parseErrorResponse(response);
  1641→    return { success: false, error: errorMsg };
  1642→  }
  1643→
  1644→  const data = await response.json();
  1645→  return {
  1646→    success: data.success,
  1647→    transcript: data.transcript,
  1648→    takes: data.takes,
  1649→    error: data.error
  1650→  };
  1651→}
  1652→
  1653→// ============================================================================
  1654→// BATCH PROCESSING
  1655→// ============================================================================
  1656→let batchQueue = [];
  1657→let currentBatchJobId = null;
  1658→
  1659→/**
  1660→ * Initialize batch processing handlers
  1661→ */
  1662→function initBatchHandlers() {
  1663→  const addToBatchBtn = document.getElementById('addToBatchBtn');
  1664→  const startBatchBtn = document.getElementById('startBatchBtn');
  1665→  const clearBatchBtn = document.getElementById('clearBatchBtn');
  1666→  const batchSection = document.getElementById('batchSection');
  1667→
  1668→  // Show batch section in settings or after first detection
  1669→  if (batchSection) {
  1670→    batchSection.classList.remove('hidden');
  1671→  }
  1672→
  1673→  // Add files to batch queue
  1674→  if (addToBatchBtn) {
  1675→    addToBatchBtn.addEventListener('click', async () => {
  1676→      try {
  1677→        const uxpFs = require('uxp').storage.localFileSystem;
  1678→        const files = await uxpFs.getFileForOpening({
  1679→          allowMultiple: true,
  1680→          types: ['wav', 'mp3', 'mp4', 'mov', 'aac', 'm4a']
  1681→        });
  1682→
  1683→        if (files && files.length > 0) {
  1684→          for (const file of files) {
  1685→            const path = file.nativePath || file.name;
  1686→            if (!batchQueue.includes(path)) {
  1687→              batchQueue.push(path);
  1688→            }
  1689→          }
  1690→          updateBatchQueueDisplay();
  1691→          setStatus(`Added ${files.length} file(s) to batch queue`);
  1692→        }
  1693→      } catch (err) {
  1694→        setStatus('Error adding files: ' + err.message);
  1695→      }
  1696→    });
  1697→  }
  1698→
  1699→  // Start batch processing
  1700→  if (startBatchBtn) {
  1701→    startBatchBtn.addEventListener('click', async () => {
  1702→      if (batchQueue.length === 0) {
  1703→        setStatus('No files in batch queue');
  1704→        return;
  1705→      }
  1706→
  1707→      startBatchBtn.disabled = true;
  1708→      addToBatchBtn.disabled = true;
  1709→
  1710→      try {
  1711→        await runBatchProcessing();
  1712→      } finally {
  1713→        startBatchBtn.disabled = false;
  1714→        addToBatchBtn.disabled = false;
  1715→      }
  1716→    });
  1717→  }
  1718→
  1719→  // Clear batch queue
  1720→  if (clearBatchBtn) {
  1721→    clearBatchBtn.addEventListener('click', () => {
  1722→      batchQueue = [];
  1723→      currentBatchJobId = null;
  1724→      updateBatchQueueDisplay();
  1725→      setStatus('Batch queue cleared');
  1726→    });
  1727→  }
  1728→
  1729→  // Event delegation for batch list remove buttons (UXP-compatible)
  1730→  const batchList = document.getElementById('batchList');
  1731→  if (batchList) {
  1732→    batchList.addEventListener('click', (e) => {
  1733→      const removeBtn = e.target.closest('.batch-remove-btn');
  1734→      if (removeBtn) {
  1735→        const index = parseInt(removeBtn.dataset.index, 10);
  1736→        if (!isNaN(index) && index >= 0 && index < batchQueue.length) {
  1737→          removeBatchItem(index);
  1738→        }
  1739→      }
  1740→    });
  1741→  }
  1742→}
  1743→
  1744→/**
  1745→ * Update batch queue display (uses data attributes for UXP compatibility)
  1746→ */
  1747→function updateBatchQueueDisplay() {
  1748→  const batchEmpty = document.getElementById('batchEmpty');
  1749→  const batchList = document.getElementById('batchList');
  1750→  const startBatchBtn = document.getElementById('startBatchBtn');
  1751→
  1752→  if (batchQueue.length === 0) {
  1753→    if (batchEmpty) batchEmpty.style.display = 'block';
  1754→    if (batchList) batchList.innerHTML = '';
  1755→    if (startBatchBtn) startBatchBtn.disabled = true;
  1756→    return;
  1757→  }
  1758→
  1759→  if (batchEmpty) batchEmpty.style.display = 'none';
  1760→  if (startBatchBtn) startBatchBtn.disabled = false;
  1761→
  1762→  if (batchList) {
  1763→    // Use data-index attribute instead of inline onclick for UXP compatibility
  1764→    batchList.innerHTML = batchQueue.map((path, i) => {
  1765→      const fileName = path.split('/').pop();
  1766→      return `<div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 6px; background: #2a2a2a; border-radius: 3px; margin-bottom: 2px; font-size: 9px;">
  1767→        <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 180px;" title="${path}">${fileName}</span>
  1768→        <button class="batch-remove-btn" data-index="${i}" style="background: transparent; border: none; color: #888; cursor: pointer; font-size: 10px;" aria-label="Remove ${fileName}">x</button>
  1769→      </div>`;
  1770→    }).join('');
  1771→  }
  1772→}
  1773→
  1774→/**
  1775→ * Remove item from batch queue
  1776→ */
  1777→function removeBatchItem(index) {
  1778→  batchQueue.splice(index, 1);
  1779→  updateBatchQueueDisplay();
  1780→}
  1781→
  1782→/**
  1783→ * Run batch processing
  1784→ */
  1785→async function runBatchProcessing() {
  1786→  const batchProgress = document.getElementById('batchProgress');
  1787→  const batchProgressBar = document.getElementById('batchProgressBar');
  1788→  const batchProgressText = document.getElementById('batchProgressText');
  1789→
  1790→  if (batchProgress) batchProgress.style.display = 'block';
  1791→
  1792→  try {
  1793→    // Get settings
  1794→    const sensitivity = parseInt(document.getElementById('sensitivitySlider')?.value || 50);
  1795→    const params = mapSensitivity(sensitivity);
  1796→
  1797→    // Call batch endpoint
  1798→    const response = await fetchWithTimeout(`${getBackendUrl()}/batch/silences`, {
  1799→      method: 'POST',
  1800→      headers: getAuthHeaders(),
  1801→      body: JSON.stringify({
  1802→        files: batchQueue,
  1803→        options: {
  1804→          sensitivity,
  1805→          threshold: params.dbThreshold,
  1806→          minSilenceLength: params.minDuration,
  1807→          paddingStart: params.padding,
  1808→          paddingEnd: params.padding / 2
  1809→        }
  1810→      })
  1811→    }, FETCH_TIMEOUT_PROCESSING);
  1812→
  1813→    if (!response.ok) {
  1814→      const errorMsg = await parseErrorResponse(response);
  1815→      throw new Error(errorMsg);
  1816→    }
  1817→
  1818→    const data = await response.json();
  1819→    currentBatchJobId = data.jobId;
  1820→    setStatus(`Batch job started: ${data.jobId}`);
  1821→
  1822→    // Poll for status
  1823→    await pollBatchStatus(currentBatchJobId, batchProgressBar, batchProgressText);
  1824→
  1825→  } catch (err) {
  1826→    setStatus('Batch error: ' + err.message);
  1827→  } finally {
  1828→    if (batchProgress) batchProgress.style.display = 'none';
  1829→  }
  1830→}
  1831→
  1832→/**
  1833→ * Poll batch job status
  1834→ */
  1835→async function pollBatchStatus(jobId, progressBar, progressText) {
  1836→  const pollInterval = 2000; // 2 seconds
  1837→  const maxPolls = 300; // 10 minutes max
  1838→  let polls = 0;
  1839→
  1840→  while (polls < maxPolls) {
  1841→    try {
  1842→      const response = await fetchWithTimeout(`${getBackendUrl()}/batch/status/${jobId}`, {
  1843→        headers: getAuthHeaders()
  1844→      }, FETCH_TIMEOUT_DEFAULT);
  1845→
  1846→      if (!response.ok) {
  1847→        throw new Error('Failed to get batch status');
  1848→      }
  1849→
  1850→      const data = await response.json();
  1851→      const job = data.job;
  1852→
  1853→      // Update progress
  1854→      if (progressBar) progressBar.value = job.progress.percentage;
  1855→      if (progressText) progressText.textContent = `${job.progress.completed + job.progress.failed} / ${job.progress.total} files`;
  1856→
  1857→      // Check if complete
  1858→      if (job.status !== 'processing') {
  1859→        if (job.status === 'completed') {
  1860→          setStatus(`Batch complete: ${job.progress.completed} files processed`);
  1861→        } else if (job.status === 'completed_with_errors') {
  1862→          setStatus(`Batch complete with ${job.progress.failed} error(s)`);
  1863→        } else {
  1864→          setStatus('Batch failed');
  1865→        }
  1866→
  1867→        // Clear queue on completion
  1868→        batchQueue = [];
  1869→        updateBatchQueueDisplay();
  1870→        return;
  1871→      }
  1872→
  1873→      await new Promise(resolve => setTimeout(resolve, pollInterval));
  1874→      polls++;
  1875→    } catch (err) {
  1876→      setStatus('Polling error: ' + err.message);
  1877→      return;
  1878→    }
  1879→  }
  1880→
  1881→  setStatus('Batch timed out');
  1882→}
  1883→
  1884→// Expose for inline onclick
  1885→if (typeof window !== 'undefined') {
  1886→  window.removeBatchItem = removeBatchItem;
  1887→}
  1888→
  1889→// ============================================================================
  1890→// CUSTOM PRESETS UI (v3.5)
  1891→// ============================================================================
  1892→
  1893→/**
  1894→ * Icon mapping for display
  1895→ */
  1896→const PRESET_ICON_MAP = {
  1897→  'settings': '*',
  1898→  'mic': 'M',
  1899→  'people': 'P',
  1900→  'bolt': '!',
  1901→  'school': 'E',
  1902→  'videocam': 'V',
  1903→  'star': 'S',
  1904→  'heart': 'H'
  1905→};
  1906→
  1907→/**
  1908→ * Initialize custom presets UI handlers
  1909→ */
  1910→function initCustomPresetsUI() {
  1911→  // Refresh preset dropdown on load
  1912→  refreshPresetDropdown();
  1913→
  1914→  // Save Preset button (+)
  1915→  if (ui.savePresetBtn) {
  1916→    ui.savePresetBtn.addEventListener('click', () => {
  1917→      showPresetModal();
  1918→    });
  1919→  }
  1920→
  1921→  // Manage Presets button (...)
  1922→  if (ui.managePresetsBtn) {
  1923→    ui.managePresetsBtn.addEventListener('click', () => {
  1924→      showManagePresetsModal();
  1925→    });
  1926→  }
  1927→
  1928→  // Close Preset Modal
  1929→  if (ui.closePresetModalBtn) {
  1930→    ui.closePresetModalBtn.addEventListener('click', () => {
  1931→      hidePresetModal();
  1932→    });
  1933→  }
  1934→
  1935→  // Close on backdrop click
  1936→  if (ui.presetModal) {
  1937→    ui.presetModal.addEventListener('click', (e) => {
  1938→      if (e.target === ui.presetModal) {
  1939→        hidePresetModal();
  1940→      }
  1941→    });
  1942→  }
  1943→
  1944→  // Icon picker
  1945→  if (ui.presetIconPicker) {
  1946→    ui.presetIconPicker.addEventListener('click', (e) => {
  1947→      const btn = e.target.closest('.preset-icon-option');
  1948→      if (btn) {
  1949→        selectPresetIcon(btn.dataset.icon);
  1950→      }
  1951→    });
  1952→  }
  1953→
  1954→  // Sensitivity slider value display (Phase 3)
  1955→  if (ui.presetSensitivity && ui.presetSensitivityValue) {
  1956→    ui.presetSensitivity.addEventListener('input', () => {
  1957→      ui.presetSensitivityValue.textContent = ui.presetSensitivity.value;
  1958→    });
  1959→  }
  1960→
  1961→  // Save Preset Confirm
  1962→  if (ui.savePresetConfirmBtn) {
  1963→    ui.savePresetConfirmBtn.addEventListener('click', () => {
  1964→      savePresetFromModal();
  1965→    });
  1966→  }
  1967→
  1968→  // Close Manage Presets Modal
  1969→  if (ui.closeManagePresetsBtn) {
  1970→    ui.closeManagePresetsBtn.addEventListener('click', () => {
  1971→      hideManagePresetsModal();
  1972→    });
  1973→  }
  1974→
  1975→  // Close on backdrop click
  1976→  if (ui.managePresetsModal) {
  1977→    ui.managePresetsModal.addEventListener('click', (e) => {
  1978→      if (e.target === ui.managePresetsModal) {
  1979→        hideManagePresetsModal();
  1980→      }
  1981→    });
  1982→  }
  1983→
  1984→  // Event delegation for preset list actions
  1985→  if (ui.presetsList) {
  1986→    ui.presetsList.addEventListener('click', (e) => {
  1987→      const editBtn = e.target.closest('.preset-edit-btn');
  1988→      const deleteBtn = e.target.closest('.preset-delete-btn');
  1989→      const duplicateBtn = e.target.closest('.preset-duplicate-btn');
  1990→
  1991→      if (editBtn) {
  1992→        const presetId = editBtn.dataset.presetId;
  1993→        editPreset(presetId);
  1994→      }
  1995→
  1996→      if (deleteBtn) {
  1997→        const presetId = deleteBtn.dataset.presetId;
  1998→        const presetName = deleteBtn.dataset.presetName;
  1999→        deletePresetWithConfirm(presetId, presetName);
  2000→      }
  2001→
  2002→      if (duplicateBtn) {
  2003→        const presetId = duplicateBtn.dataset.presetId;
  2004→        const presetName = duplicateBtn.dataset.presetName;
  2005→        duplicatePresetFromUI(presetId, presetName);
  2006→      }
  2007→    });
  2008→  }
  2009→
  2010→  // Export presets button (Phase 3)
  2011→  if (ui.exportPresetsBtn) {
  2012→    ui.exportPresetsBtn.addEventListener('click', () => {
  2013→      exportPresetsToFile();
  2014→    });
  2015→  }
  2016→
  2017→  // Import presets button (Phase 3) - uses UXP file picker directly
  2018→  if (ui.importPresetsBtn) {
  2019→    ui.importPresetsBtn.addEventListener('click', () => {
  2020→      importPresetsFromFile();
  2021→    });
  2022→  }
  2023→}
  2024→
  2025→/**
  2026→ * Refresh the preset dropdown with all presets (built-in + custom)
  2027→ */
  2028→function refreshPresetDropdown() {
  2029→  if (!ui.presetSelector) return;
  2030→
  2031→  const presets = getAllPresets();
  2032→  const currentValue = ui.presetSelector.value;
  2033→
  2034→  // Clear existing options
  2035→  ui.presetSelector.innerHTML = '';
  2036→
  2037→  // Add all presets
  2038→  presets.forEach(preset => {
  2039→    const option = document.createElement('option');
  2040→    option.value = preset.id;
  2041→
  2042→    // Format: "Name - Description" or just "Name"
  2043→    const desc = preset.description ? ` - ${preset.description}` : '';
  2044→    option.textContent = preset.name + desc;
  2045→
  2046→    // Add custom marker for custom presets
  2047→    if (!preset.isBuiltIn) {
  2048→      option.textContent = `${preset.name}${desc}`;
  2049→      option.style.color = '#28a745';
  2050→    }
  2051→
  2052→    ui.presetSelector.appendChild(option);
  2053→  });
  2054→
  2055→  // Restore selection if it still exists
  2056→  if ([...ui.presetSelector.options].some(opt => opt.value === currentValue)) {
  2057→    ui.presetSelector.value = currentValue;
  2058→  } else {
  2059→    ui.presetSelector.value = 'custom';
  2060→  }
  2061→}
  2062→
  2063→/**
  2064→ * Show the preset modal for creating a new preset
  2065→ */
  2066→function showPresetModal(editId = null) {
  2067→  if (!ui.presetModal) return;
  2068→
  2069→  // Reset form
  2070→  ui.presetNameInput.value = '';
  2071→  ui.presetDescInput.value = '';
  2072→  ui.presetEditId.value = '';
  2073→  ui.presetSelectedIcon.value = 'settings';
  2074→  selectPresetIcon('settings');
  2075→  hidePresetError();
  2076→
  2077→  // Get current settings as defaults
  2078→  const currentSettings = getSettings();
  2079→  const defaultSensitivity = currentSettings.sensitivity || 50;
  2080→  const defaultThreshold = currentSettings.threshold || -32;
  2081→
  2082→  if (editId) {
  2083→    // Edit mode
  2084→    const preset = getPresetById(editId);
  2085→    if (preset && !preset.isBuiltIn) {
  2086→      ui.presetModalTitle.textContent = 'Edit Preset';
  2087→      ui.presetNameInput.value = preset.name;
  2088→      ui.presetDescInput.value = preset.description || '';
  2089→      ui.presetEditId.value = editId;
  2090→      ui.presetSelectedIcon.value = preset.icon || 'settings';
  2091→      selectPresetIcon(preset.icon || 'settings');
  2092→      ui.savePresetConfirmBtn.textContent = 'Update Preset';
  2093→
  2094→      // Populate settings from preset (Phase 3)
  2095→      const presetSensitivity = preset.settings?.sensitivity ?? defaultSensitivity;
  2096→      const presetThreshold = preset.settings?.threshold ?? defaultThreshold;
  2097→      if (ui.presetSensitivity) {
  2098→        ui.presetSensitivity.value = presetSensitivity;
  2099→        if (ui.presetSensitivityValue) ui.presetSensitivityValue.textContent = presetSensitivity;
  2100→      }
  2101→      if (ui.presetThreshold) {
  2102→        ui.presetThreshold.value = presetThreshold;
  2103→      }
  2104→    }
  2105→  } else {
  2106→    // Create mode - use current settings from main UI
  2107→    ui.presetModalTitle.textContent = 'Save Preset';
  2108→    ui.savePresetConfirmBtn.textContent = 'Save Preset';
  2109→
  2110→    // Get sensitivity from main slider if available
  2111→    const mainSensitivity = ui.sensitivitySlider?.value ?? defaultSensitivity;
  2112→    if (ui.presetSensitivity) {
  2113→      ui.presetSensitivity.value = mainSensitivity;
  2114→      if (ui.presetSensitivityValue) ui.presetSensitivityValue.textContent = mainSensitivity;
  2115→    }
  2116→    if (ui.presetThreshold) {
  2117→      ui.presetThreshold.value = defaultThreshold;
  2118→    }
  2119→  }
  2120→
  2121→  ui.presetModal.classList.remove('hidden');
  2122→  ui.presetNameInput.focus();
  2123→}
  2124→
  2125→/**
  2126→ * Hide the preset modal
  2127→ */
  2128→function hidePresetModal() {
  2129→  if (ui.presetModal) {
  2130→    ui.presetModal.classList.add('hidden');
  2131→  }
  2132→}
  2133→
  2134→/**
  2135→ * Select an icon in the preset modal
  2136→ */
  2137→function selectPresetIcon(iconName) {
  2138→  if (!ui.presetIconPicker || !ui.presetSelectedIcon) return;
  2139→
  2140→  // Update hidden input
  2141→  ui.presetSelectedIcon.value = iconName;
  2142→
  2143→  // Update visual selection
  2144→  ui.presetIconPicker.querySelectorAll('.preset-icon-option').forEach(btn => {
  2145→    if (btn.dataset.icon === iconName) {
  2146→      btn.classList.add('selected');
  2147→    } else {
  2148→      btn.classList.remove('selected');
  2149→    }
  2150→  });
  2151→}
  2152→
  2153→/**
  2154→ * Show error message in preset modal
  2155→ */
  2156→function showPresetError(message) {
  2157→  if (ui.presetModalError) {
  2158→    ui.presetModalError.textContent = message;
  2159→    ui.presetModalError.style.display = 'block';
  2160→  }
  2161→}
  2162→
  2163→/**
  2164→ * Hide error message in preset modal
  2165→ */
  2166→function hidePresetError() {
  2167→  if (ui.presetModalError) {
  2168→    ui.presetModalError.style.display = 'none';
  2169→  }
  2170→}
  2171→
  2172→/**
  2173→ * Save preset from modal (create or update)
  2174→ */
  2175→function savePresetFromModal() {
  2176→  const name = ui.presetNameInput?.value?.trim();
  2177→  const description = ui.presetDescInput?.value?.trim() || '';
  2178→  const icon = ui.presetSelectedIcon?.value || 'settings';
  2179→  const editId = ui.presetEditId?.value;
  2180→
  2181→  if (!name) {
  2182→    showPresetError('Please enter a preset name');
  2183→    return;
  2184→  }
  2185→
  2186→  // Capture settings from modal inputs (Phase 3)
  2187→  const sensitivityRaw = parseInt(ui.presetSensitivity?.value);
  2188→  const thresholdRaw = parseInt(ui.presetThreshold?.value);
  2189→  const sensitivity = isNaN(sensitivityRaw) ? 50 : sensitivityRaw;
  2190→  const threshold = isNaN(thresholdRaw) ? -32 : thresholdRaw;
  2191→
  2192→  // Get base settings and override with modal values
  2193→  const baseSettings = getCurrentPresetSettings();
  2194→  const settings = {
  2195→    ...baseSettings,
  2196→    sensitivity,
  2197→    threshold
  2198→  };
  2199→
  2200→  let result;
  2201→
  2202→  if (editId) {
  2203→    // Update existing preset (including settings)
  2204→    result = updateCustomPreset(editId, {
  2205→      name,
  2206→      description,
  2207→      icon,
  2208→      settings
  2209→    });
  2210→
  2211→    if (result.success) {
  2212→      setStatus(`Preset "${name}" updated`);
  2213→    }
  2214→  } else {
  2215→    // Create new preset with modal settings
  2216→    result = createCustomPreset({
  2217→      name,
  2218→      description,
  2219→      icon,
  2220→      settings
  2221→    });
  2222→
  2223→    if (result.success) {
  2224→      setStatus(`Preset "${name}" saved`);
  2225→      // Select the newly created preset
  2226→      refreshPresetDropdown();
  2227→      if (ui.presetSelector) {
  2228→        ui.presetSelector.value = result.id;
  2229→      }
  2230→    }
  2231→  }
  2232→
  2233→  if (result.success) {
  2234→    hidePresetModal();
  2235→    refreshPresetDropdown();
  2236→  } else {
  2237→    showPresetError(result.error || 'Failed to save preset');
  2238→  }
  2239→}
  2240→
  2241→/**
  2242→ * Show the manage presets modal
  2243→ */
  2244→function showManagePresetsModal() {
  2245→  if (!ui.managePresetsModal) return;
  2246→
  2247→  renderPresetsList();
  2248→  ui.managePresetsModal.classList.remove('hidden');
  2249→}
  2250→
  2251→/**
  2252→ * Hide the manage presets modal
  2253→ */
  2254→function hideManagePresetsModal() {
  2255→  if (ui.managePresetsModal) {
  2256→    ui.managePresetsModal.classList.add('hidden');
  2257→  }
  2258→}
  2259→
  2260→/**
  2261→ * Render the presets list in the manage modal
  2262→ */
  2263→function renderPresetsList() {
  2264→  if (!ui.presetsList) return;
  2265→
  2266→  const presets = getAllPresets();
  2267→  const customPresets = presets.filter(p => !p.isBuiltIn);
  2268→
  2269→  // Show/hide empty state
  2270→  if (ui.noCustomPresets) {
  2271→    ui.noCustomPresets.style.display = customPresets.length === 0 ? 'block' : 'none';
  2272→  }
  2273→
  2274→  // Build HTML
  2275→  const fragment = document.createDocumentFragment();
  2276→
  2277→  presets.forEach(preset => {
  2278→    const div = document.createElement('div');
  2279→    div.className = `preset-list-item ${preset.isBuiltIn ? 'built-in' : 'custom'}`;
  2280→
  2281→    const iconChar = PRESET_ICON_MAP[preset.icon] || '*';
  2282→    const desc = preset.description || (preset.isBuiltIn ? 'Built-in preset' : 'Custom preset');
  2283→
  2284→    if (preset.isBuiltIn) {
  2285→      // Built-in presets: only duplicate button (Phase 3)
  2286→      div.innerHTML = `
  2287→        <div class="preset-list-item-icon">${iconChar}</div>
  2288→        <div class="preset-list-item-info">
  2289→          <div class="preset-list-item-name">${preset.name}</div>
  2290→          <div class="preset-list-item-desc">${desc}</div>
  2291→        </div>
  2292→        <div class="preset-list-item-actions">
  2293→          <button class="preset-duplicate-btn" data-preset-id="${preset.id}" data-preset-name="${preset.name}" title="Duplicate preset">D</button>
  2294→        </div>
  2295→      `;
  2296→    } else {
  2297→      // Custom presets: duplicate/edit/delete buttons (Phase 3)
  2298→      div.innerHTML = `
  2299→        <div class="preset-list-item-icon">${iconChar}</div>
  2300→        <div class="preset-list-item-info">
  2301→          <div class="preset-list-item-name">${preset.name}</div>
  2302→          <div class="preset-list-item-desc">${desc}</div>
  2303→        </div>
  2304→        <div class="preset-list-item-actions">
  2305→          <button class="preset-duplicate-btn" data-preset-id="${preset.id}" data-preset-name="${preset.name}" title="Duplicate preset">D</button>
  2306→          <button class="preset-edit-btn" data-preset-id="${preset.id}" title="Edit preset">E</button>
  2307→          <button class="preset-delete-btn delete" data-preset-id="${preset.id}" data-preset-name="${preset.name}" title="Delete preset">X</button>
  2308→        </div>
  2309→      `;
  2310→    }
  2311→
  2312→    fragment.appendChild(div);
  2313→  });
  2314→
  2315→  ui.presetsList.innerHTML = '';
  2316→  ui.presetsList.appendChild(fragment);
  2317→}
  2318→
  2319→/**
  2320→ * Edit a preset
  2321→ */
  2322→function editPreset(presetId) {
  2323→  hideManagePresetsModal();
  2324→  showPresetModal(presetId);
  2325→}
  2326→
  2327→/**
  2328→ * Delete a preset with confirmation (uses UXP-compatible modal)
  2329→ */
  2330→function deletePresetWithConfirm(presetId, presetName) {
  2331→  showConfirmModal(
  2332→    'Delete Preset',
  2333→    `Are you sure you want to delete "${presetName}"? This action cannot be undone.`,
  2334→    () => {
  2335→      // onConfirm callback
  2336→      const result = deleteCustomPreset(presetId);
  2337→
  2338→      if (result.success) {
  2339→        setStatus(`Preset "${presetName}" deleted`);
  2340→        renderPresetsList();
  2341→        refreshPresetDropdown();
  2342→      } else {
  2343→        setStatus('Failed to delete preset: ' + (result.error || 'Unknown error'));
  2344→      }
  2345→    },
  2346→    null, // onCancel - no action needed
  2347→    { confirmText: 'Delete', confirmStyle: '#dc3545' }
  2348→  );
  2349→}
  2350→
  2351→/**
  2352→ * Duplicate a preset from the UI (Phase 3)
  2353→ */
  2354→function duplicatePresetFromUI(presetId, presetName) {
  2355→  const result = duplicatePreset(presetId);
  2356→
  2357→  if (result.success) {
  2358→    setStatus(`Created copy of "${presetName}"`);
  2359→    renderPresetsList();
  2360→    refreshPresetDropdown();
  2361→
  2362→    // Select the new copy in dropdown
  2363→    if (ui.presetSelector && result.id) {
  2364→      ui.presetSelector.value = result.id;
  2365→    }
  2366→  } else {
  2367→    setStatus('Failed to duplicate preset: ' + (result.error || 'Unknown error'));
  2368→  }
  2369→}
  2370→
  2371→/**
  2372→ * Export presets to a JSON file (Phase 3)
  2373→ */
  2374→async function exportPresetsToFile() {
  2375→  const result = exportPresets();
  2376→
  2377→  if (!result.success) {
  2378→    setStatus(result.error || 'No presets to export');
  2379→    return;
  2380→  }
  2381→
  2382→  try {
  2383→    // Create a blob and download it
  2384→    const blob = new Blob([result.data], { type: 'application/json' });
  2385→    const filename = `splice-presets-${new Date().toISOString().slice(0, 10)}.json`;
  2386→
  2387→    // UXP approach: use file system API
  2388→    const uxpFs = require('uxp').storage.localFileSystem;
  2389→    const file = await uxpFs.getFileForSaving(filename, { types: ['json'] });
  2390→
  2391→    if (file) {
  2392→      await file.write(result.data);
  2393→      setStatus(`Exported ${result.count} preset(s) to ${file.name}`);
  2394→    } else {
  2395→      setStatus('Export cancelled');
  2396→    }
  2397→  } catch (err) {
  2398→    console.error('[SPLICE] Export error:', err);
  2399→    setStatus('Export failed: ' + err.message);
  2400→  }
  2401→}
  2402→
  2403→/**
  2404→ * Import presets from a JSON file using UXP file picker (Phase 3)
  2405→ * Uses UXP file API instead of FileReader for compatibility
  2406→ */
  2407→async function importPresetsFromFile() {
  2408→  try {
  2409→    // Use UXP file picker API instead of HTML file input
  2410→    const uxpFs = require('uxp').storage.localFileSystem;
  2411→    const file = await uxpFs.getFileForOpening({ types: ['json'] });
  2412→
  2413→    if (!file) {
  2414→      // User cancelled file picker
  2415→      return;
  2416→    }
  2417→
  2418→    // Read file content using UXP async file API
  2419→    const jsonString = await file.read();
  2420→
  2421→    if (!jsonString || jsonString.trim() === '') {
  2422→      setStatus('Import failed: File is empty');
  2423→      return;
  2424→    }
  2425→
  2426→    // Parse and import presets
  2427→    const result = importPresets(jsonString, true);
  2428→
  2429→    if (result.success) {
  2430→      setStatus(`Imported ${result.imported} preset(s)${result.skipped > 0 ? `, ${result.skipped} skipped` : ''}`);
  2431→      renderPresetsList();
  2432→      refreshPresetDropdown();
  2433→    } else {
  2434→      setStatus('Import failed: ' + (result.error || 'Unknown error'));
  2435→    }
  2436→  } catch (err) {
  2437→    console.error('[SPLICE] Import error:', err);
  2438→
  2439→    // Provide user-friendly error messages
  2440→    if (err.message && err.message.includes('JSON')) {
  2441→      setStatus('Import failed: Invalid JSON file');
  2442→    } else if (err.message && err.message.includes('permission')) {
  2443→      setStatus('Import failed: Permission denied');
  2444→    } else {
  2445→      setStatus('Import failed: ' + err.message);
  2446→    }
  2447→  }
  2448→}
  2449→
  2450→/**
  2451→ * Apply a preset and update UI controls
  2452→ * Called when user selects a preset from dropdown
  2453→ */
  2454→function applyPresetAndUpdateUI(presetId) {
  2455→  const preset = getPresetById(presetId);
  2456→  if (!preset) return;
  2457→
  2458→  // For custom presets, apply the settings
  2459→  if (!preset.isBuiltIn) {
  2460→    const settings = preset.settings;
  2461→    if (settings) {
  2462→      // Update sensitivity slider
  2463→      if (ui.sensitivitySlider && settings.sensitivity !== undefined) {
  2464→        ui.sensitivitySlider.value = settings.sensitivity;
  2465→      }
  2466→
  2467→      // Update takes detection checkbox
  2468→      if (ui.enableTakesDetection && settings.enableTakesDetection !== undefined) {
  2469→        ui.enableTakesDetection.checked = settings.enableTakesDetection;
  2470→      }
  2471→
  2472→      // Update auto-mark best checkbox
  2473→      if (ui.autoMarkBest && settings.autoMarkBest !== undefined) {
  2474→        ui.autoMarkBest.checked = settings.autoMarkBest;
  2475→      }
  2476→
  2477→      // Save as active preset
  2478→      saveSettings({ activePreset: presetId, ...settings });
  2479→    }
  2480→  } else {
  2481→    // Built-in preset: use applyPreset from settings.js
  2482→    const appliedSettings = applyPreset(presetId);
  2483→
  2484→    // Update sensitivity slider to match preset
  2485→    if (ui.sensitivitySlider && appliedSettings.sensitivity !== undefined) {
  2486→      ui.sensitivitySlider.value = appliedSettings.sensitivity;
  2487→    }
  2488→
  2489→    // Update takes detection checkbox
  2490→    if (ui.enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {
  2491→      ui.enableTakesDetection.checked = appliedSettings.enableTakesDetection;
  2492→    }
  2493→
  2494→    // Update auto-mark best checkbox
  2495→    if (ui.autoMarkBest && appliedSettings.autoMarkBest !== undefined) {
  2496→      ui.autoMarkBest.checked = appliedSettings.autoMarkBest;
  2497→    }
  2498→  }
  2499→
  2500→  setStatus(`Applied preset: ${preset.name}`);
  2501→}
  2502→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
