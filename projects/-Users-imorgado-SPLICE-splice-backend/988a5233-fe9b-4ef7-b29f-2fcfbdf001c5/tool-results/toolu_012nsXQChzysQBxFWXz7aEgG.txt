     1→/**
     2→ * SPLICE Cut List Generator (v3.5)
     3→ *
     4→ * Generates JSON cut lists for direct DOM sequence building.
     5→ * Replaces XML processing for v3.5 architecture.
     6→ *
     7→ * Cut list format:
     8→ * {
     9→ *   version: '3.5',
    10→ *   source: { name, path, duration },
    11→ *   segments: [{ type, sourceName, sourcePath, inPoint, outPoint }],
    12→ *   metadata: { silencesRemoved, takesDetected, generatedAt }
    13→ * }
    14→ *
    15→ * Frame Alignment:
    16→ * When frameRate is provided, all cut points are aligned to frame boundaries.
    17→ * This prevents sub-frame edits that can cause playback issues.
    18→ */
    19→
    20→/**
    21→ * Align a time value to the nearest frame boundary
    22→ * @param {number} time - Time in seconds
    23→ * @param {number} frameRate - Frames per second (e.g., 23.976, 24, 29.97, 30, 60)
    24→ * @returns {number} Time aligned to frame boundary
    25→ */
    26→function alignToFrame(time, frameRate) {
    27→  if (!frameRate || frameRate <= 0) return time;
    28→  const frameDuration = 1 / frameRate;
    29→  return Math.round(time / frameDuration) * frameDuration;
    30→}
    31→
    32→/**
    33→ * Align to frame boundary, rounding down (for in-points)
    34→ */
    35→function alignToFrameFloor(time, frameRate) {
    36→  if (!frameRate || frameRate <= 0) return time;
    37→  const frameDuration = 1 / frameRate;
    38→  return Math.floor(time / frameDuration) * frameDuration;
    39→}
    40→
    41→/**
    42→ * Align to frame boundary, rounding up (for out-points)
    43→ */
    44→function alignToFrameCeil(time, frameRate) {
    45→  if (!frameRate || frameRate <= 0) return time;
    46→  const frameDuration = 1 / frameRate;
    47→  return Math.ceil(time / frameDuration) * frameDuration;
    48→}
    49→
    50→/**
    51→ * Generate a cut list from detected silences
    52→ * Creates segments that represent speech (non-silence) portions
    53→ *
    54→ * @param {Object} options - Generation options
    55→ * @param {string} options.sourceName - Name of the source clip
    56→ * @param {string} options.sourcePath - Full path to the source file
    57→ * @param {number} options.duration - Total duration of source in seconds
    58→ * @param {Array} options.silences - Array of silence segments [{start, end, duration}]
    59→ * @param {Array} [options.takes] - Optional array of detected takes
    60→ * @param {Object} [options.settings] - Optional generation settings
    61→ * @returns {Object} The generated cut list
    62→ */
    63→function generateCutList(options) {
    64→  const {
    65→    sourceName,
    66→    sourcePath,
    67→    duration,
    68→    silences = [],
    69→    takes = [],
    70→    settings = {}
    71→  } = options;
    72→
    73→  // Settings with defaults
    74→  const {
    75→    minSegmentDuration = 0.1,  // Minimum segment length to include
    76→    padding = 0,               // Padding around speech (extend into silence)
    77→    markBestTakes = true,      // Color-code best takes differently
    78→    frameRate = 0,             // Frame rate for alignment (0 = no alignment)
    79→    jCutOffset = 0,            // J-cut: audio starts before video (negative value)
    80→    lCutOffset = 0             // L-cut: audio extends after video (positive value)
    81→  } = settings;
    82→
    83→  // Sort silences by start time
    84→  const sortedSilences = [...silences].sort((a, b) => a.start - b.start);
    85→
    86→  // Build segments from gaps between silences (speech segments)
    87→  const segments = [];
    88→  let lastEnd = 0;
    89→  let silencesRemoved = 0;
    90→
    91→  for (const silence of sortedSilences) {
    92→    // Calculate segment boundaries with padding and frame alignment
    93→    let segmentStart = Math.max(0, lastEnd - padding);
    94→    let segmentEnd = Math.min(duration, silence.start + padding);
    95→
    96→    // Align to frame boundaries if frameRate is specified
    97→    if (frameRate > 0) {
    98→      segmentStart = alignToFrameFloor(segmentStart, frameRate);
    99→      segmentEnd = alignToFrameCeil(segmentEnd, frameRate);
   100→    }
   101→
   102→    // Only add if segment meets minimum duration
   103→    if (segmentEnd - segmentStart >= minSegmentDuration) {
   104→      const segment = {
   105→        type: 'speech',
   106→        sourceName,
   107→        sourcePath,
   108→        inPoint: parseFloat(segmentStart.toFixed(6)),
   109→        outPoint: parseFloat(segmentEnd.toFixed(6))
   110→      };
   111→
   112→      // Add J-cut/L-cut audio offsets if specified
   113→      if (jCutOffset !== 0 || lCutOffset !== 0) {
   114→        // Audio in/out points differ from video
   115→        segment.audioInOffset = jCutOffset;  // Negative = audio starts earlier (J-cut)
   116→        segment.audioOutOffset = lCutOffset; // Positive = audio ends later (L-cut)
   117→
   118→        // Calculate actual audio in/out points
   119→        segment.audioInPoint = parseFloat(Math.max(0, segmentStart + jCutOffset).toFixed(6));
   120→        segment.audioOutPoint = parseFloat(Math.min(duration, segmentEnd + lCutOffset).toFixed(6));
   121→      }
   122→
   123→      // Check if this segment contains a take
   124→      const containingTake = findContainingTake(segmentStart, segmentEnd, takes);
   125→      if (containingTake) {
   126→        segment.take = {
   127→          text: containingTake.text?.substring(0, 100),
   128→          isBest: containingTake.isBest || false
   129→        };
   130→        if (containingTake.isBest && markBestTakes) {
   131→          segment.type = 'best_take';
   132→        }
   133→      }
   134→
   135→      segments.push(segment);
   136→    }
   137→
   138→    silencesRemoved++;
   139→    lastEnd = silence.end;
   140→  }
   141→
   142→  // Add final segment after last silence
   143→  if (lastEnd < duration) {
   144→    let segmentStart = Math.max(0, lastEnd - padding);
   145→    let segmentEnd = duration;
   146→
   147→    // Align to frame boundaries if frameRate is specified
   148→    if (frameRate > 0) {
   149→      segmentStart = alignToFrameFloor(segmentStart, frameRate);
   150→      segmentEnd = alignToFrameCeil(segmentEnd, frameRate);
   151→    }
   152→
   153→    if (segmentEnd - segmentStart >= minSegmentDuration) {
   154→      const segment = {
   155→        type: 'speech',
   156→        sourceName,
   157→        sourcePath,
   158→        inPoint: parseFloat(segmentStart.toFixed(6)),
   159→        outPoint: parseFloat(segmentEnd.toFixed(6))
   160→      };
   161→
   162→      // Add J-cut/L-cut audio offsets if specified
   163→      if (jCutOffset !== 0 || lCutOffset !== 0) {
   164→        segment.audioInOffset = jCutOffset;
   165→        segment.audioOutOffset = lCutOffset;
   166→        segment.audioInPoint = parseFloat(Math.max(0, segmentStart + jCutOffset).toFixed(6));
   167→        segment.audioOutPoint = parseFloat(Math.min(duration, segmentEnd + lCutOffset).toFixed(6));
   168→      }
   169→
   170→      // Check if this segment contains a take
   171→      const containingTake = findContainingTake(segmentStart, segmentEnd, takes);
   172→      if (containingTake) {
   173→        segment.take = {
   174→          text: containingTake.text?.substring(0, 100),
   175→          isBest: containingTake.isBest || false
   176→        };
   177→        if (containingTake.isBest && markBestTakes) {
   178→          segment.type = 'best_take';
   179→        }
   180→      }
   181→
   182→      segments.push(segment);
   183→    }
   184→  }
   185→
   186→  // Calculate stats
   187→  const totalKeptDuration = segments.reduce(
   188→    (sum, seg) => sum + (seg.outPoint - seg.inPoint),
   189→    0
   190→  );
   191→  const totalRemovedDuration = duration - totalKeptDuration;
   192→
   193→  const cutList = {
   194→    version: '3.5',
   195→    source: {
   196→      name: sourceName,
   197→      path: sourcePath,
   198→      duration
   199→    },
   200→    segments,
   201→    metadata: {
   202→      silencesRemoved,
   203→      takesDetected: takes.length,
   204→      totalKeptDuration: parseFloat(totalKeptDuration.toFixed(3)),
   205→      totalRemovedDuration: parseFloat(totalRemovedDuration.toFixed(3)),
   206→      segmentCount: segments.length,
   207→      frameRate: frameRate > 0 ? frameRate : null,
   208→      frameAligned: frameRate > 0,
   209→      jCutOffset: jCutOffset !== 0 ? jCutOffset : null,
   210→      lCutOffset: lCutOffset !== 0 ? lCutOffset : null,
   211→      hasAudioOffsets: jCutOffset !== 0 || lCutOffset !== 0,
   212→      generatedAt: new Date().toISOString()
   213→    }
   214→  };
   215→
   216→  console.log(`[SPLICE] Generated cut list: ${segments.length} segments, ${silencesRemoved} silences removed`);
   217→
   218→  return cutList;
   219→}
   220→
   221→/**
   222→ * Find a take that overlaps with a given time range
   223→ * @param {number} start - Start time in seconds
   224→ * @param {number} end - End time in seconds
   225→ * @param {Array} takes - Array of takes
   226→ * @returns {Object|null} The overlapping take or null
   227→ */
   228→function findContainingTake(start, end, takes) {
   229→  if (!takes || takes.length === 0) return null;
   230→
   231→  for (const take of takes) {
   232→    const takeStart = take.startTime || take.start;
   233→    const takeEnd = take.endTime || take.end;
   234→
   235→    // Check for overlap
   236→    if (start < takeEnd && end > takeStart) {
   237→      return take;
   238→    }
   239→  }
   240→
   241→  return null;
   242→}
   243→
   244→/**
   245→ * Generate a cut list that keeps only specific takes
   246→ * Useful for "keep best takes only" workflow
   247→ *
   248→ * @param {Object} options - Generation options
   249→ * @param {string} options.sourceName - Name of the source clip
   250→ * @param {string} options.sourcePath - Full path to the source file
   251→ * @param {number} options.duration - Total duration of source in seconds
   252→ * @param {Array} options.takes - Array of takes to keep
   253→ * @param {Object} [options.settings] - Optional generation settings
   254→ * @returns {Object} The generated cut list
   255→ */
   256→function generateTakesCutList(options) {
   257→  const {
   258→    sourceName,
   259→    sourcePath,
   260→    duration,
   261→    takes = [],
   262→    settings = {}
   263→  } = options;
   264→
   265→  const {
   266→    padding = 0.2,          // Small padding around takes
   267→    onlyBestTakes = false   // If true, only include takes marked as best
   268→  } = settings;
   269→
   270→  // Filter to best takes if requested
   271→  const takesToKeep = onlyBestTakes
   272→    ? takes.filter(t => t.isBest)
   273→    : takes;
   274→
   275→  // Sort by start time
   276→  const sortedTakes = [...takesToKeep].sort((a, b) => {
   277→    const aStart = a.startTime || a.start;
   278→    const bStart = b.startTime || b.start;
   279→    return aStart - bStart;
   280→  });
   281→
   282→  // Build segments from takes
   283→  const segments = sortedTakes.map(take => {
   284→    const takeStart = take.startTime || take.start;
   285→    const takeEnd = take.endTime || take.end;
   286→
   287→    return {
   288→      type: take.isBest ? 'best_take' : 'take',
   289→      sourceName,
   290→      sourcePath,
   291→      inPoint: Math.max(0, takeStart - padding),
   292→      outPoint: Math.min(duration, takeEnd + padding),
   293→      take: {
   294→        text: take.text?.substring(0, 100),
   295→        isBest: take.isBest || false
   296→      }
   297→    };
   298→  });
   299→
   300→  const totalKeptDuration = segments.reduce(
   301→    (sum, seg) => sum + (seg.outPoint - seg.inPoint),
   302→    0
   303→  );
   304→
   305→  const cutList = {
   306→    version: '3.5',
   307→    source: {
   308→      name: sourceName,
   309→      path: sourcePath,
   310→      duration
   311→    },
   312→    segments,
   313→    metadata: {
   314→      takesKept: segments.length,
   315→      takesTotal: takes.length,
   316→      totalKeptDuration: parseFloat(totalKeptDuration.toFixed(3)),
   317→      totalRemovedDuration: parseFloat((duration - totalKeptDuration).toFixed(3)),
   318→      generatedAt: new Date().toISOString()
   319→    }
   320→  };
   321→
   322→  console.log(`[SPLICE] Generated takes cut list: ${segments.length} takes kept`);
   323→
   324→  return cutList;
   325→}
   326→
   327→/**
   328→ * Merge overlapping segments in a cut list
   329→ * Useful when silences and takes create overlapping regions
   330→ *
   331→ * @param {Object} cutList - The cut list to merge
   332→ * @returns {Object} Cut list with merged segments
   333→ */
   334→function mergeOverlappingSegments(cutList) {
   335→  if (!cutList.segments || cutList.segments.length < 2) {
   336→    return cutList;
   337→  }
   338→
   339→  // Sort by start time
   340→  const sorted = [...cutList.segments].sort((a, b) => a.inPoint - b.inPoint);
   341→
   342→  const merged = [];
   343→  let current = { ...sorted[0] };
   344→
   345→  for (let i = 1; i < sorted.length; i++) {
   346→    const next = sorted[i];
   347→
   348→    // Check for overlap
   349→    if (next.inPoint <= current.outPoint) {
   350→      // Merge: extend current segment
   351→      current.outPoint = Math.max(current.outPoint, next.outPoint);
   352→      // Keep the more specific type (best_take > take > speech)
   353→      if (next.type === 'best_take' || (next.type === 'take' && current.type === 'speech')) {
   354→        current.type = next.type;
   355→        current.take = next.take;
   356→      }
   357→    } else {
   358→      // No overlap: save current and start new
   359→      merged.push(current);
   360→      current = { ...next };
   361→    }
   362→  }
   363→
   364→  // Don't forget the last segment
   365→  merged.push(current);
   366→
   367→  // Update metadata
   368→  const newCutList = {
   369→    ...cutList,
   370→    segments: merged,
   371→    metadata: {
   372→      ...cutList.metadata,
   373→      segmentCount: merged.length,
   374→      mergedFrom: cutList.segments.length
   375→    }
   376→  };
   377→
   378→  console.log(`[SPLICE] Merged ${cutList.segments.length} segments into ${merged.length}`);
   379→
   380→  return newCutList;
   381→}
   382→
   383→/**
   384→ * Validate a cut list structure
   385→ * @param {Object} cutList - The cut list to validate
   386→ * @returns {{valid: boolean, errors: string[]}}
   387→ */
   388→function validateCutList(cutList) {
   389→  const errors = [];
   390→
   391→  if (!cutList) {
   392→    errors.push('Cut list is null or undefined');
   393→    return { valid: false, errors };
   394→  }
   395→
   396→  if (!cutList.version) {
   397→    errors.push('Missing version field');
   398→  }
   399→
   400→  if (!cutList.source) {
   401→    errors.push('Missing source field');
   402→  } else {
   403→    if (!cutList.source.name && !cutList.source.path) {
   404→      errors.push('Source must have name or path');
   405→    }
   406→    if (typeof cutList.source.duration !== 'number' || cutList.source.duration <= 0) {
   407→      errors.push('Source duration must be a positive number');
   408→    }
   409→  }
   410→
   411→  if (!Array.isArray(cutList.segments)) {
   412→    errors.push('Segments must be an array');
   413→  } else {
   414→    cutList.segments.forEach((seg, i) => {
   415→      if (typeof seg.inPoint !== 'number') {
   416→        errors.push(`Segment ${i}: inPoint must be a number`);
   417→      }
   418→      if (typeof seg.outPoint !== 'number') {
   419→        errors.push(`Segment ${i}: outPoint must be a number`);
   420→      }
   421→      if (seg.inPoint >= seg.outPoint) {
   422→        errors.push(`Segment ${i}: inPoint must be less than outPoint`);
   423→      }
   424→      if (!seg.sourceName && !seg.sourcePath) {
   425→        errors.push(`Segment ${i}: must have sourceName or sourcePath`);
   426→      }
   427→    });
   428→  }
   429→
   430→  return {
   431→    valid: errors.length === 0,
   432→    errors
   433→  };
   434→}
   435→
   436→module.exports = {
   437→  generateCutList,
   438→  generateTakesCutList,
   439→  mergeOverlappingSegments,
   440→  validateCutList,
   441→  // Frame alignment utilities
   442→  alignToFrame,
   443→  alignToFrameFloor,
   444→  alignToFrameCeil
   445→};
   446→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
