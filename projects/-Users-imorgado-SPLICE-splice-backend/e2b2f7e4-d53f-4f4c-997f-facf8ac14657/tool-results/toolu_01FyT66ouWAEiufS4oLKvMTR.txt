     1→/**
     2→ * Rate Limiter Middleware
     3→ *
     4→ * Checks if user has sufficient credits before processing.
     5→ * Uses atomic credit reservation to prevent race conditions.
     6→ * Returns 402 Payment Required if insufficient credits.
     7→ *
     8→ * SECURITY FEATURES:
     9→ * - JWT authentication via authenticateToken middleware
    10→ * - Redis-backed rate limiting with in-memory fallback
    11→ * - Tiered limits: authenticated users get higher limits than anonymous
    12→ * - Endpoint-specific limits for sensitive operations
    13→ * - Proper 429 responses with Retry-After header
    14→ * - Legacy x-stripe-customer-id header is DISABLED in production for security
    15→ */
    16→
    17→const {
    18→  deductUsage,
    19→  getBalance,
    20→  reserveCredits,
    21→  confirmReservation,
    22→  releaseReservation,
    23→  customerExists,
    24→  hasFeatureAccess
    25→} = require('../services/usageTracking');
    26→const { verifyToken, extractBearerToken } = require('./auth');
    27→const redisClient = require('../services/redisClient');
    28→
    29→// SECURITY: Disable legacy auth in production unless explicitly enabled
    30→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    31→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';
    32→
    33→// =============================================================================
    34→// SECURITY: Enhanced IP-based Rate Limiting with Redis Backend
    35→// =============================================================================
    36→
    37→/**
    38→ * Rate limit configuration
    39→ * Tiered limits: authenticated users get higher limits than anonymous
    40→ */
    41→const RATE_LIMITS = {
    42→  // Global IP limits
    43→  global: {
    44→    anonymous: { max: 100, window: 60 },      // 100 req/min for unauthenticated
    45→    authenticated: { max: 300, window: 60 }   // 300 req/min for authenticated users
    46→  },
    47→  // Endpoint-specific limits (stricter)
    48→  endpoints: {
    49→    '/auth/send-code': { max: 5, window: 300 },        // 5 requests per 5 minutes
    50→    '/auth/verify-code': { max: 10, window: 300 },     // 10 requests per 5 minutes
    51→    '/music/generate': { max: 10, window: 60 },        // 10 requests per minute
    52→    '/analyze': { max: 30, window: 60 },               // 30 requests per minute
    53→    'upload': { max: 20, window: 60 }                  // 20 uploads per minute
    54→  }
    55→};
    56→
    57→// In-memory fallback for when Redis is unavailable
    58→const ipRequestCounts = new Map(); // IP -> { count, windowStart }
    59→
    60→// Cleanup old entries every 5 minutes to prevent memory leaks
    61→setInterval(() => {
    62→  const now = Date.now();
    63→  for (const [ip, data] of ipRequestCounts.entries()) {
    64→    if (now - data.windowStart > 120000) { // Clean up entries older than 2 minutes
    65→      ipRequestCounts.delete(ip);
    66→    }
    67→  }
    68→}, 300000);
    69→
    70→/**
    71→ * SECURITY: Check rate limit using Redis with in-memory fallback
    72→ * @param {string} key - Redis key for rate limit counter
    73→ * @param {number} max - Maximum requests allowed
    74→ * @param {number} windowSeconds - Time window in seconds
    75→ * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}
    76→ */
    77→async function checkRateLimit(key, max, windowSeconds) {
    78→  try {
    79→    // Try Redis first (preferred for multi-instance deployments)
    80→    // Use isRedisAvailable() function and getRedisClient() to access raw client

</system-reminder>
