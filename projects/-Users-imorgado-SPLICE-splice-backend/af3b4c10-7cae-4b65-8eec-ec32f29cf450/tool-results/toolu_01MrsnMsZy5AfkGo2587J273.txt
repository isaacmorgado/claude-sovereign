     1→/**
     2→ * Settings Management
     3→ *
     4→ * Persists user preferences to localStorage
     5→ * v3.5: Added Persistent Token support for media folder access
     6→ */
     7→
     8→const uxpFs = require('uxp').storage.localFileSystem;
     9→
    10→// =============================================================================
    11→// CUSTOM PRESETS STORAGE (v3.5+)
    12→// =============================================================================
    13→
    14→const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';
    15→
    16→/**
    17→ * Default structure for custom presets storage
    18→ */
    19→const DEFAULT_CUSTOM_PRESETS = {
    20→  version: 1,
    21→  presets: {},
    22→  order: []
    23→};
    24→
    25→/**
    26→ * Load custom presets from localStorage
    27→ * @returns {Object} Custom presets data structure
    28→ */
    29→function loadCustomPresets() {
    30→  try {
    31→    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    32→    if (saved) {
    33→      const parsed = JSON.parse(saved);
    34→      // Validate structure
    35→      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
    36→        // Return deep copy to avoid mutation issues
    37→        return {
    38→          version: parsed.version || 1,
    39→          presets: { ...parsed.presets },
    40→          order: [...(parsed.order || [])]
    41→        };
    42→      }
    43→    }
    44→  } catch (e) {
    45→    console.warn('[SPLICE] Could not load custom presets:', e);
    46→  }
    47→  // Return fresh objects to avoid mutation of defaults
    48→  return {
    49→    version: 1,
    50→    presets: {},
    51→    order: []
    52→  };
    53→}
    54→
    55→/**
    56→ * Save custom presets to localStorage
    57→ * @param {Object} data - Custom presets data structure
    58→ * @returns {boolean} Success status
    59→ */
    60→function saveCustomPresets(data) {
    61→  try {
    62→    if (!data || typeof data !== 'object') {
    63→      console.warn('[SPLICE] Invalid custom presets data');
    64→      return false;
    65→    }
    66→    // Ensure required fields
    67→    const toSave = {
    68→      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
    69→      presets: data.presets || {},
    70→      order: data.order || []
    71→    };
    72→    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    73→    return true;
    74→  } catch (e) {
    75→    console.warn('[SPLICE] Could not save custom presets:', e);
    76→    return false;
    77→  }
    78→}
    79→
    80→/**
    81→ * Generate a slugified ID from a preset name
    82→ * @param {string} name - Preset name
    83→ * @returns {string} Slugified ID
    84→ */
    85→function slugifyPresetName(name) {
    86→  return name
    87→    .toLowerCase()
    88→    .trim()
    89→    .replace(/[^a-z0-9]+/g, '-')
    90→    .replace(/^-+|-+$/g, '')
    91→    .substring(0, 50) || 'preset';
    92→}
    93→
    94→/**
    95→ * Generate a unique ID for a custom preset
    96→ * @param {string} baseName - Base name to slugify
    97→ * @param {Object} existingPresets - Current presets object
    98→ * @returns {string} Unique ID
    99→ */
   100→function generateUniquePresetId(baseName, existingPresets) {
   101→  const baseId = slugifyPresetName(baseName);
   102→  let id = baseId;
   103→  let counter = 1;
   104→
   105→  while (existingPresets[id]) {
   106→    id = `${baseId}-${counter}`;
   107→    counter++;
   108→  }
   109→
   110→  return id;
   111→}
   112→
   113→/**
   114→ * Create a new custom preset
   115→ * @param {Object} preset - Preset data
   116→ * @param {string} preset.name - Preset name (required)
   117→ * @param {string} [preset.description] - Preset description
   118→ * @param {string} [preset.icon] - Icon name (default: 'settings')
   119→ * @param {Object} [preset.settings] - Preset settings (uses current if not provided)
   120→ * @returns {{success: boolean, id?: string, error?: string}}
   121→ */
   122→function createCustomPreset(preset) {
   123→  // Validate input
   124→  if (!preset || typeof preset !== 'object') {
   125→    return { success: false, error: 'Invalid preset data' };
   126→  }
   127→
   128→  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {
   129→    return { success: false, error: 'Preset name is required' };
   130→  }
   131→
   132→  const name = preset.name.trim();
   133→
   134→  // Load current data
   135→  const data = loadCustomPresets();
   136→
   137→  // Generate unique ID
   138→  const id = generateUniquePresetId(name, data.presets);
   139→
   140→  // Get settings from preset or current settings
   141→  const settings = preset.settings && typeof preset.settings === 'object'
   142→    ? { ...preset.settings }
   143→    : getCurrentPresetSettings();
   144→
   145→  // Validate settings
   146→  if (!settings || typeof settings !== 'object') {
   147→    return { success: false, error: 'Invalid settings' };
   148→  }
   149→
   150→  // Create the preset object
   151→  const newPreset = {
   152→    id,
   153→    name,
   154→    description: preset.description || '',
   155→    icon: preset.icon || 'settings',
   156→    createdAt: new Date().toISOString(),
   157→    settings
   158→  };
   159→
   160→  // Add to presets and order
   161→  data.presets[id] = newPreset;
   162→  data.order.push(id);
   163→
   164→  // Save
   165→  const saved = saveCustomPresets(data);
   166→  if (!saved) {
   167→    return { success: false, error: 'Failed to save preset' };
   168→  }
   169→
   170→  console.log(`[SPLICE] Created custom preset: ${name} (${id})`);
   171→  return { success: true, id };
   172→}
   173→
   174→/**
   175→ * Get current settings suitable for a preset
   176→ * @returns {Object} Current preset-compatible settings
   177→ */
   178→function getCurrentPresetSettings() {
   179→  const current = typeof getSettings === 'function' ? getSettings() : {};
   180→  return {
   181→    sensitivity: current.sensitivity || 50,
   182→    threshold: current.threshold || -32,
   183→    minSilenceLength: current.minSilenceLength || 0.5,
   184→    paddingStart: current.paddingStart || 0.1,
   185→    paddingEnd: current.paddingEnd || 0.1,
   186→    autoMarkBest: current.autoMarkBest !== false,
   187→    enableTakesDetection: current.enableTakesDetection !== false
   188→  };
   189→}
   190→
   191→/**
   192→ * Update an existing custom preset
   193→ * @param {string} id - Preset ID to update
   194→ * @param {Object} updates - Fields to update
   195→ * @param {string} [updates.name] - New name
   196→ * @param {string} [updates.description] - New description
   197→ * @param {string} [updates.icon] - New icon
   198→ * @param {Object} [updates.settings] - New settings (merged with existing)
   199→ * @returns {{success: boolean, error?: string}}
   200→ */
   201→function updateCustomPreset(id, updates) {
   202→  // Validate input
   203→  if (!id || typeof id !== 'string') {
   204→    return { success: false, error: 'Preset ID is required' };
   205→  }
   206→
   207→  if (!updates || typeof updates !== 'object') {
   208→    return { success: false, error: 'Updates must be an object' };
   209→  }
   210→
   211→  // Load current data
   212→  const data = loadCustomPresets();
   213→
   214→  // Check if preset exists
   215→  if (!data.presets[id]) {
   216→    return { success: false, error: 'Preset not found' };
   217→  }
   218→
   219→  const existing = data.presets[id];
   220→
   221→  // Apply updates (preserve fields not being updated)
   222→  const updated = {
   223→    ...existing,
   224→    updatedAt: new Date().toISOString()
   225→  };
   226→
   227→  // Update name (with validation)
   228→  if (updates.name !== undefined) {
   229→    if (typeof updates.name !== 'string' || !updates.name.trim()) {
   230→      return { success: false, error: 'Name must be a non-empty string' };
   231→    }
   232→    updated.name = updates.name.trim();
   233→  }
   234→
   235→  // Update description
   236→  if (updates.description !== undefined) {
   237→    updated.description = String(updates.description);
   238→  }
   239→
   240→  // Update icon
   241→  if (updates.icon !== undefined) {
   242→    updated.icon = String(updates.icon);
   243→  }
   244→
   245→  // Update settings (merge with existing)
   246→  if (updates.settings !== undefined) {
   247→    if (typeof updates.settings !== 'object') {
   248→      return { success: false, error: 'Settings must be an object' };
   249→    }
   250→    updated.settings = {
   251→      ...existing.settings,
   252→      ...updates.settings
   253→    };
   254→  }
   255→
   256→  // Save updated preset
   257→  data.presets[id] = updated;
   258→
   259→  const saved = saveCustomPresets(data);
   260→  if (!saved) {
   261→    return { success: false, error: 'Failed to save preset' };
   262→  }
   263→
   264→  console.log(`[SPLICE] Updated custom preset: ${updated.name} (${id})`);
   265→  return { success: true };
   266→}
   267→
   268→/**
   269→ * Get a custom preset by ID
   270→ * @param {string} id - Preset ID
   271→ * @returns {Object|null} Preset object or null if not found
   272→ */
   273→function getCustomPreset(id) {
   274→  if (!id || typeof id !== 'string') {
   275→    return null;
   276→  }
   277→
   278→  const data = loadCustomPresets();
   279→  return data.presets[id] || null;
   280→}
   281→
   282→/**
   283→ * Delete a custom preset
   284→ * @param {string} id - Preset ID to delete
   285→ * @returns {{success: boolean, error?: string}}
   286→ */
   287→function deleteCustomPreset(id) {
   288→  // Validate input
   289→  if (!id || typeof id !== 'string') {
   290→    return { success: false, error: 'Preset ID is required' };
   291→  }
   292→
   293→  // Load current data
   294→  const data = loadCustomPresets();
   295→
   296→  // Check if preset exists
   297→  if (!data.presets[id]) {
   298→    return { success: false, error: 'Preset not found' };
   299→  }
   300→
   301→  const presetName = data.presets[id].name;
   302→
   303→  // Remove from presets object
   304→  delete data.presets[id];
   305→
   306→  // Remove from order array
   307→  const orderIndex = data.order.indexOf(id);
   308→  if (orderIndex !== -1) {
   309→    data.order.splice(orderIndex, 1);
   310→  }
   311→
   312→  // Save
   313→  const saved = saveCustomPresets(data);
   314→  if (!saved) {
   315→    return { success: false, error: 'Failed to save after deletion' };
   316→  }
   317→
   318→  console.log(`[SPLICE] Deleted custom preset: ${presetName} (${id})`);
   319→  return { success: true };
   320→}
   321→
   322→/**
   323→ * List of built-in preset IDs (cannot be modified or deleted)
   324→ */
   325→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];
   326→
   327→/**
   328→ * Check if a preset is a built-in preset
   329→ * @param {string} id - Preset ID to check
   330→ * @returns {boolean} True if built-in, false if custom
   331→ */
   332→function isBuiltInPreset(id) {
   333→  return BUILT_IN_PRESET_IDS.includes(id);
   334→}
   335→
   336→/**
   337→ * Get all presets (built-in + custom merged)
   338→ * Built-in presets appear first, then custom presets in their creation order.
   339→ * Each preset has isBuiltIn flag added.
   340→ *
   341→ * @returns {Array<Object>} Array of preset objects with metadata
   342→ */
   343→function getAllPresets() {
   344→  // Get built-in presets
   345→  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {
   346→    const preset = PRESETS[id];
   347→    return {
   348→      id,
   349→      name: preset.name,
   350→      description: preset.description,
   351→      icon: preset.icon,
   352→      settings: preset.settings,
   353→      isBuiltIn: true
   354→    };
   355→  });
   356→
   357→  // Get custom presets
   358→  const customData = loadCustomPresets();
   359→  const customPresets = customData.order.map(id => {
   360→    const preset = customData.presets[id];
   361→    if (!preset) return null;
   362→    return {
   363→      ...preset,
   364→      isBuiltIn: false
   365→    };
   366→  }).filter(Boolean);
   367→
   368→  // Merge: built-in first, then custom
   369→  return [...builtInPresets, ...customPresets];
   370→}
   371→
   372→/**
   373→ * Get all preset IDs (built-in + custom)
   374→ * @returns {Array<string>} Array of preset IDs
   375→ */
   376→function getAllPresetIds() {
   377→  const customData = loadCustomPresets();
   378→  return [...BUILT_IN_PRESET_IDS, ...customData.order];
   379→}
   380→
   381→/**
   382→ * Get a preset by ID (built-in or custom)
   383→ * @param {string} id - Preset ID
   384→ * @returns {Object|null} Preset object or null if not found
   385→ */
   386→function getPresetById(id) {
   387→  if (!id || typeof id !== 'string') {
   388→    return null;
   389→  }
   390→
   391→  // Check built-in first
   392→  if (isBuiltInPreset(id)) {
   393→    const preset = PRESETS[id];
   394→    return {
   395→      id,
   396→      name: preset.name,
   397→      description: preset.description,
   398→      icon: preset.icon,
   399→      settings: preset.settings,
   400→      isBuiltIn: true
   401→    };
   402→  }
   403→
   404→  // Check custom presets
   405→  const custom = getCustomPreset(id);
   406→  if (custom) {
   407→    return {
   408→      ...custom,
   409→      isBuiltIn: false
   410→    };
   411→  }
   412→
   413→  return null;
   414→}
   415→
   416→const DEFAULT_SETTINGS = {
   417→  sensitivity: 50,
   418→  audioSource: 'original',
   419→  autoMarkBest: true,
   420→  enableTakesDetection: true,
   421→  rememberOptions: false,
   422→  optionsExpanded: false,
   423→  customerId: null,          // Stripe customer ID for billing
   424→  mediaFolderToken: null,    // Persistent token for media folder access
   425→  mediaFolderPath: null,     // Path to the media folder (for display)
   426→  activePreset: 'custom'     // Currently active preset
   427→};
   428→
   429→// =============================================================================
   430→// PRESET PROFILES
   431→// =============================================================================
   432→
   433→/**
   434→ * Detection presets for different content types.
   435→ * Each preset defines optimal settings for a specific use case.
   436→ */
   437→const PRESETS = {
   438→  // Custom - user-defined settings (default)
   439→  custom: {
   440→    name: 'Custom',
   441→    description: 'Your custom settings',
   442→    icon: 'settings',
   443→    settings: null // Uses current user settings
   444→  },
   445→
   446→  // Podcast - longer pauses are natural, be conservative
   447→  podcast: {
   448→    name: 'Podcast',
   449→    description: 'Longer natural pauses, conversational flow',
   450→    icon: 'mic',
   451→    settings: {
   452→      sensitivity: 35,           // Lower sensitivity (fewer cuts)
   453→      threshold: -35,            // Higher threshold (only deep silence)
   454→      minSilenceLength: 0.8,     // Longer minimum silence
   455→      paddingStart: 0.15,        // More padding for natural transitions
   456→      paddingEnd: 0.15,
   457→      mergeDistance: 0.3,        // Merge nearby silences
   458→      autoMarkBest: false,       // Don't auto-mark (manual review)
   459→      enableTakesDetection: true
   460→    }
   461→  },
   462→
   463→  // Interview - balanced, respects speaker pauses
   464→  interview: {
   465→    name: 'Interview',
   466→    description: 'Balanced cuts, preserves Q&A rhythm',
   467→    icon: 'people',
   468→    settings: {
   469→      sensitivity: 50,           // Medium sensitivity
   470→      threshold: -32,            // Moderate threshold
   471→      minSilenceLength: 0.5,     // Standard minimum silence
   472→      paddingStart: 0.12,        // Moderate padding
   473→      paddingEnd: 0.08,
   474→      mergeDistance: 0.2,
   475→      autoMarkBest: true,
   476→      enableTakesDetection: true
   477→    }
   478→  },
   479→
   480→  // Reaction video - fast pacing, quick cuts
   481→  reaction: {
   482→    name: 'Reaction',
   483→    description: 'Fast-paced, tight cuts for energy',
   484→    icon: 'bolt',
   485→    settings: {
   486→      sensitivity: 70,           // Higher sensitivity (more cuts)
   487→      threshold: -28,            // Lower threshold (catches more silence)
   488→      minSilenceLength: 0.3,     // Short minimum silence
   489→      paddingStart: 0.05,        // Minimal padding for snappy edits
   490→      paddingEnd: 0.03,
   491→      mergeDistance: 0.15,
   492→      autoMarkBest: true,
   493→      enableTakesDetection: false // Usually single-take content
   494→    }
   495→  },
   496→
   497→  // Tutorial/Educational - preserve thinking pauses
   498→  tutorial: {
   499→    name: 'Tutorial',
   500→    description: 'Preserves teaching pace, minimal cuts',
   501→    icon: 'school',
   502→    settings: {
   503→      sensitivity: 30,           // Low sensitivity
   504→      threshold: -38,            // Only deep silence
   505→      minSilenceLength: 1.0,     // Long minimum (preserve demo pauses)
   506→      paddingStart: 0.2,         // Extra padding for clarity
   507→      paddingEnd: 0.15,
   508→      mergeDistance: 0.4,
   509→      autoMarkBest: false,
   510→      enableTakesDetection: true
   511→    }
   512→  },
   513→
   514→  // Vlog/YouTube - punchy edits, engagement-focused
   515→  vlog: {
   516→    name: 'Vlog',
   517→    description: 'Punchy edits for YouTube engagement',
   518→    icon: 'videocam',
   519→    settings: {
   520→      sensitivity: 65,           // Higher sensitivity
   521→      threshold: -30,            // Moderate-low threshold
   522→      minSilenceLength: 0.35,    // Short silences
   523→      paddingStart: 0.08,        // Quick transitions
   524→      paddingEnd: 0.05,
   525→      mergeDistance: 0.2,
   526→      autoMarkBest: true,
   527→      enableTakesDetection: true
   528→    }
   529→  }
   530→};
   531→
   532→/**
   533→ * Get all available presets
   534→ * @returns {Object} All preset definitions
   535→ */
   536→function getPresets() {
   537→  return { ...PRESETS };
   538→}
   539→
   540→/**
   541→ * Get a specific preset by name
   542→ * @param {string} presetName - Name of the preset
   543→ * @returns {Object|null} Preset definition or null if not found
   544→ */
   545→function getPreset(presetName) {
   546→  return PRESETS[presetName] || null;
   547→}
   548→
   549→/**
   550→ * Get preset names as array (for UI)
   551→ * @returns {Array<string>} Array of preset names
   552→ */
   553→function getPresetNames() {
   554→  return Object.keys(PRESETS);
   555→}
   556→
   557→/**
   558→ * Apply a preset to current settings
   559→ * @param {string} presetName - Name of the preset to apply
   560→ * @returns {Object} The applied settings
   561→ */
   562→function applyPreset(presetName) {
   563→  const preset = PRESETS[presetName];
   564→
   565→  if (!preset) {
   566→    console.warn(`[SPLICE] Unknown preset: ${presetName}`);
   567→    return getSettings();
   568→  }
   569→
   570→  // Custom preset uses current settings
   571→  if (presetName === 'custom' || !preset.settings) {
   572→    saveSettings({ activePreset: 'custom' });
   573→    return getSettings();
   574→  }
   575→
   576→  // Apply preset settings
   577→  const newSettings = {
   578→    ...preset.settings,
   579→    activePreset: presetName
   580→  };
   581→
   582→  saveSettings(newSettings);
   583→  console.log(`[SPLICE] Applied preset: ${preset.name}`);
   584→
   585→  return getSettings();
   586→}
   587→
   588→/**
   589→ * Get the currently active preset
   590→ * @returns {string} Active preset name
   591→ */
   592→function getActivePreset() {
   593→  const settings = getSettings();
   594→  return settings.activePreset || 'custom';
   595→}
   596→
   597→/**
   598→ * Check if current settings match a preset
   599→ * @param {string} presetName - Preset to compare against
   600→ * @returns {boolean} True if settings match the preset
   601→ */
   602→function settingsMatchPreset(presetName) {
   603→  const preset = PRESETS[presetName];
   604→  if (!preset || !preset.settings) return presetName === 'custom';
   605→
   606→  const current = getSettings();
   607→
   608→  // Compare relevant settings
   609→  return Object.keys(preset.settings).every(key => {
   610→    if (key === 'activePreset') return true;
   611→    return current[key] === preset.settings[key];
   612→  });
   613→}
   614→
   615→let currentSettings = { ...DEFAULT_SETTINGS };
   616→
   617→/**
   618→ * Load settings from localStorage
   619→ */
   620→function loadSettings() {
   621→  try {
   622→    const saved = localStorage.getItem('spliceSettings');
   623→    if (saved) {
   624→      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
   625→    }
   626→  } catch (e) {
   627→    console.warn('[SPLICE] Could not load settings:', e);
   628→    currentSettings = { ...DEFAULT_SETTINGS };
   629→  }
   630→  return currentSettings;
   631→}
   632→
   633→/**
   634→ * Save settings to localStorage
   635→ */
   636→function saveSettings(settings) {
   637→  try {
   638→    currentSettings = { ...currentSettings, ...settings };
   639→    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
   640→  } catch (e) {
   641→    console.warn('[SPLICE] Could not save settings:', e);
   642→  }
   643→}
   644→
   645→/**
   646→ * Get current settings
   647→ */
   648→function getSettings() {
   649→  return { ...currentSettings };
   650→}
   651→
   652→/**
   653→ * Reset settings to defaults
   654→ */
   655→function resetSettings() {
   656→  currentSettings = { ...DEFAULT_SETTINGS };
   657→  try {
   658→    localStorage.removeItem('spliceSettings');
   659→  } catch (e) {
   660→    console.warn('[SPLICE] Could not clear settings:', e);
   661→  }
   662→}
   663→
   664→/**
   665→ * Initialize settings UI components
   666→ */
   667→function initSettingsUI() {
   668→  const settings = loadSettings();
   669→
   670→  // Apply saved sensitivity to slider
   671→  const sensitivitySlider = document.getElementById('sensitivitySlider');
   672→  if (sensitivitySlider) {
   673→    sensitivitySlider.value = settings.sensitivity;
   674→  }
   675→
   676→  // Apply saved audio source
   677→  const sourceOriginal = document.getElementById('sourceOriginal');
   678→  const sourceIsolated = document.getElementById('sourceIsolated');
   679→  if (sourceOriginal && sourceIsolated) {
   680→    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';
   681→    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';
   682→  }
   683→
   684→  // Apply auto-mark best setting
   685→  const autoMarkBest = document.getElementById('autoMarkBest');
   686→  if (autoMarkBest) {
   687→    autoMarkBest.checked = settings.autoMarkBest;
   688→  }
   689→
   690→  // Apply takes detection setting
   691→  const enableTakesDetection = document.getElementById('enableTakesDetection');
   692→  if (enableTakesDetection) {
   693→    enableTakesDetection.checked = settings.enableTakesDetection;
   694→  }
   695→
   696→  // Apply remember options setting
   697→  const rememberOptions = document.getElementById('rememberOptions');
   698→  if (rememberOptions) {
   699→    rememberOptions.checked = settings.rememberOptions;
   700→  }
   701→
   702→  // Restore expanded state if remember is enabled
   703→  if (settings.rememberOptions && settings.optionsExpanded) {
   704→    toggleOptionsPanel(true);
   705→  }
   706→}
   707→
   708→/**
   709→ * Toggle options panel visibility (unified panel)
   710→ */
   711→function toggleOptionsPanel(forceState) {
   712→  const toggle = document.getElementById('optionsToggle');
   713→  const panel = document.getElementById('optionsPanel');
   714→
   715→  if (!toggle || !panel) return;
   716→
   717→  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');
   718→
   719→  if (shouldExpand) {
   720→    panel.classList.remove('collapsed');
   721→    toggle.classList.add('expanded');
   722→  } else {
   723→    panel.classList.add('collapsed');
   724→    toggle.classList.remove('expanded');
   725→  }
   726→
   727→  // Save state if remember is enabled
   728→  const settings = getSettings();
   729→  if (settings.rememberOptions) {
   730→    saveSettings({ optionsExpanded: shouldExpand });
   731→  }
   732→}
   733→
   734→/**
   735→ * Initialize settings modal
   736→ */
   737→function initSettingsModal() {
   738→  const settingsBtn = document.getElementById('settingsBtn');
   739→  const modal = document.getElementById('settingsModal');
   740→  const closeBtn = document.getElementById('closeSettingsBtn');
   741→  const defaultSensitivity = document.getElementById('defaultSensitivity');
   742→  const rememberOptions = document.getElementById('rememberOptions');
   743→
   744→  if (settingsBtn && modal) {
   745→    settingsBtn.addEventListener('click', () => {
   746→      modal.classList.remove('hidden');
   747→      // Sync modal values with current settings
   748→      const settings = getSettings();
   749→      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;
   750→      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;
   751→    });
   752→  }
   753→
   754→  if (closeBtn && modal) {
   755→    closeBtn.addEventListener('click', () => {
   756→      modal.classList.add('hidden');
   757→    });
   758→  }
   759→
   760→  // Close on backdrop click
   761→  if (modal) {
   762→    modal.addEventListener('click', (e) => {
   763→      if (e.target === modal) {
   764→        modal.classList.add('hidden');
   765→      }
   766→    });
   767→  }
   768→
   769→  // Save default sensitivity when changed
   770→  if (defaultSensitivity) {
   771→    defaultSensitivity.addEventListener('change', () => {
   772→      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });
   773→      // Also update the main slider
   774→      const mainSlider = document.getElementById('sensitivitySlider');
   775→      if (mainSlider) mainSlider.value = defaultSensitivity.value;
   776→    });
   777→  }
   778→
   779→  // Save remember options when changed
   780→  if (rememberOptions) {
   781→    rememberOptions.addEventListener('change', () => {
   782→      saveSettings({ rememberOptions: rememberOptions.checked });
   783→    });
   784→  }
   785→}
   786→
   787→/**
   788→ * Initialize options toggle (unified panel)
   789→ */
   790→function initOptionsToggles() {
   791→  const toggle = document.getElementById('optionsToggle');
   792→
   793→  if (toggle) {
   794→    toggle.addEventListener('click', () => toggleOptionsPanel());
   795→  }
   796→}
   797→
   798→/**
   799→ * Initialize preset selector
   800→ */
   801→function initPresetSelector() {
   802→  const presetSelector = document.getElementById('presetSelector');
   803→  const sensitivitySlider = document.getElementById('sensitivitySlider');
   804→
   805→  if (!presetSelector) return;
   806→
   807→  // Set initial value from settings
   808→  const settings = getSettings();
   809→  presetSelector.value = settings.activePreset || 'custom';
   810→
   811→  // Handle preset change (supports both built-in and custom presets)
   812→  presetSelector.addEventListener('change', () => {
   813→    const presetId = presetSelector.value;
   814→
   815→    // Get preset info (works for both built-in and custom)
   816→    const preset = getPresetById(presetId);
   817→    if (!preset) {
   818→      console.warn(`[SPLICE] Preset not found: ${presetId}`);
   819→      return;
   820→    }
   821→
   822→    let appliedSettings;
   823→
   824→    if (preset.isBuiltIn) {
   825→      // Built-in preset: use the existing applyPreset function
   826→      appliedSettings = applyPreset(presetId);
   827→    } else {
   828→      // Custom preset: apply stored settings
   829→      appliedSettings = preset.settings || {};
   830→      saveSettings({ activePreset: presetId, ...appliedSettings });
   831→    }
   832→
   833→    // Update sensitivity slider to match preset
   834→    if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {
   835→      sensitivitySlider.value = appliedSettings.sensitivity;
   836→    }
   837→
   838→    // Update takes detection checkbox
   839→    const enableTakesDetection = document.getElementById('enableTakesDetection');
   840→    if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {
   841→      enableTakesDetection.checked = appliedSettings.enableTakesDetection;
   842→    }
   843→
   844→    // Update auto-mark best checkbox
   845→    const autoMarkBest = document.getElementById('autoMarkBest');
   846→    if (autoMarkBest && appliedSettings.autoMarkBest !== undefined) {
   847→      autoMarkBest.checked = appliedSettings.autoMarkBest;
   848→    }
   849→
   850→    if (typeof setStatus === 'function') {
   851→      const desc = preset.description ? ` - ${preset.description}` : '';
   852→      setStatus(`Preset: ${preset.name}${desc}`);
   853→    }
   854→  });
   855→
   856→  // Switch to custom when user manually changes sensitivity
   857→  if (sensitivitySlider) {
   858→    sensitivitySlider.addEventListener('change', () => {
   859→      if (presetSelector.value !== 'custom') {
   860→        presetSelector.value = 'custom';
   861→        saveSettings({ activePreset: 'custom' });
   862→      }
   863→    });
   864→  }
   865→}
   866→
   867→/**
   868→ * Initialize help button
   869→ */
   870→function initHelpButton() {
   871→  const helpBtn = document.getElementById('helpBtn');
   872→  if (helpBtn) {
   873→    helpBtn.addEventListener('click', () => {
   874→      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');
   875→    });
   876→  }
   877→}
   878→
   879→// =============================================================================
   880→// PERSISTENT TOKEN MANAGEMENT (v3.5)
   881→// =============================================================================
   882→
   883→/**
   884→ * Media folder entry (cached after selection)
   885→ * @type {Object|null}
   886→ */
   887→let mediaFolderEntry = null;
   888→
   889→/**
   890→ * Prompt user to select a media folder and create a persistent token.
   891→ * This allows silent file access without repeated permission prompts.
   892→ *
   893→ * @returns {Promise<{success: boolean, path?: string, error?: string}>}
   894→ */
   895→async function setupMediaFolder() {
   896→  try {
   897→    // Open folder picker dialog
   898→    const folder = await uxpFs.getFolder();
   899→
   900→    if (!folder) {
   901→      return { success: false, error: 'No folder selected' };
   902→    }
   903→
   904→    // Create a persistent token for this folder
   905→    const token = await uxpFs.createPersistentToken(folder);
   906→
   907→    if (!token) {
   908→      return { success: false, error: 'Failed to create persistent token' };
   909→    }
   910→
   911→    // Get the folder path for display
   912→    const folderPath = folder.nativePath || folder.name;
   913→
   914→    // Save to settings
   915→    saveSettings({
   916→      mediaFolderToken: token,
   917→      mediaFolderPath: folderPath
   918→    });
   919→
   920→    // Cache the folder entry
   921→    mediaFolderEntry = folder;
   922→
   923→    console.log(`[SPLICE] Media folder set: ${folderPath}`);
   924→
   925→    return {
   926→      success: true,
   927→      path: folderPath,
   928→      token
   929→    };
   930→  } catch (err) {
   931→    console.error('[SPLICE] Error setting up media folder:', err);
   932→    return { success: false, error: err.message };
   933→  }
   934→}
   935→
   936→/**
   937→ * Get the media folder entry using the stored persistent token.
   938→ * Falls back to prompting if token is invalid.
   939→ *
   940→ * @returns {Promise<Object|null>} The folder entry or null
   941→ */
   942→async function getMediaFolder() {
   943→  // Return cached entry if available
   944→  if (mediaFolderEntry) {
   945→    return mediaFolderEntry;
   946→  }
   947→
   948→  const settings = getSettings();
   949→
   950→  // Try to restore from persistent token
   951→  if (settings.mediaFolderToken) {
   952→    try {
   953→      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);
   954→      if (folder) {
   955→        mediaFolderEntry = folder;
   956→        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);
   957→        return folder;
   958→      }
   959→    } catch (err) {
   960→      console.warn('[SPLICE] Could not restore media folder from token:', err.message);
   961→      // Clear invalid token
   962→      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });
   963→    }
   964→  }
   965→
   966→  return null;
   967→}
   968→
   969→/**
   970→ * Check if a media folder is configured
   971→ * @returns {boolean}
   972→ */
   973→function hasMediaFolder() {
   974→  const settings = getSettings();
   975→  return !!settings.mediaFolderToken;
   976→}
   977→
   978→/**
   979→ * Get the configured media folder path (for display)
   980→ * @returns {string|null}
   981→ */
   982→function getMediaFolderPath() {
   983→  const settings = getSettings();
   984→  return settings.mediaFolderPath;
   985→}
   986→
   987→/**
   988→ * Clear the media folder configuration
   989→ */
   990→function clearMediaFolder() {
   991→  mediaFolderEntry = null;
   992→  saveSettings({
   993→    mediaFolderToken: null,
   994→    mediaFolderPath: null
   995→  });
   996→  console.log('[SPLICE] Media folder cleared');
   997→}
   998→
   999→/**
  1000→ * Read a file from the media folder
  1001→ * @param {string} filename - Name of the file to read
  1002→ * @returns {Promise<ArrayBuffer|null>} File contents or null
  1003→ */
  1004→async function readMediaFile(filename) {
  1005→  const folder = await getMediaFolder();
  1006→  if (!folder) {
  1007→    console.warn('[SPLICE] No media folder configured');
  1008→    return null;
  1009→  }
  1010→
  1011→  try {
  1012→    const file = await folder.getEntry(filename);
  1013→    if (!file) {
  1014→      console.warn(`[SPLICE] File not found in media folder: ${filename}`);
  1015→      return null;
  1016→    }
  1017→
  1018→    const contents = await file.read({ format: uxpFs.formats.binary });
  1019→    return contents;
  1020→  } catch (err) {
  1021→    console.error(`[SPLICE] Error reading file ${filename}:`, err);
  1022→    return null;
  1023→  }
  1024→}
  1025→
  1026→// =============================================================================
  1027→// LOGIN MODAL
  1028→// =============================================================================
  1029→
  1030→/**
  1031→ * Initialize login modal handlers
  1032→ */
  1033→function initLoginModal() {
  1034→  const loginModal = document.getElementById('loginModal');
  1035→  const closeLoginBtn = document.getElementById('closeLoginBtn');
  1036→  const saveLoginBtn = document.getElementById('saveLoginBtn');
  1037→  const customerIdInput = document.getElementById('customerIdInput');
  1038→  const loginError = document.getElementById('loginError');
  1039→  const creditBadge = document.getElementById('creditBadge');
  1040→
  1041→  // Show login modal when clicking credit badge (if not logged in)
  1042→  if (creditBadge) {
  1043→    creditBadge.addEventListener('click', () => {
  1044→      const settings = getSettings();
  1045→      if (!settings.customerId) {
  1046→        showLoginModal();
  1047→      }
  1048→    });
  1049→  }
  1050→
  1051→  // Close login modal
  1052→  if (closeLoginBtn && loginModal) {
  1053→    closeLoginBtn.addEventListener('click', () => {
  1054→      loginModal.classList.add('hidden');
  1055→    });
  1056→  }
  1057→
  1058→  // Close on backdrop click
  1059→  if (loginModal) {
  1060→    loginModal.addEventListener('click', (e) => {
  1061→      if (e.target === loginModal) {
  1062→        loginModal.classList.add('hidden');
  1063→      }
  1064→    });
  1065→  }
  1066→
  1067→  // Save customer ID
  1068→  if (saveLoginBtn) {
  1069→    saveLoginBtn.addEventListener('click', async () => {
  1070→      const customerId = customerIdInput?.value?.trim();
  1071→
  1072→      if (!customerId) {
  1073→        showLoginError('Please enter your customer ID');
  1074→        return;
  1075→      }
  1076→
  1077→      if (!customerId.startsWith('cus_')) {
  1078→        showLoginError('Customer ID should start with "cus_"');
  1079→        return;
  1080→      }
  1081→
  1082→      // Save to settings
  1083→      saveSettings({ customerId });
  1084→
  1085→      // Hide modal
  1086→      loginModal?.classList.add('hidden');
  1087→
  1088→      // Refresh credits display
  1089→      if (typeof refreshCredits === 'function') {
  1090→        await refreshCredits();
  1091→      }
  1092→
  1093→      if (typeof setStatus === 'function') {
  1094→        setStatus('Logged in successfully');
  1095→      }
  1096→    });
  1097→  }
  1098→
  1099→  // Load existing customer ID into input
  1100→  const settings = getSettings();
  1101→  if (customerIdInput && settings.customerId) {
  1102→    customerIdInput.value = settings.customerId;
  1103→  }
  1104→}
  1105→
  1106→/**
  1107→ * Show login modal
  1108→ */
  1109→function showLoginModal() {
  1110→  const loginModal = document.getElementById('loginModal');
  1111→  const loginError = document.getElementById('loginError');
  1112→
  1113→  if (loginError) {
  1114→    loginError.style.display = 'none';
  1115→  }
  1116→
  1117→  if (loginModal) {
  1118→    loginModal.classList.remove('hidden');
  1119→  }
  1120→}
  1121→
  1122→/**
  1123→ * Show login error message
  1124→ */
  1125→function showLoginError(message) {
  1126→  const loginError = document.getElementById('loginError');
  1127→  if (loginError) {
  1128→    loginError.textContent = message;
  1129→    loginError.style.display = 'block';
  1130→  }
  1131→}
  1132→
  1133→/**
  1134→ * Check if user is logged in
  1135→ * @returns {boolean}
  1136→ */
  1137→function isLoggedIn() {
  1138→  const settings = getSettings();
  1139→  return !!settings.customerId;
  1140→}
  1141→
  1142→/**
  1143→ * Get customer ID
  1144→ * @returns {string|null}
  1145→ */
  1146→function getCustomerId() {
  1147→  const settings = getSettings();
  1148→  return settings.customerId || null;
  1149→}
  1150→
  1151→/**
  1152→ * Logout - clear customer ID
  1153→ */
  1154→function logout() {
  1155→  saveSettings({ customerId: null });
  1156→  if (typeof setStatus === 'function') {
  1157→    setStatus('Logged out');
  1158→  }
  1159→}
  1160→
  1161→// Load settings on script load
  1162→loadSettings();
  1163→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
