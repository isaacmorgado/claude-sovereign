     1→/**
     2→ * Rate Limiter Middleware
     3→ *
     4→ * Checks if user has sufficient credits before processing.
     5→ * Returns 402 Payment Required if insufficient credits.
     6→ */
     7→
     8→const { hasCredits, deductUsage, getBalance } = require('../services/usageTracking');
     9→
    10→/**
    11→ * Middleware to check credits before processing
    12→ *
    13→ * Expects req.stripeCustomerId to be set by auth middleware
    14→ * Optionally uses req.estimatedDuration (in seconds) for pre-check
    15→ */
    16→function requireCredits(options = {}) {
    17→  const { endpoint = 'unknown' } = options;
    18→
    19→  return async (req, res, next) => {
    20→    const stripeCustomerId = req.stripeCustomerId || req.headers['x-stripe-customer-id'];
    21→
    22→    if (!stripeCustomerId) {
    23→      return res.status(401).json({
    24→        error: 'Authentication required',
    25→        message: 'Missing Stripe customer ID'
    26→      });
    27→    }
    28→
    29→    // Store for later use
    30→    req.stripeCustomerId = stripeCustomerId;
    31→
    32→    try {
    33→      // Check if user has any credits
    34→      const hasCreds = await hasCredits(stripeCustomerId, req.estimatedDuration || 0);
    35→
    36→      if (!hasCreds) {
    37→        const balance = await getBalance(stripeCustomerId);
    38→        return res.status(402).json({
    39→          error: 'Insufficient credits',
    40→          message: 'Please upgrade your plan or wait for your next billing cycle',
    41→          balance: {
    42→            hoursRemaining: balance.hoursRemaining,
    43→            tier: balance.tier
    44→          }
    45→        });
    46→      }
    47→
    48→      // Attach helper function to deduct after processing
    49→      req.deductUsage = async (audioDurationSeconds) => {
    50→        return await deductUsage(stripeCustomerId, audioDurationSeconds, endpoint);
    51→      };
    52→
    53→      next();
    54→    } catch (err) {
    55→      console.error('[RateLimiter] Error checking credits:', err);
    56→      return res.status(500).json({
    57→        error: 'Credit check failed',
    58→        message: err.message
    59→      });
    60→    }
    61→  };
    62→}
    63→
    64→/**
    65→ * Middleware to track usage after successful response
    66→ *
    67→ * Call this after processing to deduct actual usage
    68→ */
    69→function trackUsage(endpoint = 'unknown') {
    70→  return async (req, res, next) => {
    71→    // Store original json method
    72→    const originalJson = res.json.bind(res);
    73→
    74→    // Override json to track usage on success
    75→    res.json = async (data) => {
    76→      // Only deduct on successful responses
    77→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {
    78→        try {
    79→          const balance = await deductUsage(
    80→            req.stripeCustomerId,
    81→            req.audioDuration,
    82→            endpoint
    83→          );
    84→          // Attach updated balance to response
    85→          data.balance = balance;
    86→        } catch (err) {
    87→          console.error('[RateLimiter] Error deducting usage:', err);
    88→        }
    89→      }
    90→      return originalJson(data);
    91→    };
    92→
    93→    next();
    94→  };
    95→}
    96→
    97→module.exports = {
    98→  requireCredits,
    99→  trackUsage
   100→};
   101→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
