     1→/**
     2→ * SPLICE Music Module
     3→ * AI-powered music generation for video projects
     4→ */
     5→
     6→// ============================================
     7→// STATE
     8→// ============================================
     9→const musicState = {
    10→  jobs: [],
    11→  selectedJob: null,
    12→  isIdentifying: false,
    13→  isGenerating: false,
    14→  identifiedSong: null,
    15→  audioPlayer: null,
    16→  pollInterval: null,
    17→  // Variations state
    18→  variationsJob: null,
    19→  variationsPollingInterval: null,
    20→  selectedVariationIndex: null,
    21→  variationPlayers: [null, null, null],  // Audio players for each variation
    22→  // Scene-aware state
    23→  sceneAwareEnabled: false,
    24→  // Alignment state
    25→  isAligning: false,
    26→  alignmentOptions: null,
    27→  beatAnalysis: null,
    28→  // Timeline state
    29→  isGeneratingTimeline: false,
    30→  timelineOptions: null
    31→};
    32→
    33→// ============================================
    34→// CONSTANTS
    35→// ============================================
    36→const MUSIC_POLL_INTERVAL = 5000; // 5 seconds
    37→
    38→const MOOD_OPTIONS = [
    39→  { id: 'energetic', name: 'Energetic', description: 'Upbeat, high energy' },
    40→  { id: 'relaxed', name: 'Relaxed', description: 'Calm, peaceful' },
    41→  { id: 'melancholic', name: 'Melancholic', description: 'Sad, emotional' },
    42→  { id: 'intense', name: 'Intense', description: 'Powerful, dramatic' },
    43→  { id: 'happy', name: 'Happy', description: 'Joyful, cheerful' },
    44→  { id: 'mysterious', name: 'Mysterious', description: 'Dark, suspenseful' },
    45→  { id: 'romantic', name: 'Romantic', description: 'Warm, intimate' },
    46→  { id: 'epic', name: 'Epic', description: 'Grand, orchestral' },
    47→  { id: 'chill', name: 'Chill', description: 'Lo-fi, laid-back' },
    48→  { id: 'neutral', name: 'Neutral', description: 'Balanced, versatile' }
    49→];
    50→
    51→const INSTRUMENT_OPTIONS = [
    52→  { id: 'acoustic', name: 'Acoustic', description: 'Guitar, piano, strings' },
    53→  { id: 'electronic', name: 'Electronic', description: 'Synths, beats' },
    54→  { id: 'rock', name: 'Rock', description: 'Electric guitars, drums' },
    55→  { id: 'orchestral', name: 'Orchestral', description: 'Strings, brass, woodwinds' },
    56→  { id: 'minimal', name: 'Minimal', description: 'Piano, ambient' },
    57→  { id: 'hiphop', name: 'Hip-Hop', description: '808s, trap drums' }
    58→];
    59→
    60→const DURATION_OPTIONS = [
    61→  { value: 30, label: '30 seconds' },
    62→  { value: 60, label: '1 minute' },
    63→  { value: 90, label: '1.5 minutes' },
    64→  { value: 120, label: '2 minutes' },
    65→  { value: 180, label: '3 minutes' }
    66→];
    67→
    68→// ============================================
    69→// API FUNCTIONS
    70→// ============================================
    71→
    72→/**
    73→ * Identify song from YouTube URL
    74→ * @param {string} youtubeUrl - YouTube URL
    75→ * @returns {Promise<Object>} Identification result
    76→ */
    77→async function identifySong(youtubeUrl) {
    78→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/identify`, {
    79→    method: 'POST',
    80→    headers: {
    81→      ...getAuthHeaders(),
    82→      'Content-Type': 'application/json'
    83→    },
    84→    body: JSON.stringify({ youtubeUrl })
    85→  }, 90000); // 90 second timeout for identification
    86→
    87→  if (!response.ok) {
    88→    const error = await parseErrorResponse(response);
    89→    throw new Error(error.message || 'Failed to identify song');
    90→  }
    91→
    92→  return response.json();
    93→}
    94→
    95→/**
    96→ * Generate music
    97→ * @param {Object} options - Generation options
    98→ * @returns {Promise<Object>} Job info
    99→ */
   100→async function generateMusicRequest(options) {
   101→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate`, {
   102→    method: 'POST',
   103→    headers: {
   104→      ...getAuthHeaders(),
   105→      'Content-Type': 'application/json'
   106→    },
   107→    body: JSON.stringify(options)
   108→  });
   109→
   110→  if (!response.ok) {
   111→    const error = await parseErrorResponse(response);
   112→    throw new Error(error.message || 'Failed to start music generation');
   113→  }
   114→
   115→  return response.json();
   116→}
   117→
   118→/**
   119→ * Get job status
   120→ * @param {string} jobId - Job ID
   121→ * @returns {Promise<Object>} Job status
   122→ */
   123→async function getJobStatus(jobId) {
   124→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/status/${jobId}`, {
   125→    headers: getAuthHeaders()
   126→  });
   127→
   128→  if (!response.ok) {
   129→    const error = await parseErrorResponse(response);
   130→    throw new Error(error.message || 'Failed to get job status');
   131→  }
   132→
   133→  return response.json();
   134→}
   135→
   136→/**
   137→ * Get user's music library
   138→ * @returns {Promise<Object[]>} Array of music items
   139→ */
   140→async function getMusicLibrary() {
   141→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/library`, {
   142→    headers: getAuthHeaders()
   143→  });
   144→
   145→  if (!response.ok) {
   146→    const error = await parseErrorResponse(response);
   147→    throw new Error(error.message || 'Failed to load music library');
   148→  }
   149→
   150→  return response.json();
   151→}
   152→
   153→/**
   154→ * Get music file with download URL
   155→ * @param {string} jobId - Job ID
   156→ * @returns {Promise<Object>} Music info with signed URL
   157→ */
   158→async function getMusicFile(jobId) {
   159→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
   160→    headers: getAuthHeaders()
   161→  });
   162→
   163→  if (!response.ok) {
   164→    const error = await parseErrorResponse(response);
   165→    throw new Error(error.message || 'Failed to get music file');
   166→  }
   167→
   168→  return response.json();
   169→}
   170→
   171→/**
   172→ * Delete music from library
   173→ * @param {string} jobId - Job ID
   174→ * @returns {Promise<Object>} Result
   175→ */
   176→async function deleteMusicFile(jobId) {
   177→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
   178→    method: 'DELETE',
   179→    headers: getAuthHeaders()
   180→  });
   181→
   182→  if (!response.ok) {
   183→    const error = await parseErrorResponse(response);
   184→    throw new Error(error.message || 'Failed to delete music');
   185→  }
   186→
   187→  return response.json();
   188→}
   189→
   190→/**
   191→ * Get music credits balance
   192→ * @returns {Promise<Object>} Credits info
   193→ */
   194→async function getMusicCredits() {
   195→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/credits`, {
   196→    headers: getAuthHeaders()
   197→  });
   198→
   199→  if (!response.ok) {
   200→    return { remaining: 0, total: 0 };
   201→  }
   202→
   203→  return response.json();
   204→}
   205→
   206→// ============================================
   207→// VARIATIONS API FUNCTIONS
   208→// ============================================
   209→
   210→/**
   211→ * Generate 3 music variations
   212→ * @param {Object} options - Generation options
   213→ * @returns {Promise<Object>} Job info
   214→ */
   215→async function generateVariationsRequest(options) {
   216→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-variations`, {
   217→    method: 'POST',
   218→    headers: {
   219→      ...getAuthHeaders(),
   220→      'Content-Type': 'application/json'
   221→    },
   222→    body: JSON.stringify(options)
   223→  });
   224→
   225→  if (!response.ok) {
   226→    const error = await parseErrorResponse(response);
   227→    throw new Error(error.message || 'Failed to start variations generation');
   228→  }
   229→
   230→  return response.json();
   231→}
   232→
   233→/**
   234→ * Get variations job status
   235→ * @param {string} jobId - Job ID
   236→ * @returns {Promise<Object>} Job status with variations
   237→ */
   238→async function getVariationsStatus(jobId) {
   239→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/variations/status/${jobId}`, {
   240→    headers: getAuthHeaders()
   241→  });
   242→
   243→  if (!response.ok) {
   244→    const error = await parseErrorResponse(response);
   245→    throw new Error(error.message || 'Failed to get variations status');
   246→  }
   247→
   248→  return response.json();
   249→}
   250→
   251→/**
   252→ * Select a variation from the generated options
   253→ * @param {string} jobId - Job ID
   254→ * @param {number} variationIndex - Index of variation to select (0-2)
   255→ * @returns {Promise<Object>} Selection result
   256→ */
   257→async function selectVariation(jobId, variationIndex) {
   258→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/variations/${jobId}/select`, {
   259→    method: 'POST',
   260→    headers: {
   261→      ...getAuthHeaders(),
   262→      'Content-Type': 'application/json'
   263→    },
   264→    body: JSON.stringify({ variationIndex })
   265→  });
   266→
   267→  if (!response.ok) {
   268→    const error = await parseErrorResponse(response);
   269→    throw new Error(error.message || 'Failed to select variation');
   270→  }
   271→
   272→  return response.json();
   273→}
   274→
   275→// ============================================
   276→// SCENE-AWARE API FUNCTIONS
   277→// ============================================
   278→
   279→/**
   280→ * Generate scene-aware music using transcript analysis
   281→ * @param {Object} options - Generation options
   282→ * @param {Object[]} segments - Transcript segments
   283→ * @returns {Promise<Object>} Job info
   284→ */
   285→async function generateSceneAwareRequest(options, segments) {
   286→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-scene-aware`, {
   287→    method: 'POST',
   288→    headers: {
   289→      ...getAuthHeaders(),
   290→      'Content-Type': 'application/json'
   291→    },
   292→    body: JSON.stringify({
   293→      ...options,
   294→      segments
   295→    })
   296→  });
   297→
   298→  if (!response.ok) {
   299→    const error = await parseErrorResponse(response);
   300→    throw new Error(error.message || 'Failed to start scene-aware music generation');
   301→  }
   302→
   303→  return response.json();
   304→}
   305→
   306→/**
   307→ * Get transcript segments from the current session
   308→ * @returns {Object[]|null} Transcript segments or null if not available
   309→ */
   310→function getCurrentTranscriptSegments() {
   311→  // Check if transcript is available from main workflow
   312→  if (window.currentTranscript && window.currentTranscript.segments) {
   313→    return window.currentTranscript.segments;
   314→  }
   315→  return null;
   316→}
   317→
   318→// ============================================
   319→// ALIGNMENT API FUNCTIONS
   320→// ============================================
   321→
   322→/**
   323→ * Align music to video duration with beat-matching
   324→ * @param {string} jobId - Job ID
   325→ * @param {number} targetDuration - Target duration in seconds
   326→ * @param {Object} options - Alignment options
   327→ * @returns {Promise<Object>} Alignment result
   328→ */
   329→async function alignMusicRequest(jobId, targetDuration, options = {}) {
   330→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/align`, {
   331→    method: 'POST',
   332→    headers: {
   333→      ...getAuthHeaders(),
   334→      'Content-Type': 'application/json'
   335→    },
   336→    body: JSON.stringify({
   337→      jobId,
   338→      targetDuration,
   339→      fadeDuration: options.fadeDuration,
   340→      beatAlign: options.beatAlign !== false,
   341→      searchWindow: options.searchWindow
   342→    })
   343→  }, 120000); // 2 minute timeout
   344→
   345→  if (!response.ok) {
   346→    const error = await parseErrorResponse(response);
   347→    throw new Error(error.message || 'Failed to align music');
   348→  }
   349→
   350→  return response.json();
   351→}
   352→
   353→/**
   354→ * Analyze beats in music without trimming
   355→ * @param {string} jobId - Job ID
   356→ * @returns {Promise<Object>} Beat analysis
   357→ */
   358→async function analyzeBeatsRequest(jobId) {
   359→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/analyze-beats`, {
   360→    method: 'POST',
   361→    headers: {
   362→      ...getAuthHeaders(),
   363→      'Content-Type': 'application/json'
   364→    },
   365→    body: JSON.stringify({ jobId })
   366→  }, 60000); // 1 minute timeout
   367→
   368→  if (!response.ok) {
   369→    const error = await parseErrorResponse(response);
   370→    throw new Error(error.message || 'Failed to analyze beats');
   371→  }
   372→
   373→  return response.json();
   374→}
   375→
   376→/**
   377→ * Get alignment configuration options
   378→ * @returns {Promise<Object>} Alignment options
   379→ */
   380→async function getAlignmentOptions() {
   381→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/alignment-options`, {
   382→    headers: getAuthHeaders()
   383→  });
   384→
   385→  if (!response.ok) {
   386→    return {
   387→      fadeDuration: { default: 2, min: 0.5, max: 5 },
   388→      searchWindow: { default: 3, min: 0.5, max: 10 },
   389→      minAudioDuration: 5
   390→    };
   391→  }
   392→
   393→  return response.json();
   394→}
   395→
   396→// ============================================
   397→// TIMELINE API FUNCTIONS
   398→// ============================================
   399→
   400→/**
   401→ * Generate timeline music with per-chapter mood matching
   402→ * @param {Object} transcript - Full transcript with segments
   403→ * @param {Object} options - Generation options
   404→ * @returns {Promise<Object>} Timeline generation result
   405→ */
   406→async function generateTimelineRequest(transcript, options = {}) {
   407→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-timeline`, {
   408→    method: 'POST',
   409→    headers: {
   410→      ...getAuthHeaders(),
   411→      'Content-Type': 'application/json'
   412→    },
   413→    body: JSON.stringify({
   414→      transcript,
   415→      maxChapters: options.maxChapters || 10,
   416→      minChapterLength: options.minChapterLength || 60,
   417→      crossfadeDuration: options.crossfadeDuration || 2,
   418→      instruments: options.instruments || [],
   419→      prompt: options.prompt || ''
   420→    })
   421→  }, 600000); // 10 minute timeout for timeline generation
   422→
   423→  if (!response.ok) {
   424→    const error = await parseErrorResponse(response);
   425→    throw new Error(error.message || 'Failed to generate timeline music');
   426→  }
   427→
   428→  return response.json();
   429→}
   430→
   431→/**
   432→ * Get timeline generation options
   433→ * @returns {Promise<Object>} Timeline options
   434→ */
   435→async function getTimelineOptions() {
   436→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/timeline-options`, {
   437→    headers: getAuthHeaders()
   438→  });
   439→
   440→  if (!response.ok) {
   441→    return {
   442→      defaults: {
   443→        maxChapters: 10,
   444→        minChapterLength: 60,
   445→        crossfadeDuration: 2
   446→      },
   447→      constraints: {
   448→        minCrossfadeDuration: 0.5,
   449→        maxCrossfadeDuration: 5
   450→      }
   451→    };
   452→  }
   453→
   454→  return response.json();
   455→}
   456→
   457→/**
   458→ * Estimate timeline generation time
   459→ * @param {Object} transcript - Transcript with duration
   460→ * @param {Object} options - Options
   461→ * @returns {Promise<Object>} Estimate
   462→ */
   463→async function estimateTimelineRequest(transcript, options = {}) {
   464→  const response = await fetchWithTimeout(`${getBackendUrl()}/music/timeline-estimate`, {
   465→    method: 'POST',
   466→    headers: {
   467→      ...getAuthHeaders(),
   468→      'Content-Type': 'application/json'
   469→    },
   470→    body: JSON.stringify({
   471→      transcript,
   472→      maxChapters: options.maxChapters,
   473→      minChapterLength: options.minChapterLength
   474→    })
   475→  });
   476→
   477→  if (!response.ok) {
   478→    return {
   479→      estimatedChapters: 3,
   480→      estimatedMinutes: 12,
   481→      estimatedTimeDisplay: '10-15 minutes'
   482→    };
   483→  }
   484→
   485→  return response.json();
   486→}
   487→
   488→/**
   489→ * Get current transcript from main workflow
   490→ * @returns {Object|null} Full transcript object or null
   491→ */
   492→function getCurrentTranscript() {
   493→  // Check if full transcript is available from main workflow
   494→  if (window.currentTranscript) {
   495→    return window.currentTranscript;
   496→  }
   497→  return null;
   498→}
   499→
   500→/**
   501→ * Get current sequence duration from Premiere Pro
   502→ * @returns {Promise<number|null>} Duration in seconds or null
   503→ */
   504→async function getSequenceDuration() {
   505→  try {
   506→    const pproBuilder = require('premierepro').pproBuilder;
   507→    const sequence = await pproBuilder.Sequence.getActiveSequence();
   508→    if (sequence) {
   509→      const duration = await sequence.getOutPoint();
   510→      return duration.seconds || null;
   511→    }
   512→  } catch (error) {
   513→    console.error('Could not get sequence duration:', error);
   514→  }
   515→  return null;
   516→}
   517→
   518→// ============================================
   519→// UI FUNCTIONS
   520→// ============================================
   521→
   522→/**
   523→ * Initialize music module
   524→ */
   525→function initMusicModule() {
   526→  // Set up event listeners
   527→  setupMusicEventListeners();
   528→
   529→  // Populate dropdowns
   530→  populateMoodDropdown();
   531→  populateInstrumentDropdown();
   532→  populateDurationDropdown();
   533→
   534→  // Load library on init
   535→  loadMusicLibrary();
   536→
   537→  // Update credits display
   538→  updateMusicCreditsDisplay();
   539→}
   540→
   541→/**
   542→ * Set up event listeners for music UI
   543→ */
   544→function setupMusicEventListeners() {
   545→  // YouTube URL input
   546→  const urlInput = document.getElementById('musicYoutubeUrl');
   547→  if (urlInput) {
   548→    urlInput.addEventListener('input', debounce(handleYoutubeUrlChange, 500));
   549→  }
   550→
   551→  // Identify button
   552→  const identifyBtn = document.getElementById('musicIdentifyBtn');
   553→  if (identifyBtn) {
   554→    identifyBtn.addEventListener('click', handleIdentifySong);
   555→  }
   556→
   557→  // Generate button
   558→  const generateBtn = document.getElementById('musicGenerateBtn');
   559→  if (generateBtn) {
   560→    generateBtn.addEventListener('click', handleGenerateMusic);
   561→  }
   562→
   563→  // Generate Variations button
   564→  const variationsBtn = document.getElementById('musicGenerateVariationsBtn');
   565→  if (variationsBtn) {
   566→    variationsBtn.addEventListener('click', handleGenerateVariations);
   567→  }
   568→
   569→  // Scene-aware toggle
   570→  const sceneAwareToggle = document.getElementById('musicSceneAwareToggle');
   571→  if (sceneAwareToggle) {
   572→    sceneAwareToggle.addEventListener('change', handleSceneAwareToggle);
   573→  }
   574→
   575→  // Clear reference button
   576→  const clearRefBtn = document.getElementById('musicClearRefBtn');
   577→  if (clearRefBtn) {
   578→    clearRefBtn.addEventListener('click', handleClearReference);
   579→  }
   580→
   581→  // Library refresh
   582→  const refreshBtn = document.getElementById('musicRefreshLibraryBtn');
   583→  if (refreshBtn) {
   584→    refreshBtn.addEventListener('click', loadMusicLibrary);
   585→  }
   586→
   587→  // Timeline generation button
   588→  const timelineBtn = document.getElementById('musicGenerateTimelineBtn');
   589→  if (timelineBtn) {
   590→    timelineBtn.addEventListener('click', showTimelineModal);
   591→  }
   592→
   593→  // Update scene-aware availability on init
   594→  updateSceneAwareAvailability();
   595→
   596→  // Update timeline availability on init
   597→  updateTimelineAvailability();
   598→}
   599→
   600→/**
   601→ * Handle scene-aware toggle change
   602→ */
   603→function handleSceneAwareToggle() {
   604→  const toggle = document.getElementById('musicSceneAwareToggle');
   605→  musicState.sceneAwareEnabled = toggle?.checked || false;
   606→
   607→  // Show/hide the scene-aware indicator
   608→  const indicator = document.getElementById('sceneAwareIndicator');
   609→  if (indicator) {
   610→    indicator.style.display = musicState.sceneAwareEnabled ? 'block' : 'none';
   611→  }
   612→
   613→  // Update status
   614→  if (musicState.sceneAwareEnabled) {
   615→    const segments = getCurrentTranscriptSegments();
   616→    if (segments) {
   617→      setMusicStatus(`Scene-aware enabled: ${segments.length} segments detected`, 'info');
   618→    } else {
   619→      setMusicStatus('Scene-aware enabled: Run transcription first for best results', 'warning');
   620→    }
   621→  }
   622→}
   623→
   624→/**
   625→ * Update scene-aware toggle availability based on transcript presence
   626→ */
   627→function updateSceneAwareAvailability() {
   628→  const toggle = document.getElementById('musicSceneAwareToggle');
   629→  const segments = getCurrentTranscriptSegments();
   630→
   631→  if (toggle) {
   632→    // Enable toggle if transcript is available
   633→    toggle.disabled = !segments;
   634→
   635→    // Update label to show availability
   636→    const label = toggle.closest('label') || toggle.parentElement;
   637→    if (label) {
   638→      const statusSpan = label.querySelector('.scene-aware-status');
   639→      if (statusSpan) {
   640→        statusSpan.textContent = segments
   641→          ? `(${segments.length} segments available)`
   642→          : '(run transcription first)';
   643→      }
   644→    }
   645→  }
   646→}
   647→
   648→/**
   649→ * Populate mood dropdown
   650→ */
   651→function populateMoodDropdown() {
   652→  const select = document.getElementById('musicMood');
   653→  if (!select) return;
   654→
   655→  select.innerHTML = MOOD_OPTIONS.map(mood =>
   656→    `<option value="${mood.id}" title="${mood.description}">${mood.name}</option>`
   657→  ).join('');
   658→}
   659→
   660→/**
   661→ * Populate instrument dropdown
   662→ */
   663→function populateInstrumentDropdown() {
   664→  const select = document.getElementById('musicInstruments');
   665→  if (!select) return;
   666→
   667→  select.innerHTML = INSTRUMENT_OPTIONS.map(inst =>
   668→    `<option value="${inst.id}" title="${inst.description}">${inst.name}</option>`
   669→  ).join('');
   670→}
   671→
   672→/**
   673→ * Populate duration dropdown
   674→ */
   675→function populateDurationDropdown() {
   676→  const select = document.getElementById('musicDuration');
   677→  if (!select) return;
   678→
   679→  select.innerHTML = DURATION_OPTIONS.map(dur =>
   680→    `<option value="${dur.value}">${dur.label}</option>`
   681→  ).join('');
   682→
   683→  // Default to 60 seconds
   684→  select.value = '60';
   685→}
   686→
   687→/**
   688→ * Handle YouTube URL change
   689→ */
   690→function handleYoutubeUrlChange() {
   691→  const urlInput = document.getElementById('musicYoutubeUrl');
   692→  const identifyBtn = document.getElementById('musicIdentifyBtn');
   693→
   694→  if (!urlInput || !identifyBtn) return;
   695→
   696→  const url = urlInput.value.trim();
   697→  const isValidUrl = isValidYouTubeUrl(url);
   698→
   699→  identifyBtn.disabled = !isValidUrl;
   700→
   701→  // Clear previous identification if URL changed
   702→  if (musicState.identifiedSong) {
   703→    handleClearReference();
   704→  }
   705→}
   706→
   707→/**
   708→ * Validate YouTube URL
   709→ * @param {string} url - URL to validate
   710→ * @returns {boolean} Is valid
   711→ */
   712→function isValidYouTubeUrl(url) {
   713→  if (!url) return false;
   714→  const patterns = [
   715→    /youtube\.com\/watch\?v=[\w-]{11}/,
   716→    /youtu\.be\/[\w-]{11}/,
   717→    /youtube\.com\/embed\/[\w-]{11}/
   718→  ];
   719→  return patterns.some(p => p.test(url));
   720→}
   721→
   722→/**
   723→ * Handle identify song button click
   724→ */
   725→async function handleIdentifySong() {
   726→  const urlInput = document.getElementById('musicYoutubeUrl');
   727→  const identifyBtn = document.getElementById('musicIdentifyBtn');
   728→  const refDisplay = document.getElementById('musicReferenceDisplay');
   729→
   730→  if (!urlInput || !identifyBtn) return;
   731→
   732→  const url = urlInput.value.trim();
   733→  if (!isValidYouTubeUrl(url)) {
   734→    setMusicStatus('Invalid YouTube URL', 'error');
   735→    return;
   736→  }
   737→
   738→  try {
   739→    musicState.isIdentifying = true;
   740→    identifyBtn.disabled = true;
   741→    identifyBtn.textContent = 'Identifying...';
   742→    setMusicStatus('Identifying song...', 'info');
   743→
   744→    const result = await identifySong(url);
   745→
   746→    if (result.identified) {
   747→      musicState.identifiedSong = result;
   748→      displayIdentifiedSong(result);
   749→      setMusicStatus(`Identified: ${result.title} by ${result.artist}`, 'success');
   750→    } else {
   751→      setMusicStatus('Could not identify song. You can still generate music.', 'warning');
   752→    }
   753→
   754→  } catch (error) {
   755→    console.error('Identification error:', error);
   756→    setMusicStatus(`Error: ${error.message}`, 'error');
   757→  } finally {
   758→    musicState.isIdentifying = false;
   759→    identifyBtn.disabled = false;
   760→    identifyBtn.textContent = 'Identify';
   761→  }
   762→}
   763→
   764→/**
   765→ * Display identified song info
   766→ * @param {Object} song - Song info
   767→ */
   768→function displayIdentifiedSong(song) {
   769→  const display = document.getElementById('musicReferenceDisplay');
   770→  if (!display) return;
   771→
   772→  const details = [];
   773→  if (song.bpm) details.push(`${song.bpm} BPM`);
   774→  if (song.key) details.push(song.key);
   775→  if (song.mood) details.push(song.mood);
   776→
   777→  display.innerHTML = `
   778→    <div class="music-reference-card">
   779→      <div class="music-ref-title">${escapeHtml(song.title)}</div>
   780→      <div class="music-ref-artist">${escapeHtml(song.artist)}</div>
   781→      <div class="music-ref-details">${details.join(' • ')}</div>
   782→      <button id="musicClearRefBtn" class="music-clear-ref-btn" title="Clear reference">×</button>
   783→    </div>
   784→  `;
   785→
   786→  display.style.display = 'block';
   787→
   788→  // Re-attach clear button listener
   789→  const clearBtn = document.getElementById('musicClearRefBtn');
   790→  if (clearBtn) {
   791→    clearBtn.addEventListener('click', handleClearReference);
   792→  }
   793→}
   794→
   795→/**
   796→ * Clear reference song
   797→ */
   798→function handleClearReference() {
   799→  musicState.identifiedSong = null;
   800→
   801→  const display = document.getElementById('musicReferenceDisplay');
   802→  if (display) {
   803→    display.innerHTML = '';
   804→    display.style.display = 'none';
   805→  }
   806→
   807→  const urlInput = document.getElementById('musicYoutubeUrl');
   808→  if (urlInput) {
   809→    urlInput.value = '';
   810→  }
   811→
   812→  const identifyBtn = document.getElementById('musicIdentifyBtn');
   813→  if (identifyBtn) {
   814→    identifyBtn.disabled = true;
   815→  }
   816→}
   817→
   818→/**
   819→ * Handle generate music button click
   820→ */
   821→async function handleGenerateMusic() {
   822→  const generateBtn = document.getElementById('musicGenerateBtn');
   823→  const moodSelect = document.getElementById('musicMood');
   824→  const instrumentSelect = document.getElementById('musicInstruments');
   825→  const durationSelect = document.getElementById('musicDuration');
   826→  const promptInput = document.getElementById('musicPrompt');
   827→
   828→  if (!generateBtn) return;
   829→
   830→  try {
   831→    musicState.isGenerating = true;
   832→    generateBtn.disabled = true;
   833→    generateBtn.textContent = 'Starting...';
   834→
   835→    const options = {
   836→      mood: moodSelect?.value || 'neutral',
   837→      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
   838→      duration: parseInt(durationSelect?.value) || 60,
   839→      prompt: promptInput?.value || '',
   840→      youtubeUrl: musicState.identifiedSong?.sourceUrl || null,
   841→      referenceSong: musicState.identifiedSong || null
   842→    };
   843→
   844→    let result;
   845→
   846→    // Check if scene-aware is enabled and transcript is available
   847→    if (musicState.sceneAwareEnabled) {
   848→      const segments = getCurrentTranscriptSegments();
   849→      if (segments && segments.length > 0) {
   850→        setMusicStatus('Analyzing transcript and generating scene-aware music...', 'info');
   851→        result = await generateSceneAwareRequest(options, segments);
   852→        setMusicStatus(`Scene-aware generation started! Job ID: ${result.jobId}`, 'success');
   853→      } else {
   854→        // Fallback to regular generation if no transcript
   855→        setMusicStatus('No transcript available, using regular generation...', 'warning');
   856→        result = await generateMusicRequest(options);
   857→        setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
   858→      }
   859→    } else {
   860→      setMusicStatus('Submitting generation request...', 'info');
   861→      result = await generateMusicRequest(options);
   862→      setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
   863→    }
   864→
   865→    // Add to jobs list and start polling
   866→    addJobToList(result.jobId, options, result.isSceneAware);
   867→    startPollingJob(result.jobId);
   868→
   869→    // Clear form
   870→    handleClearReference();
   871→    if (promptInput) promptInput.value = '';
   872→
   873→  } catch (error) {
   874→    console.error('Generation error:', error);
   875→    setMusicStatus(`Error: ${error.message}`, 'error');
   876→  } finally {
   877→    musicState.isGenerating = false;
   878→    generateBtn.disabled = false;
   879→    generateBtn.textContent = 'Generate Music';
   880→  }
   881→}
   882→
   883→/**
   884→ * Handle generate variations button click
   885→ */
   886→async function handleGenerateVariations() {
   887→  const generateBtn = document.getElementById('musicGenerateVariationsBtn');
   888→  const moodSelect = document.getElementById('musicMood');
   889→  const instrumentSelect = document.getElementById('musicInstruments');
   890→  const durationSelect = document.getElementById('musicDuration');
   891→  const promptInput = document.getElementById('musicPrompt');
   892→
   893→  if (!generateBtn) return;
   894→
   895→  try {
   896→    musicState.isGenerating = true;
   897→    generateBtn.disabled = true;
   898→    generateBtn.textContent = 'Starting...';
   899→    setMusicStatus('Generating 3 variations... This may take 5-8 minutes.', 'info');
   900→
   901→    const options = {
   902→      mood: moodSelect?.value || 'neutral',
   903→      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
   904→      duration: parseInt(durationSelect?.value) || 60,
   905→      prompt: promptInput?.value || '',
   906→      referenceSong: musicState.identifiedSong || null
   907→    };
   908→
   909→    const result = await generateVariationsRequest(options);
   910→
   911→    setMusicStatus(`Variations generation started! Job ID: ${result.jobId}`, 'success');
   912→
   913→    // Store variations job and start polling
   914→    musicState.variationsJob = {
   915→      jobId: result.jobId,
   916→      status: 'pending',
   917→      options
   918→    };
   919→
   920→    startPollingVariations(result.jobId);
   921→
   922→    // Show variations panel
   923→    showVariationsPanel();
   924→
   925→    // Clear form
   926→    handleClearReference();
   927→    if (promptInput) promptInput.value = '';
   928→
   929→  } catch (error) {
   930→    console.error('Variations error:', error);
   931→    setMusicStatus(`Error: ${error.message}`, 'error');
   932→  } finally {
   933→    musicState.isGenerating = false;
   934→    generateBtn.disabled = false;
   935→    generateBtn.textContent = 'Generate 3 Variations';
   936→  }
   937→}
   938→
   939→/**
   940→ * Start polling for variations job completion
   941→ * @param {string} jobId - Job ID
   942→ */
   943→function startPollingVariations(jobId) {
   944→  // Clear any existing poll
   945→  if (musicState.variationsPollingInterval) {
   946→    clearInterval(musicState.variationsPollingInterval);
   947→  }
   948→
   949→  musicState.variationsPollingInterval = setInterval(async () => {
   950→    try {
   951→      const status = await getVariationsStatus(jobId);
   952→
   953→      // Update variations job state
   954→      musicState.variationsJob = {
   955→        ...musicState.variationsJob,
   956→        ...status
   957→      };
   958→
   959→      // Update UI
   960→      renderVariationsProgress(status);
   961→
   962→      // Check if ready for selection or failed
   963→      if (status.status === 'selecting' || status.status === 'completed') {
   964→        clearInterval(musicState.variationsPollingInterval);
   965→        musicState.variationsPollingInterval = null;
   966→
   967→        if (status.variations && status.variations.length > 0) {
   968→          setMusicStatus('Variations ready! Select your favorite.', 'success');
   969→          renderVariationsSelection(status.variations);
   970→        }
   971→      } else if (status.status === 'failed') {
   972→        clearInterval(musicState.variationsPollingInterval);
   973→        musicState.variationsPollingInterval = null;
   974→        setMusicStatus(`Variations failed: ${status.failedReason || 'Unknown error'}`, 'error');
   975→      }
   976→
   977→    } catch (error) {
   978→      console.error('Variations polling error:', error);
   979→    }
   980→  }, MUSIC_POLL_INTERVAL);
   981→}
   982→
   983→/**
   984→ * Show variations panel
   985→ */
   986→function showVariationsPanel() {
   987→  const panel = document.getElementById('variationsPanel');
   988→  if (panel) {
   989→    panel.style.display = 'block';
   990→    panel.innerHTML = `
   991→      <div class="variations-header">
   992→        <h4>Generating 3 Variations</h4>
   993→        <button id="variationsCancelBtn" class="variations-cancel-btn" title="Cancel">×</button>
   994→      </div>
   995→      <div class="variations-progress">
   996→        <div class="variation-progress-item" data-index="0">
   997→          <span class="variation-name">Version A</span>
   998→          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
   999→          <span class="progress-text">0%</span>
  1000→        </div>
  1001→        <div class="variation-progress-item" data-index="1">
  1002→          <span class="variation-name">Version B</span>
  1003→          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
  1004→          <span class="progress-text">0%</span>
  1005→        </div>
  1006→        <div class="variation-progress-item" data-index="2">
  1007→          <span class="variation-name">Version C</span>
  1008→          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
  1009→          <span class="progress-text">0%</span>
  1010→        </div>
  1011→      </div>
  1012→      <div id="variationsSelection" class="variations-selection" style="display: none;"></div>
  1013→    `;
  1014→
  1015→    // Add cancel button listener
  1016→    const cancelBtn = document.getElementById('variationsCancelBtn');
  1017→    if (cancelBtn) {
  1018→      cancelBtn.addEventListener('click', hideVariationsPanel);
  1019→    }
  1020→  }
  1021→}
  1022→
  1023→/**
  1024→ * Hide variations panel
  1025→ */
  1026→function hideVariationsPanel() {
  1027→  const panel = document.getElementById('variationsPanel');
  1028→  if (panel) {
  1029→    panel.style.display = 'none';
  1030→    panel.innerHTML = '';
  1031→  }
  1032→
  1033→  // Stop polling
  1034→  if (musicState.variationsPollingInterval) {
  1035→    clearInterval(musicState.variationsPollingInterval);
  1036→    musicState.variationsPollingInterval = null;
  1037→  }
  1038→
  1039→  // Stop all variation audio players
  1040→  musicState.variationPlayers.forEach(player => {
  1041→    if (player) {
  1042→      player.pause();
  1043→      player.src = '';
  1044→    }
  1045→  });
  1046→  musicState.variationPlayers = [null, null, null];
  1047→  musicState.variationsJob = null;
  1048→  musicState.selectedVariationIndex = null;
  1049→}
  1050→
  1051→/**
  1052→ * Render variations progress
  1053→ * @param {Object} status - Variations job status
  1054→ */
  1055→function renderVariationsProgress(status) {
  1056→  const progressItems = document.querySelectorAll('.variation-progress-item');
  1057→  const variationProgress = status.variationProgress || [0, 0, 0];
  1058→
  1059→  progressItems.forEach((item, index) => {
  1060→    const progress = variationProgress[index] || 0;
  1061→    const fill = item.querySelector('.progress-fill');
  1062→    const text = item.querySelector('.progress-text');
  1063→
  1064→    if (fill) {
  1065→      fill.style.width = `${progress}%`;
  1066→    }
  1067→    if (text) {
  1068→      text.textContent = `${progress}%`;
  1069→    }
  1070→
  1071→    // Add completed class if done
  1072→    if (progress >= 100) {
  1073→      item.classList.add('completed');
  1074→    }
  1075→  });
  1076→}
  1077→
  1078→/**
  1079→ * Render variations selection UI with 3 audio previews
  1080→ * @param {Object[]} variations - Array of variation objects
  1081→ */
  1082→function renderVariationsSelection(variations) {
  1083→  const container = document.getElementById('variationsSelection');
  1084→  if (!container) return;
  1085→
  1086→  // Hide progress, show selection
  1087→  const progressContainer = document.querySelector('.variations-progress');
  1088→  if (progressContainer) {
  1089→    progressContainer.style.display = 'none';
  1090→  }
  1091→
  1092→  container.style.display = 'block';
  1093→  container.innerHTML = `
  1094→    <div class="variations-header">
  1095→      <h4>Select Your Favorite</h4>
  1096→      <p class="variations-subtitle">Preview each variation and choose one to keep</p>
  1097→    </div>
  1098→    <div class="variations-cards">
  1099→      ${variations.map((v, index) => `
  1100→        <div class="variation-card ${v.status === 'failed' ? 'failed' : ''}"
  1101→             data-index="${index}"
  1102→             ${v.status === 'failed' ? 'data-failed="true"' : ''}>
  1103→          <div class="variation-card-header">
  1104→            <span class="variation-name">${escapeHtml(v.variationName)}</span>
  1105→            ${v.status === 'failed' ? '<span class="failed-badge">Failed</span>' : ''}
  1106→          </div>
  1107→          ${v.promptDescription ? `<div class="variation-description">${escapeHtml(v.promptDescription)}</div>` : ''}
  1108→          ${v.status !== 'failed' ? `
  1109→            <div class="variation-player" data-index="${index}">
  1110→              <button class="play-btn" data-action="play" data-index="${index}" data-url="${v.previewUrl || ''}">
  1111→                ▶
  1112→              </button>
  1113→              <div class="waveform-placeholder"></div>
  1114→              <span class="duration">${v.duration ? `${v.duration}s` : '--'}</span>
  1115→            </div>
  1116→            <button class="select-variation-btn" data-index="${index}">
  1117→              Select This Version
  1118→            </button>
  1119→          ` : `
  1120→            <div class="variation-error">${escapeHtml(v.error || 'Generation failed')}</div>
  1121→          `}
  1122→        </div>
  1123→      `).join('')}
  1124→    </div>
  1125→  `;
  1126→
  1127→  // Add event listeners for play buttons
  1128→  container.querySelectorAll('.play-btn').forEach(btn => {
  1129→    btn.addEventListener('click', handleVariationPlay);
  1130→  });
  1131→
  1132→  // Add event listeners for select buttons
  1133→  container.querySelectorAll('.select-variation-btn').forEach(btn => {
  1134→    btn.addEventListener('click', handleVariationSelect);
  1135→  });
  1136→}
  1137→
  1138→/**
  1139→ * Handle variation play button click
  1140→ * @param {Event} event - Click event
  1141→ */
  1142→async function handleVariationPlay(event) {
  1143→  const btn = event.target;
  1144→  const index = parseInt(btn.dataset.index);
  1145→  const url = btn.dataset.url;
  1146→
  1147→  if (!url) {
  1148→    setMusicStatus('No preview available', 'warning');
  1149→    return;
  1150→  }
  1151→
  1152→  // Stop all other variation players
  1153→  musicState.variationPlayers.forEach((player, i) => {
  1154→    if (player && i !== index) {
  1155→      player.pause();
  1156→      const otherBtn = document.querySelector(`.play-btn[data-index="${i}"]`);
  1157→      if (otherBtn) otherBtn.textContent = '▶';
  1158→    }
  1159→  });
  1160→
  1161→  // Create or get player for this variation
  1162→  if (!musicState.variationPlayers[index]) {
  1163→    musicState.variationPlayers[index] = new Audio();
  1164→    musicState.variationPlayers[index].addEventListener('ended', () => {
  1165→      btn.textContent = '▶';
  1166→    });
  1167→  }
  1168→
  1169→  const player = musicState.variationPlayers[index];
  1170→
  1171→  if (player.paused || player.src !== url) {
  1172→    player.src = url;
  1173→    try {
  1174→      await player.play();
  1175→      btn.textContent = '⏸';
  1176→    } catch (error) {
  1177→      console.error('Play error:', error);
  1178→      setMusicStatus('Could not play preview', 'error');
  1179→    }
  1180→  } else {
  1181→    player.pause();
  1182→    btn.textContent = '▶';
  1183→  }
  1184→}
  1185→
  1186→/**
  1187→ * Handle variation selection
  1188→ * @param {Event} event - Click event
  1189→ */
  1190→async function handleVariationSelect(event) {
  1191→  const btn = event.target;
  1192→  const index = parseInt(btn.dataset.index);
  1193→  const jobId = musicState.variationsJob?.jobId;
  1194→
  1195→  if (!jobId) {
  1196→    setMusicStatus('No variations job found', 'error');
  1197→    return;
  1198→  }
  1199→
  1200→  try {
  1201→    // Disable all select buttons
  1202→    document.querySelectorAll('.select-variation-btn').forEach(b => {
  1203→      b.disabled = true;
  1204→    });
  1205→    btn.textContent = 'Selecting...';
  1206→
  1207→    setMusicStatus('Finalizing your selection...', 'info');
  1208→
  1209→    const result = await selectVariation(jobId, index);
  1210→
  1211→    setMusicStatus(`Selected ${result.variationName}! Music added to library.`, 'success');
  1212→
  1213→    // Stop all players
  1214→    musicState.variationPlayers.forEach(player => {
  1215→      if (player) player.pause();
  1216→    });
  1217→
  1218→    // Hide panel and refresh library
  1219→    hideVariationsPanel();
  1220→    loadMusicLibrary();
  1221→    updateMusicCreditsDisplay();
  1222→
  1223→  } catch (error) {
  1224→    console.error('Selection error:', error);
  1225→    setMusicStatus(`Error: ${error.message}`, 'error');
  1226→
  1227→    // Re-enable buttons
  1228→    document.querySelectorAll('.select-variation-btn').forEach(b => {
  1229→      b.disabled = false;
  1230→    });
  1231→    btn.textContent = 'Select This Version';
  1232→  }
  1233→}
  1234→
  1235→/**
  1236→ * Add job to the jobs list
  1237→ * @param {string} jobId - Job ID
  1238→ * @param {Object} options - Job options
  1239→ * @param {boolean} isSceneAware - Whether this is a scene-aware job
  1240→ */
  1241→function addJobToList(jobId, options, isSceneAware = false) {
  1242→  const job = {
  1243→    jobId,
  1244→    status: 'pending',
  1245→    progress: 0,
  1246→    mood: options.mood,
  1247→    duration: options.duration,
  1248→    isSceneAware,
  1249→    createdAt: new Date().toISOString()
  1250→  };
  1251→
  1252→  musicState.jobs.unshift(job);
  1253→  renderJobsList();
  1254→}
  1255→
  1256→/**
  1257→ * Start polling for job completion
  1258→ * @param {string} jobId - Job ID
  1259→ */
  1260→function startPollingJob(jobId) {
  1261→  // Clear any existing poll
  1262→  if (musicState.pollInterval) {
  1263→    clearInterval(musicState.pollInterval);
  1264→  }
  1265→
  1266→  musicState.pollInterval = setInterval(async () => {
  1267→    try {
  1268→      const status = await getJobStatus(jobId);
  1269→
  1270→      // Update job in list
  1271→      const jobIndex = musicState.jobs.findIndex(j => j.jobId === jobId);
  1272→      if (jobIndex !== -1) {
  1273→        musicState.jobs[jobIndex] = {
  1274→          ...musicState.jobs[jobIndex],
  1275→          ...status
  1276→        };
  1277→        renderJobsList();
  1278→      }
  1279→
  1280→      // Check if complete or failed
  1281→      if (status.status === 'completed' || status.status === 'failed') {
  1282→        clearInterval(musicState.pollInterval);
  1283→        musicState.pollInterval = null;
  1284→
  1285→        if (status.status === 'completed') {
  1286→          setMusicStatus('Music generation completed!', 'success');
  1287→          loadMusicLibrary(); // Refresh library
  1288→        } else {
  1289→          setMusicStatus(`Generation failed: ${status.failedReason || 'Unknown error'}`, 'error');
  1290→        }
  1291→      }
  1292→
  1293→    } catch (error) {
  1294→      console.error('Polling error:', error);
  1295→    }
  1296→  }, MUSIC_POLL_INTERVAL);
  1297→}
  1298→
  1299→/**
  1300→ * Render jobs list UI
  1301→ */
  1302→function renderJobsList() {
  1303→  const container = document.getElementById('musicJobsList');
  1304→  if (!container) return;
  1305→
  1306→  if (musicState.jobs.length === 0) {
  1307→    container.innerHTML = '<div class="music-empty">No generation jobs yet</div>';
  1308→    return;
  1309→  }
  1310→
  1311→  container.innerHTML = musicState.jobs.map(job => `
  1312→    <div class="music-job-item ${job.status}" data-job-id="${job.jobId}">
  1313→      <div class="music-job-status ${job.status}"></div>
  1314→      <div class="music-job-info">
  1315→        <span class="music-job-mood">${job.mood || 'Music'}${job.isSceneAware ? ' 🎬' : ''}</span>
  1316→        <span class="music-job-duration">${job.duration}s</span>
  1317→      </div>
  1318→      <div class="music-job-progress">
  1319→        ${job.status === 'completed' ? '✓' : job.status === 'failed' ? '✗' : `${job.progress}%`}
  1320→      </div>
  1321→    </div>
  1322→  `).join('');
  1323→}
  1324→
  1325→/**
  1326→ * Load and display music library
  1327→ */
  1328→async function loadMusicLibrary() {
  1329→  const container = document.getElementById('musicLibrary');
  1330→  if (!container) return;
  1331→
  1332→  try {
  1333→    container.innerHTML = '<div class="music-loading">Loading library...</div>';
  1334→
  1335→    const library = await getMusicLibrary();
  1336→
  1337→    if (library.length === 0) {
  1338→      container.innerHTML = '<div class="music-empty">Your music library is empty</div>';
  1339→      return;
  1340→    }
  1341→
  1342→    container.innerHTML = library.map(item => `
  1343→      <div class="music-library-item" data-job-id="${item.jobId}">
  1344→        <div class="music-item-info">
  1345→          <div class="music-item-title">${escapeHtml(item.title || 'Untitled')}</div>
  1346→          <div class="music-item-meta">${item.duration}s • ${item.mood || 'Music'}</div>
  1347→        </div>
  1348→        <div class="music-item-actions">
  1349→          <button class="music-action-btn" data-action="preview" data-job-id="${item.jobId}" title="Preview">▶</button>
  1350→          <button class="music-action-btn" data-action="align" data-job-id="${item.jobId}" title="Align to Video">⚡</button>
  1351→          <button class="music-action-btn" data-action="import" data-job-id="${item.jobId}" title="Import to Timeline">+</button>
  1352→          <button class="music-action-btn danger" data-action="delete" data-job-id="${item.jobId}" title="Delete">×</button>
  1353→        </div>
  1354→      </div>
  1355→    `).join('');
  1356→
  1357→    // Add event listeners
  1358→    container.querySelectorAll('.music-action-btn').forEach(btn => {
  1359→      btn.addEventListener('click', handleLibraryAction);
  1360→    });
  1361→
  1362→  } catch (error) {
  1363→    console.error('Library load error:', error);
  1364→    container.innerHTML = '<div class="music-error">Failed to load library</div>';
  1365→  }
  1366→}
  1367→
  1368→/**
  1369→ * Handle library action (preview, import, delete)
  1370→ * @param {Event} event - Click event
  1371→ */
  1372→async function handleLibraryAction(event) {
  1373→  const btn = event.target;
  1374→  const action = btn.dataset.action;
  1375→  const jobId = btn.dataset.jobId;
  1376→
  1377→  switch (action) {
  1378→    case 'preview':
  1379→      await previewMusic(jobId);
  1380→      break;
  1381→    case 'align':
  1382→      await showAlignmentModal(jobId);
  1383→      break;
  1384→    case 'import':
  1385→      await importMusicToTimeline(jobId);
  1386→      break;
  1387→    case 'delete':
  1388→      await confirmDeleteMusic(jobId);
  1389→      break;
  1390→  }
  1391→}
  1392→
  1393→/**
  1394→ * Preview music file
  1395→ * @param {string} jobId - Job ID
  1396→ */
  1397→async function previewMusic(jobId) {
  1398→  try {
  1399→    setMusicStatus('Loading preview...', 'info');
  1400→
  1401→    const music = await getMusicFile(jobId);
  1402→
  1403→    if (!music.previewUrl && !music.downloadUrl) {
  1404→      setMusicStatus('No preview available', 'warning');
  1405→      return;
  1406→    }
  1407→
  1408→    // Create or update audio player
  1409→    if (!musicState.audioPlayer) {
  1410→      musicState.audioPlayer = new Audio();
  1411→      musicState.audioPlayer.addEventListener('ended', () => {
  1412→        setMusicStatus('Preview finished', 'info');
  1413→      });
  1414→    }
  1415→
  1416→    musicState.audioPlayer.src = music.previewUrl || music.downloadUrl;
  1417→    musicState.audioPlayer.play();
  1418→
  1419→    setMusicStatus('Playing preview...', 'success');
  1420→
  1421→  } catch (error) {
  1422→    console.error('Preview error:', error);
  1423→    setMusicStatus(`Preview error: ${error.message}`, 'error');
  1424→  }
  1425→}
  1426→
  1427→/**
  1428→ * Import music to Premiere Pro timeline
  1429→ * @param {string} jobId - Job ID
  1430→ */
  1431→async function importMusicToTimeline(jobId) {
  1432→  try {
  1433→    setMusicStatus('Downloading music...', 'info');
  1434→
  1435→    const music = await getMusicFile(jobId);
  1436→
  1437→    if (!music.downloadUrl) {
  1438→      setMusicStatus('Download URL not available', 'error');
  1439→      return;
  1440→    }
  1441→
  1442→    setMusicStatus('Importing to timeline...', 'info');
  1443→
  1444→    // Download file
  1445→    const response = await fetch(music.downloadUrl);
  1446→    const blob = await response.blob();
  1447→
  1448→    // Get temp folder access
  1449→    const tempFolder = await getTempFolder();
  1450→    if (!tempFolder) {
  1451→      setMusicStatus('Could not access temp folder', 'error');
  1452→      return;
  1453→    }
  1454→
  1455→    // Save to temp file
  1456→    const fileName = `splice_music_${jobId}.wav`;
  1457→    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
  1458→    const arrayBuffer = await blob.arrayBuffer();
  1459→    await tempFile.write(arrayBuffer);
  1460→
  1461→    // Import to project
  1462→    const pproBuilder = require('premierepro').pproBuilder;
  1463→    const project = await pproBuilder.Project.getActiveProject();
  1464→
  1465→    if (!project) {
  1466→      setMusicStatus('No active project', 'error');
  1467→      return;
  1468→    }
  1469→
  1470→    // Import file
  1471→    const imported = await project.importFiles([tempFile.nativePath]);
  1472→
  1473→    if (imported && imported.length > 0) {
  1474→      setMusicStatus('Music imported to project!', 'success');
  1475→
  1476→      // Optionally insert at playhead
  1477→      const sequence = await pproBuilder.Sequence.getActiveSequence();
  1478→      if (sequence) {
  1479→        // TODO: Insert clip at playhead position
  1480→        setMusicStatus('Music imported and ready to use!', 'success');
  1481→      }
  1482→    } else {
  1483→      setMusicStatus('Import failed', 'error');
  1484→    }
  1485→
  1486→  } catch (error) {
  1487→    console.error('Import error:', error);
  1488→    setMusicStatus(`Import error: ${error.message}`, 'error');
  1489→  }
  1490→}
  1491→
  1492→/**
  1493→ * Confirm and delete music
  1494→ * @param {string} jobId - Job ID
  1495→ */
  1496→async function confirmDeleteMusic(jobId) {
  1497→  const confirmed = await showConfirmModal(
  1498→    'Delete Music',
  1499→    'Are you sure you want to delete this music file?'
  1500→  );
  1501→
  1502→  if (!confirmed) return;
  1503→
  1504→  try {
  1505→    setMusicStatus('Deleting...', 'info');
  1506→    await deleteMusicFile(jobId);
  1507→    setMusicStatus('Music deleted', 'success');
  1508→    loadMusicLibrary();
  1509→  } catch (error) {
  1510→    console.error('Delete error:', error);
  1511→    setMusicStatus(`Delete error: ${error.message}`, 'error');
  1512→  }
  1513→}
  1514→
  1515→// ============================================
  1516→// ALIGNMENT UI FUNCTIONS
  1517→// ============================================
  1518→
  1519→/**
  1520→ * Show alignment modal for a music item
  1521→ * @param {string} jobId - Job ID
  1522→ */
  1523→async function showAlignmentModal(jobId) {
  1524→  try {
  1525→    setMusicStatus('Loading alignment options...', 'info');
  1526→
  1527→    // Get alignment options from backend
  1528→    const options = await getAlignmentOptions();
  1529→    musicState.alignmentOptions = options;
  1530→
  1531→    // Try to get sequence duration
  1532→    const sequenceDuration = await getSequenceDuration();
  1533→
  1534→    // Get beat analysis
  1535→    setMusicStatus('Analyzing beats...', 'info');
  1536→    const beatAnalysis = await analyzeBeatsRequest(jobId);
  1537→    musicState.beatAnalysis = beatAnalysis;
  1538→
  1539→    // Show modal
  1540→    renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration);
  1541→    setMusicStatus('', 'info');
  1542→
  1543→  } catch (error) {
  1544→    console.error('Alignment modal error:', error);
  1545→    setMusicStatus(`Error: ${error.message}`, 'error');
  1546→  }
  1547→}
  1548→
  1549→/**
  1550→ * Render alignment modal UI
  1551→ * @param {string} jobId - Job ID
  1552→ * @param {Object} beatAnalysis - Beat analysis data
  1553→ * @param {Object} options - Alignment options
  1554→ * @param {number|null} sequenceDuration - Sequence duration if available
  1555→ */
  1556→function renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration) {
  1557→  // Create or get modal container
  1558→  let modal = document.getElementById('alignmentModal');
  1559→  if (!modal) {
  1560→    modal = document.createElement('div');
  1561→    modal.id = 'alignmentModal';
  1562→    modal.className = 'modal-overlay';
  1563→    document.body.appendChild(modal);
  1564→  }
  1565→
  1566→  const defaultDuration = sequenceDuration
  1567→    ? Math.round(sequenceDuration)
  1568→    : Math.round(beatAnalysis.duration * 0.8);
  1569→
  1570→  modal.innerHTML = `
  1571→    <div class="modal-content alignment-modal">
  1572→      <div class="modal-header">
  1573→        <h3>Align Music to Video</h3>
  1574→        <button class="modal-close-btn" id="alignmentCloseBtn">×</button>
  1575→      </div>
  1576→      <div class="modal-body">
  1577→        <div class="alignment-info">
  1578→          <div class="alignment-stat">
  1579→            <span class="stat-label">Original Duration:</span>
  1580→            <span class="stat-value">${formatDuration(beatAnalysis.duration)}</span>
  1581→          </div>
  1582→          <div class="alignment-stat">
  1583→            <span class="stat-label">Detected BPM:</span>
  1584→            <span class="stat-value">${beatAnalysis.bpm || 'Unknown'}</span>
  1585→          </div>
  1586→          <div class="alignment-stat">
  1587→            <span class="stat-label">Beat Count:</span>
  1588→            <span class="stat-value">${beatAnalysis.beatCount}</span>
  1589→          </div>
  1590→          ${sequenceDuration ? `
  1591→          <div class="alignment-stat highlight">
  1592→            <span class="stat-label">Sequence Duration:</span>
  1593→            <span class="stat-value">${formatDuration(sequenceDuration)}</span>
  1594→          </div>
  1595→          ` : ''}
  1596→        </div>
  1597→
  1598→        <div class="alignment-form">
  1599→          <div class="form-group">
  1600→            <label for="alignTargetDuration">Target Duration (seconds)</label>
  1601→            <input type="number" id="alignTargetDuration"
  1602→                   value="${defaultDuration}"
  1603→                   min="${options.minAudioDuration}"
  1604→                   max="${Math.ceil(beatAnalysis.duration)}"
  1605→                   step="1">
  1606→            <span class="form-hint">Music will be trimmed at the nearest beat</span>
  1607→          </div>
  1608→
  1609→          <div class="form-group">
  1610→            <label for="alignFadeDuration">Fade Out Duration (seconds)</label>
  1611→            <input type="number" id="alignFadeDuration"
  1612→                   value="${options.fadeDuration.default}"
  1613→                   min="${options.fadeDuration.min}"
  1614→                   max="${options.fadeDuration.max}"
  1615→                   step="0.5">
  1616→          </div>
  1617→
  1618→          <div class="form-group checkbox-group">
  1619→            <label>
  1620→              <input type="checkbox" id="alignBeatAlign" checked>
  1621→              Align to nearest beat (recommended)
  1622→            </label>
  1623→            <span class="form-hint">Ensures clean cut at a musical beat</span>
  1624→          </div>
  1625→
  1626→          ${sequenceDuration ? `
  1627→          <button type="button" id="alignMatchSequenceBtn" class="btn-secondary">
  1628→            Match Sequence Duration (${formatDuration(sequenceDuration)})
  1629→          </button>
  1630→          ` : ''}
  1631→        </div>
  1632→      </div>
  1633→      <div class="modal-footer">
  1634→        <button type="button" id="alignmentCancelBtn" class="btn-secondary">Cancel</button>
  1635→        <button type="button" id="alignmentConfirmBtn" class="btn-primary" data-job-id="${jobId}">
  1636→          Align Music
  1637→        </button>
  1638→      </div>
  1639→    </div>
  1640→  `;
  1641→
  1642→  modal.style.display = 'flex';
  1643→
  1644→  // Event listeners
  1645→  document.getElementById('alignmentCloseBtn').addEventListener('click', hideAlignmentModal);
  1646→  document.getElementById('alignmentCancelBtn').addEventListener('click', hideAlignmentModal);
  1647→  document.getElementById('alignmentConfirmBtn').addEventListener('click', handleAlignmentConfirm);
  1648→
  1649→  if (sequenceDuration) {
  1650→    document.getElementById('alignMatchSequenceBtn').addEventListener('click', () => {
  1651→      document.getElementById('alignTargetDuration').value = Math.round(sequenceDuration);
  1652→    });
  1653→  }
  1654→
  1655→  // Close on overlay click
  1656→  modal.addEventListener('click', (e) => {
  1657→    if (e.target === modal) hideAlignmentModal();
  1658→  });
  1659→}
  1660→
  1661→/**
  1662→ * Hide alignment modal
  1663→ */
  1664→function hideAlignmentModal() {
  1665→  const modal = document.getElementById('alignmentModal');
  1666→  if (modal) {
  1667→    modal.style.display = 'none';
  1668→    modal.innerHTML = '';
  1669→  }
  1670→  musicState.beatAnalysis = null;
  1671→}
  1672→
  1673→/**
  1674→ * Handle alignment confirmation
  1675→ * @param {Event} event - Click event
  1676→ */
  1677→async function handleAlignmentConfirm(event) {
  1678→  const btn = event.target;
  1679→  const jobId = btn.dataset.jobId;
  1680→
  1681→  const targetDuration = parseFloat(document.getElementById('alignTargetDuration').value);
  1682→  const fadeDuration = parseFloat(document.getElementById('alignFadeDuration').value);
  1683→  const beatAlign = document.getElementById('alignBeatAlign').checked;
  1684→
  1685→  if (!targetDuration || targetDuration < 5) {
  1686→    setMusicStatus('Target duration must be at least 5 seconds', 'error');
  1687→    return;
  1688→  }
  1689→
  1690→  try {
  1691→    musicState.isAligning = true;
  1692→    btn.disabled = true;
  1693→    btn.textContent = 'Aligning...';
  1694→    setMusicStatus('Aligning music to video duration...', 'info');
  1695→
  1696→    const result = await alignMusicRequest(jobId, targetDuration, {
  1697→      fadeDuration,
  1698→      beatAlign
  1699→    });
  1700→
  1701→    setMusicStatus(
  1702→      `Aligned! Cut at ${formatDuration(result.actualDuration)} (${result.wasAligned ? 'beat-aligned' : 'exact'})`,
  1703→      'success'
  1704→    );
  1705→
  1706→    // Hide modal
  1707→    hideAlignmentModal();
  1708→
  1709→    // Show download option
  1710→    showAlignedDownload(result);
  1711→
  1712→  } catch (error) {
  1713→    console.error('Alignment error:', error);
  1714→    setMusicStatus(`Alignment failed: ${error.message}`, 'error');
  1715→    btn.disabled = false;
  1716→    btn.textContent = 'Align Music';
  1717→  } finally {
  1718→    musicState.isAligning = false;
  1719→  }
  1720→}
  1721→
  1722→/**
  1723→ * Show aligned music download/import options
  1724→ * @param {Object} result - Alignment result
  1725→ */
  1726→function showAlignedDownload(result) {
  1727→  // Create notification with download option
  1728→  const notification = document.createElement('div');
  1729→  notification.className = 'alignment-notification';
  1730→  notification.innerHTML = `
  1731→    <div class="notification-content">
  1732→      <span class="notification-icon">✓</span>
  1733→      <div class="notification-text">
  1734→        <strong>Music Aligned!</strong>
  1735→        <span>Duration: ${formatDuration(result.actualDuration)}</span>
  1736→      </div>
  1737→      <div class="notification-actions">
  1738→        <button class="btn-small" data-action="import" data-url="${result.downloadUrl}">
  1739→          Import to Timeline
  1740→        </button>
  1741→        <button class="btn-small btn-secondary" data-action="download" data-url="${result.downloadUrl}">
  1742→          Download
  1743→        </button>
  1744→        <button class="btn-close" data-action="close">×</button>
  1745→      </div>
  1746→    </div>
  1747→  `;
  1748→
  1749→  // Add to page
  1750→  const container = document.getElementById('musicSection') || document.body;
  1751→  container.appendChild(notification);
  1752→
  1753→  // Event handlers
  1754→  notification.querySelector('[data-action="import"]').addEventListener('click', async (e) => {
  1755→    await importAlignedMusic(e.target.dataset.url, result.jobId);
  1756→    notification.remove();
  1757→  });
  1758→
  1759→  notification.querySelector('[data-action="download"]').addEventListener('click', (e) => {
  1760→    window.open(e.target.dataset.url, '_blank');
  1761→    notification.remove();
  1762→  });
  1763→
  1764→  notification.querySelector('[data-action="close"]').addEventListener('click', () => {
  1765→    notification.remove();
  1766→  });
  1767→
  1768→  // Auto-remove after 30 seconds
  1769→  setTimeout(() => notification.remove(), 30000);
  1770→}
  1771→
  1772→/**
  1773→ * Import aligned music to timeline
  1774→ * @param {string} downloadUrl - Download URL
  1775→ * @param {string} jobId - Job ID
  1776→ */
  1777→async function importAlignedMusic(downloadUrl, jobId) {
  1778→  try {
  1779→    setMusicStatus('Importing aligned music...', 'info');
  1780→
  1781→    // Download file
  1782→    const response = await fetch(downloadUrl);
  1783→    const blob = await response.blob();
  1784→
  1785→    // Get temp folder
  1786→    const tempFolder = await getTempFolder();
  1787→    if (!tempFolder) {
  1788→      setMusicStatus('Could not access temp folder', 'error');
  1789→      return;
  1790→    }
  1791→
  1792→    // Save to temp file
  1793→    const fileName = `splice_aligned_${jobId}.wav`;
  1794→    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
  1795→    const arrayBuffer = await blob.arrayBuffer();
  1796→    await tempFile.write(arrayBuffer);
  1797→
  1798→    // Import to project
  1799→    const pproBuilder = require('premierepro').pproBuilder;
  1800→    const project = await pproBuilder.Project.getActiveProject();
  1801→
  1802→    if (!project) {
  1803→      setMusicStatus('No active project', 'error');
  1804→      return;
  1805→    }
  1806→
  1807→    const imported = await project.importFiles([tempFile.nativePath]);
  1808→
  1809→    if (imported && imported.length > 0) {
  1810→      setMusicStatus('Aligned music imported to project!', 'success');
  1811→    } else {
  1812→      setMusicStatus('Import failed', 'error');
  1813→    }
  1814→
  1815→  } catch (error) {
  1816→    console.error('Import error:', error);
  1817→    setMusicStatus(`Import error: ${error.message}`, 'error');
  1818→  }
  1819→}
  1820→
  1821→// ============================================
  1822→// TIMELINE UI FUNCTIONS
  1823→// ============================================
  1824→
  1825→/**
  1826→ * Update timeline button availability
  1827→ */
  1828→function updateTimelineAvailability() {
  1829→  const btn = document.getElementById('musicGenerateTimelineBtn');
  1830→  const transcript = getCurrentTranscript();
  1831→
  1832→  if (btn) {
  1833→    btn.disabled = !transcript || !transcript.segments || transcript.segments.length === 0;
  1834→
  1835→    // Update tooltip
  1836→    if (!transcript) {
  1837→      btn.title = 'Run transcription first to enable mood timeline';
  1838→    } else if (!transcript.segments || transcript.segments.length === 0) {
  1839→      btn.title = 'No transcript segments available';
  1840→    } else {
  1841→      btn.title = 'Generate per-chapter music with mood matching';
  1842→    }
  1843→  }
  1844→}
  1845→
  1846→/**
  1847→ * Show timeline generation modal
  1848→ */
  1849→async function showTimelineModal() {
  1850→  const transcript = getCurrentTranscript();
  1851→
  1852→  if (!transcript) {
  1853→    setMusicStatus('Run transcription first to generate mood timeline', 'error');
  1854→    return;
  1855→  }
  1856→
  1857→  try {
  1858→    setMusicStatus('Loading timeline options...', 'info');
  1859→
  1860→    // Get timeline options
  1861→    const options = await getTimelineOptions();
  1862→    musicState.timelineOptions = options;
  1863→
  1864→    // Get estimate
  1865→    const estimate = await estimateTimelineRequest(transcript);
  1866→
  1867→    // Render modal
  1868→    renderTimelineModal(transcript, options, estimate);
  1869→    setMusicStatus('', 'info');
  1870→
  1871→  } catch (error) {
  1872→    console.error('Timeline modal error:', error);
  1873→    setMusicStatus(`Error: ${error.message}`, 'error');
  1874→  }
  1875→}
  1876→
  1877→/**
  1878→ * Render timeline generation modal
  1879→ * @param {Object} transcript - Transcript object
  1880→ * @param {Object} options - Timeline options
  1881→ * @param {Object} estimate - Time estimate
  1882→ */
  1883→function renderTimelineModal(transcript, options, estimate) {
  1884→  let modal = document.getElementById('timelineModal');
  1885→  if (!modal) {
  1886→    modal = document.createElement('div');
  1887→    modal.id = 'timelineModal';
  1888→    modal.className = 'modal-overlay';
  1889→    document.body.appendChild(modal);
  1890→  }
  1891→
  1892→  const defaults = options.defaults || {};
  1893→  const constraints = options.constraints || {};
  1894→
  1895→  modal.innerHTML = `
  1896→    <div class="modal-content timeline-modal">
  1897→      <div class="modal-header">
  1898→        <h3>Generate Mood Timeline</h3>
  1899→        <button class="modal-close-btn" id="timelineCloseBtn">×</button>
  1900→      </div>
  1901→      <div class="modal-body">
  1902→        <div class="timeline-info">
  1903→          <div class="timeline-stat">
  1904→            <span class="stat-label">Video Duration:</span>
  1905→            <span class="stat-value">${formatDuration(transcript.duration)}</span>
  1906→          </div>
  1907→          <div class="timeline-stat">
  1908→            <span class="stat-label">Transcript Segments:</span>
  1909→            <span class="stat-value">${transcript.segments?.length || 0}</span>
  1910→          </div>
  1911→          <div class="timeline-stat highlight">
  1912→            <span class="stat-label">Estimated Chapters:</span>
  1913→            <span class="stat-value">${estimate.estimatedChapters}</span>
  1914→          </div>
  1915→          <div class="timeline-stat highlight">
  1916→            <span class="stat-label">Estimated Time:</span>
  1917→            <span class="stat-value">${estimate.estimatedTimeDisplay}</span>
  1918→          </div>
  1919→        </div>
  1920→
  1921→        <div class="timeline-description">
  1922→          <p>This will analyze your video transcript to detect chapters and their emotional tone,
  1923→          then generate unique music for each chapter with crossfades between them.</p>
  1924→          <p><strong>Cost:</strong> 3 music credits</p>
  1925→        </div>
  1926→
  1927→        <div class="timeline-form">
  1928→          <div class="form-group">
  1929→            <label for="timelineMaxChapters">Maximum Chapters</label>
  1930→            <input type="number" id="timelineMaxChapters"
  1931→                   value="${defaults.maxChapters || 10}"
  1932→                   min="1" max="20" step="1">
  1933→            <span class="form-hint">More chapters = more varied music segments</span>
  1934→          </div>
  1935→
  1936→          <div class="form-group">
  1937→            <label for="timelineMinLength">Minimum Chapter Length (seconds)</label>
  1938→            <input type="number" id="timelineMinLength"
  1939→                   value="${defaults.minChapterLength || 60}"
  1940→                   min="30" max="300" step="10">
  1941→            <span class="form-hint">Chapters shorter than this will be merged</span>
  1942→          </div>
  1943→
  1944→          <div class="form-group">
  1945→            <label for="timelineCrossfade">Crossfade Duration (seconds)</label>
  1946→            <input type="number" id="timelineCrossfade"
  1947→                   value="${defaults.crossfadeDuration || 2}"
  1948→                   min="${constraints.minCrossfadeDuration || 0.5}"
  1949→                   max="${constraints.maxCrossfadeDuration || 5}"
  1950→                   step="0.5">
  1951→            <span class="form-hint">Smooth transition between music segments</span>
  1952→          </div>
  1953→
  1954→          <div class="form-group">
  1955→            <label for="timelineInstruments">Instrument Style</label>
  1956→            <select id="timelineInstruments">
  1957→              <option value="">Auto-detect from content</option>
  1958→              ${INSTRUMENT_OPTIONS.map(i => `<option value="${i.id}">${i.name} - ${i.description}</option>`).join('')}
  1959→            </select>
  1960→          </div>
  1961→
  1962→          <div class="form-group">
  1963→            <label for="timelinePrompt">Additional Instructions (optional)</label>
  1964→            <textarea id="timelinePrompt" rows="2" placeholder="E.g., 'Modern electronic feel' or 'Keep energy consistent'"></textarea>
  1965→          </div>
  1966→        </div>
  1967→      </div>
  1968→      <div class="modal-footer">
  1969→        <button type="button" id="timelineCancelBtn" class="btn-secondary">Cancel</button>
  1970→        <button type="button" id="timelineConfirmBtn" class="btn-primary">
  1971→          Generate Timeline Music (3 credits)
  1972→        </button>
  1973→      </div>
  1974→    </div>
  1975→  `;
  1976→
  1977→  modal.style.display = 'flex';
  1978→
  1979→  // Event listeners
  1980→  document.getElementById('timelineCloseBtn').addEventListener('click', hideTimelineModal);
  1981→  document.getElementById('timelineCancelBtn').addEventListener('click', hideTimelineModal);
  1982→  document.getElementById('timelineConfirmBtn').addEventListener('click', handleTimelineConfirm);
  1983→
  1984→  // Close on overlay click
  1985→  modal.addEventListener('click', (e) => {
  1986→    if (e.target === modal) hideTimelineModal();
  1987→  });
  1988→}
  1989→
  1990→/**
  1991→ * Hide timeline modal
  1992→ */
  1993→function hideTimelineModal() {
  1994→  const modal = document.getElementById('timelineModal');
  1995→  if (modal) {
  1996→    modal.style.display = 'none';
  1997→    modal.innerHTML = '';
  1998→  }
  1999→}
  2000→
  2001→/**
  2002→ * Handle timeline generation confirmation
  2003→ */
  2004→async function handleTimelineConfirm() {
  2005→  const transcript = getCurrentTranscript();
  2006→  if (!transcript) {
  2007→    setMusicStatus('Transcript not available', 'error');
  2008→    return;
  2009→  }
  2010→
  2011→  const maxChapters = parseInt(document.getElementById('timelineMaxChapters').value) || 10;
  2012→  const minChapterLength = parseInt(document.getElementById('timelineMinLength').value) || 60;
  2013→  const crossfadeDuration = parseFloat(document.getElementById('timelineCrossfade').value) || 2;
  2014→  const instruments = document.getElementById('timelineInstruments').value;
  2015→  const prompt = document.getElementById('timelinePrompt').value || '';
  2016→
  2017→  const confirmBtn = document.getElementById('timelineConfirmBtn');
  2018→
  2019→  try {
  2020→    musicState.isGeneratingTimeline = true;
  2021→    confirmBtn.disabled = true;
  2022→    confirmBtn.textContent = 'Generating...';
  2023→
  2024→    setMusicStatus('Generating mood timeline... This may take several minutes.', 'info');
  2025→
  2026→    // Hide modal
  2027→    hideTimelineModal();
  2028→
  2029→    // Show progress panel
  2030→    showTimelineProgressPanel();
  2031→
  2032→    // Make the request
  2033→    const result = await generateTimelineRequest(transcript, {
  2034→      maxChapters,
  2035→      minChapterLength,
  2036→      crossfadeDuration,
  2037→      instruments: instruments ? [instruments] : [],
  2038→      prompt
  2039→    });
  2040→
  2041→    // Show success
  2042→    setMusicStatus(`Timeline generated! ${result.chapters?.length || 0} chapters, ${formatDuration(result.duration)}`, 'success');
  2043→
  2044→    // Show download option
  2045→    if (result.audioUrl) {
  2046→      showTimelineResult(result);
  2047→    }
  2048→
  2049→    // Refresh library
  2050→    loadMusicLibrary();
  2051→    updateMusicCreditsDisplay();
  2052→
  2053→  } catch (error) {
  2054→    console.error('Timeline generation error:', error);
  2055→    setMusicStatus(`Timeline generation failed: ${error.message}`, 'error');
  2056→    hideTimelineProgressPanel();
  2057→  } finally {
  2058→    musicState.isGeneratingTimeline = false;
  2059→    if (confirmBtn) {
  2060→      confirmBtn.disabled = false;
  2061→      confirmBtn.textContent = 'Generate Timeline Music (3 credits)';
  2062→    }
  2063→  }
  2064→}
  2065→
  2066→/**
  2067→ * Show timeline progress panel
  2068→ */
  2069→function showTimelineProgressPanel() {
  2070→  let panel = document.getElementById('timelineProgressPanel');
  2071→  if (!panel) {
  2072→    panel = document.createElement('div');
  2073→    panel.id = 'timelineProgressPanel';
  2074→    panel.className = 'timeline-progress-panel';
  2075→
  2076→    const container = document.getElementById('musicSection') || document.body;
  2077→    container.insertBefore(panel, container.firstChild);
  2078→  }
  2079→
  2080→  panel.innerHTML = `
  2081→    <div class="timeline-progress-content">
  2082→      <div class="timeline-progress-header">
  2083→        <span class="progress-icon">🎵</span>
  2084→        <span class="progress-title">Generating Mood Timeline</span>
  2085→      </div>
  2086→      <div class="timeline-progress-steps">
  2087→        <div class="progress-step active">Analyzing chapters...</div>
  2088→        <div class="progress-step">Detecting moods...</div>
  2089→        <div class="progress-step">Generating music...</div>
  2090→        <div class="progress-step">Assembling with crossfades...</div>
  2091→      </div>
  2092→      <div class="timeline-progress-note">
  2093→        This may take 10-15 minutes. You can continue using the plugin.
  2094→      </div>
  2095→    </div>
  2096→  `;
  2097→
  2098→  panel.style.display = 'block';
  2099→}
  2100→
  2101→/**
  2102→ * Hide timeline progress panel
  2103→ */
  2104→function hideTimelineProgressPanel() {
  2105→  const panel = document.getElementById('timelineProgressPanel');
  2106→  if (panel) {
  2107→    panel.style.display = 'none';
  2108→  }
  2109→}
  2110→
  2111→/**
  2112→ * Show timeline generation result
  2113→ * @param {Object} result - Timeline result
  2114→ */
  2115→function showTimelineResult(result) {
  2116→  hideTimelineProgressPanel();
  2117→
  2118→  let resultPanel = document.getElementById('timelineResultPanel');
  2119→  if (!resultPanel) {
  2120→    resultPanel = document.createElement('div');
  2121→    resultPanel.id = 'timelineResultPanel';
  2122→    resultPanel.className = 'timeline-result-panel';
  2123→
  2124→    const container = document.getElementById('musicSection') || document.body;
  2125→    container.insertBefore(resultPanel, container.firstChild);
  2126→  }
  2127→
  2128→  // Build chapter info
  2129→  const chapterList = (result.chapters || []).map((ch, i) => `
  2130→    <div class="timeline-chapter">
  2131→      <span class="chapter-num">${i + 1}</span>
  2132→      <span class="chapter-title">${escapeHtml(ch.title)}</span>
  2133→      <span class="chapter-mood">${ch.mood || 'neutral'}</span>
  2134→      <span class="chapter-status">${ch.musicGenerated ? '✓' : '✗'}</span>
  2135→    </div>
  2136→  `).join('');
  2137→
  2138→  resultPanel.innerHTML = `
  2139→    <div class="timeline-result-content">
  2140→      <div class="timeline-result-header">
  2141→        <span class="result-icon">✓</span>
  2142→        <span class="result-title">Mood Timeline Generated!</span>
  2143→        <button class="close-btn" data-action="close">×</button>
  2144→      </div>
  2145→
  2146→      <div class="timeline-result-stats">
  2147→        <div class="result-stat">
  2148→          <span class="stat-label">Duration:</span>
  2149→          <span class="stat-value">${formatDuration(result.duration)}</span>
  2150→        </div>
  2151→        <div class="result-stat">
  2152→          <span class="stat-label">Chapters:</span>
  2153→          <span class="stat-value">${result.chapters?.length || 0}</span>
  2154→        </div>
  2155→        <div class="result-stat">
  2156→          <span class="stat-label">Credits Used:</span>
  2157→          <span class="stat-value">${result.creditCost || 3}</span>
  2158→        </div>
  2159→      </div>
  2160→
  2161→      <div class="timeline-chapters">
  2162→        <h4>Chapters</h4>
  2163→        ${chapterList}
  2164→      </div>
  2165→
  2166→      <div class="timeline-result-actions">
  2167→        <button class="btn-primary" data-action="import" data-url="${result.audioUrl}">
  2168→          Import to Timeline
  2169→        </button>
  2170→        <button class="btn-secondary" data-action="download" data-url="${result.audioUrl}">
  2171→          Download
  2172→        </button>
  2173→      </div>
  2174→    </div>
  2175→  `;
  2176→
  2177→  resultPanel.style.display = 'block';
  2178→
  2179→  // Event listeners
  2180→  resultPanel.querySelector('[data-action="close"]').addEventListener('click', () => {
  2181→    resultPanel.style.display = 'none';
  2182→  });
  2183→
  2184→  resultPanel.querySelector('[data-action="import"]').addEventListener('click', async (e) => {
  2185→    await importTimelineMusic(e.target.dataset.url);
  2186→    resultPanel.style.display = 'none';
  2187→  });
  2188→
  2189→  resultPanel.querySelector('[data-action="download"]').addEventListener('click', (e) => {
  2190→    window.open(e.target.dataset.url, '_blank');
  2191→  });
  2192→
  2193→  // Auto-hide after 60 seconds
  2194→  setTimeout(() => {
  2195→    if (resultPanel) resultPanel.style.display = 'none';
  2196→  }, 60000);
  2197→}
  2198→
  2199→/**
  2200→ * Import timeline music to project
  2201→ * @param {string} downloadUrl - Download URL
  2202→ */
  2203→async function importTimelineMusic(downloadUrl) {
  2204→  try {
  2205→    setMusicStatus('Importing timeline music...', 'info');
  2206→
  2207→    const response = await fetch(downloadUrl);
  2208→    const blob = await response.blob();
  2209→
  2210→    const tempFolder = await getTempFolder();
  2211→    if (!tempFolder) {
  2212→      setMusicStatus('Could not access temp folder', 'error');
  2213→      return;
  2214→    }
  2215→
  2216→    const fileName = `splice_timeline_${Date.now()}.wav`;
  2217→    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
  2218→    const arrayBuffer = await blob.arrayBuffer();
  2219→    await tempFile.write(arrayBuffer);
  2220→
  2221→    const pproBuilder = require('premierepro').pproBuilder;
  2222→    const project = await pproBuilder.Project.getActiveProject();
  2223→
  2224→    if (!project) {
  2225→      setMusicStatus('No active project', 'error');
  2226→      return;
  2227→    }
  2228→
  2229→    const imported = await project.importFiles([tempFile.nativePath]);
  2230→
  2231→    if (imported && imported.length > 0) {
  2232→      setMusicStatus('Timeline music imported to project!', 'success');
  2233→    } else {
  2234→      setMusicStatus('Import failed', 'error');
  2235→    }
  2236→
  2237→  } catch (error) {
  2238→    console.error('Import error:', error);
  2239→    setMusicStatus(`Import error: ${error.message}`, 'error');
  2240→  }
  2241→}
  2242→
  2243→/**
  2244→ * Format duration in mm:ss format
  2245→ * @param {number} seconds - Duration in seconds
  2246→ * @returns {string} Formatted duration
  2247→ */
  2248→function formatDuration(seconds) {
  2249→  if (!seconds) return '0:00';
  2250→  const mins = Math.floor(seconds / 60);
  2251→  const secs = Math.round(seconds % 60);
  2252→  return `${mins}:${secs.toString().padStart(2, '0')}`;
  2253→}
  2254→
  2255→/**
  2256→ * Update music credits display
  2257→ */
  2258→async function updateMusicCreditsDisplay() {
  2259→  const badge = document.getElementById('musicCreditsBadge');
  2260→  if (!badge) return;
  2261→
  2262→  try {
  2263→    const credits = await getMusicCredits();
  2264→    badge.textContent = `${credits.remaining}/${credits.total} songs`;
  2265→    badge.className = 'music-credits-badge';
  2266→
  2267→    if (credits.remaining === 0) {
  2268→      badge.classList.add('empty');
  2269→    } else if (credits.remaining <= 2) {
  2270→      badge.classList.add('low');
  2271→    }
  2272→  } catch (error) {
  2273→    badge.textContent = 'Credits: --';
  2274→  }
  2275→}
  2276→
  2277→/**
  2278→ * Set music status message
  2279→ * @param {string} message - Status message
  2280→ * @param {string} type - Message type (info, success, warning, error)
  2281→ */
  2282→function setMusicStatus(message, type = 'info') {
  2283→  const status = document.getElementById('musicStatus');
  2284→  if (!status) return;
  2285→
  2286→  status.textContent = message;
  2287→  status.className = `music-status ${type}`;
  2288→  status.style.display = 'block';
  2289→
  2290→  // Auto-hide after delay for non-error messages
  2291→  if (type !== 'error') {
  2292→    setTimeout(() => {
  2293→      status.style.display = 'none';
  2294→    }, 5000);
  2295→  }
  2296→}
  2297→
  2298→/**
  2299→ * Get temp folder for file operations
  2300→ * @returns {Promise<Folder|null>}
  2301→ */
  2302→async function getTempFolder() {
  2303→  try {
  2304→    const uxpFs = require('uxp').storage.localFileSystem;
  2305→    return await uxpFs.getTemporaryFolder();
  2306→  } catch (error) {
  2307→    console.error('Temp folder error:', error);
  2308→    return null;
  2309→  }
  2310→}
  2311→
  2312→/**
  2313→ * Escape HTML special characters
  2314→ * @param {string} str - String to escape
  2315→ * @returns {string} Escaped string
  2316→ */
  2317→function escapeHtml(str) {
  2318→  if (!str) return '';
  2319→  const div = document.createElement('div');
  2320→  div.textContent = str;
  2321→  return div.innerHTML;
  2322→}
  2323→
  2324→/**
  2325→ * Simple debounce function
  2326→ * @param {Function} fn - Function to debounce
  2327→ * @param {number} delay - Delay in ms
  2328→ * @returns {Function} Debounced function
  2329→ */
  2330→function debounce(fn, delay) {
  2331→  let timeoutId;
  2332→  return function (...args) {
  2333→    clearTimeout(timeoutId);
  2334→    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  2335→  };
  2336→}
  2337→
  2338→// Export for use in other modules
  2339→window.musicModule = {
  2340→  init: initMusicModule,
  2341→  identifySong,
  2342→  generateMusicRequest,
  2343→  getMusicLibrary,
  2344→  getMusicCredits,
  2345→  loadMusicLibrary,
  2346→  previewMusic,
  2347→  importMusicToTimeline,
  2348→  // Variations exports
  2349→  generateVariationsRequest,
  2350→  getVariationsStatus,
  2351→  selectVariation,
  2352→  handleGenerateVariations,
  2353→  showVariationsPanel,
  2354→  hideVariationsPanel,
  2355→  // Scene-aware exports
  2356→  generateSceneAwareRequest,
  2357→  getCurrentTranscriptSegments,
  2358→  handleSceneAwareToggle,
  2359→  updateSceneAwareAvailability,
  2360→  // Alignment exports
  2361→  alignMusicRequest,
  2362→  analyzeBeatsRequest,
  2363→  getAlignmentOptions,
  2364→  showAlignmentModal,
  2365→  hideAlignmentModal,
  2366→  formatDuration,
  2367→  getSequenceDuration,
  2368→  // Timeline exports
  2369→  generateTimelineRequest,
  2370→  getTimelineOptions,
  2371→  estimateTimelineRequest,
  2372→  getCurrentTranscript,
  2373→  showTimelineModal,
  2374→  hideTimelineModal,
  2375→  updateTimelineAvailability,
  2376→  importTimelineMusic,
  2377→  MOOD_OPTIONS,
  2378→  INSTRUMENT_OPTIONS,
  2379→  DURATION_OPTIONS
  2380→};
  2381→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
