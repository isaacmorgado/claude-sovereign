     1→/**
     2→ * Cloudflare R2 Storage Service
     3→ * Handles music file uploads and signed URL generation
     4→ */
     5→
     6→const { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, HeadObjectCommand } = require('@aws-sdk/client-s3');
     7→const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
     8→
     9→// Initialize R2 client (lazy initialization)
    10→let s3Client = null;
    11→
    12→function getS3Client() {
    13→  if (!s3Client) {
    14→    // Validate required environment variables
    15→    const requiredEnvVars = ['R2_ACCOUNT_ID', 'R2_ACCESS_KEY_ID', 'R2_SECRET_ACCESS_KEY', 'R2_BUCKET_NAME'];
    16→    const missing = requiredEnvVars.filter(v => !process.env[v]);
    17→
    18→    if (missing.length > 0) {
    19→      throw new Error(`Missing R2 environment variables: ${missing.join(', ')}`);
    20→    }
    21→
    22→    s3Client = new S3Client({
    23→      region: 'auto',
    24→      endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    25→      credentials: {
    26→        accessKeyId: process.env.R2_ACCESS_KEY_ID,
    27→        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY
    28→      }
    29→    });
    30→  }
    31→  return s3Client;
    32→}
    33→
    34→/**
    35→ * Generate storage key for music file
    36→ * @param {string} customerId - Stripe customer ID
    37→ * @param {string} jobId - Music generation job ID
    38→ * @param {string} filename - File name (e.g., 'master.wav', 'preview.mp3')
    39→ * @returns {string} Storage key path
    40→ */
    41→function generateStorageKey(customerId, jobId, filename = 'master.wav') {
    42→  // Sanitize inputs
    43→  const safeCustomerId = customerId.replace(/[^a-zA-Z0-9_-]/g, '');
    44→  const safeJobId = jobId.replace(/[^a-zA-Z0-9_-]/g, '');
    45→  const safeFilename = filename.replace(/[^a-zA-Z0-9._-]/g, '');
    46→
    47→  return `${safeCustomerId}/${safeJobId}/${safeFilename}`;
    48→}
    49→
    50→/**
    51→ * Upload music file to R2
    52→ * @param {Buffer} buffer - File buffer
    53→ * @param {string} key - Storage key (use generateStorageKey)
    54→ * @param {Object} metadata - Optional metadata
    55→ * @returns {Promise<{success: boolean, key: string, size: number}>}
    56→ */
    57→async function uploadMusic(buffer, key, metadata = {}) {
    58→  const client = getS3Client();
    59→
    60→  // Determine content type from key
    61→  let contentType = 'audio/wav';
    62→  if (key.endsWith('.mp3')) contentType = 'audio/mpeg';
    63→  else if (key.endsWith('.json')) contentType = 'application/json';
    64→
    65→  const command = new PutObjectCommand({
    66→    Bucket: process.env.R2_BUCKET_NAME,
    67→    Key: key,
    68→    Body: buffer,
    69→    ContentType: contentType,
    70→    Metadata: {
    71→      ...metadata,
    72→      'uploaded-at': new Date().toISOString()
    73→    }
    74→  });
    75→
    76→  await client.send(command);
    77→
    78→  return {
    79→    success: true,
    80→    key,
    81→    size: buffer.length
    82→  };
    83→}
    84→
    85→/**
    86→ * Upload metadata JSON file
    87→ * @param {string} key - Storage key for metadata file
    88→ * @param {Object} metadata - Metadata object to store
    89→ * @returns {Promise<{success: boolean, key: string}>}
    90→ */
    91→async function uploadMetadata(key, metadata) {
    92→  const buffer = Buffer.from(JSON.stringify(metadata, null, 2));
    93→  return uploadMusic(buffer, key, { type: 'metadata' });
    94→}
    95→
    96→/**
    97→ * Upload buffer to R2 with specified content type
    98→ * @param {string} key - Storage key
    99→ * @param {Buffer} buffer - File buffer
   100→ * @param {string} contentType - Content type (e.g., 'audio/wav')
   101→ * @returns {Promise<{success: boolean, key: string, size: number}>}
   102→ */
   103→async function uploadBuffer(key, buffer, contentType = 'audio/wav') {
   104→  const client = getS3Client();
   105→
   106→  const command = new PutObjectCommand({
   107→    Bucket: process.env.R2_BUCKET_NAME,
   108→    Key: key,
   109→    Body: buffer,
   110→    ContentType: contentType,
   111→    Metadata: {
   112→      'uploaded-at': new Date().toISOString()
   113→    }
   114→  });
   115→
   116→  await client.send(command);
   117→
   118→  return {
   119→    success: true,
   120→    key,
   121→    size: buffer.length
   122→  };
   123→}
   124→
   125→/**
   126→ * Download file from R2 as buffer
   127→ * @param {string} key - Storage key
   128→ * @returns {Promise<Buffer>} File buffer
   129→ */
   130→async function downloadFile(key) {
   131→  const client = getS3Client();
   132→
   133→  const command = new GetObjectCommand({
   134→    Bucket: process.env.R2_BUCKET_NAME,
   135→    Key: key
   136→  });
   137→
   138→  const response = await client.send(command);
   139→
   140→  // Convert stream to buffer
   141→  const chunks = [];
   142→  for await (const chunk of response.Body) {
   143→    chunks.push(chunk);
   144→  }
   145→
   146→  return Buffer.concat(chunks);
   147→}
   148→
   149→/**
   150→ * Get signed download URL for music file
   151→ * @param {string} key - Storage key
   152→ * @param {number} expiresIn - URL expiration in seconds (default 1 hour)
   153→ * @returns {Promise<string>} Signed URL
   154→ */
   155→async function getSignedDownloadUrl(key, expiresIn = 3600) {
   156→  const client = getS3Client();
   157→
   158→  const command = new GetObjectCommand({
   159→    Bucket: process.env.R2_BUCKET_NAME,
   160→    Key: key
   161→  });
   162→
   163→  return getSignedUrl(client, command, { expiresIn });
   164→}
   165→
   166→/**
   167→ * Get signed upload URL (for direct client uploads)
   168→ * @param {string} key - Storage key
   169→ * @param {string} contentType - File content type
   170→ * @param {number} expiresIn - URL expiration in seconds (default 30 minutes)
   171→ * @returns {Promise<{url: string, key: string, expiresIn: number}>}
   172→ */
   173→async function getSignedUploadUrl(key, contentType = 'audio/wav', expiresIn = 1800) {
   174→  const client = getS3Client();
   175→
   176→  const command = new PutObjectCommand({
   177→    Bucket: process.env.R2_BUCKET_NAME,
   178→    Key: key,
   179→    ContentType: contentType
   180→  });
   181→
   182→  const url = await getSignedUrl(client, command, { expiresIn });
   183→
   184→  return {
   185→    url,
   186→    key,
   187→    expiresIn
   188→  };
   189→}
   190→
   191→/**
   192→ * Delete music file from R2
   193→ * @param {string} key - Storage key
   194→ * @returns {Promise<{success: boolean}>}
   195→ */
   196→async function deleteMusic(key) {
   197→  const client = getS3Client();
   198→
   199→  const command = new DeleteObjectCommand({
   200→    Bucket: process.env.R2_BUCKET_NAME,
   201→    Key: key
   202→  });
   203→
   204→  await client.send(command);
   205→
   206→  return { success: true };
   207→}
   208→
   209→/**
   210→ * Delete all files for a job (master, preview, metadata)
   211→ * @param {string} customerId - Stripe customer ID
   212→ * @param {string} jobId - Music generation job ID
   213→ * @returns {Promise<{success: boolean, deleted: string[]}>}
   214→ */
   215→async function deleteJobFiles(customerId, jobId) {
   216→  const files = ['master.wav', 'preview.mp3', 'metadata.json'];
   217→  const deleted = [];
   218→
   219→  for (const file of files) {
   220→    const key = generateStorageKey(customerId, jobId, file);
   221→    try {
   222→      await deleteMusic(key);
   223→      deleted.push(key);
   224→    } catch (error) {
   225→      // Ignore not found errors
   226→      if (error.name !== 'NoSuchKey') {
   227→        console.error(`Failed to delete ${key}:`, error.message);
   228→      }
   229→    }
   230→  }
   231→
   232→  return { success: true, deleted };
   233→}
   234→
   235→/**
   236→ * Check if file exists in R2
   237→ * @param {string} key - Storage key
   238→ * @returns {Promise<boolean>}
   239→ */
   240→async function fileExists(key) {
   241→  const client = getS3Client();
   242→
   243→  try {
   244→    const command = new HeadObjectCommand({
   245→      Bucket: process.env.R2_BUCKET_NAME,
   246→      Key: key
   247→    });
   248→
   249→    await client.send(command);
   250→    return true;
   251→  } catch (error) {
   252→    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {
   253→      return false;
   254→    }
   255→    throw error;
   256→  }
   257→}
   258→
   259→/**
   260→ * Get file metadata (size, content type, etc.)
   261→ * @param {string} key - Storage key
   262→ * @returns {Promise<{size: number, contentType: string, lastModified: Date}|null>}
   263→ */
   264→async function getFileInfo(key) {
   265→  const client = getS3Client();
   266→
   267→  try {
   268→    const command = new HeadObjectCommand({
   269→      Bucket: process.env.R2_BUCKET_NAME,
   270→      Key: key
   271→    });
   272→
   273→    const response = await client.send(command);
   274→
   275→    return {
   276→      size: response.ContentLength,
   277→      contentType: response.ContentType,
   278→      lastModified: response.LastModified
   279→    };
   280→  } catch (error) {
   281→    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {
   282→      return null;
   283→    }
   284→    throw error;
   285→  }
   286→}
   287→
   288→module.exports = {
   289→  generateStorageKey,
   290→  uploadMusic,
   291→  uploadMetadata,
   292→  uploadBuffer,
   293→  downloadFile,
   294→  getSignedDownloadUrl,
   295→  getSignedUploadUrl,
   296→  deleteMusic,
   297→  deleteJobFiles,
   298→  fileExists,
   299→  getFileInfo
   300→};
   301→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
