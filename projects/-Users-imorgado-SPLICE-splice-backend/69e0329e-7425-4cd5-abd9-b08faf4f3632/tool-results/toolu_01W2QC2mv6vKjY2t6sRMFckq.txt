     1→/**
     2→ * SPLICE CEP Panel - Builder Module
     3→ * Handles sequence building, cut list processing, and Premiere Pro integration
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// COLOR MAPPING
     9→// ============================================================================
    10→const SPLICE_COLORS = {
    11→    NONE: 0,
    12→    VIOLET: 1,
    13→    IRIS: 2,
    14→    CARIBBEAN: 3,
    15→    LAVENDER: 4,
    16→    CERULEAN: 5,
    17→    FOREST: 6,
    18→    ROSE: 7,
    19→    MANGO: 8,
    20→    PURPLE: 9,
    21→    BLUE: 10,
    22→    TEAL: 11,
    23→    MAGENTA: 12,
    24→    TAN: 13,
    25→    GREEN: 14,
    26→    BROWN: 15,
    27→    YELLOW: 16
    28→};
    29→
    30→const SEGMENT_COLORS = {
    31→    speech: SPLICE_COLORS.FOREST,
    32→    take: SPLICE_COLORS.LAVENDER,
    33→    best_take: SPLICE_COLORS.CERULEAN,
    34→    silence: SPLICE_COLORS.VIOLET,
    35→    wide_shot: SPLICE_COLORS.YELLOW,
    36→    speaker_a: SPLICE_COLORS.MANGO,
    37→    speaker_b: SPLICE_COLORS.CARIBBEAN
    38→};
    39→
    40→const COLOR_HINT_MAP = {
    41→    cerulean: SPLICE_COLORS.CERULEAN,
    42→    lavender: SPLICE_COLORS.LAVENDER,
    43→    forest: SPLICE_COLORS.FOREST,
    44→    mango: SPLICE_COLORS.MANGO,
    45→    caribbean: SPLICE_COLORS.CARIBBEAN,
    46→    yellow: SPLICE_COLORS.YELLOW,
    47→    violet: SPLICE_COLORS.VIOLET,
    48→    rose: SPLICE_COLORS.ROSE,
    49→    blue: SPLICE_COLORS.BLUE,
    50→    green: SPLICE_COLORS.GREEN
    51→};
    52→
    53→// ============================================================================
    54→// PROJECT ITEM CACHE
    55→// ============================================================================
    56→const projectItemCache = {
    57→    byName: new Map(),
    58→    byPath: new Map(),
    59→    projectId: null
    60→};
    61→
    62→/**
    63→ * Build the project item cache for O(1) lookups
    64→ */
    65→async function buildProjectItemCache() {
    66→    try {
    67→        const items = await jsx.call('getAllProjectItems');
    68→
    69→        projectItemCache.byName.clear();
    70→        projectItemCache.byPath.clear();
    71→
    72→        if (Array.isArray(items)) {
    73→            items.forEach(item => {
    74→                if (item.name) {
    75→                    projectItemCache.byName.set(item.name, item);
    76→                }
    77→                if (item.mediaPath) {
    78→                    projectItemCache.byPath.set(item.mediaPath, item);
    79→                }
    80→                if (item.treePath) {
    81→                    projectItemCache.byPath.set(item.treePath, item);
    82→                }
    83→            });
    84→        }
    85→
    86→        console.log(`[Builder] Cached ${projectItemCache.byName.size} project items`);
    87→        return true;
    88→    } catch (e) {
    89→        console.warn('[Builder] Failed to build cache:', e);
    90→        return false;
    91→    }
    92→}
    93→
    94→/**
    95→ * Clear the project item cache
    96→ */
    97→function clearProjectItemCache() {
    98→    projectItemCache.byName.clear();
    99→    projectItemCache.byPath.clear();
   100→    projectItemCache.projectId = null;
   101→}
   102→
   103→/**
   104→ * Find a project item by name (uses cache)
   105→ */
   106→function findProjectItemByName(name) {
   107→    return projectItemCache.byName.get(name) || null;
   108→}
   109→
   110→/**
   111→ * Find a project item by path (uses cache)
   112→ */
   113→function findProjectItemByPath(path) {
   114→    return projectItemCache.byPath.get(path) || null;
   115→}
   116→
   117→// ============================================================================
   118→// SEQUENCE BUILDING
   119→// ============================================================================
   120→
   121→/**
   122→ * Build a new sequence from a cut list
   123→ * @param {Object} cutList - The cut list from the backend
   124→ * @param {Object} options - Build options
   125→ * @returns {Promise<Object>} Build result
   126→ */
   127→async function buildSequenceFromCutList(cutList, options = {}) {
   128→    console.log('[Builder] Starting sequence build...');
   129→
   130→    try {
   131→        // Validate cut list
   132→        if (!cutList || !cutList.segments || cutList.segments.length === 0) {
   133→            throw new Error('Invalid cut list: no segments');
   134→        }
   135→
   136→        // Build cache if needed
   137→        await buildProjectItemCache();
   138→
   139→        // Call JSX to build the sequence
   140→        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));
   141→
   142→        if (result.error) {
   143→            throw new Error(result.error);
   144→        }
   145→
   146→        console.log('[Builder] Sequence built successfully:', result.sequenceName);
   147→        return {
   148→            success: true,
   149→            sequenceName: result.sequenceName,
   150→            stats: result.stats
   151→        };
   152→    } catch (e) {
   153→        console.error('[Builder] Build failed:', e);
   154→        return {
   155→            success: false,
   156→            error: e.message
   157→        };
   158→    }
   159→}
   160→
   161→/**
   162→ * Process a cut list and add color labels
   163→ * @param {Object} cutList - The cut list from the backend
   164→ * @returns {Object} Processed cut list with color indices
   165→ */
   166→function processCutList(cutList) {
   167→    if (!cutList || !cutList.segments) return cutList;
   168→
   169→    cutList.segments = cutList.segments.map(segment => {
   170→        // Determine color index
   171→        let colorIndex = null;
   172→
   173→        if (segment.colorHint && COLOR_HINT_MAP[segment.colorHint] !== undefined) {
   174→            colorIndex = COLOR_HINT_MAP[segment.colorHint];
   175→        } else if (segment.type && SEGMENT_COLORS[segment.type] !== undefined) {
   176→            colorIndex = SEGMENT_COLORS[segment.type];
   177→        }
   178→
   179→        return {
   180→            ...segment,
   181→            colorIndex
   182→        };
   183→    });
   184→
   185→    return cutList;
   186→}
   187→
   188→// ============================================================================
   189→// MARKER OPERATIONS
   190→// ============================================================================
   191→
   192→/**
   193→ * Add markers to the timeline from silence data
   194→ * @param {Array} silences - Array of silence objects
   195→ * @param {Object} options - Marker options
   196→ */
   197→async function addSilenceMarkers(silences, options = {}) {
   198→    const { colorIndex = SPLICE_COLORS.VIOLET, prefix = 'SPLICE: Silence' } = options;
   199→    let added = 0;
   200→
   201→    for (const silence of silences) {
   202→        try {
   203→            const duration = silence.end - silence.start;
   204→            await jsx.call('createMarker', silence.start, prefix, duration, null, colorIndex);
   205→            added++;
   206→        } catch (e) {
   207→            console.warn('[Builder] Failed to add silence marker:', e);
   208→        }
   209→    }
   210→
   211→    return { added };
   212→}
   213→
   214→/**
   215→ * Add markers to the timeline from take data
   216→ * @param {Array} takes - Array of take objects
   217→ * @param {Object} options - Marker options
   218→ */
   219→async function addTakeMarkers(takes, options = {}) {
   220→    const { colorIndex = SPLICE_COLORS.CERULEAN } = options;
   221→    let added = 0;
   222→
   223→    for (const take of takes) {
   224→        try {
   225→            const name = take.label || `Take ${take.takeNumber || added + 1}`;
   226→            const duration = take.end - take.start;
   227→            await jsx.call('createMarker', take.start, name, duration, null, colorIndex);
   228→            added++;
   229→        } catch (e) {
   230→            console.warn('[Builder] Failed to add take marker:', e);
   231→        }
   232→    }
   233→
   234→    return { added };
   235→}
   236→
   237→/**
   238→ * Add chapter markers to the timeline
   239→ * @param {Array} chapters - Array of chapter objects
   240→ */
   241→async function addChapterMarkers(chapters) {
   242→    let added = 0;
   243→
   244→    for (const chapter of chapters) {
   245→        try {
   246→            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);
   247→            added++;
   248→        } catch (e) {
   249→            console.warn('[Builder] Failed to add chapter marker:', e);
   250→        }
   251→    }
   252→
   253→    return { added };
   254→}
   255→
   256→/**
   257→ * Add zoom markers to the timeline
   258→ * @param {Array} zoomPoints - Array of zoom point objects
   259→ */
   260→async function addZoomMarkers(zoomPoints) {
   261→    let added = 0;
   262→
   263→    for (const zoom of zoomPoints) {
   264→        try {
   265→            await jsx.call('addZoomMarker', zoom.startTime, zoom.scale, zoom.duration, zoom.easing);
   266→            added++;
   267→        } catch (e) {
   268→            console.warn('[Builder] Failed to add zoom marker:', e);
   269→        }
   270→    }
   271→
   272→    return { added };
   273→}
   274→
   275→/**
   276→ * Clear all SPLICE markers from the timeline
   277→ */
   278→async function clearSpliceMarkers() {
   279→    try {
   280→        const result = await jsx.call('deleteMarkersByName', 'SPLICE');
   281→        return { deleted: result.deleted || 0 };
   282→    } catch (e) {
   283→        console.warn('[Builder] Failed to clear markers:', e);
   284→        return { deleted: 0 };
   285→    }
   286→}
   287→
   288→// ============================================================================
   289→// RAZOR OPERATIONS
   290→// ============================================================================
   291→
   292→/**
   293→ * Apply razor cuts at silence boundaries
   294→ * @param {Array} silences - Array of silence objects
   295→ * @param {Object} options - Razor options
   296→ */
   297→async function razorAtSilences(silences, options = {}) {
   298→    const { trackType = 'all', trackIndex = -1 } = options;
   299→
   300→    // Convert silences to frame-aligned cut points
   301→    const cutPoints = [];
   302→    const frameRate = await jsx.call('getVideoFrameRateInSeconds');
   303→
   304→    for (const silence of silences) {
   305→        // Align to frame boundaries
   306→        const startFrame = Math.round(silence.start / frameRate);
   307→        const endFrame = Math.round(silence.end / frameRate);
   308→
   309→        cutPoints.push([startFrame, endFrame]);
   310→    }
   311→
   312→    // Batch the cuts
   313→    if (cutPoints.length > 0) {
   314→        try {
   315→            await jsx.call('razorSequenceAtFramesArray', JSON.stringify(cutPoints));
   316→            return { cuts: cutPoints.length * 2 };
   317→        } catch (e) {
   318→            console.error('[Builder] Razor failed:', e);
   319→            return { cuts: 0, error: e.message };
   320→        }
   321→    }
   322→
   323→    return { cuts: 0 };
   324→}
   325→
   326→/**
   327→ * Delete clips at silence points
   328→ * @param {Array} silences - Array of silence objects
   329→ * @param {Object} options - Delete options
   330→ */
   331→async function deleteClipsAtSilences(silences, options = {}) {
   332→    const { trackType = 'video', trackIndex = 0 } = options;
   333→
   334→    try {
   335→        const result = await jsx.call(
   336→            'deleteClipsAtSilencePointsInTrack',
   337→            JSON.stringify(silences.map(s => [s.start, s.end])),
   338→            trackType,
   339→            trackIndex
   340→        );
   341→
   342→        return { deleted: result.deleted || 0 };
   343→    } catch (e) {
   344→        console.error('[Builder] Delete failed:', e);
   345→        return { deleted: 0, error: e.message };
   346→    }
   347→}
   348→
   349→// ============================================================================
   350→// UTILITY FUNCTIONS
   351→// ============================================================================
   352→
   353→/**
   354→ * Get color index for a segment type
   355→ */
   356→function getColorForSegment(type, colorHint) {
   357→    if (colorHint && COLOR_HINT_MAP[colorHint] !== undefined) {
   358→        return COLOR_HINT_MAP[colorHint];
   359→    }
   360→    if (type && SEGMENT_COLORS[type] !== undefined) {
   361→        return SEGMENT_COLORS[type];
   362→    }
   363→    return null;
   364→}
   365→
   366→/**
   367→ * Get the active sequence info
   368→ */
   369→async function getActiveSequence() {
   370→    try {
   371→        return await jsx.call('getActiveSequence');
   372→    } catch (e) {
   373→        console.warn('[Builder] Failed to get active sequence:', e);
   374→        return null;
   375→    }
   376→}
   377→
   378→/**
   379→ * Check if a sequence is open
   380→ */
   381→async function checkSequenceOpen() {
   382→    try {
   383→        const result = await jsx.call('checkSequenceOpen');
   384→        return result === true || result === 'true';
   385→    } catch {
   386→        return false;
   387→    }
   388→}
   389→
   390→/**
   391→ * Clone the current sequence
   392→ * @param {string} newName - Name for the cloned sequence
   393→ */
   394→async function cloneSequence(newName) {
   395→    try {
   396→        return await jsx.call('cloneSequence', newName);
   397→    } catch (e) {
   398→        console.error('[Builder] Clone failed:', e);
   399→        return { error: e.message };
   400→    }
   401→}
   402→
   403→/**
   404→ * Undo the last operation
   405→ */
   406→async function undo() {
   407→    try {
   408→        await jsx.call('undo');
   409→        return { success: true };
   410→    } catch (e) {
   411→        console.warn('[Builder] Undo failed:', e);
   412→        return { success: false, error: e.message };
   413→    }
   414→}
   415→
   416→// ============================================================================
   417→// EXPORTS
   418→// ============================================================================
   419→
   420→window.spliceBuilder = {
   421→    // Constants
   422→    SPLICE_COLORS,
   423→    SEGMENT_COLORS,
   424→    COLOR_HINT_MAP,
   425→
   426→    // Cache
   427→    buildProjectItemCache,
   428→    clearProjectItemCache,
   429→    findProjectItemByName,
   430→    findProjectItemByPath,
   431→
   432→    // Sequence building
   433→    buildSequenceFromCutList,
   434→    processCutList,
   435→
   436→    // Markers
   437→    addSilenceMarkers,
   438→    addTakeMarkers,
   439→    addChapterMarkers,
   440→    addZoomMarkers,
   441→    clearSpliceMarkers,
   442→
   443→    // Razor
   444→    razorAtSilences,
   445→    deleteClipsAtSilences,
   446→
   447→    // Utilities
   448→    getColorForSegment,
   449→    getActiveSequence,
   450→    checkSequenceOpen,
   451→    cloneSequence,
   452→    undo
   453→};
   454→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
