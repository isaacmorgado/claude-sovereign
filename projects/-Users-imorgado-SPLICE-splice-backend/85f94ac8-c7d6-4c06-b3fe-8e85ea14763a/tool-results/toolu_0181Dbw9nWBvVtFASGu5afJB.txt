     1→/**
     2→ * Settings Management
     3→ *
     4→ * Persists user preferences to localStorage
     5→ * v3.5: Added Persistent Token support for media folder access
     6→ */
     7→
     8→const uxpFs = require('uxp').storage.localFileSystem;
     9→
    10→// =============================================================================
    11→// CUSTOM PRESETS STORAGE (v3.5+)
    12→// =============================================================================
    13→
    14→const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';
    15→
    16→/**
    17→ * Default structure for custom presets storage
    18→ */
    19→const DEFAULT_CUSTOM_PRESETS = {
    20→  version: 1,
    21→  presets: {},
    22→  order: []
    23→};
    24→
    25→/**
    26→ * Load custom presets from localStorage
    27→ * @returns {Object} Custom presets data structure
    28→ */
    29→function loadCustomPresets() {
    30→  try {
    31→    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    32→    if (saved) {
    33→      const parsed = JSON.parse(saved);
    34→      // Validate structure
    35→      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
    36→        // Return deep copy to avoid mutation issues
    37→        return {
    38→          version: parsed.version || 1,
    39→          presets: { ...parsed.presets },
    40→          order: [...(parsed.order || [])]
    41→        };
    42→      }
    43→    }
    44→  } catch (e) {
    45→    console.warn('[SPLICE] Could not load custom presets:', e);
    46→  }
    47→  // Return fresh objects to avoid mutation of defaults
    48→  return {
    49→    version: 1,
    50→    presets: {},
    51→    order: []
    52→  };
    53→}
    54→
    55→/**
    56→ * Save custom presets to localStorage
    57→ * @param {Object} data - Custom presets data structure
    58→ * @returns {boolean} Success status
    59→ */
    60→function saveCustomPresets(data) {
    61→  try {
    62→    if (!data || typeof data !== 'object') {
    63→      console.warn('[SPLICE] Invalid custom presets data');
    64→      return false;
    65→    }
    66→    // Ensure required fields
    67→    const toSave = {
    68→      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
    69→      presets: data.presets || {},
    70→      order: data.order || []
    71→    };
    72→    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    73→    return true;
    74→  } catch (e) {
    75→    console.warn('[SPLICE] Could not save custom presets:', e);
    76→    return false;
    77→  }
    78→}
    79→
    80→/**
    81→ * Generate a slugified ID from a preset name
    82→ * @param {string} name - Preset name
    83→ * @returns {string} Slugified ID
    84→ */
    85→function slugifyPresetName(name) {
    86→  return name
    87→    .toLowerCase()
    88→    .trim()
    89→    .replace(/[^a-z0-9]+/g, '-')
    90→    .replace(/^-+|-+$/g, '')
    91→    .substring(0, 50) || 'preset';
    92→}
    93→
    94→/**
    95→ * Generate a unique ID for a custom preset
    96→ * @param {string} baseName - Base name to slugify
    97→ * @param {Object} existingPresets - Current presets object
    98→ * @returns {string} Unique ID
    99→ */
   100→function generateUniquePresetId(baseName, existingPresets) {
   101→  const baseId = slugifyPresetName(baseName);
   102→  let id = baseId;
   103→  let counter = 1;
   104→
   105→  while (existingPresets[id]) {
   106→    id = `${baseId}-${counter}`;
   107→    counter++;
   108→  }
   109→
   110→  return id;
   111→}
   112→
   113→/**
   114→ * Create a new custom preset
   115→ * @param {Object} preset - Preset data
   116→ * @param {string} preset.name - Preset name (required)
   117→ * @param {string} [preset.description] - Preset description
   118→ * @param {string} [preset.icon] - Icon name (default: 'settings')
   119→ * @param {Object} [preset.settings] - Preset settings (uses current if not provided)
   120→ * @returns {{success: boolean, id?: string, error?: string}}
   121→ */
   122→function createCustomPreset(preset) {
   123→  // Validate input
   124→  if (!preset || typeof preset !== 'object') {
   125→    return { success: false, error: 'Invalid preset data' };
   126→  }
   127→
   128→  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {
   129→    return { success: false, error: 'Preset name is required' };
   130→  }
   131→
   132→  const name = preset.name.trim();
   133→
   134→  // Load current data
   135→  const data = loadCustomPresets();
   136→
   137→  // Generate unique ID
   138→  const id = generateUniquePresetId(name, data.presets);
   139→
   140→  // Get settings from preset or current settings
   141→  const settings = preset.settings && typeof preset.settings === 'object'
   142→    ? { ...preset.settings }
   143→    : getCurrentPresetSettings();
   144→
   145→  // Validate settings
   146→  if (!settings || typeof settings !== 'object') {
   147→    return { success: false, error: 'Invalid settings' };
   148→  }
   149→
   150→  // Create the preset object
   151→  const newPreset = {
   152→    id,
   153→    name,
   154→    description: preset.description || '',
   155→    icon: preset.icon || 'settings',
   156→    createdAt: new Date().toISOString(),
   157→    settings
   158→  };
   159→
   160→  // Add to presets and order
   161→  data.presets[id] = newPreset;
   162→  data.order.push(id);
   163→
   164→  // Save
   165→  const saved = saveCustomPresets(data);
   166→  if (!saved) {
   167→    return { success: false, error: 'Failed to save preset' };
   168→  }
   169→
   170→  console.log(`[SPLICE] Created custom preset: ${name} (${id})`);
   171→  return { success: true, id };
   172→}
   173→
   174→/**
   175→ * Get current settings suitable for a preset
   176→ * @returns {Object} Current preset-compatible settings
   177→ */
   178→function getCurrentPresetSettings() {
   179→  const current = typeof getSettings === 'function' ? getSettings() : {};
   180→  return {
   181→    sensitivity: current.sensitivity || 50,
   182→    threshold: current.threshold || -32,
   183→    minSilenceLength: current.minSilenceLength || 0.5,
   184→    paddingStart: current.paddingStart || 0.1,
   185→    paddingEnd: current.paddingEnd || 0.1,
   186→    autoMarkBest: current.autoMarkBest !== false,
   187→    enableTakesDetection: current.enableTakesDetection !== false
   188→  };
   189→}
   190→
   191→/**
   192→ * Update an existing custom preset
   193→ * @param {string} id - Preset ID to update
   194→ * @param {Object} updates - Fields to update
   195→ * @param {string} [updates.name] - New name
   196→ * @param {string} [updates.description] - New description
   197→ * @param {string} [updates.icon] - New icon
   198→ * @param {Object} [updates.settings] - New settings (merged with existing)
   199→ * @returns {{success: boolean, error?: string}}
   200→ */
   201→function updateCustomPreset(id, updates) {
   202→  // Validate input
   203→  if (!id || typeof id !== 'string') {
   204→    return { success: false, error: 'Preset ID is required' };
   205→  }
   206→
   207→  if (!updates || typeof updates !== 'object') {
   208→    return { success: false, error: 'Updates must be an object' };
   209→  }
   210→
   211→  // Load current data
   212→  const data = loadCustomPresets();
   213→
   214→  // Check if preset exists
   215→  if (!data.presets[id]) {
   216→    return { success: false, error: 'Preset not found' };
   217→  }
   218→
   219→  const existing = data.presets[id];
   220→
   221→  // Apply updates (preserve fields not being updated)
   222→  const updated = {
   223→    ...existing,
   224→    updatedAt: new Date().toISOString()
   225→  };
   226→
   227→  // Update name (with validation)
   228→  if (updates.name !== undefined) {
   229→    if (typeof updates.name !== 'string' || !updates.name.trim()) {
   230→      return { success: false, error: 'Name must be a non-empty string' };
   231→    }
   232→    updated.name = updates.name.trim();
   233→  }
   234→
   235→  // Update description
   236→  if (updates.description !== undefined) {
   237→    updated.description = String(updates.description);
   238→  }
   239→
   240→  // Update icon
   241→  if (updates.icon !== undefined) {
   242→    updated.icon = String(updates.icon);
   243→  }
   244→
   245→  // Update settings (merge with existing)
   246→  if (updates.settings !== undefined) {
   247→    if (typeof updates.settings !== 'object') {
   248→      return { success: false, error: 'Settings must be an object' };
   249→    }
   250→    updated.settings = {
   251→      ...existing.settings,
   252→      ...updates.settings
   253→    };
   254→  }
   255→
   256→  // Save updated preset
   257→  data.presets[id] = updated;
   258→
   259→  const saved = saveCustomPresets(data);
   260→  if (!saved) {
   261→    return { success: false, error: 'Failed to save preset' };
   262→  }
   263→
   264→  console.log(`[SPLICE] Updated custom preset: ${updated.name} (${id})`);
   265→  return { success: true };
   266→}
   267→
   268→/**
   269→ * Get a custom preset by ID
   270→ * @param {string} id - Preset ID
   271→ * @returns {Object|null} Preset object or null if not found
   272→ */
   273→function getCustomPreset(id) {
   274→  if (!id || typeof id !== 'string') {
   275→    return null;
   276→  }
   277→
   278→  const data = loadCustomPresets();
   279→  return data.presets[id] || null;
   280→}
   281→
   282→/**
   283→ * Duplicate a custom preset
   284→ * @param {string} id - Preset ID to duplicate
   285→ * @returns {{success: boolean, id?: string, error?: string}}
   286→ */
   287→function duplicatePreset(id) {
   288→  // Validate input
   289→  if (!id || typeof id !== 'string') {
   290→    return { success: false, error: 'Preset ID is required' };
   291→  }
   292→
   293→  // Get the original preset
   294→  const original = getPresetById(id);
   295→  if (!original) {
   296→    return { success: false, error: 'Preset not found' };
   297→  }
   298→
   299→  // Generate new name with copy suffix
   300→  let copyName = `${original.name} (Copy)`;
   301→
   302→  // Check if copy name already exists and increment if needed
   303→  const data = loadCustomPresets();
   304→  let copyNumber = 1;
   305→  let testId = slugifyPresetName(copyName);
   306→  while (data.presets[testId]) {
   307→    copyNumber++;
   308→    copyName = `${original.name} (Copy ${copyNumber})`;
   309→    testId = slugifyPresetName(copyName);
   310→  }
   311→
   312→  // Create the duplicate
   313→  return createCustomPreset({
   314→    name: copyName,
   315→    description: original.description || '',
   316→    icon: original.icon || 'settings',
   317→    settings: original.settings ? { ...original.settings } : getCurrentPresetSettings()
   318→  });
   319→}
   320→
   321→/**
   322→ * Export all custom presets to JSON string
   323→ * @returns {{success: boolean, data?: string, count?: number, error?: string}}
   324→ */
   325→function exportPresets() {
   326→  try {
   327→    const data = loadCustomPresets();
   328→    const customPresets = data.order.map(id => data.presets[id]).filter(Boolean);
   329→
   330→    if (customPresets.length === 0) {
   331→      return { success: false, error: 'No custom presets to export' };
   332→    }
   333→
   334→    const exportData = {
   335→      version: 1,
   336→      exportedAt: new Date().toISOString(),
   337→      presets: customPresets
   338→    };
   339→
   340→    return {
   341→      success: true,
   342→      data: JSON.stringify(exportData, null, 2),
   343→      count: customPresets.length
   344→    };
   345→  } catch (e) {
   346→    return { success: false, error: 'Failed to export presets: ' + e.message };
   347→  }
   348→}
   349→
   350→/**
   351→ * Import presets from JSON string
   352→ * @param {string} jsonString - JSON string containing presets
   353→ * @param {boolean} merge - If true, merge with existing; if false, skip duplicates
   354→ * @returns {{success: boolean, imported?: number, skipped?: number, error?: string}}
   355→ */
   356→function importPresets(jsonString, merge = true) {
   357→  try {
   358→    // Parse JSON
   359→    const imported = JSON.parse(jsonString);
   360→
   361→    // Validate structure
   362→    if (!imported || !imported.presets || !Array.isArray(imported.presets)) {
   363→      return { success: false, error: 'Invalid preset file format' };
   364→    }
   365→
   366→    let importedCount = 0;
   367→    let skippedCount = 0;
   368→
   369→    for (const preset of imported.presets) {
   370→      // Validate each preset has required fields
   371→      if (!preset.name || typeof preset.name !== 'string') {
   372→        skippedCount++;
   373→        continue;
   374→      }
   375→
   376→      // Check if a preset with this name already exists
   377→      const existingId = slugifyPresetName(preset.name);
   378→      const existing = getCustomPreset(existingId);
   379→
   380→      if (existing && !merge) {
   381→        // Skip existing if not merging
   382→        skippedCount++;
   383→        continue;
   384→      }
   385→
   386→      // If existing and merge mode, create with unique name
   387→      if (existing && merge) {
   388→        let newName = `${preset.name} (Imported)`;
   389→        let counter = 1;
   390→        while (getCustomPreset(slugifyPresetName(newName))) {
   391→          counter++;
   392→          newName = `${preset.name} (Imported ${counter})`;
   393→        }
   394→        preset.name = newName;
   395→      }
   396→
   397→      // Create the preset
   398→      const result = createCustomPreset({
   399→        name: preset.name,
   400→        description: preset.description || '',
   401→        icon: preset.icon || 'settings',
   402→        settings: preset.settings || getCurrentPresetSettings()
   403→      });
   404→
   405→      if (result.success) {
   406→        importedCount++;
   407→      } else {
   408→        skippedCount++;
   409→      }
   410→    }
   411→
   412→    if (importedCount === 0 && skippedCount > 0) {
   413→      return { success: false, error: 'All presets already exist or were invalid', skipped: skippedCount };
   414→    }
   415→
   416→    return {
   417→      success: true,
   418→      imported: importedCount,
   419→      skipped: skippedCount
   420→    };
   421→  } catch (e) {
   422→    if (e instanceof SyntaxError) {
   423→      return { success: false, error: 'Invalid JSON format' };
   424→    }
   425→    return { success: false, error: 'Failed to import presets: ' + e.message };
   426→  }
   427→}
   428→
   429→/**
   430→ * Delete a custom preset
   431→ * @param {string} id - Preset ID to delete
   432→ * @returns {{success: boolean, error?: string}}
   433→ */
   434→function deleteCustomPreset(id) {
   435→  // Validate input
   436→  if (!id || typeof id !== 'string') {
   437→    return { success: false, error: 'Preset ID is required' };
   438→  }
   439→
   440→  // Load current data
   441→  const data = loadCustomPresets();
   442→
   443→  // Check if preset exists
   444→  if (!data.presets[id]) {
   445→    return { success: false, error: 'Preset not found' };
   446→  }
   447→
   448→  const presetName = data.presets[id].name;
   449→
   450→  // Remove from presets object
   451→  delete data.presets[id];
   452→
   453→  // Remove from order array
   454→  const orderIndex = data.order.indexOf(id);
   455→  if (orderIndex !== -1) {
   456→    data.order.splice(orderIndex, 1);
   457→  }
   458→
   459→  // Save
   460→  const saved = saveCustomPresets(data);
   461→  if (!saved) {
   462→    return { success: false, error: 'Failed to save after deletion' };
   463→  }
   464→
   465→  console.log(`[SPLICE] Deleted custom preset: ${presetName} (${id})`);
   466→  return { success: true };
   467→}
   468→
   469→/**
   470→ * List of built-in preset IDs (cannot be modified or deleted)
   471→ */
   472→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];
   473→
   474→/**
   475→ * Check if a preset is a built-in preset
   476→ * @param {string} id - Preset ID to check
   477→ * @returns {boolean} True if built-in, false if custom
   478→ */
   479→function isBuiltInPreset(id) {
   480→  return BUILT_IN_PRESET_IDS.includes(id);
   481→}
   482→
   483→/**
   484→ * Get all presets (built-in + custom merged)
   485→ * Built-in presets appear first, then custom presets in their creation order.
   486→ * Each preset has isBuiltIn flag added.
   487→ *
   488→ * @returns {Array<Object>} Array of preset objects with metadata
   489→ */
   490→function getAllPresets() {
   491→  // Get built-in presets
   492→  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {
   493→    const preset = PRESETS[id];
   494→    return {
   495→      id,
   496→      name: preset.name,
   497→      description: preset.description,
   498→      icon: preset.icon,
   499→      settings: preset.settings,
   500→      isBuiltIn: true
   501→    };
   502→  });
   503→
   504→  // Get custom presets
   505→  const customData = loadCustomPresets();
   506→  const customPresets = customData.order.map(id => {
   507→    const preset = customData.presets[id];
   508→    if (!preset) return null;
   509→    return {
   510→      ...preset,
   511→      isBuiltIn: false
   512→    };
   513→  }).filter(Boolean);
   514→
   515→  // Merge: built-in first, then custom
   516→  return [...builtInPresets, ...customPresets];
   517→}
   518→
   519→/**
   520→ * Get all preset IDs (built-in + custom)
   521→ * @returns {Array<string>} Array of preset IDs
   522→ */
   523→function getAllPresetIds() {
   524→  const customData = loadCustomPresets();
   525→  return [...BUILT_IN_PRESET_IDS, ...customData.order];
   526→}
   527→
   528→/**
   529→ * Get a preset by ID (built-in or custom)
   530→ * @param {string} id - Preset ID
   531→ * @returns {Object|null} Preset object or null if not found
   532→ */
   533→function getPresetById(id) {
   534→  if (!id || typeof id !== 'string') {
   535→    return null;
   536→  }
   537→
   538→  // Check built-in first
   539→  if (isBuiltInPreset(id)) {
   540→    const preset = PRESETS[id];
   541→    return {
   542→      id,
   543→      name: preset.name,
   544→      description: preset.description,
   545→      icon: preset.icon,
   546→      settings: preset.settings,
   547→      isBuiltIn: true
   548→    };
   549→  }
   550→
   551→  // Check custom presets
   552→  const custom = getCustomPreset(id);
   553→  if (custom) {
   554→    return {
   555→      ...custom,
   556→      isBuiltIn: false
   557→    };
   558→  }
   559→
   560→  return null;
   561→}
   562→
   563→const DEFAULT_SETTINGS = {
   564→  sensitivity: 50,
   565→  audioSource: 'original',
   566→  autoMarkBest: true,
   567→  enableTakesDetection: true,
   568→  rememberOptions: false,
   569→  optionsExpanded: false,
   570→  customerId: null,          // Stripe customer ID for billing
   571→  mediaFolderToken: null,    // Persistent token for media folder access
   572→  mediaFolderPath: null,     // Path to the media folder (for display)
   573→  activePreset: 'custom'     // Currently active preset
   574→};
   575→
   576→// =============================================================================
   577→// PRESET PROFILES
   578→// =============================================================================
   579→
   580→/**
   581→ * Detection presets for different content types.
   582→ * Each preset defines optimal settings for a specific use case.
   583→ */
   584→const PRESETS = {
   585→  // Custom - user-defined settings (default)
   586→  custom: {
   587→    name: 'Custom',
   588→    description: 'Your custom settings',
   589→    icon: 'settings',
   590→    settings: null // Uses current user settings
   591→  },
   592→
   593→  // Podcast - longer pauses are natural, be conservative
   594→  podcast: {
   595→    name: 'Podcast',
   596→    description: 'Longer natural pauses, conversational flow',
   597→    icon: 'mic',
   598→    settings: {
   599→      sensitivity: 35,           // Lower sensitivity (fewer cuts)
   600→      threshold: -35,            // Higher threshold (only deep silence)
   601→      minSilenceLength: 0.8,     // Longer minimum silence
   602→      paddingStart: 0.15,        // More padding for natural transitions
   603→      paddingEnd: 0.15,
   604→      mergeDistance: 0.3,        // Merge nearby silences
   605→      autoMarkBest: false,       // Don't auto-mark (manual review)
   606→      enableTakesDetection: true
   607→    }
   608→  },
   609→
   610→  // Interview - balanced, respects speaker pauses
   611→  interview: {
   612→    name: 'Interview',
   613→    description: 'Balanced cuts, preserves Q&A rhythm',
   614→    icon: 'people',
   615→    settings: {
   616→      sensitivity: 50,           // Medium sensitivity
   617→      threshold: -32,            // Moderate threshold
   618→      minSilenceLength: 0.5,     // Standard minimum silence
   619→      paddingStart: 0.12,        // Moderate padding
   620→      paddingEnd: 0.08,
   621→      mergeDistance: 0.2,
   622→      autoMarkBest: true,
   623→      enableTakesDetection: true
   624→    }
   625→  },
   626→
   627→  // Reaction video - fast pacing, quick cuts
   628→  reaction: {
   629→    name: 'Reaction',
   630→    description: 'Fast-paced, tight cuts for energy',
   631→    icon: 'bolt',
   632→    settings: {
   633→      sensitivity: 70,           // Higher sensitivity (more cuts)
   634→      threshold: -28,            // Lower threshold (catches more silence)
   635→      minSilenceLength: 0.3,     // Short minimum silence
   636→      paddingStart: 0.05,        // Minimal padding for snappy edits
   637→      paddingEnd: 0.03,
   638→      mergeDistance: 0.15,
   639→      autoMarkBest: true,
   640→      enableTakesDetection: false // Usually single-take content
   641→    }
   642→  },
   643→
   644→  // Tutorial/Educational - preserve thinking pauses
   645→  tutorial: {
   646→    name: 'Tutorial',
   647→    description: 'Preserves teaching pace, minimal cuts',
   648→    icon: 'school',
   649→    settings: {
   650→      sensitivity: 30,           // Low sensitivity
   651→      threshold: -38,            // Only deep silence
   652→      minSilenceLength: 1.0,     // Long minimum (preserve demo pauses)
   653→      paddingStart: 0.2,         // Extra padding for clarity
   654→      paddingEnd: 0.15,
   655→      mergeDistance: 0.4,
   656→      autoMarkBest: false,
   657→      enableTakesDetection: true
   658→    }
   659→  },
   660→
   661→  // Vlog/YouTube - punchy edits, engagement-focused
   662→  vlog: {
   663→    name: 'Vlog',
   664→    description: 'Punchy edits for YouTube engagement',
   665→    icon: 'videocam',
   666→    settings: {
   667→      sensitivity: 65,           // Higher sensitivity
   668→      threshold: -30,            // Moderate-low threshold
   669→      minSilenceLength: 0.35,    // Short silences
   670→      paddingStart: 0.08,        // Quick transitions
   671→      paddingEnd: 0.05,
   672→      mergeDistance: 0.2,
   673→      autoMarkBest: true,
   674→      enableTakesDetection: true
   675→    }
   676→  }
   677→};
   678→
   679→/**
   680→ * Get all available presets
   681→ * @returns {Object} All preset definitions
   682→ */
   683→function getPresets() {
   684→  return { ...PRESETS };
   685→}
   686→
   687→/**
   688→ * Get a specific preset by name
   689→ * @param {string} presetName - Name of the preset
   690→ * @returns {Object|null} Preset definition or null if not found
   691→ */
   692→function getPreset(presetName) {
   693→  return PRESETS[presetName] || null;
   694→}
   695→
   696→/**
   697→ * Get preset names as array (for UI)
   698→ * @returns {Array<string>} Array of preset names
   699→ */
   700→function getPresetNames() {
   701→  return Object.keys(PRESETS);
   702→}
   703→
   704→/**
   705→ * Apply a preset to current settings
   706→ * @param {string} presetName - Name of the preset to apply
   707→ * @returns {Object} The applied settings
   708→ */
   709→function applyPreset(presetName) {
   710→  const preset = PRESETS[presetName];
   711→
   712→  if (!preset) {
   713→    console.warn(`[SPLICE] Unknown preset: ${presetName}`);
   714→    return getSettings();
   715→  }
   716→
   717→  // Custom preset uses current settings
   718→  if (presetName === 'custom' || !preset.settings) {
   719→    saveSettings({ activePreset: 'custom' });
   720→    return getSettings();
   721→  }
   722→
   723→  // Apply preset settings
   724→  const newSettings = {
   725→    ...preset.settings,
   726→    activePreset: presetName
   727→  };
   728→
   729→  saveSettings(newSettings);
   730→  console.log(`[SPLICE] Applied preset: ${preset.name}`);
   731→
   732→  return getSettings();
   733→}
   734→
   735→/**
   736→ * Get the currently active preset
   737→ * @returns {string} Active preset name
   738→ */
   739→function getActivePreset() {
   740→  const settings = getSettings();
   741→  return settings.activePreset || 'custom';
   742→}
   743→
   744→/**
   745→ * Check if current settings match a preset
   746→ * @param {string} presetName - Preset to compare against
   747→ * @returns {boolean} True if settings match the preset
   748→ */
   749→function settingsMatchPreset(presetName) {
   750→  const preset = PRESETS[presetName];
   751→  if (!preset || !preset.settings) return presetName === 'custom';
   752→
   753→  const current = getSettings();
   754→
   755→  // Compare relevant settings
   756→  return Object.keys(preset.settings).every(key => {
   757→    if (key === 'activePreset') return true;
   758→    return current[key] === preset.settings[key];
   759→  });
   760→}
   761→
   762→let currentSettings = { ...DEFAULT_SETTINGS };
   763→
   764→/**
   765→ * Load settings from localStorage
   766→ */
   767→function loadSettings() {
   768→  try {
   769→    const saved = localStorage.getItem('spliceSettings');
   770→    if (saved) {
   771→      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
   772→    }
   773→  } catch (e) {
   774→    console.warn('[SPLICE] Could not load settings:', e);
   775→    currentSettings = { ...DEFAULT_SETTINGS };
   776→  }
   777→  return currentSettings;
   778→}
   779→
   780→/**
   781→ * Save settings to localStorage
   782→ */
   783→function saveSettings(settings) {
   784→  try {
   785→    currentSettings = { ...currentSettings, ...settings };
   786→    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
   787→  } catch (e) {
   788→    console.warn('[SPLICE] Could not save settings:', e);
   789→  }
   790→}
   791→
   792→/**
   793→ * Get current settings
   794→ */
   795→function getSettings() {
   796→  return { ...currentSettings };
   797→}
   798→
   799→/**
   800→ * Reset settings to defaults
   801→ */
   802→function resetSettings() {
   803→  currentSettings = { ...DEFAULT_SETTINGS };
   804→  try {
   805→    localStorage.removeItem('spliceSettings');
   806→  } catch (e) {
   807→    console.warn('[SPLICE] Could not clear settings:', e);
   808→  }
   809→}
   810→
   811→/**
   812→ * Initialize settings UI components
   813→ */
   814→function initSettingsUI() {
   815→  const settings = loadSettings();
   816→
   817→  // Apply saved sensitivity to slider
   818→  const sensitivitySlider = document.getElementById('sensitivitySlider');
   819→  if (sensitivitySlider) {
   820→    sensitivitySlider.value = settings.sensitivity;
   821→  }
   822→
   823→  // Apply saved audio source
   824→  const sourceOriginal = document.getElementById('sourceOriginal');
   825→  const sourceIsolated = document.getElementById('sourceIsolated');
   826→  if (sourceOriginal && sourceIsolated) {
   827→    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';
   828→    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';
   829→  }
   830→
   831→  // Apply auto-mark best setting
   832→  const autoMarkBest = document.getElementById('autoMarkBest');
   833→  if (autoMarkBest) {
   834→    autoMarkBest.checked = settings.autoMarkBest;
   835→  }
   836→
   837→  // Apply takes detection setting
   838→  const enableTakesDetection = document.getElementById('enableTakesDetection');
   839→  if (enableTakesDetection) {
   840→    enableTakesDetection.checked = settings.enableTakesDetection;
   841→  }
   842→
   843→  // Apply remember options setting
   844→  const rememberOptions = document.getElementById('rememberOptions');
   845→  if (rememberOptions) {
   846→    rememberOptions.checked = settings.rememberOptions;
   847→  }
   848→
   849→  // Restore expanded state if remember is enabled
   850→  if (settings.rememberOptions && settings.optionsExpanded) {
   851→    toggleOptionsPanel(true);
   852→  }
   853→}
   854→
   855→/**
   856→ * Toggle options panel visibility (unified panel)
   857→ */
   858→function toggleOptionsPanel(forceState) {
   859→  const toggle = document.getElementById('optionsToggle');
   860→  const panel = document.getElementById('optionsPanel');
   861→
   862→  if (!toggle || !panel) return;
   863→
   864→  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');
   865→
   866→  if (shouldExpand) {
   867→    panel.classList.remove('collapsed');
   868→    toggle.classList.add('expanded');
   869→  } else {
   870→    panel.classList.add('collapsed');
   871→    toggle.classList.remove('expanded');
   872→  }
   873→
   874→  // Save state if remember is enabled
   875→  const settings = getSettings();
   876→  if (settings.rememberOptions) {
   877→    saveSettings({ optionsExpanded: shouldExpand });
   878→  }
   879→}
   880→
   881→/**
   882→ * Initialize settings modal
   883→ */
   884→function initSettingsModal() {
   885→  const settingsBtn = document.getElementById('settingsBtn');
   886→  const modal = document.getElementById('settingsModal');
   887→  const closeBtn = document.getElementById('closeSettingsBtn');
   888→  const defaultSensitivity = document.getElementById('defaultSensitivity');
   889→  const rememberOptions = document.getElementById('rememberOptions');
   890→
   891→  if (settingsBtn && modal) {
   892→    settingsBtn.addEventListener('click', () => {
   893→      modal.classList.remove('hidden');
   894→      // Sync modal values with current settings
   895→      const settings = getSettings();
   896→      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;
   897→      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;
   898→    });
   899→  }
   900→
   901→  if (closeBtn && modal) {
   902→    closeBtn.addEventListener('click', () => {
   903→      modal.classList.add('hidden');
   904→    });
   905→  }
   906→
   907→  // Close on backdrop click
   908→  if (modal) {
   909→    modal.addEventListener('click', (e) => {
   910→      if (e.target === modal) {
   911→        modal.classList.add('hidden');
   912→      }
   913→    });
   914→  }
   915→
   916→  // Save default sensitivity when changed
   917→  if (defaultSensitivity) {
   918→    defaultSensitivity.addEventListener('change', () => {
   919→      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });
   920→      // Also update the main slider
   921→      const mainSlider = document.getElementById('sensitivitySlider');
   922→      if (mainSlider) mainSlider.value = defaultSensitivity.value;
   923→    });
   924→  }
   925→
   926→  // Save remember options when changed
   927→  if (rememberOptions) {
   928→    rememberOptions.addEventListener('change', () => {
   929→      saveSettings({ rememberOptions: rememberOptions.checked });
   930→    });
   931→  }
   932→}
   933→
   934→/**
   935→ * Initialize options toggle (unified panel)
   936→ */
   937→function initOptionsToggles() {
   938→  const toggle = document.getElementById('optionsToggle');
   939→
   940→  if (toggle) {
   941→    toggle.addEventListener('click', () => toggleOptionsPanel());
   942→  }
   943→}
   944→
   945→/**
   946→ * Initialize preset selector
   947→ */
   948→function initPresetSelector() {
   949→  const presetSelector = document.getElementById('presetSelector');
   950→  const sensitivitySlider = document.getElementById('sensitivitySlider');
   951→
   952→  if (!presetSelector) return;
   953→
   954→  // Set initial value from settings
   955→  const settings = getSettings();
   956→  presetSelector.value = settings.activePreset || 'custom';
   957→
   958→  // Handle preset change (supports both built-in and custom presets)
   959→  presetSelector.addEventListener('change', () => {
   960→    const presetId = presetSelector.value;
   961→
   962→    // Get preset info (works for both built-in and custom)
   963→    const preset = getPresetById(presetId);
   964→    if (!preset) {
   965→      console.warn(`[SPLICE] Preset not found: ${presetId}`);
   966→      return;
   967→    }
   968→
   969→    let appliedSettings;
   970→
   971→    if (preset.isBuiltIn) {
   972→      // Built-in preset: use the existing applyPreset function
   973→      appliedSettings = applyPreset(presetId);
   974→    } else {
   975→      // Custom preset: apply stored settings
   976→      appliedSettings = preset.settings || {};
   977→      saveSettings({ activePreset: presetId, ...appliedSettings });
   978→    }
   979→
   980→    // Update sensitivity slider to match preset
   981→    if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {
   982→      sensitivitySlider.value = appliedSettings.sensitivity;
   983→    }
   984→
   985→    // Update takes detection checkbox
   986→    const enableTakesDetection = document.getElementById('enableTakesDetection');
   987→    if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {
   988→      enableTakesDetection.checked = appliedSettings.enableTakesDetection;
   989→    }
   990→
   991→    // Update auto-mark best checkbox
   992→    const autoMarkBest = document.getElementById('autoMarkBest');
   993→    if (autoMarkBest && appliedSettings.autoMarkBest !== undefined) {
   994→      autoMarkBest.checked = appliedSettings.autoMarkBest;
   995→    }
   996→
   997→    if (typeof setStatus === 'function') {
   998→      const desc = preset.description ? ` - ${preset.description}` : '';
   999→      setStatus(`Preset: ${preset.name}${desc}`);
  1000→    }
  1001→  });
  1002→
  1003→  // Switch to custom when user manually changes sensitivity
  1004→  if (sensitivitySlider) {
  1005→    sensitivitySlider.addEventListener('change', () => {
  1006→      if (presetSelector.value !== 'custom') {
  1007→        presetSelector.value = 'custom';
  1008→        saveSettings({ activePreset: 'custom' });
  1009→      }
  1010→    });
  1011→  }
  1012→}
  1013→
  1014→/**
  1015→ * Initialize help button
  1016→ */
  1017→function initHelpButton() {
  1018→  const helpBtn = document.getElementById('helpBtn');
  1019→  if (helpBtn) {
  1020→    helpBtn.addEventListener('click', () => {
  1021→      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');
  1022→    });
  1023→  }
  1024→}
  1025→
  1026→// =============================================================================
  1027→// PERSISTENT TOKEN MANAGEMENT (v3.5)
  1028→// =============================================================================
  1029→
  1030→/**
  1031→ * Media folder entry (cached after selection)
  1032→ * @type {Object|null}
  1033→ */
  1034→let mediaFolderEntry = null;
  1035→
  1036→/**
  1037→ * Prompt user to select a media folder and create a persistent token.
  1038→ * This allows silent file access without repeated permission prompts.
  1039→ *
  1040→ * @returns {Promise<{success: boolean, path?: string, error?: string}>}
  1041→ */
  1042→async function setupMediaFolder() {
  1043→  try {
  1044→    // Open folder picker dialog
  1045→    const folder = await uxpFs.getFolder();
  1046→
  1047→    if (!folder) {
  1048→      return { success: false, error: 'No folder selected' };
  1049→    }
  1050→
  1051→    // Create a persistent token for this folder
  1052→    const token = await uxpFs.createPersistentToken(folder);
  1053→
  1054→    if (!token) {
  1055→      return { success: false, error: 'Failed to create persistent token' };
  1056→    }
  1057→
  1058→    // Get the folder path for display
  1059→    const folderPath = folder.nativePath || folder.name;
  1060→
  1061→    // Save to settings
  1062→    saveSettings({
  1063→      mediaFolderToken: token,
  1064→      mediaFolderPath: folderPath
  1065→    });
  1066→
  1067→    // Cache the folder entry
  1068→    mediaFolderEntry = folder;
  1069→
  1070→    console.log(`[SPLICE] Media folder set: ${folderPath}`);
  1071→
  1072→    return {
  1073→      success: true,
  1074→      path: folderPath,
  1075→      token
  1076→    };
  1077→  } catch (err) {
  1078→    console.error('[SPLICE] Error setting up media folder:', err);
  1079→    return { success: false, error: err.message };
  1080→  }
  1081→}
  1082→
  1083→/**
  1084→ * Get the media folder entry using the stored persistent token.
  1085→ * Falls back to prompting if token is invalid.
  1086→ *
  1087→ * @returns {Promise<Object|null>} The folder entry or null
  1088→ */
  1089→async function getMediaFolder() {
  1090→  // Return cached entry if available
  1091→  if (mediaFolderEntry) {
  1092→    return mediaFolderEntry;
  1093→  }
  1094→
  1095→  const settings = getSettings();
  1096→
  1097→  // Try to restore from persistent token
  1098→  if (settings.mediaFolderToken) {
  1099→    try {
  1100→      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);
  1101→      if (folder) {
  1102→        mediaFolderEntry = folder;
  1103→        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);
  1104→        return folder;
  1105→      }
  1106→    } catch (err) {
  1107→      console.warn('[SPLICE] Could not restore media folder from token:', err.message);
  1108→      // Clear invalid token
  1109→      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });
  1110→    }
  1111→  }
  1112→
  1113→  return null;
  1114→}
  1115→
  1116→/**
  1117→ * Check if a media folder is configured
  1118→ * @returns {boolean}
  1119→ */
  1120→function hasMediaFolder() {
  1121→  const settings = getSettings();
  1122→  return !!settings.mediaFolderToken;
  1123→}
  1124→
  1125→/**
  1126→ * Get the configured media folder path (for display)
  1127→ * @returns {string|null}
  1128→ */
  1129→function getMediaFolderPath() {
  1130→  const settings = getSettings();
  1131→  return settings.mediaFolderPath;
  1132→}
  1133→
  1134→/**
  1135→ * Clear the media folder configuration
  1136→ */
  1137→function clearMediaFolder() {
  1138→  mediaFolderEntry = null;
  1139→  saveSettings({
  1140→    mediaFolderToken: null,
  1141→    mediaFolderPath: null
  1142→  });
  1143→  console.log('[SPLICE] Media folder cleared');
  1144→}
  1145→
  1146→/**
  1147→ * Read a file from the media folder
  1148→ * @param {string} filename - Name of the file to read
  1149→ * @returns {Promise<ArrayBuffer|null>} File contents or null
  1150→ */
  1151→async function readMediaFile(filename) {
  1152→  const folder = await getMediaFolder();
  1153→  if (!folder) {
  1154→    console.warn('[SPLICE] No media folder configured');
  1155→    return null;
  1156→  }
  1157→
  1158→  try {
  1159→    const file = await folder.getEntry(filename);
  1160→    if (!file) {
  1161→      console.warn(`[SPLICE] File not found in media folder: ${filename}`);
  1162→      return null;
  1163→    }
  1164→
  1165→    const contents = await file.read({ format: uxpFs.formats.binary });
  1166→    return contents;
  1167→  } catch (err) {
  1168→    console.error(`[SPLICE] Error reading file ${filename}:`, err);
  1169→    return null;
  1170→  }
  1171→}
  1172→
  1173→// =============================================================================
  1174→// LOGIN MODAL
  1175→// =============================================================================
  1176→
  1177→/**
  1178→ * Initialize login modal handlers
  1179→ */
  1180→function initLoginModal() {
  1181→  const loginModal = document.getElementById('loginModal');
  1182→  const closeLoginBtn = document.getElementById('closeLoginBtn');
  1183→  const saveLoginBtn = document.getElementById('saveLoginBtn');
  1184→  const customerIdInput = document.getElementById('customerIdInput');
  1185→  const loginError = document.getElementById('loginError');
  1186→  const creditBadge = document.getElementById('creditBadge');
  1187→
  1188→  // Show login modal when clicking credit badge (if not logged in)
  1189→  if (creditBadge) {
  1190→    creditBadge.addEventListener('click', () => {
  1191→      const settings = getSettings();
  1192→      if (!settings.customerId) {
  1193→        showLoginModal();
  1194→      }
  1195→    });
  1196→  }
  1197→
  1198→  // Close login modal
  1199→  if (closeLoginBtn && loginModal) {
  1200→    closeLoginBtn.addEventListener('click', () => {
  1201→      loginModal.classList.add('hidden');
  1202→    });
  1203→  }
  1204→
  1205→  // Close on backdrop click
  1206→  if (loginModal) {
  1207→    loginModal.addEventListener('click', (e) => {
  1208→      if (e.target === loginModal) {
  1209→        loginModal.classList.add('hidden');
  1210→      }
  1211→    });
  1212→  }
  1213→
  1214→  // Save customer ID
  1215→  if (saveLoginBtn) {
  1216→    saveLoginBtn.addEventListener('click', async () => {
  1217→      const customerId = customerIdInput?.value?.trim();
  1218→
  1219→      if (!customerId) {
  1220→        showLoginError('Please enter your customer ID');
  1221→        return;
  1222→      }
  1223→
  1224→      if (!customerId.startsWith('cus_')) {
  1225→        showLoginError('Customer ID should start with "cus_"');
  1226→        return;
  1227→      }
  1228→
  1229→      // Save to settings
  1230→      saveSettings({ customerId });
  1231→
  1232→      // Hide modal
  1233→      loginModal?.classList.add('hidden');
  1234→
  1235→      // Refresh credits display
  1236→      if (typeof refreshCredits === 'function') {
  1237→        await refreshCredits();
  1238→      }
  1239→
  1240→      if (typeof setStatus === 'function') {
  1241→        setStatus('Logged in successfully');
  1242→      }
  1243→    });
  1244→  }
  1245→
  1246→  // Load existing customer ID into input
  1247→  const settings = getSettings();
  1248→  if (customerIdInput && settings.customerId) {
  1249→    customerIdInput.value = settings.customerId;
  1250→  }
  1251→}
  1252→
  1253→/**
  1254→ * Show login modal
  1255→ */
  1256→function showLoginModal() {
  1257→  const loginModal = document.getElementById('loginModal');
  1258→  const loginError = document.getElementById('loginError');
  1259→
  1260→  if (loginError) {
  1261→    loginError.style.display = 'none';
  1262→  }
  1263→
  1264→  if (loginModal) {
  1265→    loginModal.classList.remove('hidden');
  1266→  }
  1267→}
  1268→
  1269→/**
  1270→ * Show login error message
  1271→ */
  1272→function showLoginError(message) {
  1273→  const loginError = document.getElementById('loginError');
  1274→  if (loginError) {
  1275→    loginError.textContent = message;
  1276→    loginError.style.display = 'block';
  1277→  }
  1278→}
  1279→
  1280→/**
  1281→ * Check if user is logged in
  1282→ * @returns {boolean}
  1283→ */
  1284→function isLoggedIn() {
  1285→  const settings = getSettings();
  1286→  return !!settings.customerId;
  1287→}
  1288→
  1289→/**
  1290→ * Get customer ID
  1291→ * @returns {string|null}
  1292→ */
  1293→function getCustomerId() {
  1294→  const settings = getSettings();
  1295→  return settings.customerId || null;
  1296→}
  1297→
  1298→/**
  1299→ * Logout - clear customer ID
  1300→ */
  1301→function logout() {
  1302→  saveSettings({ customerId: null });
  1303→  if (typeof setStatus === 'function') {
  1304→    setStatus('Logged out');
  1305→  }
  1306→}
  1307→
  1308→// Load settings on script load
  1309→loadSettings();
  1310→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
