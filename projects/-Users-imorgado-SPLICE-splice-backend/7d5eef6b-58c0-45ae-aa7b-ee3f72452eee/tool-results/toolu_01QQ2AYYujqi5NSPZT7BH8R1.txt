     1→/**
     2→ * Batch Routes
     3→ *
     4→ * Batch processing endpoints
     5→ */
     6→
     7→const express = require('express');
     8→const fs = require('fs');
     9→const { detectSilencesRMS, sensitivityToParams } = require('../services/rmsSilenceDetection');
    10→
    11→// In-memory job queue for batch processing
    12→const batchJobs = new Map();
    13→
    14→// Batch job limits to prevent memory leak
    15→const MAX_BATCH_JOBS = 10000;
    16→const BATCH_JOB_MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours
    17→
    18→/**
    19→ * Generate a unique job ID
    20→ */
    21→function generateJobId() {
    22→  return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    23→}
    24→
    25→/**
    26→ * Clean up old batch jobs to prevent memory leak
    27→ * Removes jobs older than 24 hours
    28→ */
    29→function cleanupOldBatchJobs() {
    30→  const now = Date.now();
    31→  let removedCount = 0;
    32→
    33→  for (const [jobId, job] of batchJobs.entries()) {
    34→    const createdAt = new Date(job.createdAt).getTime();
    35→    if (now - createdAt > BATCH_JOB_MAX_AGE_MS) {
    36→      batchJobs.delete(jobId);
    37→      removedCount++;
    38→    }
    39→  }
    40→
    41→  if (removedCount > 0) {
    42→    console.log(`[SPLICE] Cleaned up ${removedCount} old batch job(s)`);
    43→  }
    44→}
    45→
    46→/**
    47→ * Enforce max job limit by removing oldest completed jobs
    48→ */
    49→function enforceJobLimit() {
    50→  if (batchJobs.size < MAX_BATCH_JOBS) return;
    51→
    52→  // Get completed jobs sorted by creation date (oldest first)
    53→  const completedJobs = Array.from(batchJobs.entries())
    54→    .filter(([_, job]) => job.status !== 'processing')
    55→    .sort((a, b) => new Date(a[1].createdAt) - new Date(b[1].createdAt));
    56→
    57→  // Remove oldest completed jobs until under limit
    58→  const toRemove = batchJobs.size - MAX_BATCH_JOBS + 1;
    59→  for (let i = 0; i < Math.min(toRemove, completedJobs.length); i++) {
    60→    batchJobs.delete(completedJobs[i][0]);
    61→  }
    62→
    63→  console.log(`[SPLICE] Enforced job limit, removed ${Math.min(toRemove, completedJobs.length)} job(s)`);
    64→}
    65→
    66→// Run cleanup every hour
    67→setInterval(cleanupOldBatchJobs, 60 * 60 * 1000);
    68→
    69→/**
    70→ * Process a batch job (runs in background)
    71→ */
    72→async function processBatchJob(jobId, usageTracking) {
    73→  const job = batchJobs.get(jobId);
    74→  if (!job) return;
    75→
    76→  const { sensitivity, ...manualOptions } = job.options;
    77→
    78→  // Build detection options
    79→  let detectionOptions = {};
    80→  if (typeof sensitivity === 'number') {
    81→    detectionOptions = sensitivityToParams(sensitivity);
    82→  } else {
    83→    detectionOptions = {
    84→      threshold: manualOptions.threshold ?? -30,
    85→      minSilenceLength: manualOptions.minSilenceLength ?? 0.5,
    86→      paddingStart: manualOptions.paddingStart ?? 0.1,
    87→      paddingEnd: manualOptions.paddingEnd ?? 0.05,
    88→      autoThreshold: manualOptions.autoThreshold ?? false
    89→    };
    90→  }
    91→
    92→  // Process files with controlled parallelism (3 concurrent for disk I/O efficiency)
    93→  const CONCURRENCY_LIMIT = 3;
    94→  const chunks = [];
    95→  for (let i = 0; i < job.files.length; i += CONCURRENCY_LIMIT) {
    96→    chunks.push(job.files.slice(i, i + CONCURRENCY_LIMIT));
    97→  }
    98→
    99→  for (const chunk of chunks) {
   100→    // Mark chunk files as processing
   101→    chunk.forEach(f => f.status = 'processing');
   102→
   103→    // Process chunk in parallel
   104→    await Promise.all(
   105→      chunk.map(async (fileEntry) => {
   106→        try {
   107→          const result = await detectSilencesRMS(fileEntry.path, detectionOptions);
   108→
   109→          fileEntry.status = 'completed';
   110→          fileEntry.result = {
   111→            silences: result.silences,
   112→            count: result.silences.length,
   113→            totalSilenceDuration: result.metadata.totalSilenceDuration,
   114→            audioDuration: result.metadata.audioDuration
   115→          };
   116→
   117→          job.results.push({
   118→            file: fileEntry.path,
   119→            ...fileEntry.result
   120→          });
   121→
   122→          // Deduct usage for this file
   123→          const audioDuration = result.metadata?.audioDuration || 0;
   124→          if (audioDuration > 0 && job.stripeCustomerId && usageTracking) {
   125→            try {
   126→              await usageTracking.deductUsage(job.stripeCustomerId, audioDuration, 'batch-silences');
   127→              job.totalUsageDeducted += audioDuration;
   128→            } catch (usageErr) {
   129→              console.warn(`[SPLICE] Batch ${jobId}: Usage deduction failed:`, usageErr.message);
   130→            }
   131→          }
   132→
   133→          job.progress.completed++;
   134→          return { success: true, fileEntry };
   135→        } catch (err) {
   136→          fileEntry.status = 'failed';
   137→          fileEntry.error = err.message;
   138→
   139→          job.errors.push({
   140→            file: fileEntry.path,
   141→            error: err.message
   142→          });
   143→
   144→          job.progress.failed++;
   145→          console.error(`[SPLICE] Batch ${jobId}: ${fileEntry.path} failed:`, err.message);
   146→          return { success: false, fileEntry, error: err };
   147→        }
   148→      })
   149→    );
   150→
   151→    // Update progress after each chunk
   152→    job.progress.percentage = Math.round(
   153→      ((job.progress.completed + job.progress.failed) / job.progress.total) * 100
   154→    );
   155→    console.log(`[SPLICE] Batch ${jobId}: ${job.progress.completed + job.progress.failed}/${job.files.length} processed`);
   156→  }
   157→
   158→  // Mark job as complete
   159→  job.status = job.progress.failed === job.progress.total ? 'failed' :
   160→               job.progress.failed > 0 ? 'completed_with_errors' : 'completed';
   161→  job.completedAt = new Date().toISOString();
   162→
   163→  console.log(`[SPLICE] Batch job ${jobId} ${job.status}`);
   164→}
   165→
   166→/**
   167→ * Create batch routes
   168→ * @param {Object} options - Route configuration options
   169→ * @param {Object} options.middleware - Shared middleware (requireCredits)
   170→ * @param {Object} options.services - Shared services (usageTracking)
   171→ * @returns {express.Router}
   172→ */
   173→function createBatchRoutes(options = {}) {
   174→  const router = express.Router();
   175→  const { requireCredits } = options.middleware || {};
   176→  const { usageTracking } = options.services || {};
   177→
   178→  /**
   179→   * POST /silences - Process multiple files for silence detection
   180→   *
   181→   * Creates a batch job that processes multiple audio files.
   182→   * Returns a job ID for tracking progress.
   183→   *
   184→   * Body:
   185→   * - files: Array of file paths to process
   186→   * - options: Detection options (sensitivity, threshold, etc.)
   187→   */
   188→  router.post('/silences', requireCredits({ endpoint: 'batch-silences' }), async (req, res) => {
   189→    const { files, options: batchOptions = {} } = req.body;
   190→
   191→    if (!files || !Array.isArray(files) || files.length === 0) {
   192→      return res.status(400).json({ error: 'files array is required' });
   193→    }
   194→
   195→    // Validate all files exist
   196→    const missingFiles = files.filter(f => !fs.existsSync(f));
   197→    if (missingFiles.length > 0) {
   198→      return res.status(404).json({
   199→        error: 'Some files not found',
   200→        missingFiles
   201→      });
   202→    }
   203→
   204→    // Enforce job limit before creating new job
   205→    enforceJobLimit();
   206→
   207→    const jobId = generateJobId();
   208→
   209→    // Initialize job with customer ID for usage tracking
   210→    const job = {
   211→      id: jobId,
   212→      type: 'silences',
   213→      status: 'processing',
   214→      createdAt: new Date().toISOString(),
   215→      stripeCustomerId: req.stripeCustomerId,  // Store for usage deduction
   216→      files: files.map(f => ({
   217→        path: f,
   218→        status: 'pending',
   219→        result: null,
   220→        error: null
   221→      })),
   222→      options: batchOptions,
   223→      progress: {
   224→        total: files.length,
   225→        completed: 0,
   226→        failed: 0,
   227→        percentage: 0
   228→      },
   229→      results: [],
   230→      errors: [],
   231→      totalUsageDeducted: 0  // Track total seconds deducted
   232→    };
   233→
   234→    batchJobs.set(jobId, job);
   235→    console.log(`[SPLICE] Batch job ${jobId} created with ${files.length} files`);
   236→
   237→    // Start processing in background
   238→    processBatchJob(jobId, usageTracking);
   239→
   240→    res.json({
   241→      success: true,
   242→      jobId,
   243→      message: `Batch job created with ${files.length} files`,
   244→      statusUrl: `/batch/status/${jobId}`
   245→    });
   246→  });
   247→
   248→  /**
   249→   * GET /status/:jobId - Get batch job status and results
   250→   * Requires x-stripe-customer-id header matching job owner
   251→   */
   252→  router.get('/status/:jobId', (req, res) => {
   253→    const { jobId } = req.params;
   254→    const stripeCustomerId = req.headers['x-stripe-customer-id'];
   255→    const job = batchJobs.get(jobId);
   256→
   257→    if (!job) {
   258→      return res.status(404).json({ error: 'Job not found' });
   259→    }
   260→
   261→    // Verify customer ownership
   262→    if (job.stripeCustomerId && job.stripeCustomerId !== stripeCustomerId) {
   263→      return res.status(403).json({ error: 'Access denied: Job belongs to another user' });
   264→    }
   265→
   266→    res.json({
   267→      success: true,
   268→      job: {
   269→        id: job.id,
   270→        type: job.type,
   271→        status: job.status,
   272→        createdAt: job.createdAt,
   273→        completedAt: job.completedAt,
   274→        progress: job.progress,
   275→        files: job.files.map(f => ({
   276→          path: f.path,
   277→          status: f.status,
   278→          silenceCount: f.result?.count,
   279→          error: f.error
   280→        }))
   281→      }
   282→    });
   283→  });
   284→
   285→  /**
   286→   * GET /results/:jobId - Get full results for a completed batch job
   287→   * Requires x-stripe-customer-id header matching job owner
   288→   */
   289→  router.get('/results/:jobId', (req, res) => {
   290→    const { jobId } = req.params;
   291→    const stripeCustomerId = req.headers['x-stripe-customer-id'];
   292→    const job = batchJobs.get(jobId);
   293→
   294→    if (!job) {
   295→      return res.status(404).json({ error: 'Job not found' });
   296→    }
   297→
   298→    // Verify customer ownership
   299→    if (job.stripeCustomerId && job.stripeCustomerId !== stripeCustomerId) {
   300→      return res.status(403).json({ error: 'Access denied: Job belongs to another user' });
   301→    }
   302→
   303→    if (job.status === 'processing') {
   304→      return res.status(202).json({
   305→        success: false,
   306→        message: 'Job still processing',
   307→        progress: job.progress
   308→      });
   309→    }
   310→
   311→    res.json({
   312→      success: true,
   313→      jobId: job.id,
   314→      status: job.status,
   315→      progress: job.progress,
   316→      results: job.results,
   317→      errors: job.errors,
   318→      summary: {
   319→        totalFiles: job.progress.total,
   320→        successful: job.progress.completed,
   321→        failed: job.progress.failed,
   322→        totalSilences: job.results.reduce((sum, r) => sum + (r.count || 0), 0),
   323→        totalSilenceDuration: job.results.reduce((sum, r) => sum + (r.totalSilenceDuration || 0), 0)
   324→      }
   325→    });
   326→  });
   327→
   328→  /**
   329→   * DELETE /:jobId - Cancel or delete a batch job
   330→   * Requires x-stripe-customer-id header matching job owner
   331→   */
   332→  router.delete('/:jobId', (req, res) => {
   333→    const { jobId } = req.params;
   334→    const stripeCustomerId = req.headers['x-stripe-customer-id'];
   335→    const job = batchJobs.get(jobId);
   336→
   337→    if (!job) {
   338→      return res.status(404).json({ error: 'Job not found' });
   339→    }
   340→
   341→    // Verify customer ownership
   342→    if (job.stripeCustomerId && job.stripeCustomerId !== stripeCustomerId) {
   343→      return res.status(403).json({ error: 'Access denied: Job belongs to another user' });
   344→    }
   345→
   346→    // Note: This doesn't actually cancel in-progress processing
   347→    // but prevents the job from being queried
   348→    batchJobs.delete(jobId);
   349→
   350→    res.json({
   351→      success: true,
   352→      message: `Job ${jobId} deleted`
   353→    });
   354→  });
   355→
   356→  /**
   357→   * GET /jobs - List batch jobs for authenticated user
   358→   * Requires x-stripe-customer-id header to filter jobs by owner
   359→   */
   360→  router.get('/jobs', (req, res) => {
   361→    const stripeCustomerId = req.headers['x-stripe-customer-id'];
   362→
   363→    // Filter jobs by customer ownership (only show user's own jobs)
   364→    const jobs = Array.from(batchJobs.values())
   365→      .filter(job => !job.stripeCustomerId || job.stripeCustomerId === stripeCustomerId)
   366→      .map(job => ({
   367→        id: job.id,
   368→        type: job.type,
   369→        status: job.status,
   370→        createdAt: job.createdAt,
   371→        completedAt: job.completedAt,
   372→        progress: job.progress
   373→      }));
   374→
   375→    // Sort by creation date (newest first)
   376→    jobs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
   377→
   378→    res.json({
   379→      success: true,
   380→      count: jobs.length,
   381→      jobs
   382→    });
   383→  });
   384→
   385→  return router;
   386→}
   387→
   388→// Export job queue for cleanup access
   389→createBatchRoutes.batchJobs = batchJobs;
   390→createBatchRoutes.cleanupOldBatchJobs = cleanupOldBatchJobs;
   391→
   392→module.exports = createBatchRoutes;
   393→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
