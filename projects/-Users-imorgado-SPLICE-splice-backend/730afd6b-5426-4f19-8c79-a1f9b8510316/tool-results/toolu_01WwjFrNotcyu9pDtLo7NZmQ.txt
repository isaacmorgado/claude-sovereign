     1→/**
     2→ * Credits Display Module
     3→ *
     4→ * Fetches and displays user's remaining hours from the billing backend.
     5→ * Requires customerId to be set in settings.
     6→ *
     7→ * Uses getBackendUrl() from config.js for consistent URL handling.
     8→ */
     9→
    10→/**
    11→ * Fetch user's credit balance from backend
    12→ * @returns {Promise<Object | null>} Credit data including isolation hours
    13→ */
    14→async function fetchCredits() {
    15→  const settings = getSettings();
    16→  const customerId = settings.customerId;
    17→
    18→  if (!customerId) {
    19→    console.log('[SPLICE] No customerId configured - credits display disabled');
    20→    return null;
    21→  }
    22→
    23→  try {
    24→    const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {
    25→      method: 'GET',
    26→      headers: {
    27→        'x-stripe-customer-id': customerId
    28→      }
    29→    }, FETCH_TIMEOUT_DEFAULT);
    30→
    31→    if (!response.ok) {
    32→      const errorMsg = await parseErrorResponse(response);
    33→      console.error('[SPLICE] Credits fetch failed:', errorMsg);
    34→      return null;
    35→    }
    36→
    37→    const data = await response.json();
    38→    return {
    39→      hoursRemaining: data.hoursRemaining || 0,
    40→      hoursTotal: data.hoursTotal || 0,
    41→      tierName: data.tierName || 'Free',
    42→      tier: data.tier || 'starter',
    43→      // Isolation hours
    44→      isolationHoursRemaining: data.isolationHoursRemaining || 0,
    45→      isolationHoursTotal: data.isolationHoursTotal || 0,
    46→      hasIsolationAccess: data.hasIsolationAccess || false,
    47→      isolationOverageRate: data.isolationOverageRate || 0.08
    48→    };
    49→  } catch (err) {
    50→    console.error('[SPLICE] Credits fetch error:', err);
    51→    return null;
    52→  }
    53→}
    54→
    55→// Store current credits globally for access checks
    56→let currentCredits = null;
    57→
    58→/**
    59→ * Update the credit display in the UI
    60→ * @param {Object|null} credits - Credit data or null if unavailable
    61→ */
    62→function updateCreditDisplay(credits) {
    63→  currentCredits = credits;
    64→
    65→  const creditBadge = document.getElementById('creditBadge');
    66→  if (!creditBadge) return;
    67→
    68→  if (!credits) {
    69→    creditBadge.style.display = 'none';
    70→    return;
    71→  }
    72→
    73→  creditBadge.style.display = 'flex';
    74→  creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;
    75→
    76→  // Build tooltip with isolation info if available
    77→  let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;
    78→  if (credits.hasIsolationAccess) {
    79→    tooltip += `\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;
    80→  }
    81→  creditBadge.title = tooltip;
    82→
    83→  // Color based on remaining hours
    84→  if (credits.hoursRemaining <= 1) {
    85→    creditBadge.classList.add('low');
    86→    creditBadge.classList.remove('ok');
    87→  } else {
    88→    creditBadge.classList.add('ok');
    89→    creditBadge.classList.remove('low');
    90→  }
    91→
    92→  // Update isolation checkbox state based on tier access
    93→  updateIsolationCheckboxState(credits);
    94→}
    95→
    96→/**
    97→ * Update the isolation checkbox based on tier access
    98→ */
    99→function updateIsolationCheckboxState(credits) {
   100→  const isolatedCheckbox = document.getElementById('sourceIsolated');
   101→  const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');
   102→
   103→  if (!isolatedCheckbox) return;
   104→
   105→  if (!credits || !credits.hasIsolationAccess) {
   106→    // Disable isolation for non-Pro/Team users
   107→    isolatedCheckbox.disabled = true;
   108→    isolatedCheckbox.checked = false;
   109→    if (tierBadge) {
   110→      tierBadge.textContent = 'Pro+';
   111→      tierBadge.style.opacity = '1';
   112→    }
   113→  } else {
   114→    // Enable isolation for Pro/Team users
   115→    isolatedCheckbox.disabled = false;
   116→    if (tierBadge) {
   117→      // Show remaining isolation time
   118→      const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);
   119→      tierBadge.textContent = `${minsRemaining} min`;
   120→      tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';
   121→    }
   122→  }
   123→}
   124→
   125→/**
   126→ * Check if user can use isolation and get cost estimate
   127→ * @param {number} estimatedMinutes - Estimated audio duration in minutes
   128→ * @returns {Object} Access info with allowed, message, overageCost
   129→ */
   130→function checkIsolationAccess(estimatedMinutes = 0) {
   131→  if (!currentCredits) {
   132→    return { allowed: false, message: 'Credits not loaded', overageCost: 0 };
   133→  }
   134→
   135→  if (!currentCredits.hasIsolationAccess) {
   136→    return {
   137→      allowed: false,
   138→      message: 'Vocal isolation requires Pro or Team tier',
   139→      upgradeRequired: true,
   140→      overageCost: 0
   141→    };
   142→  }
   143→
   144→  const estimatedHours = estimatedMinutes / 60;
   145→  const remaining = currentCredits.isolationHoursRemaining;
   146→
   147→  if (remaining >= estimatedHours) {
   148→    return {
   149→      allowed: true,
   150→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
   151→      overageCost: 0
   152→    };
   153→  }
   154→
   155→  // Calculate overage
   156→  const overageMinutes = estimatedMinutes - (remaining * 60);
   157→  const overageCost = overageMinutes * currentCredits.isolationOverageRate;
   158→
   159→  return {
   160→    allowed: true,
   161→    message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,
   162→    overageCost,
   163→    overageMinutes
   164→  };
   165→}
   166→
   167→/**
   168→ * Get current credits (for access checks)
   169→ */
   170→function getCurrentCredits() {
   171→  return currentCredits;
   172→}
   173→
   174→// Store interval reference for cleanup
   175→let creditsRefreshInterval = null;
   176→
   177→/**
   178→ * Initialize credits display
   179→ * Fetches credits on load and sets up periodic refresh
   180→ */
   181→async function initCredits() {
   182→  // Clear any existing interval to prevent duplicates
   183→  if (creditsRefreshInterval) {
   184→    clearInterval(creditsRefreshInterval);
   185→  }
   186→
   187→  // Initial fetch
   188→  const credits = await fetchCredits();
   189→  updateCreditDisplay(credits);
   190→
   191→  // Refresh credits every 5 minutes
   192→  creditsRefreshInterval = setInterval(async () => {
   193→    const refreshedCredits = await fetchCredits();
   194→    updateCreditDisplay(refreshedCredits);
   195→  }, 5 * 60 * 1000);
   196→}
   197→
   198→/**
   199→ * Cleanup credits module - call on plugin unload
   200→ */
   201→function cleanupCredits() {
   202→  if (creditsRefreshInterval) {
   203→    clearInterval(creditsRefreshInterval);
   204→    creditsRefreshInterval = null;
   205→  }
   206→}
   207→
   208→/**
   209→ * Manually refresh credits (e.g., after a processing operation)
   210→ */
   211→async function refreshCredits() {
   212→  const credits = await fetchCredits();
   213→  updateCreditDisplay(credits);
   214→  return credits;
   215→}
   216→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
