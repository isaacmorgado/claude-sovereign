     1→# SPLICE E2E Audit Fixes
     2→
     3→## Process
     4→For each feature: Implement → E2E Test → Identify Bugs → Fix → Re-test → Pass → Next Feature
     5→
     6→---
     7→
     8→# Phase 1: UI Critical Fixes
     9→
    10→---
    11→
    12→## Feature 1.1: Replace confirm() with UXP Modal
    13→
    14→**Files:**
    15→- `splice-plugin/js/main.js:2182`
    16→- `splice-plugin/index.html` (add modal HTML)
    17→
    18→**Problem:** `confirm()` is a browser dialog that doesn't exist in UXP environment. Delete preset will crash.
    19→
    20→**Implementation:**
    21→1. Create reusable confirmation modal in `index.html`
    22→2. Add `showConfirmModal(title, message, onConfirm, onCancel)` function
    23→3. Replace `confirm()` call in `deletePreset()` with modal
    24→4. Add proper keyboard support (Escape to cancel, Enter to confirm)
    25→5. Style consistently with existing modals
    26→
    27→**E2E Test After Implementation:**
    28→- Click delete on a preset → modal appears (not browser dialog)
    29→- Click Cancel → modal closes, preset not deleted
    30→- Click Confirm → preset deleted, modal closes
    31→- Press Escape → modal closes, preset not deleted
    32→- Verify no JavaScript errors in UXP console
    33→- Test rapid open/close cycles
    34→
    35→**Fix any bugs found, re-test until passing, then proceed to 1.2**
    36→
    37→---
    38→
    39→## Feature 1.2: Replace FileReader with UXP File API
    40→
    41→**Files:**
    42→- `splice-plugin/js/main.js:2254-2277`
    43→
    44→**Problem:** `FileReader` API may not work in UXP. Import presets functionality will fail silently.
    45→
    46→**Implementation:**
    47→1. Replace `FileReader` with UXP `file.read()` method
    48→2. Use `uxpFs.getFileForOpening()` to get file entry
    49→3. Read file content using UXP async file API
    50→4. Parse JSON and import presets
    51→5. Add proper error handling for UXP file errors
    52→
    53→**E2E Test After Implementation:**
    54→- Click Import Presets → UXP file picker opens
    55→- Select valid JSON → presets imported correctly
    56→- Select invalid JSON → friendly error message
    57→- Cancel file picker → no errors, UI stable
    58→- Import large preset file (50+ presets) → works correctly
    59→- Verify in actual Premiere Pro UXP environment
    60→
    61→**Fix any bugs found, re-test until passing, then proceed to 1.3**
    62→
    63→---
    64→
    65→## Feature 1.3: Replace Inline onclick with addEventListener
    66→
    67→**Files:**
    68→- `splice-plugin/js/main.js:1607-1611` (batch list)
    69→- Any other inline handlers
    70→
    71→**Problem:** Inline `onclick` handlers in dynamically generated HTML may not work in UXP sandbox.
    72→
    73→**Implementation:**
    74→1. Remove `onclick="removeBatchItem(${i})"` from template literal
    75→2. Add unique IDs or data attributes to buttons
    76→3. Use event delegation on parent container
    77→4. Attach listener once: `batchList.addEventListener('click', handleBatchClick)`
    78→5. In handler, check `e.target` for button class/data attribute
    79→
    80→**E2E Test After Implementation:**
    81→- Add files to batch queue → remove buttons appear
    82→- Click remove button → file removed from queue
    83→- Add multiple files → each remove button works
    84→- Rapid add/remove → no errors
    85→- Verify no "function not found" errors in console
    86→
    87→**Fix any bugs found, re-test until passing, then proceed to 1.4**
    88→
    89→---
    90→
    91→## Feature 1.4: Fix input type="file" for UXP
    92→
    93→**Files:**
    94→- `splice-plugin/index.html:1100`
    95→- `splice-plugin/js/main.js` (import handler)
    96→
    97→**Problem:** HTML `<input type="file">` doesn't work in UXP. Must use `uxpFs.getFileForOpening()`.
    98→
    99→**Implementation:**
   100→1. Remove hidden file input from HTML
   101→2. Change Import button to directly call UXP file API
   102→3. Use `uxpFs.getFileForOpening({ types: ['json'] })`
   103→4. Read file content and process
   104→
   105→**E2E Test After Implementation:**
   106→- Click Import Presets → UXP native file picker opens
   107→- Verify JSON filter works
   108→- Select file → imports correctly
   109→- Cancel → no errors
   110→
   111→**Fix any bugs found, re-test until passing**
   112→
   113→---
   114→
   115→## Phase 1 Complete Checklist
   116→- [ ] 1.1 confirm() replaced with UXP modal
   117→- [ ] 1.2 FileReader replaced with UXP file API
   118→- [ ] 1.3 Inline onclick replaced with addEventListener
   119→- [ ] 1.4 File input replaced with UXP file API
   120→- [ ] All features work in actual Premiere Pro UXP environment
   121→- [ ] Ready for Phase 2
   122→
   123→---
   124→
   125→# Phase 2: Code Quality & Consistency
   126→
   127→---
   128→
   129→## Feature 2.1: Centralized URL Configuration
   130→
   131→**Files:**
   132→- `splice-plugin/js/config.js`
   133→- `splice-plugin/js/main.js:1292`
   134→- `splice-plugin/js/credits.js:10-13`
   135→- `splice-plugin/js/settings.js:1244`
   136→
   137→**Problem:** Three different URL fallback strategies causing inconsistent behavior.
   138→
   139→**Implementation:**
   140→1. Add `getBackendUrl()` function to `config.js`:
   141→   ```javascript
   142→   function getBackendUrl() {
   143→     if (typeof BACKEND_URL !== 'undefined') return BACKEND_URL;
   144→     return 'https://127.0.0.1:3847';
   145→   }
   146→   ```
   147→2. Export function and use in all files
   148→3. Remove duplicate fallback logic from each file
   149→4. Add production URL detection based on environment
   150→
   151→**E2E Test After Implementation:**
   152→- With BACKEND_URL defined → uses defined URL
   153→- Without BACKEND_URL → falls back to dev URL (not production, not localhost)
   154→- All fetch calls use same base URL
   155→- Test in dev and production modes
   156→
   157→**Fix any bugs found, re-test until passing, then proceed to 2.2**
   158→
   159→---
   160→
   161→## Feature 2.2: Remove Duplicate Function Definitions
   162→
   163→**Files:**
   164→- `splice-plugin/js/main.js:1098` vs `splice-plugin/js/utils.js:12` (formatTime)
   165→- `splice-plugin/js/main.js:1138` vs `splice-plugin/js/utils.js:36` (setStatus)
   166→- `splice-plugin/js/slice8-silence.js:138` vs `splice-plugin/js/slice9-razor.js:255` (showRazorSection)
   167→
   168→**Problem:** Duplicate functions cause confusion and potential inconsistent behavior.
   169→
   170→**Implementation:**
   171→1. Keep `formatTime()` in `utils.js` (add NaN check from main.js version)
   172→2. Keep `setStatus()` in `utils.js` (already fixed with null check)
   173→3. Keep `showRazorSection()` in `slice9-razor.js` only
   174→4. Remove duplicates from main.js and slice8-silence.js
   175→5. Ensure all files reference the canonical versions
   176→
   177→**E2E Test After Implementation:**
   178→- `formatTime(NaN)` returns safe value (not "NaN:NaN")
   179→- `setStatus()` works when element missing
   180→- `showRazorSection()` works from both silence and razor flows
   181→- No function redefinition warnings in console
   182→
   183→**Fix any bugs found, re-test until passing, then proceed to 2.3**
   184→
   185→---
   186→
   187→## Feature 2.3: Add Fetch Timeout Support
   188→
   189→**Files:**
   190→- `splice-plugin/js/config.js` (add timeout constant)
   191→- `splice-plugin/js/main.js` (all fetch calls)
   192→- `splice-plugin/js/credits.js` (fetch call)
   193→
   194→**Problem:** No timeout on fetch calls. If server hangs, UI freezes indefinitely.
   195→
   196→**Implementation:**
   197→1. Add `FETCH_TIMEOUT = 30000` to config.js
   198→2. Create `fetchWithTimeout(url, options, timeout)` helper:
   199→   ```javascript
   200→   async function fetchWithTimeout(url, options, timeout = FETCH_TIMEOUT) {
   201→     const controller = new AbortController();
   202→     const timeoutId = setTimeout(() => controller.abort(), timeout);
   203→     try {
   204→       const response = await fetch(url, { ...options, signal: controller.signal });
   205→       clearTimeout(timeoutId);
   206→       return response;
   207→     } catch (err) {
   208→       clearTimeout(timeoutId);
   209→       if (err.name === 'AbortError') throw new Error('Request timed out');
   210→       throw err;
   211→     }
   212→   }
   213→   ```
   214→3. Replace all `fetch()` calls with `fetchWithTimeout()`
   215→4. Use shorter timeout for health checks (5s)
   216→5. Use longer timeout for processing endpoints (60s)
   217→
   218→**E2E Test After Implementation:**
   219→- Normal request → completes successfully
   220→- Slow server → times out after configured duration
   221→- Timeout error → shows user-friendly message
   222→- Verify AbortController properly cleans up
   223→
   224→**Fix any bugs found, re-test until passing, then proceed to 2.4**
   225→
   226→---
   227→
   228→## Feature 2.4: Standardize Error Response Parsing
   229→
   230→**Files:**
   231→- `splice-plugin/js/credits.js:37`
   232→- `splice-plugin/js/main.js:1337`
   233→- All other fetch error handlers
   234→
   235→**Problem:** Inconsistent error parsing. Some use `.catch()`, some don't. Field access varies.
   236→
   237→**Implementation:**
   238→1. Create standardized `parseErrorResponse(response)` helper:
   239→   ```javascript
   240→   async function parseErrorResponse(response) {
   241→     try {
   242→       const data = await response.json();
   243→       return data.error || data.message || `Error ${response.status}`;
   244→     } catch {
   245→       return `Error ${response.status}: ${response.statusText}`;
   246→     }
   247→   }
   248→   ```
   249→2. Use in all fetch error handlers
   250→3. Ensure consistent error object structure expected
   251→
   252→**E2E Test After Implementation:**
   253→- Server returns `{ error: "message" }` → displays message
   254→- Server returns `{ message: "text" }` → displays text
   255→- Server returns invalid JSON → shows status code
   256→- Server returns empty body → shows status code
   257→
   258→**Fix any bugs found, re-test until passing**
   259→
   260→---
   261→
   262→## Phase 2 Complete Checklist
   263→- [ ] 2.1 Single getBackendUrl() function used everywhere
   264→- [ ] 2.2 No duplicate function definitions
   265→- [ ] 2.3 All fetch calls have timeout support
   266→- [ ] 2.4 Standardized error response parsing
   267→- [ ] Code is consistent and maintainable
   268→- [ ] Ready for Phase 3
   269→
   270→---
   271→
   272→# Phase 3: Performance Optimizations
   273→
   274→---
   275→
   276→## Feature 3.1: Optimize Levenshtein Distance Algorithm
   277→
   278→**Files:**
   279→- `splice-backend/services/repetitionDetection.js:429-456`
   280→
   281→**Problem:** O(n²) algorithm with new array allocation per call. Called in nested loops for large transcripts.
   282→
   283→**Implementation:**
   284→1. Use single-row DP (O(n) space instead of O(m×n)):
   285→   ```javascript
   286→   function levenshteinDistance(s1, s2) {
   287→     if (s1 === s2) return 0;
   288→     if (!s1.length) return s2.length;
   289→     if (!s2.length) return s1.length;
   290→
   291→     let prev = new Array(s2.length + 1);
   292→     let curr = new Array(s2.length + 1);
   293→
   294→     for (let j = 0; j <= s2.length; j++) prev[j] = j;
   295→
   296→     for (let i = 1; i <= s1.length; i++) {
   297→       curr[0] = i;
   298→       for (let j = 1; j <= s2.length; j++) {
   299→         const cost = s1[i-1] === s2[j-1] ? 0 : 1;
   300→         curr[j] = Math.min(
   301→           curr[j-1] + 1,
   302→           prev[j] + 1,
   303→           prev[j-1] + cost
   304→         );
   305→       }
   306→       [prev, curr] = [curr, prev];
   307→     }
   308→     return prev[s2.length];
   309→   }
   310→   ```
   311→2. Add early exit when distance exceeds threshold
   312→3. Pre-allocate reusable buffers at module level
   313→
   314→**E2E Test After Implementation:**
   315→- Run repetition detection on 1000-word transcript
   316→- Measure time before and after (target: 10x improvement)
   317→- Verify detection accuracy unchanged
   318→- Test with very long words (100+ chars)
   319→- Memory profile shows no growth
   320→
   321→**Fix any bugs found, re-test until passing, then proceed to 3.2**
   322→
   323→---
   324→
   325→## Feature 3.2: Fix Array Spread in Hot Loop
   326→
   327→**Files:**
   328→- `splice-backend/services/rmsSilenceDetection.js:203, 254-256`
   329→
   330→**Problem:** `concat()` creates new array each iteration. `Math.min(...array)` can overflow call stack.
   331→
   332→**Implementation:**
   333→1. Replace `concat()` with `push.apply()`:
   334→   ```javascript
   335→   // Before
   336→   allDBFSValues = allDBFSValues.concat(Array.from(dBFSValues));
   337→   // After
   338→   allDBFSValues.push.apply(allDBFSValues, Array.from(dBFSValues));
   339→   ```
   340→2. Replace `Math.min/max(...array)` with loop:
   341→   ```javascript
   342→   let minDB = Infinity, maxDB = -Infinity, sum = 0;
   343→   for (const v of allDBFSValues) {
   344→     if (v < minDB) minDB = v;
   345→     if (v > maxDB) maxDB = v;
   346→     sum += v;
   347→   }
   348→   const avgDB = sum / allDBFSValues.length;
   349→   ```
   350→
   351→**E2E Test After Implementation:**
   352→- Process 30-minute audio file
   353→- Verify no call stack overflow
   354→- Measure performance improvement (target: 5-10x for large files)
   355→- Verify min/max/avg values correct
   356→
   357→**Fix any bugs found, re-test until passing, then proceed to 3.3**
   358→
   359→---
   360→
   361→## Feature 3.3: Reduce Database Round-Trips
   362→
   363→**Files:**
   364→- `splice-backend/services/usageTracking.js:549-587`
   365→
   366→**Problem:** `deductUsage()` calls `getBalance()` at end, causing extra SELECT after UPDATE.
   367→
   368→**Implementation:**
   369→1. Use `RETURNING *` in UPDATE query:
   370→   ```javascript
   371→   const result = await client.query(
   372→     `UPDATE users
   373→      SET hours_remaining = hours_remaining - $2
   374→      WHERE stripe_customer_id = $1
   375→      RETURNING hours_remaining, hours_total, tier`,
   376→     [stripeCustomerId, hoursToDeduct]
   377→   );
   378→   ```
   379→2. Return updated values directly instead of calling getBalance()
   380→3. Apply same pattern to: `confirmReservation()`, `releaseReservation()`, `resetHours()`, `updateTier()`
   381→
   382→**E2E Test After Implementation:**
   383→- Deduct usage → verify correct balance returned
   384→- Verify only 1 database query per operation (check logs)
   385→- Measure response time improvement
   386→- Verify all returned fields correct
   387→
   388→**Fix any bugs found, re-test until passing, then proceed to 3.4**
   389→
   390→---
   391→
   392→## Feature 3.4: Add Cache TTL to Transcription
   393→
   394→**Files:**
   395→- `splice-backend/services/transcription.js:15-19`
   396→
   397→**Problem:** Cache entries never expire based on time. Stale entries persist for deleted files.
   398→
   399→**Implementation:**
   400→1. Add TTL to cache entries:
   401→   ```javascript
   402→   const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour
   403→
   404→   function cacheSet(key, value) {
   405→     while (transcriptCache.size >= MAX_CACHE_SIZE) {
   406→       const oldestKey = transcriptCache.keys().next().value;
   407→       transcriptCache.delete(oldestKey);
   408→     }
   409→     transcriptCache.set(key, {
   410→       ...value,
   411→       cachedAt: Date.now()
   412→     });
   413→   }
   414→
   415→   function cacheGet(key) {
   416→     const entry = transcriptCache.get(key);
   417→     if (!entry) return null;
   418→     if (Date.now() - entry.cachedAt > CACHE_TTL_MS) {
   419→       transcriptCache.delete(key);
   420→       return null;
   421→     }
   422→     return entry;
   423→   }
   424→   ```
   425→2. Update cache access to use `cacheGet()`
   426→3. Add periodic cleanup of expired entries
   427→
   428→**E2E Test After Implementation:**
   429→- Cache entry created → retrievable
   430→- Wait 1+ hour → entry expired, new API call made
   431→- Verify memory doesn't grow unbounded over time
   432→- Test cache stats show correct entry count
   433→
   434→**Fix any bugs found, re-test until passing**
   435→
   436→---
   437→
   438→## Phase 3 Complete Checklist
   439→- [ ] 3.1 Levenshtein optimized (10x faster)
   440→- [ ] 3.2 Array operations don't overflow stack
   441→- [ ] 3.3 Database round-trips reduced by 30-50%
   442→- [ ] 3.4 Cache entries expire after TTL
   443→- [ ] All performance benchmarks pass
   444→- [ ] Ready for Phase 4
   445→
   446→---
   447→
   448→# Phase 4: Architecture Improvements
   449→
   450→---
   451→
   452→## Feature 4.1: Fix Hardcoded File Paths
   453→
   454→**Files:**
   455→- `splice-plugin/js/config.js:9-10, 13`
   456→
   457→**Problem:** `/tmp` paths and hardcoded "Beta" app path will break on different systems.
   458→
   459→**Implementation:**
   460→1. Use UXP temp directory API:
   461→   ```javascript
   462→   const { localFileSystem } = require('uxp').storage;
   463→   const tempFolder = await localFileSystem.getTemporaryFolder();
   464→   const WAV_PATH = (await tempFolder.createFile('splice_audio_export.wav')).nativePath;
   465→   ```
   466→2. Detect Premiere Pro version dynamically
   467→3. Add fallback paths for different OS/versions
   468→4. Validate paths exist before use
   469→
   470→**E2E Test After Implementation:**
   471→- Plugin loads on macOS → correct temp paths
   472→- Plugin loads on Windows → correct temp paths
   473→- Non-beta Premiere Pro → correct app path
   474→- Invalid path → friendly error message
   475→
   476→**Fix any bugs found, re-test until passing, then proceed to 4.2**
   477→
   478→---
   479→
   480→## Feature 4.2: Add Missing ARIA Labels
   481→
   482→**Files:**
   483→- `splice-plugin/index.html` (multiple locations)
   484→
   485→**Problem:** Icon buttons lack ARIA labels, affecting accessibility.
   486→
   487→**Implementation:**
   488→1. Add `aria-label` to icon buttons:
   489→   ```html
   490→   <button aria-label="Help" title="Help">?</button>
   491→   <button aria-label="Toggle protected" title="Toggle protected">*</button>
   492→   ```
   493→2. Add `role="dialog"` and `aria-modal="true"` to modals
   494→3. Add `aria-live="polite"` to status message area
   495→4. Add keyboard navigation support (Tab order)
   496→
   497→**E2E Test After Implementation:**
   498→- Screen reader announces button purposes
   499→- Tab navigation follows logical order
   500→- Modal focus trapped correctly
   501→- Status updates announced
   502→
   503→**Fix any bugs found, re-test until passing, then proceed to 4.3**
   504→
   505→---
   506→
   507→## Feature 4.3: Fix ProjectItemType Constant
   508→
   509→**Files:**
   510→- `splice-plugin/js/builder.js:78`
   511→
   512→**Problem:** `pproBuilder.Constants.ProjectItemType.BIN` may be undefined in some UXP versions.
   513→
   514→**Implementation:**
   515→1. Add constant fallback at top of builder.js:
   516→   ```javascript
   517→   const ProjectItemType = pproBuilder?.Constants?.ProjectItemType || {
   518→     CLIP: 1,
   519→     BIN: 2,
   520→     ROOT: 3,
   521→     FILE: 4
   522→   };
   523→   ```
   524→2. Use local constant instead of API constant
   525→3. Match pattern already used in main.js:1222-1229
   526→
   527→**E2E Test After Implementation:**
   528→- Builder works when Constants undefined
   529→- Builder works when Constants defined
   530→- Recursive item search finds all items
   531→- No TypeError on project item iteration
   532→
   533→**Fix any bugs found, re-test until passing**
   534→
   535→---
   536→
   537→## Phase 4 Complete Checklist
   538→- [ ] 4.1 Dynamic file paths work cross-platform
   539→- [ ] 4.2 Accessibility labels added
   540→- [ ] 4.3 ProjectItemType fallback works
   541→- [ ] Plugin works on all supported systems
   542→- [ ] Ready for Phase 5
   543→
   544→---
   545→
   546→# Phase 5: Final Verification
   547→
   548→---
   549→
   550→## Test 1: UXP Environment Verification
   551→
   552→**Steps:**
   553→1. Load plugin in Premiere Pro 25.6+
   554→2. Open Settings modal → verify no browser dialogs
   555→3. Import presets → verify UXP file picker
   556→4. Delete preset → verify custom confirmation modal
   557→5. All buttons respond correctly
   558→6. No JavaScript errors in UXP console
   559→
   560→**Pass Criteria:** All UXP-specific features work
   561→
   562→---
   563→
   564→## Test 2: Performance Benchmark
   565→
   566→**Steps:**
   567→1. Process 10-minute audio file with repetition detection
   568→2. Measure time (target: <5 seconds for 1000 words)
   569→3. Process 30-minute audio with RMS silence detection
   570→4. Verify no memory issues or stack overflow
   571→5. Run 100 consecutive requests
   572→6. Verify no memory growth (< 50MB increase)
   573→
   574→**Pass Criteria:** All benchmarks within targets
   575→
   576→---
   577→
   578→## Test 3: Cross-Platform Verification
   579→
   580→**Steps:**
   581→1. Test on macOS with Premiere Pro release version
   582→2. Test on macOS with Premiere Pro Beta
   583→3. Test on Windows (if available)
   584→4. Verify temp paths work on each platform
   585→5. Verify no hardcoded path failures
   586→
   587→**Pass Criteria:** Works on all tested platforms
   588→
   589→---
   590→
   591→## Test 4: Full E2E Flow
   592→
   593→**Steps:**
   594→1. Fresh plugin install
   595→2. Configure settings (customer ID, preferences)
   596→3. Run GO on test video → silences detected
   597→4. Build Sequence → new sequence created
   598→5. Export captions → file created
   599→6. Verify credits deducted correctly
   600→7. Logout → verify state cleared
   601→8. Login → verify fresh state
   602→
   603→**Pass Criteria:** Complete workflow succeeds
   604→
   605→---
   606→
   607→## Final Checklist
   608→
   609→| Test | Status |
   610→|------|--------|
   611→| 1. UXP Environment | ⬜ |
   612→| 2. Performance Benchmark | ⬜ |
   613→| 3. Cross-Platform | ⬜ |
   614→| 4. Full E2E Flow | ⬜ |
   615→
   616→## If Any Test Fails
   617→1. Log failure with specific step and error
   618→2. Trace to root cause (file:line)
   619→3. Fix the issue
   620→4. Re-run failed test
   621→5. If pass, continue
   622→6. If fail, repeat fix cycle
   623→
   624→## Completion Criteria
   625→All 4 tests passing = SPLICE E2E fixes complete and verified
   626→
   627→---
   628→
   629→# Summary of Already Fixed Issues
   630→
   631→The following issues were already fixed during the initial E2E audit:
   632→
   633→| Issue | File | Status |
   634→|-------|------|--------|
   635→| Wrong localhost fallback | `main.js:1292` | FIXED |
   636→| Production URL fallback | `credits.js:12` | FIXED |
   637→| Missing await on lockedAccess | `slice8-silence.js`, `slice7-apply.js` | FIXED |
   638→| Null dereference in setStatus | `utils.js:37` | FIXED |
   639→| Memory leak (interval not cleared) | `credits.js:189` | FIXED |
   640→| Sync fs.existsSync blocking | `server.js` (9 locations) | FIXED |
   641→
   642→---
   643→
   644→*Each phase prompt is self-contained. Complete the features with E2E testing, then move to the next phase. Phase 5 is the final comprehensive validation.*
   645→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
