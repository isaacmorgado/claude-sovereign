     1â†’/**
     2â†’ * Phase 2: Runtime E2E Tests
     3â†’ *
     4â†’ * Actually exercises the implemented features at runtime:
     5â†’ * - fetchWithTimeout with real network calls
     6â†’ * - parseErrorResponse with actual responses
     7â†’ * - API calls using the new patterns
     8â†’ */
     9â†’
    10â†’const https = require('https');
    11â†’
    12â†’// Disable SSL verification for self-signed certs (dev only)
    13â†’process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
    14â†’
    15â†’// Test helpers
    16â†’let passed = 0;
    17â†’let failed = 0;
    18â†’
    19â†’function test(name, fn) {
    20â†’  try {
    21â†’    fn();
    22â†’    console.log(`  âœ“ ${name}`);
    23â†’    passed++;
    24â†’  } catch (err) {
    25â†’    console.log(`  âœ— ${name}`);
    26â†’    console.log(`    Error: ${err.message}`);
    27â†’    failed++;
    28â†’  }
    29â†’}
    30â†’
    31â†’async function asyncTest(name, fn) {
    32â†’  try {
    33â†’    await fn();
    34â†’    console.log(`  âœ“ ${name}`);
    35â†’    passed++;
    36â†’  } catch (err) {
    37â†’    console.log(`  âœ— ${name}`);
    38â†’    console.log(`    Error: ${err.message}`);
    39â†’    failed++;
    40â†’  }
    41â†’}
    42â†’
    43â†’// ============================================================================
    44â†’// Implement the functions exactly as they are in config.js
    45â†’// ============================================================================
    46â†’
    47â†’const BACKEND_URL_DEV = 'https://127.0.0.1:3847';
    48â†’const FETCH_TIMEOUT_DEFAULT = 30000;
    49â†’const FETCH_TIMEOUT_HEALTH = 5000;
    50â†’const FETCH_TIMEOUT_PROCESSING = 120000;
    51â†’
    52â†’function getBackendUrl() {
    53â†’  return BACKEND_URL_DEV;
    54â†’}
    55â†’
    56â†’async function parseErrorResponse(response) {
    57â†’  try {
    58â†’    const data = await response.json();
    59â†’    return data.error || data.message || `Error ${response.status}`;
    60â†’  } catch {
    61â†’    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
    62â†’  }
    63â†’}
    64â†’
    65â†’// Use https.request for proper self-signed cert handling
    66â†’function httpsRequest(url, options = {}) {
    67â†’  return new Promise((resolve, reject) => {
    68â†’    const parsedUrl = new URL(url);
    69â†’    const reqOptions = {
    70â†’      hostname: parsedUrl.hostname,
    71â†’      port: parsedUrl.port || 443,
    72â†’      path: parsedUrl.pathname + parsedUrl.search,
    73â†’      method: options.method || 'GET',
    74â†’      headers: options.headers || {},
    75â†’      rejectUnauthorized: false
    76â†’    };
    77â†’
    78â†’    const req = https.request(reqOptions, (res) => {
    79â†’      let data = '';
    80â†’      res.on('data', chunk => data += chunk);
    81â†’      res.on('end', () => {
    82â†’        resolve({
    83â†’          ok: res.statusCode >= 200 && res.statusCode < 300,
    84â†’          status: res.statusCode,
    85â†’          statusText: res.statusMessage,
    86â†’          json: async () => JSON.parse(data),
    87â†’          text: async () => data,
    88â†’          clone: function() { return this; }
    89â†’        });
    90â†’      });
    91â†’    });
    92â†’
    93â†’    req.on('error', reject);
    94â†’
    95â†’    if (options.body) {
    96â†’      req.write(options.body);
    97â†’    }
    98â†’    req.end();
    99â†’  });
   100â†’}
   101â†’
   102â†’function httpsRequestWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT_DEFAULT) {
   103â†’  return new Promise((resolve, reject) => {
   104â†’    const parsedUrl = new URL(url);
   105â†’    const reqOptions = {
   106â†’      hostname: parsedUrl.hostname,
   107â†’      port: parsedUrl.port || 443,
   108â†’      path: parsedUrl.pathname + parsedUrl.search,
   109â†’      method: options.method || 'GET',
   110â†’      headers: options.headers || {},
   111â†’      rejectUnauthorized: false,
   112â†’      timeout: timeout
   113â†’    };
   114â†’
   115â†’    const req = https.request(reqOptions, (res) => {
   116â†’      let data = '';
   117â†’      res.on('data', chunk => data += chunk);
   118â†’      res.on('end', () => {
   119â†’        resolve({
   120â†’          ok: res.statusCode >= 200 && res.statusCode < 300,
   121â†’          status: res.statusCode,
   122â†’          statusText: res.statusMessage,
   123â†’          json: async () => JSON.parse(data),
   124â†’          text: async () => data,
   125â†’          clone: function() { return this; }
   126â†’        });
   127â†’      });
   128â†’    });
   129â†’
   130â†’    req.on('timeout', () => {
   131â†’      req.destroy();
   132â†’      reject(new Error('Request timed out'));
   133â†’    });
   134â†’
   135â†’    req.on('error', (err) => {
   136â†’      if (err.code === 'ECONNRESET') {
   137â†’        reject(new Error('Request timed out'));
   138â†’      } else {
   139â†’        reject(err);
   140â†’      }
   141â†’    });
   142â†’
   143â†’    if (options.body) {
   144â†’      req.write(options.body);
   145â†’    }
   146â†’    req.end();
   147â†’  });
   148â†’}
   149â†’
   150â†’// Aliases for cleaner test code
   151â†’const nodeFetch = httpsRequest;
   152â†’const nodeFetchWithTimeout = httpsRequestWithTimeout;
   153â†’
   154â†’// ============================================================================
   155â†’// Main test runner (properly awaits async tests)
   156â†’// ============================================================================
   157â†’async function runAllTests() {
   158â†’
   159â†’// ============================================================================
   160â†’// Feature 2.1: Centralized URL Configuration - Runtime Tests
   161â†’// ============================================================================
   162â†’console.log('\nðŸ”Œ Feature 2.1: Centralized URL Runtime Tests\n');
   163â†’
   164â†’test('getBackendUrl returns correct dev URL', () => {
   165â†’  const url = getBackendUrl();
   166â†’  if (url !== 'https://127.0.0.1:3847') {
   167â†’    throw new Error(`Expected https://127.0.0.1:3847, got ${url}`);
   168â†’  }
   169â†’});
   170â†’
   171â†’await await asyncTest('Backend health check responds at configured URL', async () => {
   172â†’  const url = `${getBackendUrl()}/health`;
   173â†’  const response = await nodeFetch(url);
   174â†’  if (!response.ok) {
   175â†’    throw new Error(`Health check failed with status ${response.status}`);
   176â†’  }
   177â†’  const data = await response.json();
   178â†’  if (data.status !== 'ok') {
   179â†’    throw new Error(`Expected status "ok", got "${data.status}"`);
   180â†’  }
   181â†’});
   182â†’
   183â†’// ============================================================================
   184â†’// Feature 2.3: Fetch Timeout - Runtime Tests
   185â†’// ============================================================================
   186â†’console.log('\nâ±ï¸ Feature 2.3: Fetch Timeout Runtime Tests\n');
   187â†’
   188â†’await asyncTest('fetchWithTimeout completes fast requests successfully', async () => {
   189â†’  const response = await nodeFetchWithTimeout(`${getBackendUrl()}/health`, {}, 5000);
   190â†’  if (!response.ok) {
   191â†’    throw new Error(`Request failed with status ${response.status}`);
   192â†’  }
   193â†’});
   194â†’
   195â†’await asyncTest('fetchWithTimeout throws on very short timeout', async () => {
   196â†’  try {
   197â†’    // Use a 1ms timeout - request cannot complete this fast
   198â†’    await nodeFetchWithTimeout(`${getBackendUrl()}/health`, {}, 1);
   199â†’    throw new Error('Should have timed out');
   200â†’  } catch (err) {
   201â†’    if (!err.message.includes('timed out') && err.name !== 'AbortError') {
   202â†’      throw new Error(`Expected timeout error, got: ${err.message}`);
   203â†’    }
   204â†’  }
   205â†’});
   206â†’
   207â†’await asyncTest('Health endpoint responds within FETCH_TIMEOUT_HEALTH (5s)', async () => {
   208â†’  const start = Date.now();
   209â†’  const response = await nodeFetchWithTimeout(`${getBackendUrl()}/health`, {}, FETCH_TIMEOUT_HEALTH);
   210â†’  const elapsed = Date.now() - start;
   211â†’
   212â†’  if (!response.ok) {
   213â†’    throw new Error(`Health check failed with status ${response.status}`);
   214â†’  }
   215â†’  if (elapsed > FETCH_TIMEOUT_HEALTH) {
   216â†’    throw new Error(`Request took ${elapsed}ms, exceeds ${FETCH_TIMEOUT_HEALTH}ms timeout`);
   217â†’  }
   218â†’});
   219â†’
   220â†’// ============================================================================
   221â†’// Feature 2.4: Error Response Parsing - Runtime Tests
   222â†’// ============================================================================
   223â†’console.log('\nðŸ”´ Feature 2.4: Error Parsing Runtime Tests\n');
   224â†’
   225â†’await asyncTest('parseErrorResponse handles 404 with error field', async () => {
   226â†’  // Call an endpoint that doesn't exist
   227â†’  const response = await nodeFetch(`${getBackendUrl()}/nonexistent-endpoint-xyz`);
   228â†’  if (response.ok) {
   229â†’    throw new Error('Expected 404, got success');
   230â†’  }
   231â†’
   232â†’  const errorMsg = await parseErrorResponse(response);
   233â†’  // Should contain "404" or an error message
   234â†’  if (!errorMsg && response.status !== 404) {
   235â†’    throw new Error(`Expected error message, got empty`);
   236â†’  }
   237â†’});
   238â†’
   239â†’await asyncTest('parseErrorResponse handles missing auth header (401/403)', async () => {
   240â†’  // Call credits endpoint without auth header
   241â†’  const response = await nodeFetch(`${getBackendUrl()}/credits`);
   242â†’
   243â†’  // Clone response to read body twice
   244â†’  const clonedResponse = response.clone();
   245â†’
   246â†’  if (response.status === 401 || response.status === 403 || response.status === 400) {
   247â†’    const errorMsg = await parseErrorResponse(clonedResponse);
   248â†’    if (!errorMsg) {
   249â†’      throw new Error('Expected error message for auth failure');
   250â†’    }
   251â†’  }
   252â†’});
   253â†’
   254â†’await asyncTest('parseErrorResponse handles invalid JSON gracefully', async () => {
   255â†’  // Create a mock response with invalid JSON
   256â†’  const mockResponse = {
   257â†’    status: 500,
   258â†’    statusText: 'Internal Server Error',
   259â†’    json: async () => { throw new SyntaxError('Invalid JSON'); }
   260â†’  };
   261â†’
   262â†’  const errorMsg = await parseErrorResponse(mockResponse);
   263â†’  if (!errorMsg.includes('500')) {
   264â†’    throw new Error(`Expected status code in message, got: ${errorMsg}`);
   265â†’  }
   266â†’});
   267â†’
   268â†’// ============================================================================
   269â†’// Integration Tests: Full API Calls with New Patterns
   270â†’// ============================================================================
   271â†’console.log('\nðŸ”— Integration Tests: Full API Patterns\n');
   272â†’
   273â†’await asyncTest('Credits endpoint with proper headers returns data or auth error', async () => {
   274â†’  const response = await nodeFetchWithTimeout(`${getBackendUrl()}/credits`, {
   275â†’    method: 'GET',
   276â†’    headers: {
   277â†’      'x-stripe-customer-id': 'cus_test_nonexistent'
   278â†’    }
   279â†’  }, FETCH_TIMEOUT_DEFAULT);
   280â†’
   281â†’  // Either success with data or proper error response
   282â†’  if (response.ok) {
   283â†’    const data = await response.json();
   284â†’    // Should have expected fields
   285â†’    if (typeof data.hoursRemaining === 'undefined') {
   286â†’      throw new Error('Missing hoursRemaining in response');
   287â†’    }
   288â†’  } else {
   289â†’    // Should return parseable error
   290â†’    const errorMsg = await parseErrorResponse(response);
   291â†’    if (!errorMsg) {
   292â†’      throw new Error('Expected error message for failed request');
   293â†’    }
   294â†’  }
   295â†’});
   296â†’
   297â†’await asyncTest('FFprobe check endpoint works with timeout', async () => {
   298â†’  const response = await nodeFetchWithTimeout(
   299â†’    `${getBackendUrl()}/ffprobe-check`,
   300â†’    {},
   301â†’    FETCH_TIMEOUT_HEALTH
   302â†’  );
   303â†’
   304â†’  if (!response.ok) {
   305â†’    throw new Error(`FFprobe check failed: ${response.status}`);
   306â†’  }
   307â†’
   308â†’  const data = await response.json();
   309â†’  // Should have installed field
   310â†’  if (typeof data.installed !== 'boolean') {
   311â†’    throw new Error('Missing installed field in ffprobe-check response');
   312â†’  }
   313â†’});
   314â†’
   315â†’await asyncTest('API metadata endpoint returns version info', async () => {
   316â†’  const response = await nodeFetchWithTimeout(
   317â†’    `${getBackendUrl()}/`,
   318â†’    {},
   319â†’    FETCH_TIMEOUT_DEFAULT
   320â†’  );
   321â†’
   322â†’  if (!response.ok) {
   323â†’    throw new Error(`API metadata failed: ${response.status}`);
   324â†’  }
   325â†’
   326â†’  const data = await response.json();
   327â†’  if (!data.service || !data.version) {
   328â†’    throw new Error('Missing service or version in API metadata');
   329â†’  }
   330â†’});
   331â†’
   332â†’await asyncTest('Silences endpoint requires auth (returns proper error)', async () => {
   333â†’  const response = await nodeFetchWithTimeout(
   334â†’    `${getBackendUrl()}/silences-audio`,
   335â†’    {
   336â†’      method: 'POST',
   337â†’      headers: { 'Content-Type': 'application/json' },
   338â†’      body: JSON.stringify({ wavPath: '/tmp/test.wav' })
   339â†’    },
   340â†’    FETCH_TIMEOUT_DEFAULT
   341â†’  );
   342â†’
   343â†’  // Should return auth error, not crash
   344â†’  if (response.ok) {
   345â†’    // Might succeed if no auth required in dev mode
   346â†’    console.log('    (Note: endpoint succeeded without auth - dev mode?)');
   347â†’  } else {
   348â†’    const errorMsg = await parseErrorResponse(response);
   349â†’    if (!errorMsg) {
   350â†’      throw new Error('Expected parseable error response');
   351â†’    }
   352â†’  }
   353â†’});
   354â†’
   355â†’// ============================================================================
   356â†’// Concurrent Request Tests
   357â†’// ============================================================================
   358â†’console.log('\nâš¡ Concurrent Request Tests\n');
   359â†’
   360â†’await asyncTest('Multiple concurrent requests complete successfully', async () => {
   361â†’  const urls = [
   362â†’    `${getBackendUrl()}/health`,
   363â†’    `${getBackendUrl()}/`,
   364â†’    `${getBackendUrl()}/ffprobe-check`
   365â†’  ];
   366â†’
   367â†’  const promises = urls.map(url =>
   368â†’    nodeFetchWithTimeout(url, {}, FETCH_TIMEOUT_DEFAULT)
   369â†’  );
   370â†’
   371â†’  const responses = await Promise.all(promises);
   372â†’
   373â†’  for (let i = 0; i < responses.length; i++) {
   374â†’    if (!responses[i].ok) {
   375â†’      throw new Error(`Request ${i} failed: ${responses[i].status}`);
   376â†’    }
   377â†’  }
   378â†’});
   379â†’
   380â†’await asyncTest('Rapid sequential requests work correctly', async () => {
   381â†’  for (let i = 0; i < 5; i++) {
   382â†’    const response = await nodeFetchWithTimeout(
   383â†’      `${getBackendUrl()}/health`,
   384â†’      {},
   385â†’      FETCH_TIMEOUT_HEALTH
   386â†’    );
   387â†’    if (!response.ok) {
   388â†’      throw new Error(`Request ${i + 1}/5 failed`);
   389â†’    }
   390â†’  }
   391â†’});
   392â†’
   393â†’// ============================================================================
   394â†’// Summary
   395â†’// ============================================================================
   396â†’console.log('\n' + '='.repeat(60));
   397â†’console.log(`Phase 2 Runtime Tests: ${passed} passed, ${failed} failed`);
   398â†’console.log('='.repeat(60) + '\n');
   399â†’
   400â†’if (failed > 0) {
   401â†’  process.exit(1);
   402â†’}
   403â†’
   404â†’} // End of runAllTests function
   405â†’
   406â†’// Run all tests
   407â†’runAllTests().catch(err => {
   408â†’  console.error('Test runner error:', err);
   409â†’  process.exit(1);
   410â†’});
   411â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
