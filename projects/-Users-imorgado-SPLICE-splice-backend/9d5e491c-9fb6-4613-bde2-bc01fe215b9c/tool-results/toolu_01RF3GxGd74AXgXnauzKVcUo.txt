     1→     1→/**
     2→     2→ * Phase 4: Production Blockers E2E Tests
     3→     3→ *
     4→     4→ * Tests for:
     5→     5→ * 1. Login/Auth UI - customer ID storage and retrieval
     6→     6→ * 2. Auth headers - proper header injection in requests
     7→     7→ * 3. Rate limiting - requireCredits middleware on endpoints
     8→     8→ * 4. Error messages - user-friendly build error formatting
     9→     9→ */
    10→    10→
    11→    11→// Simulate localStorage for Node.js testing
    12→    12→const storage = { data: {} };
    13→    13→global.localStorage = {
    14→    14→  getItem: (key) => storage.data[key] || null,
    15→    15→  setItem: (key, value) => { storage.data[key] = value; },
    16→    16→  removeItem: (key) => { delete storage.data[key]; },
    17→    17→  clear: () => { storage.data = {}; }
    18→    18→};
    19→    19→
    20→    20→function resetLocalStorage() {
    21→    21→  storage.data = {};
    22→    22→}
    23→    23→
    24→    24→// Suppress console noise
    25→    25→const originalWarn = console.warn;
    26→    26→const originalError = console.error;
    27→    27→console.warn = () => {};
    28→    28→console.error = () => {};
    29→    29→
    30→    30→// =============================================================================
    31→    31→// COPY OF SETTINGS FUNCTIONS (for testing without UXP)
    32→    32→// =============================================================================
    33→    33→
    34→    34→const DEFAULT_SETTINGS = {
    35→    35→  sensitivity: 50,
    36→    36→  audioSource: 'original',
    37→    37→  autoMarkBest: true,
    38→    38→  enableTakesDetection: true,
    39→    39→  rememberOptions: false,
    40→    40→  optionsExpanded: false,
    41→    41→  customerId: null,
    42→    42→  mediaFolderToken: null,
    43→    43→  mediaFolderPath: null,
    44→    44→  activePreset: 'custom'
    45→    45→};
    46→    46→
    47→    47→let currentSettings = { ...DEFAULT_SETTINGS };
    48→    48→
    49→    49→function loadSettings() {
    50→    50→  try {
    51→    51→    const saved = localStorage.getItem('spliceSettings');
    52→    52→    if (saved) {
    53→    53→      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
    54→    54→    }
    55→    55→  } catch (e) {
    56→    56→    currentSettings = { ...DEFAULT_SETTINGS };
    57→    57→  }
    58→    58→  return currentSettings;
    59→    59→}
    60→    60→
    61→    61→function saveSettings(settings) {
    62→    62→  try {
    63→    63→    currentSettings = { ...currentSettings, ...settings };
    64→    64→    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
    65→    65→  } catch (e) {
    66→    66→    // Silent fail
    67→    67→  }
    68→    68→}
    69→    69→
    70→    70→function getSettings() {
    71→    71→  return { ...currentSettings };
    72→    72→}
    73→    73→
    74→    74→function isLoggedIn() {
    75→    75→  const settings = getSettings();
    76→    76→  return !!settings.customerId;
    77→    77→}
    78→    78→
    79→    79→function getCustomerId() {
    80→    80→  const settings = getSettings();
    81→    81→  return settings.customerId || null;
    82→    82→}
    83→    83→
    84→    84→function logout() {
    85→    85→  saveSettings({ customerId: null });
    86→    86→}
    87→    87→
    88→    88→// =============================================================================
    89→    89→// COPY OF AUTH HEADERS FUNCTION (from main.js)
    90→    90→// =============================================================================
    91→    91→
    92→    92→function getAuthHeaders() {
    93→    93→  const headers = { 'Content-Type': 'application/json' };
    94→    94→  const settings = getSettings();
    95→    95→  if (settings.customerId) {
    96→    96→    headers['x-stripe-customer-id'] = settings.customerId;
    97→    97→  }
    98→    98→  return headers;
    99→    99→}
   100→   100→
   101→   101→// =============================================================================
   102→   102→// COPY OF ERROR FORMATTING FUNCTION (from main.js)
   103→   103→// =============================================================================
   104→   104→
   105→   105→function formatBuildError(error) {
   106→   106→  if (!error) return 'Unknown error occurred';
   107→   107→
   108→   108→  const errorMap = {
   109→   109→    'Builder not initialized': 'Builder module failed to load. Try restarting the plugin.',
   110→   110→    'No active project': 'No project is open. Please open or create a project first.',
   111→   111→    'No media items found': 'No media files in project. Import media before building.',
   112→   112→    'No detection data': 'Run analysis first (click GO button).',
   113→   113→    'Failed to generate cut list': 'Server error generating cuts. Check your connection.',
   114→   114→    'Failed to build sequence': 'Premiere Pro sequence build failed. Try again.',
   115→   115→    'fetch failed': 'Network error. Check if backend server is running.',
   116→   116→    'NetworkError': 'Cannot connect to server. Check your internet connection.',
   117→   117→    'Insufficient credits': 'Out of credits. Upgrade your plan to continue.',
   118→   118→    'Authentication required': 'Login required. Click the credits badge to log in.'
   119→   119→  };
   120→   120→
   121→   121→  for (const [pattern, friendly] of Object.entries(errorMap)) {
   122→   122→    if (error.includes(pattern)) {
   123→   123→      return friendly;
   124→   124→    }
   125→   125→  }
   126→   126→
   127→   127→  return error;
   128→   128→}
   129→   129→
   130→   130→// =============================================================================
   131→   131→// TEST FRAMEWORK
   132→   132→// =============================================================================
   133→   133→
   134→   134→let passCount = 0;
   135→   135→let failCount = 0;
   136→   136→
   137→   137→function test(name, fn) {
   138→   138→  try {
   139→   139→    fn();
   140→   140→    passCount++;
   141→   141→    console.log(`  ✓ ${name}`);
   142→   142→  } catch (err) {
   143→   143→    failCount++;
   144→   144→    console.log(`  ✗ ${name}`);
   145→   145→    console.log(`    Error: ${err.message}`);
   146→   146→  }
   147→   147→}
   148→   148→
   149→   149→function assertEqual(actual, expected, message = '') {
   150→   150→  if (actual !== expected) {
   151→   151→    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
   152→   152→  }
   153→   153→}
   154→   154→
   155→   155→function assertTrue(condition, message = '') {
   156→   156→  if (!condition) {
   157→   157→    throw new Error(`${message}: Expected true, got false`);
   158→   158→  }
   159→   159→}
   160→   160→
   161→   161→function assertFalse(condition, message = '') {
   162→   162→  if (condition) {
   163→   163→    throw new Error(`${message}: Expected false, got true`);
   164→   164→  }
   165→   165→}
   166→   166→
   167→   167→function assertNotNull(value, message = '') {
   168→   168→  if (value === null || value === undefined) {
   169→   169→    throw new Error(`${message}: Expected non-null value`);
   170→   170→  }
   171→   171→}
   172→   172→
   173→   173→function assertIncludes(arr, item, message = '') {
   174→   174→  if (!arr || !arr.includes) {
   175→   175→    throw new Error(`${message}: Not an array`);
   176→   176→  }
   177→   177→  if (!arr.includes(item)) {
   178→   178→    throw new Error(`${message}: Array does not include ${item}`);
   179→   179→  }
   180→   180→}
   181→   181→
   182→   182→// =============================================================================
   183→   183→// TEST SUITES
   184→   184→// =============================================================================
   185→   185→
   186→   186→console.log('\n=== Phase 4: Production Blockers E2E Tests ===\n');
   187→   187→
   188→   188→// -----------------------------------------------------------------------------
   189→   189→// Test Suite 1: Login/Auth UI - Customer ID Storage
   190→   190→// -----------------------------------------------------------------------------
   191→   191→
   192→   192→console.log('1. Login/Auth UI - Customer ID Storage');
   193→   193→
   194→   194→test('should start with no customer ID', () => {
   195→   195→  resetLocalStorage();
   196→   196→  currentSettings = { ...DEFAULT_SETTINGS };
   197→   197→  loadSettings();
   198→   198→  assertFalse(isLoggedIn(), 'Should not be logged in initially');
   199→   199→  assertEqual(getCustomerId(), null, 'Customer ID should be null');
   200→   200→});
   201→   201→
   202→   202→test('should save customer ID via saveSettings', () => {
   203→   203→  resetLocalStorage();
   204→   204→  currentSettings = { ...DEFAULT_SETTINGS };
   205→   205→  saveSettings({ customerId: 'cus_test123' });
   206→   206→  assertEqual(getCustomerId(), 'cus_test123', 'Customer ID should be saved');
   207→   207→  assertTrue(isLoggedIn(), 'Should be logged in after saving');
   208→   208→});
   209→   209→
   210→   210→test('should persist customer ID across loadSettings', () => {
   211→   211→  // Keep existing localStorage from previous test
   212→   212→  currentSettings = { ...DEFAULT_SETTINGS };
   213→   213→  loadSettings();
   214→   214→  assertEqual(getCustomerId(), 'cus_test123', 'Customer ID should persist');
   215→   215→  assertTrue(isLoggedIn(), 'Should still be logged in');
   216→   216→});
   217→   217→
   218→   218→test('should clear customer ID on logout', () => {
   219→   219→  logout();
   220→   220→  assertEqual(getCustomerId(), null, 'Customer ID should be cleared');
   221→   221→  assertFalse(isLoggedIn(), 'Should not be logged in after logout');
   222→   222→});
   223→   223→
   224→   224→test('should validate customer ID format (starts with cus_)', () => {
   225→   225→  resetLocalStorage();
   226→   226→  currentSettings = { ...DEFAULT_SETTINGS };
   227→   227→  saveSettings({ customerId: 'cus_valid123' });
   228→   228→  const customerId = getCustomerId();
   229→   229→  assertTrue(customerId.startsWith('cus_'), 'Valid ID starts with cus_');
   230→   230→});
   231→   231→
   232→   232→// -----------------------------------------------------------------------------
   233→   233→// Test Suite 2: Auth Headers
   234→   234→// -----------------------------------------------------------------------------
   235→   235→
   236→   236→console.log('\n2. Auth Headers');
   237→   237→
   238→   238→test('should include Content-Type in headers', () => {
   239→   239→  resetLocalStorage();
   240→   240→  currentSettings = { ...DEFAULT_SETTINGS };
   241→   241→  const headers = getAuthHeaders();
   242→   242→  assertEqual(headers['Content-Type'], 'application/json', 'Content-Type header');
   243→   243→});
   244→   244→
   245→   245→test('should NOT include customer ID when not logged in', () => {
   246→   246→  resetLocalStorage();
   247→   247→  currentSettings = { ...DEFAULT_SETTINGS };
   248→   248→  const headers = getAuthHeaders();
   249→   249→  assertEqual(headers['x-stripe-customer-id'], undefined, 'No customer ID header');
   250→   250→});
   251→   251→
   252→   252→test('should include customer ID when logged in', () => {
   253→   253→  resetLocalStorage();
   254→   254→  currentSettings = { ...DEFAULT_SETTINGS };
   255→   255→  saveSettings({ customerId: 'cus_auth_test' });
   256→   256→  const headers = getAuthHeaders();
   257→   257→  assertEqual(headers['x-stripe-customer-id'], 'cus_auth_test', 'Customer ID header');
   258→   258→});
   259→   259→
   260→   260→test('should update headers after login', () => {
   261→   261→  resetLocalStorage();
   262→   262→  currentSettings = { ...DEFAULT_SETTINGS };
   263→   263→
   264→   264→  // Before login
   265→   265→  let headers = getAuthHeaders();
   266→   266→  assertEqual(headers['x-stripe-customer-id'], undefined, 'No header before login');
   267→   267→
   268→   268→  // After login
   269→   269→  saveSettings({ customerId: 'cus_new_user' });
   270→   270→  headers = getAuthHeaders();
   271→   271→  assertEqual(headers['x-stripe-customer-id'], 'cus_new_user', 'Header after login');
   272→   272→});
   273→   273→
   274→   274→test('should remove headers after logout', () => {
   275→   275→  saveSettings({ customerId: 'cus_will_logout' });
   276→   276→  let headers = getAuthHeaders();
   277→   277→  assertEqual(headers['x-stripe-customer-id'], 'cus_will_logout', 'Header before logout');
   278→   278→
   279→   279→  logout();
   280→   280→  headers = getAuthHeaders();
   281→   281→  assertEqual(headers['x-stripe-customer-id'], undefined, 'No header after logout');
   282→   282→});
   283→   283→
   284→   284→// -----------------------------------------------------------------------------
   285→   285→// Test Suite 3: Error Message Formatting
   286→   286→// -----------------------------------------------------------------------------
   287→   287→
   288→   288→console.log('\n3. Error Message Formatting');
   289→   289→
   290→   290→test('should format "Builder not initialized" error', () => {
   291→   291→  const result = formatBuildError('Builder not initialized');
   292→   292→  assertEqual(result, 'Builder module failed to load. Try restarting the plugin.', 'Builder error');
   293→   293→});
   294→   294→
   295→   295→test('should format "No active project" error', () => {
   296→   296→  const result = formatBuildError('No active project');
   297→   297→  assertEqual(result, 'No project is open. Please open or create a project first.', 'Project error');
   298→   298→});
   299→   299→
   300→   300→test('should format "No media items found" error', () => {
   301→   301→  const result = formatBuildError('No media items found in project');
   302→   302→  assertEqual(result, 'No media files in project. Import media before building.', 'Media error');
   303→   303→});
   304→   304→
   305→   305→test('should format "No detection data" error', () => {
   306→   306→  const result = formatBuildError('No detection data found');
   307→   307→  assertEqual(result, 'Run analysis first (click GO button).', 'Detection error');
   308→   308→});
   309→   309→
   310→   310→test('should format "Failed to generate cut list" error', () => {
   311→   311→  const result = formatBuildError('Failed to generate cut list: timeout');
   312→   312→  assertEqual(result, 'Server error generating cuts. Check your connection.', 'Cut list error');
   313→   313→});
   314→   314→
   315→   315→test('should format "Failed to build sequence" error', () => {
   316→   316→  const result = formatBuildError('Failed to build sequence');
   317→   317→  assertEqual(result, 'Premiere Pro sequence build failed. Try again.', 'Build error');
   318→   318→});
   319→   319→
   320→   320→test('should format network errors', () => {
   321→   321→  const result1 = formatBuildError('TypeError: fetch failed');
   322→   322→  assertEqual(result1, 'Network error. Check if backend server is running.', 'Fetch error');
   323→   323→
   324→   324→  const result2 = formatBuildError('NetworkError when attempting to fetch');
   325→   325→  assertEqual(result2, 'Cannot connect to server. Check your internet connection.', 'Network error');
   326→   326→});
   327→   327→
   328→   328→test('should format auth errors', () => {
   329→   329→  const result1 = formatBuildError('Insufficient credits');
   330→   330→  assertEqual(result1, 'Out of credits. Upgrade your plan to continue.', 'Credits error');
   331→   331→
   332→   332→  const result2 = formatBuildError('Authentication required');
   333→   333→  assertEqual(result2, 'Login required. Click the credits badge to log in.', 'Auth error');
   334→   334→});
   335→   335→
   336→   336→test('should return original error if no match', () => {
   337→   337→  const result = formatBuildError('Some random error message');
   338→   338→  assertEqual(result, 'Some random error message', 'Passthrough unknown error');
   339→   339→});
   340→   340→
   341→   341→test('should handle null/undefined errors', () => {
   342→   342→  const result1 = formatBuildError(null);
   343→   343→  assertEqual(result1, 'Unknown error occurred', 'Null error');
   344→   344→
   345→   345→  const result2 = formatBuildError(undefined);
   346→   346→  assertEqual(result2, 'Unknown error occurred', 'Undefined error');
   347→   347→
   348→   348→  const result3 = formatBuildError('');
   349→   349→  assertEqual(result3, 'Unknown error occurred', 'Empty error');
   350→   350→});
   351→   351→
   352→   352→// -----------------------------------------------------------------------------
   353→   353→// Test Suite 4: Rate Limiting Endpoints (verification)
   354→   354→// -----------------------------------------------------------------------------
   355→   355→
   356→   356→console.log('\n4. Rate Limiting Verification');
   357→   357→
   358→   358→// These tests verify that the endpoints have requireCredits middleware
   359→   359→// by checking the server.js source code patterns
   360→   360→
   361→   361→const fs = require('fs');
   362→   362→const path = require('path');
   363→   363→
   364→   364→let serverSource = '';
   365→   365→try {
   366→   366→  serverSource = fs.readFileSync(path.join(__dirname, '../server.js'), 'utf8');
   367→   367→} catch (e) {
   368→   368→  console.log('  [Warning: Could not read server.js for verification]');
   369→   369→}
   370→   370→
   371→   371→if (serverSource) {
   372→   372→  const endpointsToCheck = [
   373→   373→    { path: '/silences-audio', pattern: "app.post('/silences-audio', requireCredits" },
   374→   374→    { path: '/repetitions', pattern: "app.post('/repetitions', requireCredits" },
   375→   375→    { path: '/fillers', pattern: "app.post('/fillers', requireCredits" },
   376→   376→    { path: '/stutters', pattern: "app.post('/stutters', requireCredits" },
   377→   377→    { path: '/export/captions', pattern: "app.post('/export/captions', requireCredits" },
   378→   378→    { path: '/multitrack/auto-balance', pattern: "app.post('/multitrack/auto-balance', requireCredits" },
   379→   379→    { path: '/batch/silences', pattern: "app.post('/batch/silences', requireCredits" },
   380→   380→    { path: '/isolate-vocals', pattern: "app.post('/isolate-vocals', requireCredits" }
   381→   381→  ];
   382→   382→
   383→   383→  for (const endpoint of endpointsToCheck) {
   384→   384→    test(`should have requireCredits on ${endpoint.path}`, () => {
   385→   385→      assertTrue(
   386→   386→        serverSource.includes(endpoint.pattern),
   387→   387→        `${endpoint.path} should have requireCredits middleware`
   388→   388→      );
   389→   389→    });
   390→   390→  }
   391→   391→}
   392→   392→
   393→   393→// -----------------------------------------------------------------------------
   394→   394→// Test Suite 4b: Usage Deduction Verification
   395→   395→// -----------------------------------------------------------------------------
   396→   396→
   397→   397→console.log('\n4b. Usage Deduction Verification');
   398→   398→
   399→   399→if (serverSource) {
   400→   400→  const endpointsWithDeduction = [
   401→   401→    { name: '/analyze', pattern: 'req.deductUsage(audioDuration)' },
   402→   402→    { name: '/silences', pattern: 'req.deductUsage(audioDuration)' },
   403→   403→    { name: '/silences-audio', pattern: 'req.deductUsage(audioDuration)' },
   404→   404→    { name: '/silences-rms', pattern: 'req.deductUsage(audioDuration)' },
   405→   405→    { name: '/profanity', pattern: 'req.deductUsage(audioDuration)' },
   406→   406→    { name: '/repetitions', pattern: 'req.deductUsage(audioDuration)' },
   407→   407→    { name: '/fillers', pattern: 'req.deductUsage(audioDuration)' },
   408→   408→    { name: '/stutters', pattern: 'req.deductUsage(audioDuration)' },
   409→   409→    { name: '/export/captions', pattern: 'req.deductUsage(audioDuration)' },
   410→   410→    { name: '/multitrack', pattern: 'req.deductUsage(audioDuration)' },
   411→   411→    { name: '/multitrack/auto-balance', pattern: 'req.deductUsage(audioDuration)' },
   412→   412→    { name: 'batch processing', pattern: 'usageTracking.deductUsage(job.stripeCustomerId' }
   413→   413→  ];
   414→   414→
   415→   415→  for (const endpoint of endpointsWithDeduction) {
   416→   416→    test(`should deduct usage in ${endpoint.name}`, () => {
   417→   417→      assertTrue(
   418→   418→        serverSource.includes(endpoint.pattern),
   419→   419→        `${endpoint.name} should call deductUsage`
   420→   420→      );
   421→   421→    });
   422→   422→  }
   423→   423→}
   424→   424→
   425→   425→// -----------------------------------------------------------------------------
   426→   426→// Test Suite 5: Integration - Full Auth Flow
   427→   427→// -----------------------------------------------------------------------------
   428→   428→
   429→   429→console.log('\n5. Integration - Full Auth Flow');
   430→   430→
   431→   431→test('should handle complete login flow', () => {
   432→   432→  resetLocalStorage();
   433→   433→  currentSettings = { ...DEFAULT_SETTINGS };
   434→   434→
   435→   435→  // 1. Start logged out
   436→   436→  assertFalse(isLoggedIn(), 'Step 1: Not logged in');
   437→   437→  let headers = getAuthHeaders();
   438→   438→  assertEqual(headers['x-stripe-customer-id'], undefined, 'Step 1: No header');
   439→   439→
   440→   440→  // 2. Login
   441→   441→  saveSettings({ customerId: 'cus_integration_test' });
   442→   442→  assertTrue(isLoggedIn(), 'Step 2: Now logged in');
   443→   443→  headers = getAuthHeaders();
   444→   444→  assertEqual(headers['x-stripe-customer-id'], 'cus_integration_test', 'Step 2: Has header');
   445→   445→
   446→   446→  // 3. Persist across page reload (simulate)
   447→   447→  currentSettings = { ...DEFAULT_SETTINGS };
   448→   448→  loadSettings();
   449→   449→  assertTrue(isLoggedIn(), 'Step 3: Still logged in');
   450→   450→  assertEqual(getCustomerId(), 'cus_integration_test', 'Step 3: ID persisted');
   451→   451→
   452→   452→  // 4. Logout
   453→   453→  logout();
   454→   454→  assertFalse(isLoggedIn(), 'Step 4: Logged out');
   455→   455→  headers = getAuthHeaders();
   456→   456→  assertEqual(headers['x-stripe-customer-id'], undefined, 'Step 4: No header');
   457→   457→});
   458→   458→
   459→   459→test('should handle customer ID change', () => {
   460→   460→  resetLocalStorage();
   461→   461→  currentSettings = { ...DEFAULT_SETTINGS };
   462→   462→
   463→   463→  // Login with first ID
   464→   464→  saveSettings({ customerId: 'cus_first_id' });
   465→   465→  assertEqual(getCustomerId(), 'cus_first_id', 'First ID set');
   466→   466→
   467→   467→  // Change to new ID
   468→   468→  saveSettings({ customerId: 'cus_second_id' });
   469→   469→  assertEqual(getCustomerId(), 'cus_second_id', 'Second ID set');
   470→   470→
   471→   471→  // Verify headers updated
   472→   472→  const headers = getAuthHeaders();
   473→   473→  assertEqual(headers['x-stripe-customer-id'], 'cus_second_id', 'Headers updated');
   474→   474→});
   475→   475→
   476→   476→// =============================================================================
   477→   477→// SUMMARY
   478→   478→// =============================================================================
   479→   479→
   480→   480→console.log('\n=== Test Summary ===');
   481→   481→console.log(`  Passed: ${passCount}`);
   482→   482→console.log(`  Failed: ${failCount}`);
   483→   483→console.log(`  Total: ${passCount + failCount}`);
   484→   484→
   485→   485→// Restore console
   486→   486→console.warn = originalWarn;
   487→   487→console.error = originalError;
   488→   488→
   489→   489→if (failCount > 0) {
   490→   490→  console.log('\n❌ Some tests failed');
   491→   491→  process.exit(1);
   492→   492→} else {
   493→   493→  console.log('\n✓ All Phase 4 tests passed');
   494→   494→  process.exit(0);
   495→   495→}
   496→   496→
   497→
   498→<system-reminder>
   499→Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
   500→</system-reminder>
   501→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
