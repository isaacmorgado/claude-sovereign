     1→/**
     2→ * SPLICE Plugin Configuration
     3→ *
     4→ * Constants and configuration values used across all slices.
     5→ */
     6→
     7→// Backend API configuration
     8→const BACKEND_URL_DEV = 'https://127.0.0.1:3847';
     9→const BACKEND_URL_PROD = 'https://splice-api-production.up.railway.app';
    10→
    11→// Default to dev URL - production detection handled by getBackendUrl()
    12→const BACKEND_URL = BACKEND_URL_DEV;
    13→
    14→/**
    15→ * Get the backend URL with consistent fallback logic.
    16→ * Used across all plugin modules for API calls.
    17→ * @returns {string} Backend API base URL
    18→ */
    19→function getBackendUrl() {
    20→  // Check if explicitly defined
    21→  if (typeof BACKEND_URL !== 'undefined' && BACKEND_URL) {
    22→    return BACKEND_URL;
    23→  }
    24→  // Fallback to dev URL (use 127.0.0.1, not localhost - UXP requirement)
    25→  return BACKEND_URL_DEV;
    26→}
    27→
    28→const WAV_PATH = '/tmp/splice_audio_export.wav';
    29→const XML_PATH = '/tmp/splice_export.xml';
    30→
    31→// WAV export preset path (Premiere Pro Beta)
    32→const WAV_PRESET_PATH = '/Applications/Adobe Premiere Pro (Beta)/Adobe Premiere Pro (Beta).app/Contents/Settings/EncoderPresets/Wave48mono16.epr';
    33→
    34→// Premiere Pro timebase (ticks per second)
    35→const TICKS_PER_SECOND = 254016000000;
    36→
    37→// Fetch timeout configuration (milliseconds)
    38→const FETCH_TIMEOUT_DEFAULT = 30000;      // 30 seconds for most requests
    39→const FETCH_TIMEOUT_HEALTH = 5000;        // 5 seconds for health checks
    40→const FETCH_TIMEOUT_PROCESSING = 120000;  // 2 minutes for processing endpoints
    41→
    42→/**
    43→ * Fetch with timeout support (AbortController-based).
    44→ * Prevents UI from freezing if server hangs.
    45→ * @param {string} url - URL to fetch
    46→ * @param {Object} options - Fetch options
    47→ * @param {number} [timeout] - Timeout in milliseconds (default: FETCH_TIMEOUT_DEFAULT)
    48→ * @returns {Promise<Response>} Fetch response
    49→ * @throws {Error} 'Request timed out' if timeout exceeded
    50→ */
    51→async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT_DEFAULT) {
    52→  const controller = new AbortController();
    53→  const timeoutId = setTimeout(() => controller.abort(), timeout);
    54→
    55→  try {
    56→    const response = await fetch(url, {
    57→      ...options,
    58→      signal: controller.signal
    59→    });
    60→    clearTimeout(timeoutId);
    61→    return response;
    62→  } catch (err) {
    63→    clearTimeout(timeoutId);
    64→    if (err.name === 'AbortError') {
    65→      throw new Error('Request timed out');
    66→    }
    67→    throw err;
    68→  }
    69→}
    70→
    71→/**
    72→ * Parse error response from API with consistent fallback.
    73→ * Handles various error response formats gracefully.
    74→ * @param {Response} response - Fetch response object
    75→ * @returns {Promise<string>} Error message string
    76→ */
    77→async function parseErrorResponse(response) {
    78→  try {
    79→    const data = await response.json();
    80→    return data.error || data.message || `Error ${response.status}`;
    81→  } catch {
    82→    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
    83→  }
    84→}
    85→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
