     1→/**
     2→ * Custom Presets E2E Tests
     3→ *
     4→ * Tests for Phase 1: Custom Presets Foundation
     5→ * Each feature is tested individually then together.
     6→ */
     7→
     8→// Simulate localStorage for Node.js testing - using object wrapper for proper reset
     9→const storage = { data: {} };
    10→global.localStorage = {
    11→  getItem: (key) => storage.data[key] || null,
    12→  setItem: (key, value) => { storage.data[key] = value; },
    13→  removeItem: (key) => { delete storage.data[key]; },
    14→  clear: () => { storage.data = {}; }
    15→};
    16→
    17→// Helper to reset localStorage
    18→function resetLocalStorage() {
    19→  storage.data = {};
    20→}
    21→
    22→// Mock console.warn to avoid noise
    23→const originalWarn = console.warn;
    24→console.warn = () => {};
    25→
    26→// =============================================================================
    27→// COPY OF FUNCTIONS FROM settings.js (for testing without UXP)
    28→// =============================================================================
    29→
    30→const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';
    31→
    32→const DEFAULT_CUSTOM_PRESETS = {
    33→  version: 1,
    34→  presets: {},
    35→  order: []
    36→};
    37→
    38→function loadCustomPresets() {
    39→  try {
    40→    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    41→    if (saved) {
    42→      const parsed = JSON.parse(saved);
    43→      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
    44→        return {
    45→          version: parsed.version || 1,
    46→          presets: { ...parsed.presets } || {},
    47→          order: [...(parsed.order || [])]
    48→        };
    49→      }
    50→    }
    51→  } catch (e) {
    52→    // Silently handle parse errors
    53→  }
    54→  // Return a DEEP copy of defaults to avoid mutation issues
    55→  return {
    56→    version: 1,
    57→    presets: {},
    58→    order: []
    59→  };
    60→}
    61→
    62→function saveCustomPresets(data) {
    63→  try {
    64→    if (!data || typeof data !== 'object') {
    65→      return false;
    66→    }
    67→    const toSave = {
    68→      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
    69→      presets: data.presets || {},
    70→      order: data.order || []
    71→    };
    72→    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    73→    return true;
    74→  } catch (e) {
    75→    return false;
    76→  }
    77→}
    78→
    79→// Slugify function
    80→function slugifyPresetName(name) {
    81→  return name
    82→    .toLowerCase()
    83→    .trim()
    84→    .replace(/[^a-z0-9]+/g, '-')
    85→    .replace(/^-+|-+$/g, '')
    86→    .substring(0, 50) || 'preset';
    87→}
    88→
    89→// Generate unique ID
    90→function generateUniquePresetId(baseName, existingPresets) {
    91→  const baseId = slugifyPresetName(baseName);
    92→  let id = baseId;
    93→  let counter = 1;
    94→
    95→  while (existingPresets[id]) {
    96→    id = `${baseId}-${counter}`;
    97→    counter++;
    98→  }
    99→
   100→  return id;

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
