     1â†’     1â†’/**
     2â†’     2â†’ * Phase 2: Code Quality & Consistency E2E Tests
     3â†’     3â†’ *
     4â†’     4â†’ * Tests for:
     5â†’     5â†’ * - 2.1: Centralized URL configuration
     6â†’     6â†’ * - 2.2: No duplicate function definitions
     7â†’     7â†’ * - 2.3: Fetch timeout support
     8â†’     8â†’ * - 2.4: Standardized error response parsing
     9â†’     9â†’ */
    10â†’    10â†’
    11â†’    11â†’const fs = require('fs');
    12â†’    12â†’const path = require('path');
    13â†’    13â†’const assert = require('assert');
    14â†’    14â†’
    15â†’    15â†’// Test helpers
    16â†’    16â†’let passed = 0;
    17â†’    17â†’let failed = 0;
    18â†’    18â†’
    19â†’    19â†’function test(name, fn) {
    20â†’    20â†’  try {
    21â†’    21â†’    fn();
    22â†’    22â†’    console.log(`  âœ“ ${name}`);
    23â†’    23â†’    passed++;
    24â†’    24â†’  } catch (err) {
    25â†’    25â†’    console.log(`  âœ— ${name}`);
    26â†’    26â†’    console.log(`    Error: ${err.message}`);
    27â†’    27â†’    failed++;
    28â†’    28â†’  }
    29â†’    29â†’}
    30â†’    30â†’
    31â†’    31â†’async function asyncTest(name, fn) {
    32â†’    32â†’  try {
    33â†’    33â†’    await fn();
    34â†’    34â†’    console.log(`  âœ“ ${name}`);
    35â†’    35â†’    passed++;
    36â†’    36â†’  } catch (err) {
    37â†’    37â†’    console.log(`  âœ— ${name}`);
    38â†’    38â†’    console.log(`    Error: ${err.message}`);
    39â†’    39â†’    failed++;
    40â†’    40â†’  }
    41â†’    41â†’}
    42â†’    42â†’
    43â†’    43â†’// Read plugin files
    44â†’    44â†’const pluginDir = path.join(__dirname, '../../splice-plugin/js');
    45â†’    45â†’const configJs = fs.readFileSync(path.join(pluginDir, 'config.js'), 'utf8');
    46â†’    46â†’const mainJs = fs.readFileSync(path.join(pluginDir, 'main.js'), 'utf8');
    47â†’    47â†’const creditsJs = fs.readFileSync(path.join(pluginDir, 'credits.js'), 'utf8');
    48â†’    48â†’const settingsJs = fs.readFileSync(path.join(pluginDir, 'settings.js'), 'utf8');
    49â†’    49â†’const utilsJs = fs.readFileSync(path.join(pluginDir, 'utils.js'), 'utf8');
    50â†’    50â†’const slice8Js = fs.readFileSync(path.join(pluginDir, 'slice8-silence.js'), 'utf8');
    51â†’    51â†’const slice9Js = fs.readFileSync(path.join(pluginDir, 'slice9-razor.js'), 'utf8');
    52â†’    52â†’
    53â†’    53â†’// ============================================================================
    54â†’    54â†’// 2.1: Centralized URL Configuration Tests
    55â†’    55â†’// ============================================================================
    56â†’    56â†’console.log('\nðŸ“¦ Feature 2.1: Centralized URL Configuration\n');
    57â†’    57â†’
    58â†’    58â†’test('config.js exports getBackendUrl() function', () => {
    59â†’    59â†’  assert(configJs.includes('function getBackendUrl()'), 'getBackendUrl function not found');
    60â†’    60â†’});
    61â†’    61â†’
    62â†’    62â†’test('config.js defines BACKEND_URL_DEV constant', () => {
    63â†’    63â†’  assert(configJs.includes("BACKEND_URL_DEV = 'https://127.0.0.1:3847'"), 'BACKEND_URL_DEV not found');
    64â†’    64â†’});
    65â†’    65â†’
    66â†’    66â†’test('config.js uses 127.0.0.1 not localhost', () => {
    67â†’    67â†’  assert(!configJs.includes('localhost:3847'), 'Should use 127.0.0.1, not localhost');
    68â†’    68â†’  assert(configJs.includes('127.0.0.1:3847'), 'Should use 127.0.0.1');
    69â†’    69â†’});
    70â†’    70â†’
    71â†’    71â†’test('credits.js uses getBackendUrl() not hardcoded fallback', () => {
    72â†’    72â†’  assert(!creditsJs.includes("'https://127.0.0.1:3847'"), 'Should not have hardcoded fallback');
    73â†’    73â†’  assert(creditsJs.includes('getBackendUrl()'), 'Should use getBackendUrl()');
    74â†’    74â†’});
    75â†’    75â†’
    76â†’    76â†’test('credits.js removed getCreditsBackendUrl() duplicate', () => {
    77â†’    77â†’  assert(!creditsJs.includes('function getCreditsBackendUrl'), 'Duplicate function should be removed');
    78â†’    78â†’});
    79â†’    79â†’
    80â†’    80â†’test('settings.js uses getBackendUrl() for license activation', () => {
    81â†’    81â†’  assert(settingsJs.includes('getBackendUrl()}/license/activate'), 'Should use getBackendUrl()');
    82â†’    82â†’  assert(!settingsJs.includes("const baseUrl = typeof BACKEND_URL"), 'Should not have hardcoded fallback pattern');
    83â†’    83â†’});
    84â†’    84â†’
    85â†’    85â†’test('main.js uses getBackendUrl() not BACKEND_URL directly', () => {
    86â†’    86â†’  // Count uses of getBackendUrl() - should be 5+ (isolate, silences, analyze, batch, batch-status)
    87â†’    87â†’  const getBackendUrlCount = (mainJs.match(/getBackendUrl\(\)/g) || []).length;
    88â†’    88â†’  assert(getBackendUrlCount >= 5, `Expected 5+ getBackendUrl() uses, found ${getBackendUrlCount}`);
    89â†’    89â†’});
    90â†’    90â†’
    91â†’    91â†’// ============================================================================
    92â†’    92â†’// 2.2: Duplicate Function Definitions Tests
    93â†’    93â†’// ============================================================================
    94â†’    94â†’console.log('\nðŸ“¦ Feature 2.2: Remove Duplicate Function Definitions\n');
    95â†’    95â†’
    96â†’    96â†’test('utils.js has formatTime with NaN check', () => {
    97â†’    97â†’  assert(utilsJs.includes("isNaN(seconds)"), 'formatTime should check for NaN');
    98â†’    98â†’  assert(utilsJs.includes("return '0:00'"), 'formatTime should return 0:00 for invalid input');
    99â†’    99â†’});
   100â†’   100â†’
   101â†’   101â†’test('main.js references formatTime from utils.js (not duplicate)', () => {
   102â†’   102â†’  // main.js should have a comment about formatTime being in utils.js
   103â†’   103â†’  assert(mainJs.includes('formatTime is defined in utils.js'), 'Should reference utils.js formatTime');
   104â†’   104â†’});
   105â†’   105â†’
   106â†’   106â†’test('utils.js has setStatus with null check', () => {
   107â†’   107â†’  assert(utilsJs.includes("if (statusEl)"), 'setStatus should have null check');
   108â†’   108â†’});
   109â†’   109â†’
   110â†’   110â†’test('slice8-silence.js references showRazorSection from slice9', () => {
   111â†’   111â†’  assert(slice8Js.includes('showRazorSection is defined in slice9-razor.js'),
   112â†’   112â†’    'Should reference slice9 for showRazorSection');
   113â†’   113â†’});
   114â†’   114â†’
   115â†’   115â†’test('slice9-razor.js defines showRazorSection', () => {
   116â†’   116â†’  assert(slice9Js.includes('function showRazorSection()'), 'showRazorSection should be in slice9');
   117â†’   117â†’});
   118â†’   118â†’
   119â†’   119â†’// Count function definitions to ensure no duplicates
   120â†’   120â†’test('formatTime is defined exactly once across files', () => {
   121â†’   121â†’  const formatTimeInUtils = (utilsJs.match(/function formatTime\(/g) || []).length;
   122â†’   122â†’  const formatTimeInMain = (mainJs.match(/function formatTime\(/g) || []).length;
   123â†’   123â†’  assert(formatTimeInUtils === 1, `Expected 1 in utils.js, found ${formatTimeInUtils}`);
   124â†’   124â†’  assert(formatTimeInMain === 0, `Expected 0 in main.js, found ${formatTimeInMain}`);
   125â†’   125â†’});
   126â†’   126â†’
   127â†’   127â†’// ============================================================================
   128â†’   128â†’// 2.3: Fetch Timeout Support Tests
   129â†’   129â†’// ============================================================================
   130â†’   130â†’console.log('\nðŸ“¦ Feature 2.3: Fetch Timeout Support\n');
   131â†’   131â†’
   132â†’   132â†’test('config.js exports fetchWithTimeout function', () => {
   133â†’   133â†’  assert(configJs.includes('async function fetchWithTimeout'), 'fetchWithTimeout function not found');
   134â†’   134â†’});
   135â†’   135â†’
   136â†’   136â†’test('config.js defines timeout constants', () => {
   137â†’   137â†’  assert(configJs.includes('FETCH_TIMEOUT_DEFAULT'), 'FETCH_TIMEOUT_DEFAULT not found');
   138â†’   138â†’  assert(configJs.includes('FETCH_TIMEOUT_HEALTH'), 'FETCH_TIMEOUT_HEALTH not found');
   139â†’   139â†’  assert(configJs.includes('FETCH_TIMEOUT_PROCESSING'), 'FETCH_TIMEOUT_PROCESSING not found');
   140â†’   140â†’});
   141â†’   141â†’
   142â†’   142â†’test('fetchWithTimeout uses AbortController', () => {
   143â†’   143â†’  assert(configJs.includes('AbortController'), 'Should use AbortController');
   144â†’   144â†’  assert(configJs.includes('controller.abort()'), 'Should call abort on timeout');
   145â†’   145â†’});
   146â†’   146â†’
   147â†’   147â†’test('fetchWithTimeout throws "Request timed out" on abort', () => {
   148â†’   148â†’  assert(configJs.includes("throw new Error('Request timed out')"), 'Should throw timeout error');
   149â†’   149â†’});
   150â†’   150â†’
   151â†’   151â†’test('main.js uses fetchWithTimeout for API calls', () => {
   152â†’   152â†’  const fetchWithTimeoutCount = (mainJs.match(/fetchWithTimeout\(/g) || []).length;
   153â†’   153â†’  assert(fetchWithTimeoutCount >= 6, `Expected 6+ fetchWithTimeout uses, found ${fetchWithTimeoutCount}`);
   154â†’   154â†’});
   155â†’   155â†’
   156â†’   156â†’test('credits.js uses fetchWithTimeout', () => {
   157â†’   157â†’  assert(creditsJs.includes('fetchWithTimeout('), 'credits.js should use fetchWithTimeout');
   158â†’   158â†’});
   159â†’   159â†’
   160â†’   160â†’test('settings.js uses fetchWithTimeout for license activation', () => {
   161â†’   161â†’  assert(settingsJs.includes('fetchWithTimeout('), 'settings.js should use fetchWithTimeout');
   162â†’   162â†’});
   163â†’   163â†’
   164â†’   164â†’test('slice9-razor.js uses fetchWithTimeout', () => {
   165â†’   165â†’  assert(slice9Js.includes('fetchWithTimeout('), 'slice9 should use fetchWithTimeout');
   166â†’   166â†’});
   167â†’   167â†’
   168â†’   168â†’test('health check uses FETCH_TIMEOUT_HEALTH (shorter timeout)', () => {
   169â†’   169â†’  assert(slice9Js.includes('FETCH_TIMEOUT_HEALTH'), 'FFprobe check should use short timeout');
   170â†’   170â†’});
   171â†’   171â†’
   172â†’   172â†’test('processing endpoints use FETCH_TIMEOUT_PROCESSING (longer timeout)', () => {
   173â†’   173â†’  const processingTimeoutCount = (mainJs.match(/FETCH_TIMEOUT_PROCESSING/g) || []).length;
   174â†’   174â†’  assert(processingTimeoutCount >= 5, `Expected 5+ FETCH_TIMEOUT_PROCESSING uses, found ${processingTimeoutCount}`);
   175â†’   175â†’});
   176â†’   176â†’
   177â†’   177â†’// ============================================================================
   178â†’   178â†’// 2.4: Standardized Error Response Parsing Tests
   179â†’   179â†’// ============================================================================
   180â†’   180â†’console.log('\nðŸ“¦ Feature 2.4: Standardized Error Response Parsing\n');
   181â†’   181â†’
   182â†’   182â†’test('config.js exports parseErrorResponse function', () => {
   183â†’   183â†’  assert(configJs.includes('async function parseErrorResponse'), 'parseErrorResponse function not found');
   184â†’   184â†’});
   185â†’   185â†’
   186â†’   186â†’test('parseErrorResponse handles error field', () => {
   187â†’   187â†’  assert(configJs.includes('data.error'), 'Should check data.error');
   188â†’   188â†’});
   189â†’   189â†’
   190â†’   190â†’test('parseErrorResponse handles message field', () => {
   191â†’   191â†’  assert(configJs.includes('data.message'), 'Should check data.message');
   192â†’   192â†’});
   193â†’   193â†’
   194â†’   194â†’test('parseErrorResponse handles JSON parse failure', () => {
   195â†’   195â†’  assert(configJs.includes('catch'), 'Should catch JSON parse errors');
   196â†’   196â†’  assert(configJs.includes('response.status'), 'Should fall back to status code');
   197â†’   197â†’});
   198â†’   198â†’
   199â†’   199â†’test('main.js uses parseErrorResponse', () => {
   200â†’   200â†’  const parseErrorCount = (mainJs.match(/parseErrorResponse\(/g) || []).length;
   201â†’   201â†’  assert(parseErrorCount >= 5, `Expected 5+ parseErrorResponse uses, found ${parseErrorCount}`);
   202â†’   202â†’});
   203â†’   203â†’
   204â†’   204â†’test('credits.js uses parseErrorResponse', () => {
   205â†’   205â†’  assert(creditsJs.includes('parseErrorResponse('), 'credits.js should use parseErrorResponse');
   206â†’   206â†’});
   207â†’   207â†’
   208â†’   208â†’test('slice9-razor.js uses parseErrorResponse', () => {
   209â†’   209â†’  assert(slice9Js.includes('parseErrorResponse('), 'slice9 should use parseErrorResponse');
   210â†’   210â†’});
   211â†’   211â†’
   212â†’   212â†’// ============================================================================
   213â†’   213â†’// Integration Tests - Simulated fetchWithTimeout behavior
   214â†’   214â†’// ============================================================================
   215â†’   215â†’console.log('\nðŸ“¦ Integration Tests: Fetch Timeout Behavior\n');
   216â†’   216â†’
   217â†’   217â†’// Simulate the fetchWithTimeout function
   218â†’   218â†’async function simulateFetchWithTimeout(url, options = {}, timeout = 1000) {
   219â†’   219â†’  const controller = new AbortController();
   220â†’   220â†’  const timeoutId = setTimeout(() => controller.abort(), timeout);
   221â†’   221â†’
   222â†’   222â†’  try {
   223â†’   223â†’    // Simulate a slow response
   224â†’   224â†’    await new Promise((resolve, reject) => {
   225â†’   225â†’      const timer = setTimeout(resolve, 500); // Fast response
   226â†’   226â†’      controller.signal.addEventListener('abort', () => {
   227â†’   227â†’        clearTimeout(timer);
   228â†’   228â†’        reject(new Error('AbortError'));
   229â†’   229â†’      });
   230â†’   230â†’    });
   231â†’   231â†’    clearTimeout(timeoutId);
   232â†’   232â†’    return { ok: true, status: 200 };
   233â†’   233â†’  } catch (err) {
   234â†’   234â†’    clearTimeout(timeoutId);
   235â†’   235â†’    if (err.message === 'AbortError') {
   236â†’   236â†’      throw new Error('Request timed out');
   237â†’   237â†’    }
   238â†’   238â†’    throw err;
   239â†’   239â†’  }
   240â†’   240â†’}
   241â†’   241â†’
   242â†’   242â†’asyncTest('fetchWithTimeout completes before timeout', async () => {
   243â†’   243â†’  const response = await simulateFetchWithTimeout('http://test', {}, 1000);
   244â†’   244â†’  assert(response.ok === true, 'Should complete successfully');
   245â†’   245â†’});
   246â†’   246â†’
   247â†’   247â†’asyncTest('fetchWithTimeout throws on timeout', async () => {
   248â†’   248â†’  try {
   249â†’   249â†’    await simulateFetchWithTimeout('http://test', {}, 1); // 1ms timeout
   250â†’   250â†’    await new Promise(r => setTimeout(r, 100)); // Wait for abort
   251â†’   251â†’    assert(false, 'Should have thrown');
   252â†’   252â†’  } catch (err) {
   253â†’   253â†’    assert(err.message === 'Request timed out', 'Should throw timeout error');
   254â†’   254â†’  }
   255â†’   255â†’});
   256â†’   256â†’
   257â†’   257â†’// Simulate parseErrorResponse
   258â†’   258â†’async function simulateParseErrorResponse(response) {
   259â†’   259â†’  try {
   260â†’   260â†’    const data = response.json ? await response.json() : {};
   261â†’   261â†’    return data.error || data.message || `Error ${response.status}`;
   262â†’   262â†’  } catch {
   263â†’   263â†’    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
   264â†’   264â†’  }
   265â†’   265â†’}
   266â†’   266â†’
   267â†’   267â†’asyncTest('parseErrorResponse extracts error field', async () => {
   268â†’   268â†’  const response = { status: 400, json: async () => ({ error: 'Bad request' }) };
   269â†’   269â†’  const msg = await simulateParseErrorResponse(response);
   270â†’   270â†’  assert(msg === 'Bad request', 'Should extract error field');
   271â†’   271â†’});
   272â†’   272â†’
   273â†’   273â†’asyncTest('parseErrorResponse extracts message field', async () => {
   274â†’   274â†’  const response = { status: 401, json: async () => ({ message: 'Unauthorized' }) };
   275â†’   275â†’  const msg = await simulateParseErrorResponse(response);
   276â†’   276â†’  assert(msg === 'Unauthorized', 'Should extract message field');
   277â†’   277â†’});
   278â†’   278â†’
   279â†’   279â†’asyncTest('parseErrorResponse handles JSON parse failure', async () => {
   280â†’   280â†’  const response = {
   281â†’   281â†’    status: 500,
   282â†’   282â†’    statusText: 'Internal Server Error',
   283â†’   283â†’    json: async () => { throw new Error('Invalid JSON'); }
   284â†’   284â†’  };
   285â†’   285â†’  const msg = await simulateParseErrorResponse(response);
   286â†’   286â†’  assert(msg.includes('500'), 'Should include status code');
   287â†’   287â†’});
   288â†’   288â†’
   289â†’   289â†’asyncTest('parseErrorResponse handles empty body', async () => {
   290â†’   290â†’  const response = {
   291â†’   291â†’    status: 502,
   292â†’   292â†’    statusText: 'Bad Gateway',
   293â†’   293â†’    json: async () => ({})
   294â†’   294â†’  };
   295â†’   295â†’  const msg = await simulateParseErrorResponse(response);
   296â†’   296â†’  assert(msg.includes('502'), 'Should fall back to status code');
   297â†’   297â†’});
   298â†’   298â†’
   299â†’   299â†’// ============================================================================
   300â†’   300â†’// Summary
   301â†’   301â†’// ============================================================================
   302â†’   302â†’console.log('\n' + '='.repeat(60));
   303â†’   303â†’console.log(`Phase 2 Tests: ${passed} passed, ${failed} failed`);
   304â†’   304â†’console.log('='.repeat(60) + '\n');
   305â†’   305â†’
   306â†’   306â†’if (failed > 0) {
   307â†’   307â†’  process.exit(1);
   308â†’   308â†’}
   309â†’   309â†’
   310â†’
   311â†’<system-reminder>
   312â†’Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
   313â†’</system-reminder>
   314â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
