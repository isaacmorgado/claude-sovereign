     1→/**
     2→ * Settings Management
     3→ *
     4→ * Persists user preferences to localStorage
     5→ * v3.5: Added Persistent Token support for media folder access
     6→ */
     7→
     8→const uxpFs = require('uxp').storage.localFileSystem;
     9→
    10→const DEFAULT_SETTINGS = {
    11→  sensitivity: 50,
    12→  audioSource: 'original',
    13→  autoMarkBest: true,
    14→  enableTakesDetection: true,
    15→  rememberOptions: false,
    16→  optionsExpanded: false,
    17→  customerId: null,          // Stripe customer ID for billing
    18→  mediaFolderToken: null,    // Persistent token for media folder access
    19→  mediaFolderPath: null      // Path to the media folder (for display)
    20→};
    21→
    22→let currentSettings = { ...DEFAULT_SETTINGS };
    23→
    24→/**
    25→ * Load settings from localStorage
    26→ */
    27→function loadSettings() {
    28→  try {
    29→    const saved = localStorage.getItem('spliceSettings');
    30→    if (saved) {
    31→      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
    32→    }
    33→  } catch (e) {
    34→    console.warn('[SPLICE] Could not load settings:', e);
    35→    currentSettings = { ...DEFAULT_SETTINGS };
    36→  }
    37→  return currentSettings;
    38→}
    39→
    40→/**
    41→ * Save settings to localStorage
    42→ */
    43→function saveSettings(settings) {
    44→  try {
    45→    currentSettings = { ...currentSettings, ...settings };
    46→    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
    47→  } catch (e) {
    48→    console.warn('[SPLICE] Could not save settings:', e);
    49→  }
    50→}
    51→
    52→/**
    53→ * Get current settings
    54→ */
    55→function getSettings() {
    56→  return { ...currentSettings };
    57→}
    58→
    59→/**
    60→ * Reset settings to defaults
    61→ */
    62→function resetSettings() {
    63→  currentSettings = { ...DEFAULT_SETTINGS };
    64→  try {
    65→    localStorage.removeItem('spliceSettings');
    66→  } catch (e) {
    67→    console.warn('[SPLICE] Could not clear settings:', e);
    68→  }
    69→}
    70→
    71→/**
    72→ * Initialize settings UI components
    73→ */
    74→function initSettingsUI() {
    75→  const settings = loadSettings();
    76→
    77→  // Apply saved sensitivity to slider
    78→  const sensitivitySlider = document.getElementById('sensitivitySlider');
    79→  if (sensitivitySlider) {
    80→    sensitivitySlider.value = settings.sensitivity;
    81→  }
    82→
    83→  // Apply saved audio source
    84→  const sourceOriginal = document.getElementById('sourceOriginal');
    85→  const sourceIsolated = document.getElementById('sourceIsolated');
    86→  if (sourceOriginal && sourceIsolated) {
    87→    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';
    88→    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';
    89→  }
    90→
    91→  // Apply auto-mark best setting
    92→  const autoMarkBest = document.getElementById('autoMarkBest');
    93→  if (autoMarkBest) {
    94→    autoMarkBest.checked = settings.autoMarkBest;
    95→  }
    96→
    97→  // Apply takes detection setting
    98→  const enableTakesDetection = document.getElementById('enableTakesDetection');
    99→  if (enableTakesDetection) {
   100→    enableTakesDetection.checked = settings.enableTakesDetection;
   101→  }
   102→
   103→  // Apply remember options setting
   104→  const rememberOptions = document.getElementById('rememberOptions');
   105→  if (rememberOptions) {
   106→    rememberOptions.checked = settings.rememberOptions;
   107→  }
   108→
   109→  // Restore expanded state if remember is enabled
   110→  if (settings.rememberOptions && settings.optionsExpanded) {
   111→    toggleOptionsPanel(true);
   112→  }
   113→}
   114→
   115→/**
   116→ * Toggle options panel visibility (unified panel)
   117→ */
   118→function toggleOptionsPanel(forceState) {
   119→  const toggle = document.getElementById('optionsToggle');
   120→  const panel = document.getElementById('optionsPanel');
   121→
   122→  if (!toggle || !panel) return;
   123→
   124→  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');
   125→
   126→  if (shouldExpand) {
   127→    panel.classList.remove('collapsed');
   128→    toggle.classList.add('expanded');
   129→  } else {
   130→    panel.classList.add('collapsed');
   131→    toggle.classList.remove('expanded');
   132→  }
   133→
   134→  // Save state if remember is enabled
   135→  const settings = getSettings();
   136→  if (settings.rememberOptions) {
   137→    saveSettings({ optionsExpanded: shouldExpand });
   138→  }
   139→}
   140→
   141→/**
   142→ * Initialize settings modal
   143→ */
   144→function initSettingsModal() {
   145→  const settingsBtn = document.getElementById('settingsBtn');
   146→  const modal = document.getElementById('settingsModal');
   147→  const closeBtn = document.getElementById('closeSettingsBtn');
   148→  const defaultSensitivity = document.getElementById('defaultSensitivity');
   149→  const rememberOptions = document.getElementById('rememberOptions');
   150→
   151→  if (settingsBtn && modal) {
   152→    settingsBtn.addEventListener('click', () => {
   153→      modal.classList.remove('hidden');
   154→      // Sync modal values with current settings
   155→      const settings = getSettings();
   156→      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;
   157→      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;
   158→    });
   159→  }
   160→
   161→  if (closeBtn && modal) {
   162→    closeBtn.addEventListener('click', () => {
   163→      modal.classList.add('hidden');
   164→    });
   165→  }
   166→
   167→  // Close on backdrop click
   168→  if (modal) {
   169→    modal.addEventListener('click', (e) => {
   170→      if (e.target === modal) {
   171→        modal.classList.add('hidden');
   172→      }
   173→    });
   174→  }
   175→
   176→  // Save default sensitivity when changed
   177→  if (defaultSensitivity) {
   178→    defaultSensitivity.addEventListener('change', () => {
   179→      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });
   180→      // Also update the main slider
   181→      const mainSlider = document.getElementById('sensitivitySlider');
   182→      if (mainSlider) mainSlider.value = defaultSensitivity.value;
   183→    });
   184→  }
   185→
   186→  // Save remember options when changed
   187→  if (rememberOptions) {
   188→    rememberOptions.addEventListener('change', () => {
   189→      saveSettings({ rememberOptions: rememberOptions.checked });
   190→    });
   191→  }
   192→}
   193→
   194→/**
   195→ * Initialize options toggle (unified panel)
   196→ */
   197→function initOptionsToggles() {
   198→  const toggle = document.getElementById('optionsToggle');
   199→
   200→  if (toggle) {
   201→    toggle.addEventListener('click', () => toggleOptionsPanel());
   202→  }
   203→}
   204→
   205→/**
   206→ * Initialize help button
   207→ */
   208→function initHelpButton() {
   209→  const helpBtn = document.getElementById('helpBtn');
   210→  if (helpBtn) {
   211→    helpBtn.addEventListener('click', () => {
   212→      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');
   213→    });
   214→  }
   215→}
   216→
   217→// =============================================================================
   218→// PERSISTENT TOKEN MANAGEMENT (v3.5)
   219→// =============================================================================
   220→
   221→/**
   222→ * Media folder entry (cached after selection)
   223→ * @type {Object|null}
   224→ */
   225→let mediaFolderEntry = null;
   226→
   227→/**
   228→ * Prompt user to select a media folder and create a persistent token.
   229→ * This allows silent file access without repeated permission prompts.
   230→ *
   231→ * @returns {Promise<{success: boolean, path?: string, error?: string}>}
   232→ */
   233→async function setupMediaFolder() {
   234→  try {
   235→    // Open folder picker dialog
   236→    const folder = await uxpFs.getFolder();
   237→
   238→    if (!folder) {
   239→      return { success: false, error: 'No folder selected' };
   240→    }
   241→
   242→    // Create a persistent token for this folder
   243→    const token = await uxpFs.createPersistentToken(folder);
   244→
   245→    if (!token) {
   246→      return { success: false, error: 'Failed to create persistent token' };
   247→    }
   248→
   249→    // Get the folder path for display
   250→    const folderPath = folder.nativePath || folder.name;
   251→
   252→    // Save to settings
   253→    saveSettings({
   254→      mediaFolderToken: token,
   255→      mediaFolderPath: folderPath
   256→    });
   257→
   258→    // Cache the folder entry
   259→    mediaFolderEntry = folder;
   260→
   261→    console.log(`[SPLICE] Media folder set: ${folderPath}`);
   262→
   263→    return {
   264→      success: true,
   265→      path: folderPath,
   266→      token
   267→    };
   268→  } catch (err) {
   269→    console.error('[SPLICE] Error setting up media folder:', err);
   270→    return { success: false, error: err.message };
   271→  }
   272→}
   273→
   274→/**
   275→ * Get the media folder entry using the stored persistent token.
   276→ * Falls back to prompting if token is invalid.
   277→ *
   278→ * @returns {Promise<Object|null>} The folder entry or null
   279→ */
   280→async function getMediaFolder() {
   281→  // Return cached entry if available
   282→  if (mediaFolderEntry) {
   283→    return mediaFolderEntry;
   284→  }
   285→
   286→  const settings = getSettings();
   287→
   288→  // Try to restore from persistent token
   289→  if (settings.mediaFolderToken) {
   290→    try {
   291→      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);
   292→      if (folder) {
   293→        mediaFolderEntry = folder;
   294→        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);
   295→        return folder;
   296→      }
   297→    } catch (err) {
   298→      console.warn('[SPLICE] Could not restore media folder from token:', err.message);
   299→      // Clear invalid token
   300→      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });
   301→    }
   302→  }
   303→
   304→  return null;
   305→}
   306→
   307→/**
   308→ * Check if a media folder is configured
   309→ * @returns {boolean}
   310→ */
   311→function hasMediaFolder() {
   312→  const settings = getSettings();
   313→  return !!settings.mediaFolderToken;
   314→}
   315→
   316→/**
   317→ * Get the configured media folder path (for display)
   318→ * @returns {string|null}
   319→ */
   320→function getMediaFolderPath() {
   321→  const settings = getSettings();
   322→  return settings.mediaFolderPath;
   323→}
   324→
   325→/**
   326→ * Clear the media folder configuration
   327→ */
   328→function clearMediaFolder() {
   329→  mediaFolderEntry = null;
   330→  saveSettings({
   331→    mediaFolderToken: null,
   332→    mediaFolderPath: null
   333→  });
   334→  console.log('[SPLICE] Media folder cleared');
   335→}
   336→
   337→/**
   338→ * Read a file from the media folder
   339→ * @param {string} filename - Name of the file to read
   340→ * @returns {Promise<ArrayBuffer|null>} File contents or null
   341→ */
   342→async function readMediaFile(filename) {
   343→  const folder = await getMediaFolder();
   344→  if (!folder) {
   345→    console.warn('[SPLICE] No media folder configured');
   346→    return null;
   347→  }
   348→
   349→  try {
   350→    const file = await folder.getEntry(filename);
   351→    if (!file) {
   352→      console.warn(`[SPLICE] File not found in media folder: ${filename}`);
   353→      return null;
   354→    }
   355→
   356→    const contents = await file.read({ format: uxpFs.formats.binary });
   357→    return contents;
   358→  } catch (err) {
   359→    console.error(`[SPLICE] Error reading file ${filename}:`, err);
   360→    return null;
   361→  }
   362→}
   363→
   364→// Load settings on script load
   365→loadSettings();
   366→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
