The file /Users/imorgado/SPLICE/splice-backend/server.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   644→    res.status(500).json({ error: err.message });
   645→  }
   646→});
   647→
   648→/**
   649→ * POST /fillers - Detect filler words (um, uh, like, etc.)
   650→ *
   651→ * Transcribes audio and identifies filler words with timestamps.
   652→ * Returns segments that can be cut or reviewed for removal.
   653→ *
   654→ * Options:
   655→ * - wavPath: Path to audio file (required unless transcript provided)
   656→ * - transcript: Pre-existing transcript with word-level timing (optional)
   657→ * - customFillers: Additional filler words to detect (optional)
   658→ */
   659→app.post('/fillers', async (req, res) => {
   660→  const {
   661→    wavPath,
   662→    transcript: providedTranscript,
   663→    customFillers = []
   664→  } = req.body;
   665→
   666→  if (!wavPath && !providedTranscript) {
   667→    return res.status(400).json({ error: 'wavPath or transcript is required' });
   668→  }
   669→
   670→  if (wavPath && !fs.existsSync(wavPath)) {
   671→    return res.status(404).json({ error: `File not found: ${wavPath}` });
   672→  }
   673→
   674→  console.log(`[SPLICE] Filler word detection: ${wavPath || 'provided transcript'}`);
   675→
   676→  try {
   677→    // Get or create transcript with word-level timestamps
   678→    let transcript = providedTranscript;
   679→    if (!transcript && wavPath) {
   680→      transcript = await transcribeWithWords(wavPath);
   681→    }
   682→
   683→    // Validate transcript has words
   684→    if (!transcript || !transcript.words || transcript.words.length === 0) {
   685→      return res.status(400).json({
   686→        error: 'Transcript must contain word-level timing data'
   687→      });
   688→    }
   689→
   690→    // Default filler words (common in English speech)
   691→    const defaultFillers = [
   692→      'um', 'uh', 'ah', 'er', 'eh',           // Hesitation sounds
   693→      'like', 'so', 'well', 'right',           // Discourse markers
   694→      'you know', 'i mean', 'basically',       // Filler phrases
   695→      'actually', 'literally', 'honestly',     // Overused qualifiers
   696→      'kind of', 'sort of', 'you see'          // Hedging phrases
   697→    ];
   698→
   699→    // Combine default + custom fillers (lowercase for matching)
   700→    const fillerSet = new Set([
   701→      ...defaultFillers,
   702→      ...customFillers.map(f => f.toLowerCase().trim())
   703→    ]);
   704→
   705→    // Detect filler words
   706→    const fillers = [];
   707→    const words = transcript.words;
   708→
   709→    for (let i = 0; i < words.length; i++) {
   710→      const word = words[i];
   711→      const normalizedWord = word.word.toLowerCase().replace(/[.,!?;:'"]/g, '').trim();
   712→
   713→      // Check single-word fillers
   714→      if (fillerSet.has(normalizedWord)) {
   715→        fillers.push({
   716→          word: word.word,
   717→          normalizedWord,
   718→          start: word.start,
   719→          end: word.end,
   720→          duration: word.end - word.start,
   721→          index: i,
   722→          type: 'filler'
   723→        });
   724→        continue;
   725→      }
   726→
   727→      // Check two-word phrases (e.g., "you know", "kind of")
   728→      if (i < words.length - 1) {
   729→        const nextWord = words[i + 1];
   730→        const twoWordPhrase = `${normalizedWord} ${nextWord.word.toLowerCase().replace(/[.,!?;:'"]/g, '').trim()}`;
   731→        if (fillerSet.has(twoWordPhrase)) {
   732→          fillers.push({
   733→            word: `${word.word} ${nextWord.word}`,
   734→            normalizedWord: twoWordPhrase,
   735→            start: word.start,
   736→            end: nextWord.end,
   737→            duration: nextWord.end - word.start,
   738→            index: i,
   739→            type: 'filler_phrase'
   740→          });
   741→          // Skip next word since it's part of this phrase
   742→          i++;
   743→        }
   744→      }
   745→    }
   746→
   747→    // Calculate total filler time
   748→    const totalFillerDuration = fillers.reduce((sum, f) => sum + f.duration, 0);
   749→    const audioDuration = transcript.duration || (words.length > 0 ? words[words.length - 1].end : 0);
   750→    const fillerPercentage = audioDuration > 0 ? (totalFillerDuration / audioDuration) * 100 : 0;
   751→
   752→    res.json({
   753→      success: true,
   754→      wavPath,
   755→      fillers,
   756→      metadata: {
   757→        totalWords: words.length,
   758→        fillerCount: fillers.length,
   759→        totalFillerDuration: parseFloat(totalFillerDuration.toFixed(3)),
   760→        audioDuration: parseFloat(audioDuration.toFixed(3)),
   761→        fillerPercentage: parseFloat(fillerPercentage.toFixed(2)),
   762→        fillersPerMinute: audioDuration > 0 ? parseFloat((fillers.length / (audioDuration / 60)).toFixed(2)) : 0
   763→      },
   764→      removalSegments: fillers.map(f => ({
   765→        start: f.start,
   766→        end: f.end,
   767→        duration: f.duration,
   768→        reason: `Filler: "${f.word}"`,
   769→        type: f.type
   770→      }))
   771→    });
   772→  } catch (err) {
   773→    console.error('[SPLICE] Filler detection error:', err);
   774→    res.status(500).json({ error: err.message });
   775→  }
   776→});
   777→
   778→/**
   779→ * POST /stutters - Detect single-word stutters only
   780→ *
   781→ * Focused detection for word-level stutters (e.g., "I I I think").
   782→ * Faster than full repetition detection.
   783→ */
   784→app.post('/stutters', async (req, res) => {
   785→  const {
   786→    wavPath,
   787→    transcript: providedTranscript,
   788→    options = {},