{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":"Explore the agent system in src/core/agents/ in detail. I need to understand:\n\n1. What's already implemented (registry, orchestrator, lifecycle, communication, coordination)\n2. How agents are registered and managed\n3. How task distribution works\n4. How agents communicate\n5. Any gaps or areas for enhancement\n\nRead the actual code files and provide detailed analysis of:\n- Current agent capabilities\n- Missing features (e.g., better orchestration, agent chaining, workflows)\n- How agents connect to providers and MCP\n- Code patterns being used\n\nBe very thorough - read each file completely."},"uuid":"b6be98ce-ff0d-446f-b511-a1764c02d828","timestamp":"2026-01-12T06:23:12.509Z"}
{"parentUuid":"b6be98ce-ff0d-446f-b511-a1764c02d828","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018nmLweRirNbqRh9nXnLWcn","type":"message","role":"assistant","content":[{"type":"text","text":"I'll thoroughly explore the agent system in src/core/agents/ for you. Let me start by understanding the directory structure and then reading each file in detail."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1481,"cache_read_input_tokens":17176,"cache_creation":{"ephemeral_5m_input_tokens":1481,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX31B7ECJg4vXqtsmfVwL","type":"assistant","uuid":"f3339408-74c4-433d-a973-fe892db9e6cd","timestamp":"2026-01-12T06:23:14.659Z"}
{"parentUuid":"f3339408-74c4-433d-a973-fe892db9e6cd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018nmLweRirNbqRh9nXnLWcn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019y14WRA8Ls3NYfdFkc3hwW","name":"Bash","input":{"command":"find /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents -type f -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.json\" | head -30"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":1481,"cache_read_input_tokens":17176,"cache_creation":{"ephemeral_5m_input_tokens":1481,"ephemeral_1h_input_tokens":0},"output_tokens":147,"service_tier":"standard"}},"requestId":"req_011CX31B7ECJg4vXqtsmfVwL","type":"assistant","uuid":"45eb6bcf-58f1-45d9-89cb-c3a43514cee4","timestamp":"2026-01-12T06:23:15.262Z"}
{"parentUuid":"45eb6bcf-58f1-45d9-89cb-c3a43514cee4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019y14WRA8Ls3NYfdFkc3hwW","type":"tool_result","content":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/coordination.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/test-agents.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/orchestrator.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/lifecycle.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/communication.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/registry.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/index.ts","is_error":false}]},"uuid":"deb97e72-e953-445f-884a-47d8d7f7a8c1","timestamp":"2026-01-12T06:23:15.348Z","toolUseResult":{"stdout":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/coordination.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/test-agents.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/orchestrator.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/lifecycle.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/communication.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/registry.ts\n/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/index.ts","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"deb97e72-e953-445f-884a-47d8d7f7a8c1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gvp4dBzbRhVLEMYu6NXiMQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read all the agent system files in detail:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":641,"cache_read_input_tokens":18657,"cache_creation":{"ephemeral_5m_input_tokens":641,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BK5aZwxCdGfJwJwWK","type":"assistant","uuid":"747ed034-4c73-4540-b214-2615214c2130","timestamp":"2026-01-12T06:23:16.356Z"}
{"parentUuid":"747ed034-4c73-4540-b214-2615214c2130","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gvp4dBzbRhVLEMYu6NXiMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0178wMusP5jBYqSyGjUsuiFa","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":641,"cache_read_input_tokens":18657,"cache_creation":{"ephemeral_5m_input_tokens":641,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BK5aZwxCdGfJwJwWK","type":"assistant","uuid":"6b8426a7-d393-4c13-ab91-b4a602abb413","timestamp":"2026-01-12T06:23:16.542Z"}
{"parentUuid":"6b8426a7-d393-4c13-ab91-b4a602abb413","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gvp4dBzbRhVLEMYu6NXiMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BzEKTHN8AwjLAGfSa9F2wF","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/index.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":641,"cache_read_input_tokens":18657,"cache_creation":{"ephemeral_5m_input_tokens":641,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BK5aZwxCdGfJwJwWK","type":"assistant","uuid":"28a1b4cf-1b53-4d75-81f7-0930ccf08c6c","timestamp":"2026-01-12T06:23:16.773Z"}
{"parentUuid":"28a1b4cf-1b53-4d75-81f7-0930ccf08c6c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gvp4dBzbRhVLEMYu6NXiMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011jBrXeXJfjNfpqCRihVbkG","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/registry.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":641,"cache_read_input_tokens":18657,"cache_creation":{"ephemeral_5m_input_tokens":641,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BK5aZwxCdGfJwJwWK","type":"assistant","uuid":"76073550-e92c-46ad-9f57-7d8ef082c089","timestamp":"2026-01-12T06:23:16.965Z"}
{"parentUuid":"76073550-e92c-46ad-9f57-7d8ef082c089","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gvp4dBzbRhVLEMYu6NXiMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UE5XVjBhyVbH7umUqv7pav","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/orchestrator.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":641,"cache_read_input_tokens":18657,"cache_creation":{"ephemeral_5m_input_tokens":641,"ephemeral_1h_input_tokens":0},"output_tokens":279,"service_tier":"standard"}},"requestId":"req_011CX31BK5aZwxCdGfJwJwWK","type":"assistant","uuid":"cdfe3fed-31e2-48af-a471-37bf95a9237e","timestamp":"2026-01-12T06:23:17.192Z"}
{"parentUuid":"cdfe3fed-31e2-48af-a471-37bf95a9237e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"EISDIR: illegal operation on a directory, read","is_error":true,"tool_use_id":"toolu_0178wMusP5jBYqSyGjUsuiFa"}]},"uuid":"1bc68a0c-59a8-44e5-9626-44b908146619","timestamp":"2026-01-12T06:23:17.229Z","toolUseResult":"Error: EISDIR: illegal operation on a directory, read"}
{"parentUuid":"1bc68a0c-59a8-44e5-9626-44b908146619","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BzEKTHN8AwjLAGfSa9F2wF","type":"tool_result","content":"     1→/**\n     2→ * Agent System for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Core agent system providing registry, lifecycle management, orchestration,\n     5→ * communication, and coordination capabilities.\n     6→ *\n     7→ * This module exports all components of the agent system:\n     8→ * - AgentRegistry: Agent registration and discovery\n     9→ * - AgentLifecycleManager: Agent lifecycle management\n    10→ * - AgentOrchestrator: Multi-agent orchestration\n    11→ * - AgentCommunicationManager: Agent communication\n    12→ * - AgentCoordinationManager: Agent coordination primitives\n    13→ */\n    14→\n    15→// Test agents\n    16→export {\n    17→  GENERAL_AGENT,\n    18→  CODER_AGENT,\n    19→  REVERSE_ENGINEER_AGENT,\n    20→  TEST_AGENTS,\n    21→  initializeTestAgents,\n    22→  getTestAgent,\n    23→} from './test-agents';\n    24→\n    25→// Registry\n    26→export {\n    27→  AgentRegistry,\n    28→  type AgentRegistrationOptions,\n    29→  type AgentFilterOptions,\n    30→  type AgentStatistics,\n    31→  initAgentRegistry,\n    32→  getAgentRegistry,\n    33→} from './registry';\n    34→\n    35→// Lifecycle\n    36→export {\n    37→  AgentLifecycleManager,\n    38→  AgentLifecycleState,\n    39→  AgentLifecycleEvent,\n    40→  type AgentLifecycleEventHandler,\n    41→  type AgentExecutionContext,\n    42→  type AgentInstance,\n    43→  type AgentLifecycleManagerConfig,\n    44→  initAgentLifecycleManager,\n    45→  getAgentLifecycleManager,\n    46→} from './lifecycle';\n    47→\n    48→// Orchestrator\n    49→export {\n    50→  AgentOrchestrator,\n    51→  TaskPriority,\n    52→  TaskStatus,\n    53→  type OrchestratedTask,\n    54→  AgentSelectionStrategy,\n    55→  type AgentSelectionCriteria,\n    56→  type AgentOrchestratorConfig,\n    57→  initAgentOrchestrator,\n    58→  getAgentOrchestrator,\n    59→} from './orchestrator';\n    60→\n    61→// Communication\n    62→export {\n    63→  AgentCommunicationManager,\n    64→  MessageType,\n    65→  MessagePriority,\n    66→  type AgentMessage,\n    67→  type MessageHandler,\n    68→  type MessageFilter,\n    69→  type CommunicationChannelConfig,\n    70→  initAgentCommunicationManager,\n    71→  getAgentCommunicationManager,\n    72→} from './communication';\n    73→\n    74→// Coordination\n    75→export {\n    76→  AgentCoordinationManager,\n    77→  TaskQueue,\n    78→  QueuePriority,\n    79→  type QueueItem,\n    80→  type QueueStatistics,\n    81→  type TaskQueueConfig,\n    82→  SharedState,\n    83→  type SharedStateConfig,\n    84→  Barrier,\n    85→  type BarrierConfig,\n    86→  Semaphore,\n    87→  type SemaphoreConfig,\n    88→  initAgentCoordinationManager,\n    89→  getAgentCoordinationManager,\n    90→} from './coordination';\n    91→\n\n</system-reminder>\n"}]},"uuid":"4d3f7586-3944-40ab-8cde-dd240dd9413f","timestamp":"2026-01-12T06:23:17.222Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/index.ts","content":"/**\n * Agent System for KOMPLETE-KONTROL CLI\n *\n * Core agent system providing registry, lifecycle management, orchestration,\n * communication, and coordination capabilities.\n *\n * This module exports all components of the agent system:\n * - AgentRegistry: Agent registration and discovery\n * - AgentLifecycleManager: Agent lifecycle management\n * - AgentOrchestrator: Multi-agent orchestration\n * - AgentCommunicationManager: Agent communication\n * - AgentCoordinationManager: Agent coordination primitives\n */\n\n// Test agents\nexport {\n  GENERAL_AGENT,\n  CODER_AGENT,\n  REVERSE_ENGINEER_AGENT,\n  TEST_AGENTS,\n  initializeTestAgents,\n  getTestAgent,\n} from './test-agents';\n\n// Registry\nexport {\n  AgentRegistry,\n  type AgentRegistrationOptions,\n  type AgentFilterOptions,\n  type AgentStatistics,\n  initAgentRegistry,\n  getAgentRegistry,\n} from './registry';\n\n// Lifecycle\nexport {\n  AgentLifecycleManager,\n  AgentLifecycleState,\n  AgentLifecycleEvent,\n  type AgentLifecycleEventHandler,\n  type AgentExecutionContext,\n  type AgentInstance,\n  type AgentLifecycleManagerConfig,\n  initAgentLifecycleManager,\n  getAgentLifecycleManager,\n} from './lifecycle';\n\n// Orchestrator\nexport {\n  AgentOrchestrator,\n  TaskPriority,\n  TaskStatus,\n  type OrchestratedTask,\n  AgentSelectionStrategy,\n  type AgentSelectionCriteria,\n  type AgentOrchestratorConfig,\n  initAgentOrchestrator,\n  getAgentOrchestrator,\n} from './orchestrator';\n\n// Communication\nexport {\n  AgentCommunicationManager,\n  MessageType,\n  MessagePriority,\n  type AgentMessage,\n  type MessageHandler,\n  type MessageFilter,\n  type CommunicationChannelConfig,\n  initAgentCommunicationManager,\n  getAgentCommunicationManager,\n} from './communication';\n\n// Coordination\nexport {\n  AgentCoordinationManager,\n  TaskQueue,\n  QueuePriority,\n  type QueueItem,\n  type QueueStatistics,\n  type TaskQueueConfig,\n  SharedState,\n  type SharedStateConfig,\n  Barrier,\n  type BarrierConfig,\n  Semaphore,\n  type SemaphoreConfig,\n  initAgentCoordinationManager,\n  getAgentCoordinationManager,\n} from './coordination';\n","numLines":91,"startLine":1,"totalLines":91}}}
{"parentUuid":"4d3f7586-3944-40ab-8cde-dd240dd9413f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011jBrXeXJfjNfpqCRihVbkG","type":"tool_result","content":"     1→/**\n     2→ * Agent Registry for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Provides agent registration, discovery, and management capabilities.\n     5→ * Follows patterns from agent-swarm-kit with simplified architecture.\n     6→ */\n     7→\n     8→import type { AgentDefinition } from '../../types';\n     9→import { AgentError } from '../../types';\n    10→import { Logger } from '../../utils/logger';\n    11→\n    12→/**\n    13→ * Agent registration options\n    14→ */\n    15→export interface AgentRegistrationOptions {\n    16→  /**\n    17→   * Whether to auto-start the agent on registration\n    18→   */\n    19→  autoStart?: boolean;\n    20→  /**\n    21→   * Priority for agent selection (higher = preferred)\n    22→   */\n    23→  priority?: number;\n    24→  /**\n    25→   * Tags for categorization and filtering\n    26→   */\n    27→  tags?: string[];\n    28→}\n    29→\n    30→/**\n    31→ * Agent registration record\n    32→ */\n    33→interface AgentRecord {\n    34→  definition: AgentDefinition;\n    35→  options: AgentRegistrationOptions;\n    36→  registeredAt: Date;\n    37→  lastUsed?: Date;\n    38→  status: 'registered' | 'active' | 'paused' | 'unregistered';\n    39→}\n    40→\n    41→/**\n    42→ * Agent filter options\n    43→ */\n    44→export interface AgentFilterOptions {\n    45→  /**\n    46→   * Filter by capability\n    47→   */\n    48→  capability?: string;\n    49→  /**\n    50→   * Filter by tag\n    51→   */\n    52→  tag?: string;\n    53→  /**\n    54→   * Filter by status\n    55→   */\n    56→  status?: 'registered' | 'active' | 'paused' | 'unregistered';\n    57→  /**\n    58→   * Filter by dependencies (agents that depend on given agent)\n    59→   */\n    60→  dependsOn?: string;\n    61→  /**\n    62→   * Minimum priority\n    63→   */\n    64→  minPriority?: number;\n    65→}\n    66→\n    67→/**\n    68→ * Agent statistics\n    69→ */\n    70→export interface AgentStatistics {\n    71→  /**\n    72→   * Total number of registered agents\n    73→   */\n    74→  totalAgents: number;\n    75→  /**\n    76→   * Number of active agents\n    77→   */\n    78→  activeAgents: number;\n    79→  /**\n    80→   * Number of paused agents\n    81→   */\n    82→  pausedAgents: number;\n    83→  /**\n    84→   * Most recently used agent\n    85→   */\n    86→  lastUsedAgent?: string;\n    87→  /**\n    88→   * Capabilities distribution\n    89→   */\n    90→  capabilitiesDistribution: Record<string, number>;\n    91→}\n    92→\n    93→/**\n    94→ * Agent Registry class\n    95→ *\n    96→ * Manages agent registration, discovery, and querying.\n    97→ * Provides a centralized registry for all available agents.\n    98→ */\n    99→export class AgentRegistry {\n   100→  private agents: Map<string, AgentRecord> = new Map();\n   101→  private logger: Logger;\n   102→\n   103→  constructor(logger?: Logger) {\n   104→    this.logger = logger || new Logger();\n   105→    this.logger.info('AgentRegistry initialized', 'AgentRegistry');\n   106→  }\n   107→\n   108→  /**\n   109→   * Register an agent\n   110→   *\n   111→   * @param definition - Agent definition to register\n   112→   * @param options - Registration options\n   113→   * @returns The registered agent ID\n   114→   * @throws AgentError if agent with same ID already exists\n   115→   */\n   116→  register(definition: AgentDefinition, options: AgentRegistrationOptions = {}): string {\n   117→    const agentId = definition.id;\n   118→\n   119→    // Check if agent already exists\n   120→    if (this.agents.has(agentId)) {\n   121→      throw new AgentError(\n   122→        `Agent with ID '${agentId}' is already registered`,\n   123→        agentId,\n   124→        { existingAgent: this.agents.get(agentId)?.definition }\n   125→      );\n   126→    }\n   127→\n   128→    // Validate agent definition\n   129→    this.validateDefinition(definition);\n   130→\n   131→    // Create agent record\n   132→    const record: AgentRecord = {\n   133→      definition,\n   134→      options: {\n   135→        autoStart: options.autoStart ?? false,\n   136→        priority: options.priority ?? 0,\n   137→        tags: options.tags ?? [],\n   138→      },\n   139→      registeredAt: new Date(),\n   140→      status: options.autoStart ? 'active' : 'registered',\n   141→    };\n   142→\n   143→    // Store agent\n   144→    this.agents.set(agentId, record);\n   145→\n   146→    this.logger.info(\n   147→      `Agent registered: ${agentId}`,\n   148→      'AgentRegistry',\n   149→      {\n   150→        name: definition.name,\n   151→        capabilities: definition.capabilities,\n   152→        status: record.status,\n   153→      }\n   154→    );\n   155→\n   156→    return agentId;\n   157→  }\n   158→\n   159→  /**\n   160→   * Unregister an agent\n   161→   *\n   162→   * @param agentId - ID of agent to unregister\n   163→   * @returns True if agent was unregistered, false if not found\n   164→   */\n   165→  unregister(agentId: string): boolean {\n   166→    const record = this.agents.get(agentId);\n   167→\n   168→    if (!record) {\n   169→      this.logger.warn(`Agent not found for unregistration: ${agentId}`, 'AgentRegistry');\n   170→      return false;\n   171→    }\n   172→\n   173→    // Check for dependent agents\n   174→    const dependents = this.getDependents(agentId);\n   175→    if (dependents.length > 0) {\n   176→      throw new AgentError(\n   177→        `Cannot unregister agent '${agentId}' - ${dependents.length} agent(s) depend on it`,\n   178→        agentId,\n   179→        { dependents }\n   180→      );\n   181→    }\n   182→\n   183→    // Mark as unregistered\n   184→    record.status = 'unregistered';\n   185→\n   186→    this.logger.info(`Agent unregistered: ${agentId}`, 'AgentRegistry', {\n   187→      name: record.definition.name,\n   188→    });\n   189→\n   190→    return true;\n   191→  }\n   192→\n   193→  /**\n   194→   * Get an agent by ID\n   195→   *\n   196→   * @param agentId - ID of agent to get\n   197→   * @returns Agent definition or undefined if not found\n   198→   */\n   199→  get(agentId: string): AgentDefinition | undefined {\n   200→    const record = this.agents.get(agentId);\n   201→    return record?.definition;\n   202→  }\n   203→\n   204→  /**\n   205→   * Check if an agent is registered\n   206→   *\n   207→   * @param agentId - ID of agent to check\n   208→   * @returns True if agent is registered\n   209→   */\n   210→  has(agentId: string): boolean {\n   211→    return this.agents.has(agentId);\n   212→  }\n   213→\n   214→  /**\n   215→   * List all registered agents\n   216→   *\n   217→   * @param filter - Optional filter options\n   218→   * @returns Array of agent definitions\n   219→   */\n   220→  list(filter?: AgentFilterOptions): AgentDefinition[] {\n   221→    let agents = Array.from(this.agents.values());\n   222→\n   223→    // Apply filters\n   224→    if (filter) {\n   225→      if (filter.capability) {\n   226→        agents = agents.filter((record) =>\n   227→          record.definition.capabilities.includes(filter.capability!)\n   228→        );\n   229→      }\n   230→      if (filter.tag) {\n   231→        agents = agents.filter((record) =>\n   232→          record.options.tags?.includes(filter.tag!)\n   233→        );\n   234→      }\n   235→      if (filter.status) {\n   236→        agents = agents.filter((record) => record.status === filter.status);\n   237→      }\n   238→      if (filter.dependsOn) {\n   239→        agents = agents.filter((record) =>\n   240→          record.definition.dependencies?.includes(filter.dependsOn!)\n   241→        );\n   242→      }\n   243→      if (filter.minPriority !== undefined) {\n   244→        agents = agents.filter(\n   245→          (record) => record.options.priority! >= filter.minPriority!\n   246→        );\n   247→      }\n   248→    }\n   249→\n   250→    // Sort by priority (descending) then by registration time (ascending)\n   251→    agents.sort((a, b) => {\n   252→      const priorityDiff = (b.options.priority ?? 0) - (a.options.priority ?? 0);\n   253→      if (priorityDiff !== 0) return priorityDiff;\n   254→      return a.registeredAt.getTime() - b.registeredAt.getTime();\n   255→    });\n   256→\n   257→    return agents.map((record) => record.definition);\n   258→  }\n   259→\n   260→  /**\n   261→   * Find agents by capability\n   262→   *\n   263→   * @param capability - Capability to search for\n   264→   * @returns Array of agent definitions with the capability\n   265→   */\n   266→  findByCapability(capability: string): AgentDefinition[] {\n   267→    return this.list({ capability });\n   268→  }\n   269→\n   270→  /**\n   271→   * Find agents by tag\n   272→   *\n   273→   * @param tag - Tag to search for\n   274→   * @returns Array of agent definitions with the tag\n   275→   */\n   276→  findByTag(tag: string): AgentDefinition[] {\n   277→    return this.list({ tag });\n   278→  }\n   279→\n   280→  /**\n   281→   * Get agent capabilities\n   282→   *\n   283→   * @param agentId - ID of agent\n   284→   * @returns Array of capabilities or undefined if agent not found\n   285→   */\n   286→  getCapabilities(agentId: string): string[] | undefined {\n   287→    const record = this.agents.get(agentId);\n   288→    return record?.definition.capabilities;\n   289→  }\n   290→\n   291→  /**\n   292→   * Check if agent dependencies are satisfied\n   293→   *\n   294→   * @param agentId - ID of agent to check\n   295→   * @returns True if all dependencies are registered\n   296→   */\n   297→  checkDependencies(agentId: string): boolean {\n   298→    const record = this.agents.get(agentId);\n   299→\n   300→    if (!record || !record.definition.dependencies) {\n   301→      return true;\n   302→    }\n   303→\n   304→    const { dependencies } = record.definition;\n   305→\n   306→    for (const depId of dependencies) {\n   307→      if (!this.agents.has(depId)) {\n   308→        this.logger.warn(\n   309→          `Missing dependency for agent '${agentId}': ${depId}`,\n   310→          'AgentRegistry'\n   311→        );\n   312→        return false;\n   313→      }\n   314→\n   315→      const depRecord = this.agents.get(depId)!;\n   316→      if (depRecord.status === 'unregistered') {\n   317→        this.logger.warn(\n   318→          `Dependency '${depId}' for agent '${agentId}' is unregistered`,\n   319→          'AgentRegistry'\n   320→        );\n   321→        return false;\n   322→      }\n   323→    }\n   324→\n   325→    return true;\n   326→  }\n   327→\n   328→  /**\n   329→   * Get agents that depend on a given agent\n   330→   *\n   331→   * @param agentId - ID of agent to find dependents for\n   332→   * @returns Array of agent IDs that depend on the given agent\n   333→   */\n   334→  getDependents(agentId: string): string[] {\n   335→    const dependents: string[] = [];\n   336→\n   337→    for (const [id, record] of this.agents.entries()) {\n   338→      if (record.definition.dependencies?.includes(agentId)) {\n   339→        dependents.push(id);\n   340→      }\n   341→    }\n   342→\n   343→    return dependents;\n   344→  }\n   345→\n   346→  /**\n   347→   * Update agent status\n   348→   *\n   349→   * @param agentId - ID of agent to update\n   350→   * @param status - New status\n   351→   * @returns True if status was updated, false if agent not found\n   352→   */\n   353→  updateStatus(\n   354→    agentId: string,\n   355→    status: 'registered' | 'active' | 'paused' | 'unregistered'\n   356→  ): boolean {\n   357→    const record = this.agents.get(agentId);\n   358→\n   359→    if (!record) {\n   360→      this.logger.warn(`Agent not found for status update: ${agentId}`, 'AgentRegistry');\n   361→      return false;\n   362→    }\n   363→\n   364→    record.status = status;\n   365→\n   366→    this.logger.debug(\n   367→      `Agent status updated: ${agentId} -> ${status}`,\n   368→      'AgentRegistry'\n   369→    );\n   370→\n   371→    return true;\n   372→  }\n   373→\n   374→  /**\n   375→   * Mark agent as used\n   376→   *\n   377→   * @param agentId - ID of agent to mark as used\n   378→   */\n   379→  markUsed(agentId: string): void {\n   380→    const record = this.agents.get(agentId);\n   381→\n   382→    if (record) {\n   383→      record.lastUsed = new Date();\n   384→      this.logger.debug(`Agent marked as used: ${agentId}`, 'AgentRegistry');\n   385→    }\n   386→  }\n   387→\n   388→  /**\n   389→   * Get agent statistics\n   390→   *\n   391→   * @returns Registry statistics\n   392→   */\n   393→  getStatistics(): AgentStatistics {\n   394→    const agents = Array.from(this.agents.values());\n   395→    const activeAgents = agents.filter((a) => a.status === 'active');\n   396→    const pausedAgents = agents.filter((a) => a.status === 'paused');\n   397→\n   398→    // Find most recently used agent\n   399→    let lastUsedAgent: string | undefined;\n   400→    let lastUsedTime: Date | undefined;\n   401→\n   402→    for (const [id, record] of this.agents.entries()) {\n   403→      if (record.lastUsed && (!lastUsedTime || record.lastUsed > lastUsedTime)) {\n   404→        lastUsedTime = record.lastUsed;\n   405→        lastUsedAgent = id;\n   406→      }\n   407→    }\n   408→\n   409→    // Calculate capabilities distribution\n   410→    const capabilitiesDistribution: Record<string, number> = {};\n   411→\n   412→    for (const record of agents) {\n   413→      for (const capability of record.definition.capabilities) {\n   414→        capabilitiesDistribution[capability] =\n   415→          (capabilitiesDistribution[capability] || 0) + 1;\n   416→      }\n   417→    }\n   418→\n   419→    return {\n   420→      totalAgents: agents.length,\n   421→      activeAgents: activeAgents.length,\n   422→      pausedAgents: pausedAgents.length,\n   423→      lastUsedAgent,\n   424→      capabilitiesDistribution,\n   425→    };\n   426→  }\n   427→\n   428→  /**\n   429→   * Clear all registered agents\n   430→   */\n   431→  clear(): void {\n   432→    this.agents.clear();\n   433→    this.logger.info('AgentRegistry cleared', 'AgentRegistry');\n   434→  }\n   435→\n   436→  /**\n   437→   * Validate agent definition\n   438→   *\n   439→   * @param definition - Agent definition to validate\n   440→   * @throws AgentError if validation fails\n   441→   */\n   442→  private validateDefinition(definition: AgentDefinition): void {\n   443→    if (!definition.id || definition.id.trim() === '') {\n   444→      throw new AgentError('Agent ID is required', definition.id || 'unknown');\n   445→    }\n   446→\n   447→    if (!definition.name || definition.name.trim() === '') {\n   448→      throw new AgentError('Agent name is required', definition.id);\n   449→    }\n   450→\n   451→    if (!definition.description || definition.description.trim() === '') {\n   452→      throw new AgentError('Agent description is required', definition.id);\n   453→    }\n   454→\n   455→    if (!definition.capabilities || definition.capabilities.length === 0) {\n   456→      throw new AgentError('Agent must have at least one capability', definition.id);\n   457→    }\n   458→\n   459→    if (!definition.systemPrompt || definition.systemPrompt.trim() === '') {\n   460→      throw new AgentError('Agent system prompt is required', definition.id);\n   461→    }\n   462→\n   463→    // Validate dependencies exist\n   464→    if (definition.dependencies) {\n   465→      for (const depId of definition.dependencies) {\n   466→        if (!this.agents.has(depId)) {\n   467→          this.logger.warn(\n   468→            `Dependency '${depId}' for agent '${definition.id}' is not yet registered`,\n   469→            'AgentRegistry'\n   470→          );\n   471→        }\n   472→      }\n   473→    }\n   474→  }\n   475→}\n   476→\n   477→/**\n   478→ * Global agent registry instance\n   479→ */\n   480→let globalAgentRegistry: AgentRegistry | null = null;\n   481→\n   482→/**\n   483→ * Initialize global agent registry\n   484→ *\n   485→ * @param logger - Optional logger instance\n   486→ * @returns The global agent registry\n   487→ */\n   488→export function initAgentRegistry(logger?: Logger): AgentRegistry {\n   489→  globalAgentRegistry = new AgentRegistry(logger);\n   490→  return globalAgentRegistry;\n   491→}\n   492→\n   493→/**\n   494→ * Get global agent registry\n   495→ *\n   496→ * @returns The global agent registry\n   497→ */\n   498→export function getAgentRegistry(): AgentRegistry {\n   499→  if (!globalAgentRegistry) {\n   500→    globalAgentRegistry = new AgentRegistry();\n   501→  }\n   502→  return globalAgentRegistry;\n   503→}\n   504→\n\n</system-reminder>\n"}]},"uuid":"2372ce0c-22b0-4db3-80c7-025fa5968269","timestamp":"2026-01-12T06:23:17.223Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/registry.ts","content":"/**\n * Agent Registry for KOMPLETE-KONTROL CLI\n *\n * Provides agent registration, discovery, and management capabilities.\n * Follows patterns from agent-swarm-kit with simplified architecture.\n */\n\nimport type { AgentDefinition } from '../../types';\nimport { AgentError } from '../../types';\nimport { Logger } from '../../utils/logger';\n\n/**\n * Agent registration options\n */\nexport interface AgentRegistrationOptions {\n  /**\n   * Whether to auto-start the agent on registration\n   */\n  autoStart?: boolean;\n  /**\n   * Priority for agent selection (higher = preferred)\n   */\n  priority?: number;\n  /**\n   * Tags for categorization and filtering\n   */\n  tags?: string[];\n}\n\n/**\n * Agent registration record\n */\ninterface AgentRecord {\n  definition: AgentDefinition;\n  options: AgentRegistrationOptions;\n  registeredAt: Date;\n  lastUsed?: Date;\n  status: 'registered' | 'active' | 'paused' | 'unregistered';\n}\n\n/**\n * Agent filter options\n */\nexport interface AgentFilterOptions {\n  /**\n   * Filter by capability\n   */\n  capability?: string;\n  /**\n   * Filter by tag\n   */\n  tag?: string;\n  /**\n   * Filter by status\n   */\n  status?: 'registered' | 'active' | 'paused' | 'unregistered';\n  /**\n   * Filter by dependencies (agents that depend on given agent)\n   */\n  dependsOn?: string;\n  /**\n   * Minimum priority\n   */\n  minPriority?: number;\n}\n\n/**\n * Agent statistics\n */\nexport interface AgentStatistics {\n  /**\n   * Total number of registered agents\n   */\n  totalAgents: number;\n  /**\n   * Number of active agents\n   */\n  activeAgents: number;\n  /**\n   * Number of paused agents\n   */\n  pausedAgents: number;\n  /**\n   * Most recently used agent\n   */\n  lastUsedAgent?: string;\n  /**\n   * Capabilities distribution\n   */\n  capabilitiesDistribution: Record<string, number>;\n}\n\n/**\n * Agent Registry class\n *\n * Manages agent registration, discovery, and querying.\n * Provides a centralized registry for all available agents.\n */\nexport class AgentRegistry {\n  private agents: Map<string, AgentRecord> = new Map();\n  private logger: Logger;\n\n  constructor(logger?: Logger) {\n    this.logger = logger || new Logger();\n    this.logger.info('AgentRegistry initialized', 'AgentRegistry');\n  }\n\n  /**\n   * Register an agent\n   *\n   * @param definition - Agent definition to register\n   * @param options - Registration options\n   * @returns The registered agent ID\n   * @throws AgentError if agent with same ID already exists\n   */\n  register(definition: AgentDefinition, options: AgentRegistrationOptions = {}): string {\n    const agentId = definition.id;\n\n    // Check if agent already exists\n    if (this.agents.has(agentId)) {\n      throw new AgentError(\n        `Agent with ID '${agentId}' is already registered`,\n        agentId,\n        { existingAgent: this.agents.get(agentId)?.definition }\n      );\n    }\n\n    // Validate agent definition\n    this.validateDefinition(definition);\n\n    // Create agent record\n    const record: AgentRecord = {\n      definition,\n      options: {\n        autoStart: options.autoStart ?? false,\n        priority: options.priority ?? 0,\n        tags: options.tags ?? [],\n      },\n      registeredAt: new Date(),\n      status: options.autoStart ? 'active' : 'registered',\n    };\n\n    // Store agent\n    this.agents.set(agentId, record);\n\n    this.logger.info(\n      `Agent registered: ${agentId}`,\n      'AgentRegistry',\n      {\n        name: definition.name,\n        capabilities: definition.capabilities,\n        status: record.status,\n      }\n    );\n\n    return agentId;\n  }\n\n  /**\n   * Unregister an agent\n   *\n   * @param agentId - ID of agent to unregister\n   * @returns True if agent was unregistered, false if not found\n   */\n  unregister(agentId: string): boolean {\n    const record = this.agents.get(agentId);\n\n    if (!record) {\n      this.logger.warn(`Agent not found for unregistration: ${agentId}`, 'AgentRegistry');\n      return false;\n    }\n\n    // Check for dependent agents\n    const dependents = this.getDependents(agentId);\n    if (dependents.length > 0) {\n      throw new AgentError(\n        `Cannot unregister agent '${agentId}' - ${dependents.length} agent(s) depend on it`,\n        agentId,\n        { dependents }\n      );\n    }\n\n    // Mark as unregistered\n    record.status = 'unregistered';\n\n    this.logger.info(`Agent unregistered: ${agentId}`, 'AgentRegistry', {\n      name: record.definition.name,\n    });\n\n    return true;\n  }\n\n  /**\n   * Get an agent by ID\n   *\n   * @param agentId - ID of agent to get\n   * @returns Agent definition or undefined if not found\n   */\n  get(agentId: string): AgentDefinition | undefined {\n    const record = this.agents.get(agentId);\n    return record?.definition;\n  }\n\n  /**\n   * Check if an agent is registered\n   *\n   * @param agentId - ID of agent to check\n   * @returns True if agent is registered\n   */\n  has(agentId: string): boolean {\n    return this.agents.has(agentId);\n  }\n\n  /**\n   * List all registered agents\n   *\n   * @param filter - Optional filter options\n   * @returns Array of agent definitions\n   */\n  list(filter?: AgentFilterOptions): AgentDefinition[] {\n    let agents = Array.from(this.agents.values());\n\n    // Apply filters\n    if (filter) {\n      if (filter.capability) {\n        agents = agents.filter((record) =>\n          record.definition.capabilities.includes(filter.capability!)\n        );\n      }\n      if (filter.tag) {\n        agents = agents.filter((record) =>\n          record.options.tags?.includes(filter.tag!)\n        );\n      }\n      if (filter.status) {\n        agents = agents.filter((record) => record.status === filter.status);\n      }\n      if (filter.dependsOn) {\n        agents = agents.filter((record) =>\n          record.definition.dependencies?.includes(filter.dependsOn!)\n        );\n      }\n      if (filter.minPriority !== undefined) {\n        agents = agents.filter(\n          (record) => record.options.priority! >= filter.minPriority!\n        );\n      }\n    }\n\n    // Sort by priority (descending) then by registration time (ascending)\n    agents.sort((a, b) => {\n      const priorityDiff = (b.options.priority ?? 0) - (a.options.priority ?? 0);\n      if (priorityDiff !== 0) return priorityDiff;\n      return a.registeredAt.getTime() - b.registeredAt.getTime();\n    });\n\n    return agents.map((record) => record.definition);\n  }\n\n  /**\n   * Find agents by capability\n   *\n   * @param capability - Capability to search for\n   * @returns Array of agent definitions with the capability\n   */\n  findByCapability(capability: string): AgentDefinition[] {\n    return this.list({ capability });\n  }\n\n  /**\n   * Find agents by tag\n   *\n   * @param tag - Tag to search for\n   * @returns Array of agent definitions with the tag\n   */\n  findByTag(tag: string): AgentDefinition[] {\n    return this.list({ tag });\n  }\n\n  /**\n   * Get agent capabilities\n   *\n   * @param agentId - ID of agent\n   * @returns Array of capabilities or undefined if agent not found\n   */\n  getCapabilities(agentId: string): string[] | undefined {\n    const record = this.agents.get(agentId);\n    return record?.definition.capabilities;\n  }\n\n  /**\n   * Check if agent dependencies are satisfied\n   *\n   * @param agentId - ID of agent to check\n   * @returns True if all dependencies are registered\n   */\n  checkDependencies(agentId: string): boolean {\n    const record = this.agents.get(agentId);\n\n    if (!record || !record.definition.dependencies) {\n      return true;\n    }\n\n    const { dependencies } = record.definition;\n\n    for (const depId of dependencies) {\n      if (!this.agents.has(depId)) {\n        this.logger.warn(\n          `Missing dependency for agent '${agentId}': ${depId}`,\n          'AgentRegistry'\n        );\n        return false;\n      }\n\n      const depRecord = this.agents.get(depId)!;\n      if (depRecord.status === 'unregistered') {\n        this.logger.warn(\n          `Dependency '${depId}' for agent '${agentId}' is unregistered`,\n          'AgentRegistry'\n        );\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get agents that depend on a given agent\n   *\n   * @param agentId - ID of agent to find dependents for\n   * @returns Array of agent IDs that depend on the given agent\n   */\n  getDependents(agentId: string): string[] {\n    const dependents: string[] = [];\n\n    for (const [id, record] of this.agents.entries()) {\n      if (record.definition.dependencies?.includes(agentId)) {\n        dependents.push(id);\n      }\n    }\n\n    return dependents;\n  }\n\n  /**\n   * Update agent status\n   *\n   * @param agentId - ID of agent to update\n   * @param status - New status\n   * @returns True if status was updated, false if agent not found\n   */\n  updateStatus(\n    agentId: string,\n    status: 'registered' | 'active' | 'paused' | 'unregistered'\n  ): boolean {\n    const record = this.agents.get(agentId);\n\n    if (!record) {\n      this.logger.warn(`Agent not found for status update: ${agentId}`, 'AgentRegistry');\n      return false;\n    }\n\n    record.status = status;\n\n    this.logger.debug(\n      `Agent status updated: ${agentId} -> ${status}`,\n      'AgentRegistry'\n    );\n\n    return true;\n  }\n\n  /**\n   * Mark agent as used\n   *\n   * @param agentId - ID of agent to mark as used\n   */\n  markUsed(agentId: string): void {\n    const record = this.agents.get(agentId);\n\n    if (record) {\n      record.lastUsed = new Date();\n      this.logger.debug(`Agent marked as used: ${agentId}`, 'AgentRegistry');\n    }\n  }\n\n  /**\n   * Get agent statistics\n   *\n   * @returns Registry statistics\n   */\n  getStatistics(): AgentStatistics {\n    const agents = Array.from(this.agents.values());\n    const activeAgents = agents.filter((a) => a.status === 'active');\n    const pausedAgents = agents.filter((a) => a.status === 'paused');\n\n    // Find most recently used agent\n    let lastUsedAgent: string | undefined;\n    let lastUsedTime: Date | undefined;\n\n    for (const [id, record] of this.agents.entries()) {\n      if (record.lastUsed && (!lastUsedTime || record.lastUsed > lastUsedTime)) {\n        lastUsedTime = record.lastUsed;\n        lastUsedAgent = id;\n      }\n    }\n\n    // Calculate capabilities distribution\n    const capabilitiesDistribution: Record<string, number> = {};\n\n    for (const record of agents) {\n      for (const capability of record.definition.capabilities) {\n        capabilitiesDistribution[capability] =\n          (capabilitiesDistribution[capability] || 0) + 1;\n      }\n    }\n\n    return {\n      totalAgents: agents.length,\n      activeAgents: activeAgents.length,\n      pausedAgents: pausedAgents.length,\n      lastUsedAgent,\n      capabilitiesDistribution,\n    };\n  }\n\n  /**\n   * Clear all registered agents\n   */\n  clear(): void {\n    this.agents.clear();\n    this.logger.info('AgentRegistry cleared', 'AgentRegistry');\n  }\n\n  /**\n   * Validate agent definition\n   *\n   * @param definition - Agent definition to validate\n   * @throws AgentError if validation fails\n   */\n  private validateDefinition(definition: AgentDefinition): void {\n    if (!definition.id || definition.id.trim() === '') {\n      throw new AgentError('Agent ID is required', definition.id || 'unknown');\n    }\n\n    if (!definition.name || definition.name.trim() === '') {\n      throw new AgentError('Agent name is required', definition.id);\n    }\n\n    if (!definition.description || definition.description.trim() === '') {\n      throw new AgentError('Agent description is required', definition.id);\n    }\n\n    if (!definition.capabilities || definition.capabilities.length === 0) {\n      throw new AgentError('Agent must have at least one capability', definition.id);\n    }\n\n    if (!definition.systemPrompt || definition.systemPrompt.trim() === '') {\n      throw new AgentError('Agent system prompt is required', definition.id);\n    }\n\n    // Validate dependencies exist\n    if (definition.dependencies) {\n      for (const depId of definition.dependencies) {\n        if (!this.agents.has(depId)) {\n          this.logger.warn(\n            `Dependency '${depId}' for agent '${definition.id}' is not yet registered`,\n            'AgentRegistry'\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Global agent registry instance\n */\nlet globalAgentRegistry: AgentRegistry | null = null;\n\n/**\n * Initialize global agent registry\n *\n * @param logger - Optional logger instance\n * @returns The global agent registry\n */\nexport function initAgentRegistry(logger?: Logger): AgentRegistry {\n  globalAgentRegistry = new AgentRegistry(logger);\n  return globalAgentRegistry;\n}\n\n/**\n * Get global agent registry\n *\n * @returns The global agent registry\n */\nexport function getAgentRegistry(): AgentRegistry {\n  if (!globalAgentRegistry) {\n    globalAgentRegistry = new AgentRegistry();\n  }\n  return globalAgentRegistry;\n}\n","numLines":504,"startLine":1,"totalLines":504}}}
{"parentUuid":"2372ce0c-22b0-4db3-80c7-025fa5968269","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UE5XVjBhyVbH7umUqv7pav","type":"tool_result","content":"     1→/**\n     2→ * Agent Orchestrator for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Provides multi-agent orchestration capabilities including task distribution,\n     5→ * agent selection, and coordination across multiple agents.\n     6→ * Follows patterns from agent-swarm-kit with simplified architecture.\n     7→ */\n     8→\n     9→import type { AgentDefinition, AgentError, AgentTask, AgentTaskResult } from '../../types';\n    10→import { Logger } from '../../utils/logger';\n    11→import { ErrorHandler } from '../../utils/error-handler';\n    12→import { AgentRegistry, getAgentRegistry } from './registry';\n    13→import {\n    14→  AgentLifecycleManager,\n    15→  getAgentLifecycleManager,\n    16→  AgentLifecycleState,\n    17→} from './lifecycle';\n    18→\n    19→/**\n    20→ * Task priority levels\n    21→ */\n    22→export enum TaskPriority {\n    23→  /**\n    24→   * Low priority task\n    25→   */\n    26→  LOW = 0,\n    27→  /**\n    28→   * Normal priority task\n    29→   */\n    30→  NORMAL = 1,\n    31→  /**\n    32→   * High priority task\n    33→   */\n    34→  HIGH = 2,\n    35→  /**\n    36→   * Critical priority task\n    37→   */\n    38→  CRITICAL = 3,\n    39→}\n    40→\n    41→/**\n    42→ * Task status\n    43→ */\n    44→export enum TaskStatus {\n    45→  /**\n    46→   * Task is pending\n    47→   */\n    48→  PENDING = 'pending',\n    49→  /**\n    50→   * Task is assigned to an agent\n    51→   */\n    52→  ASSIGNED = 'assigned',\n    53→  /**\n    54→   * Task is being executed\n    55→   */\n    56→  EXECUTING = 'executing',\n    57→  /**\n    58→   * Task completed successfully\n    59→   */\n    60→  COMPLETED = 'completed',\n    61→  /**\n    62→   * Task failed\n    63→   */\n    64→  FAILED = 'failed',\n    65→  /**\n    66→   * Task was cancelled\n    67→   */\n    68→  CANCELLED = 'cancelled',\n    69→}\n    70→\n    71→/**\n    72→ * Orchestrated task\n    73→ */\n    74→export interface OrchestratedTask extends AgentTask {\n    75→  /**\n    76→   * Task ID\n    77→   */\n    78→  id: string;\n    79→  /**\n    80→   * Task priority\n    81→   */\n    82→  priority: TaskPriority;\n    83→  /**\n    84→   * Task status\n    85→   */\n    86→  status: TaskStatus;\n    87→  /**\n    88→   * Assigned agent ID\n    89→   */\n    90→  assignedAgent?: string;\n    91→  /**\n    92→   * Task creation time\n    93→   */\n    94→  createdAt: Date;\n    95→  /**\n    96→   * Task start time\n    97→   */\n    98→  startedAt?: Date;\n    99→  /**\n   100→   * Task completion time\n   101→   */\n   102→  completedAt?: Date;\n   103→  /**\n   104→   * Task error (if any)\n   105→   */\n   106→  error?: Error;\n   107→  /**\n   108→   * Retry count\n   109→   */\n   110→  retryCount: number;\n   111→  /**\n   112→   * Maximum retries\n   113→   */\n   114→  maxRetries: number;\n   115→}\n   116→\n   117→/**\n   118→ * Agent selection strategy\n   119→ */\n   120→export enum AgentSelectionStrategy {\n   121→  /**\n   122→   * Select first available agent\n   123→   */\n   124→  FIRST_AVAILABLE = 'first_available',\n   125→  /**\n   126→   * Select agent with highest priority\n   127→   */\n   128→  HIGHEST_PRIORITY = 'highest_priority',\n   129→  /**\n   130→   * Select least recently used agent\n   131→   */\n   132→  LEAST_RECENTLY_USED = 'least_recently_used',\n   133→  /**\n   134→   * Round-robin selection\n   135→   */\n   136→  ROUND_ROBIN = 'round_robin',\n   137→}\n   138→\n   139→/**\n   140→ * Agent selection criteria\n   141→ */\n   142→export interface AgentSelectionCriteria {\n   143→  /**\n   144→   * Required capability\n   145→   */\n   146→  capability?: string;\n   147→  /**\n   148→   * Required tag\n   149→   */\n   150→  tag?: string;\n   151→  /**\n   152→   * Selection strategy\n   153→   */\n   154→  strategy?: AgentSelectionStrategy;\n   155→  /**\n   156→   * Exclude specific agents\n   157→   */\n   158→  exclude?: string[];\n   159→}\n   160→\n   161→/**\n   162→ * Orchestrator configuration\n   163→ */\n   164→export interface AgentOrchestratorConfig {\n   165→  /**\n   166→   * Maximum concurrent tasks\n   167→   */\n   168→  maxConcurrentTasks?: number;\n   169→  /**\n   170→   * Default task timeout in milliseconds\n   171→   */\n   172→  defaultTaskTimeout?: number;\n   173→  /**\n   174→   * Default task priority\n   175→   */\n   176→  defaultTaskPriority?: TaskPriority;\n   177→  /**\n   178→   * Default agent selection strategy\n   179→   */\n   180→  defaultSelectionStrategy?: AgentSelectionStrategy;\n   181→  /**\n   182→   * Enable task retry on failure\n   183→   */\n   184→  enableRetry?: boolean;\n   185→  /**\n   186→   * Maximum retry attempts\n   187→   */\n   188→  maxRetryAttempts?: number;\n   189→}\n   190→\n   191→/**\n   192→ * Agent Orchestrator class\n   193→ *\n   194→ * Coordinates multiple agents for task distribution and execution.\n   195→ * Provides agent selection, task scheduling, and coordination capabilities.\n   196→ */\n   197→export class AgentOrchestrator {\n   198→  private tasks: Map<string, OrchestratedTask> = new Map();\n   199→  private taskQueue: OrchestratedTask[] = [];\n   200→  private executingTasks: Set<string> = new Set();\n   201→  private roundRobinIndex: number = 0;\n   202→  private logger: Logger;\n   203→  private errorHandler: ErrorHandler;\n   204→  private registry: AgentRegistry;\n   205→  private lifecycleManager: AgentLifecycleManager;\n   206→  private config: Required<AgentOrchestratorConfig>;\n   207→\n   208→  constructor(\n   209→    config: AgentOrchestratorConfig = {},\n   210→    logger?: Logger,\n   211→    errorHandler?: ErrorHandler,\n   212→    registry?: AgentRegistry,\n   213→    lifecycleManager?: AgentLifecycleManager\n   214→  ) {\n   215→    this.logger = logger || new Logger();\n   216→    this.errorHandler = errorHandler || new ErrorHandler();\n   217→    this.registry = registry || getAgentRegistry();\n   218→    this.lifecycleManager = lifecycleManager || getAgentLifecycleManager();\n   219→    this.config = {\n   220→      maxConcurrentTasks: config.maxConcurrentTasks ?? 5,\n   221→      defaultTaskTimeout: config.defaultTaskTimeout ?? 30000,\n   222→      defaultTaskPriority: config.defaultTaskPriority ?? TaskPriority.NORMAL,\n   223→      defaultSelectionStrategy: config.defaultSelectionStrategy ?? AgentSelectionStrategy.HIGHEST_PRIORITY,\n   224→      enableRetry: config.enableRetry ?? true,\n   225→      maxRetryAttempts: config.maxRetryAttempts ?? 3,\n   226→    };\n   227→    this.logger.info('AgentOrchestrator initialized', 'AgentOrchestrator');\n   228→  }\n   229→\n   230→  /**\n   231→   * Submit a task for execution\n   232→   *\n   233→   * @param task - Task to submit\n   234→   * @param priority - Task priority (uses default if not specified)\n   235→   * @returns Task ID\n   236→   */\n   237→  submitTask(task: AgentTask, priority?: TaskPriority): string {\n   238→    const taskId = this.generateTaskId();\n   239→\n   240→    const orchestratedTask: OrchestratedTask = {\n   241→      ...task,\n   242→      id: taskId,\n   243→      priority: priority ?? this.config.defaultTaskPriority,\n   244→      status: TaskStatus.PENDING,\n   245→      createdAt: new Date(),\n   246→      retryCount: 0,\n   247→      maxRetries: this.config.maxRetryAttempts,\n   248→    };\n   249→\n   250→    this.tasks.set(taskId, orchestratedTask);\n   251→    this.taskQueue.push(orchestratedTask);\n   252→\n   253→    // Sort queue by priority (descending) then by creation time (ascending)\n   254→    this.taskQueue.sort((a, b) => {\n   255→      const priorityDiff = b.priority - a.priority;\n   256→      if (priorityDiff !== 0) return priorityDiff;\n   257→      return a.createdAt.getTime() - b.createdAt.getTime();\n   258→    });\n   259→\n   260→    this.logger.info(\n   261→      `Task submitted: ${taskId}`,\n   262→      'AgentOrchestrator',\n   263→      {\n   264→        description: task.description,\n   265→        priority: orchestratedTask.priority,\n   266→      }\n   267→    );\n   268→\n   269→    // Process queue\n   270→    this.processQueue();\n   271→\n   272→    return taskId;\n   273→  }\n   274→\n   275→  /**\n   276→   * Get a task by ID\n   277→   *\n   278→   * @param taskId - ID of task to get\n   279→   * @returns Orchestrated task or undefined if not found\n   280→   */\n   281→  getTask(taskId: string): OrchestratedTask | undefined {\n   282→    return this.tasks.get(taskId);\n   283→  }\n   284→\n   285→  /**\n   286→   * Get all tasks\n   287→   *\n   288→   * @param status - Optional status filter\n   289→   * @returns Array of orchestrated tasks\n   290→   */\n   291→  getTasks(status?: TaskStatus): OrchestratedTask[] {\n   292→    const tasks = Array.from(this.tasks.values());\n   293→\n   294→    if (status) {\n   295→      return tasks.filter((task) => task.status === status);\n   296→    }\n   297→\n   298→    return tasks;\n   299→  }\n   300→\n   301→  /**\n   302→   * Cancel a task\n   303→   *\n   304→   * @param taskId - ID of task to cancel\n   305→   * @returns True if task was cancelled, false if not found or already completed\n   306→   */\n   307→  cancelTask(taskId: string): boolean {\n   308→    const task = this.tasks.get(taskId);\n   309→\n   310→    if (!task) {\n   311→      this.logger.warn(`Task not found for cancellation: ${taskId}`, 'AgentOrchestrator');\n   312→      return false;\n   313→    }\n   314→\n   315→    if (\n   316→      task.status === TaskStatus.COMPLETED ||\n   317→      task.status === TaskStatus.FAILED ||\n   318→      task.status === TaskStatus.CANCELLED\n   319→    ) {\n   320→      this.logger.debug(\n   321→        `Task already completed/failed/cancelled: ${taskId}`,\n   322→        'AgentOrchestrator'\n   323→      );\n   324→      return false;\n   325→    }\n   326→\n   327→    // Remove from queue if pending\n   328→    if (task.status === TaskStatus.PENDING) {\n   329→      const index = this.taskQueue.indexOf(task);\n   330→      if (index > -1) {\n   331→        this.taskQueue.splice(index, 1);\n   332→      }\n   333→    }\n   334→\n   335→    // Remove from executing set if executing\n   336→    if (task.status === TaskStatus.EXECUTING) {\n   337→      this.executingTasks.delete(taskId);\n   338→    }\n   339→\n   340→    // Update task status\n   341→    task.status = TaskStatus.CANCELLED;\n   342→    task.completedAt = new Date();\n   343→\n   344→    this.logger.info(`Task cancelled: ${taskId}`, 'AgentOrchestrator');\n   345→\n   346→    // Process queue to potentially start next task\n   347→    this.processQueue();\n   348→\n   349→    return true;\n   350→  }\n   351→\n   352→  /**\n   353→   * Select an agent for task execution\n   354→   *\n   355→   * @param criteria - Agent selection criteria\n   356→   * @returns Selected agent ID or undefined if no agent available\n   357→   */\n   358→  selectAgent(criteria: AgentSelectionCriteria = {}): string | undefined {\n   359→    const {\n   360→      capability,\n   361→      tag,\n   362→      strategy = this.config.defaultSelectionStrategy,\n   363→      exclude = [],\n   364→    } = criteria;\n   365→\n   366→    // Get available agents\n   367→    let agents = this.registry.list();\n   368→\n   369→    // Filter by capability\n   370→    if (capability) {\n   371→      agents = agents.filter((agent) => agent.capabilities.includes(capability));\n   372→    }\n   373→\n   374→    // Filter by tag\n   375→    if (tag) {\n   376→      agents = agents.filter((agent) => agent.tags?.includes(tag));\n   377→    }\n   378→\n   379→    // Filter by active state\n   380→    agents = agents.filter((agent) => {\n   381→      const state = this.lifecycleManager.getState(agent.id);\n   382→      return state === AgentLifecycleState.RUNNING;\n   383→    });\n   384→\n   385→    // Exclude specific agents\n   386→    agents = agents.filter((agent) => !exclude.includes(agent.id));\n   387→\n   388→    if (agents.length === 0) {\n   389→      this.logger.warn(\n   390→        'No available agents matching criteria',\n   391→        'AgentOrchestrator',\n   392→        { capability, tag, exclude }\n   393→      );\n   394→      return undefined;\n   395→    }\n   396→\n   397→    // Apply selection strategy\n   398→    switch (strategy) {\n   399→      case AgentSelectionStrategy.FIRST_AVAILABLE:\n   400→        return agents[0]!.id;\n   401→\n   402→      case AgentSelectionStrategy.HIGHEST_PRIORITY:\n   403→        // Already sorted by priority in registry\n   404→        return agents[0]!.id;\n   405→\n   406→      case AgentSelectionStrategy.LEAST_RECENTLY_USED:\n   407→        // Find agent with oldest lastUsed timestamp\n   408→        // For now, just return the first agent as a simplification\n   409→        // In a full implementation, we'd track lastUsed timestamps\n   410→        return agents[0]!.id;\n   411→\n   412→      case AgentSelectionStrategy.ROUND_ROBIN:\n   413→        const selected = agents[this.roundRobinIndex % agents.length]!;\n   414→        this.roundRobinIndex++;\n   415→        return selected.id;\n   416→\n   417→      default:\n   418→        return agents[0]!.id;\n   419→    }\n   420→  }\n   421→\n   422→  /**\n   423→   * Process task queue\n   424→   */\n   425→  private processQueue(): void {\n   426→    // Check if we can execute more tasks\n   427→    while (\n   428→      this.taskQueue.length > 0 &&\n   429→      this.executingTasks.size < this.config.maxConcurrentTasks\n   430→    ) {\n   431→      const task = this.taskQueue.shift();\n   432→      if (!task) break;\n   433→\n   434→      // Select an agent for the task\n   435→      const agentId = this.selectAgent({\n   436→        capability: task.requiredCapability,\n   437→      });\n   438→\n   439→      if (!agentId) {\n   440→        // No agent available, put task back in queue\n   441→        this.taskQueue.unshift(task);\n   442→        break;\n   443→      }\n   444→\n   445→      // Assign task to agent\n   446→      this.assignTask(task, agentId);\n   447→    }\n   448→  }\n   449→\n   450→  /**\n   451→   * Assign a task to an agent\n   452→   *\n   453→   * @param task - Task to assign\n   454→   * @param agentId - Agent ID to assign to\n   455→   */\n   456→  private assignTask(task: OrchestratedTask, agentId: string): void {\n   457→    task.status = TaskStatus.ASSIGNED;\n   458→    task.assignedAgent = agentId;\n   459→\n   460→    this.logger.info(\n   461→      `Task assigned: ${task.id} -> ${agentId}`,\n   462→      'AgentOrchestrator'\n   463→    );\n   464→\n   465→    // Execute task\n   466→    this.executeTask(task);\n   467→  }\n   468→\n   469→  /**\n   470→   * Execute a task\n   471→   *\n   472→   * @param task - Task to execute\n   473→   */\n   474→  private async executeTask(task: OrchestratedTask): Promise<void> {\n   475→    task.status = TaskStatus.EXECUTING;\n   476→    task.startedAt = new Date();\n   477→    this.executingTasks.add(task.id);\n   478→\n   479→    this.logger.info(\n   480→      `Task executing: ${task.id}`,\n   481→      'AgentOrchestrator',\n   482→      { agentId: task.assignedAgent }\n   483→    );\n   484→\n   485→    try {\n   486→      // Execute task with timeout\n   487→      const result = await this.executeWithTimeout(\n   488→        this.performTaskExecution(task),\n   489→        this.config.defaultTaskTimeout\n   490→      );\n   491→\n   492→      // Mark task as completed\n   493→      task.status = TaskStatus.COMPLETED;\n   494→      task.completedAt = new Date();\n   495→\n   496→      this.logger.info(\n   497→        `Task completed: ${task.id}`,\n   498→        'AgentOrchestrator',\n   499→        {\n   500→          agentId: task.assignedAgent,\n   501→          duration: task.completedAt.getTime() - task.startedAt!.getTime(),\n   502→        }\n   503→      );\n   504→\n   505→      // Mark agent as used\n   506→      if (task.assignedAgent) {\n   507→        this.registry.markUsed(task.assignedAgent);\n   508→      }\n   509→    } catch (error) {\n   510→      task.error = error as Error;\n   511→\n   512→      // Check if we should retry\n   513→      if (\n   514→        this.config.enableRetry &&\n   515→        task.retryCount < task.maxRetries\n   516→      ) {\n   517→        task.retryCount++;\n   518→        task.status = TaskStatus.PENDING;\n   519→        task.assignedAgent = undefined;\n   520→        task.startedAt = undefined;\n   521→\n   522→        this.taskQueue.push(task);\n   523→\n   524→        this.logger.warn(\n   525→          `Task failed, retrying (${task.retryCount}/${task.maxRetries}): ${task.id}`,\n   526→          'AgentOrchestrator',\n   527→          { error: (error as Error).message }\n   528→        );\n   529→      } else {\n   530→        task.status = TaskStatus.FAILED;\n   531→        task.completedAt = new Date();\n   532→\n   533→        this.logger.error(\n   534→          `Task failed: ${task.id}`,\n   535→          'AgentOrchestrator',\n   536→          {\n   537→            agentId: task.assignedAgent,\n   538→            error: (error as Error).message,\n   539→          }\n   540→        );\n   541→      }\n   542→    } finally {\n   543→      this.executingTasks.delete(task.id);\n   544→\n   545→      // Process queue to potentially start next task\n   546→      this.processQueue();\n   547→    }\n   548→  }\n   549→\n   550→  /**\n   551→   * Perform actual task execution\n   552→   *\n   553→   * @param task - Task to execute\n   554→   * @returns Task result\n   555→   */\n   556→  private async performTaskExecution(task: OrchestratedTask): Promise<AgentTaskResult> {\n   557→    // This is a placeholder implementation\n   558→    // In a real implementation, this would call the agent's execute method\n   559→    // For now, we'll just return a success result\n   560→\n   561→    return {\n   562→      taskId: task.id,\n   563→      success: true,\n   564→      output: `Task executed: ${task.description}`,\n   565→      metadata: {\n   566→        agentId: task.assignedAgent,\n   567→      },\n   568→    };\n   569→  }\n   570→\n   571→  /**\n   572→   * Execute with timeout\n   573→   *\n   574→   * @param promise - Promise to execute\n   575→   * @param timeout - Timeout in milliseconds\n   576→   * @returns Promise result\n   577→   * @throws Error if timeout is exceeded\n   578→   */\n   579→  private async executeWithTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {\n   580→    const timeoutPromise = new Promise<never>((_, reject) => {\n   581→      setTimeout(() => {\n   582→        reject(new Error(`Task execution timeout after ${timeout}ms`));\n   583→      }, timeout);\n   584→    });\n   585→\n   586→    return Promise.race([promise, timeoutPromise]);\n   587→  }\n   588→\n   589→  /**\n   590→   * Generate unique task ID\n   591→   *\n   592→   * @returns Unique task ID\n   593→   */\n   594→  private generateTaskId(): string {\n   595→    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   596→  }\n   597→\n   598→  /**\n   599→   * Get orchestrator statistics\n   600→   *\n   601→   * @returns Orchestrator statistics\n   602→   */\n   603→  getStatistics(): {\n   604→    totalTasks: number;\n   605→    pendingTasks: number;\n   606→    executingTasks: number;\n   607→    completedTasks: number;\n   608→    failedTasks: number;\n   609→    cancelledTasks: number;\n   610→  } {\n   611→    const tasks = Array.from(this.tasks.values());\n   612→\n   613→    return {\n   614→      totalTasks: tasks.length,\n   615→      pendingTasks: tasks.filter((t) => t.status === TaskStatus.PENDING).length,\n   616→      executingTasks: tasks.filter((t) => t.status === TaskStatus.EXECUTING).length,\n   617→      completedTasks: tasks.filter((t) => t.status === TaskStatus.COMPLETED).length,\n   618→      failedTasks: tasks.filter((t) => t.status === TaskStatus.FAILED).length,\n   619→      cancelledTasks: tasks.filter((t) => t.status === TaskStatus.CANCELLED).length,\n   620→    };\n   621→  }\n   622→\n   623→  /**\n   624→   * Clear all tasks\n   625→   */\n   626→  clearTasks(): void {\n   627→    this.tasks.clear();\n   628→    this.taskQueue = [];\n   629→    this.executingTasks.clear();\n   630→    this.logger.info('AgentOrchestrator tasks cleared', 'AgentOrchestrator');\n   631→  }\n   632→}\n   633→\n   634→/**\n   635→ * Global agent orchestrator instance\n   636→ */\n   637→let globalAgentOrchestrator: AgentOrchestrator | null = null;\n   638→\n   639→/**\n   640→ * Initialize global agent orchestrator\n   641→ *\n   642→ * @param config - Orchestrator configuration\n   643→ * @param logger - Optional logger instance\n   644→ * @param errorHandler - Optional error handler instance\n   645→ * @param registry - Optional agent registry instance\n   646→ * @param lifecycleManager - Optional lifecycle manager instance\n   647→ * @returns The global agent orchestrator\n   648→ */\n   649→export function initAgentOrchestrator(\n   650→  config?: AgentOrchestratorConfig,\n   651→  logger?: Logger,\n   652→  errorHandler?: ErrorHandler,\n   653→  registry?: AgentRegistry,\n   654→  lifecycleManager?: AgentLifecycleManager\n   655→): AgentOrchestrator {\n   656→  globalAgentOrchestrator = new AgentOrchestrator(\n   657→    config,\n   658→    logger,\n   659→    errorHandler,\n   660→    registry,\n   661→    lifecycleManager\n   662→  );\n   663→  return globalAgentOrchestrator;\n   664→}\n   665→\n   666→/**\n   667→ * Get global agent orchestrator\n   668→ *\n   669→ * @returns The global agent orchestrator\n   670→ */\n   671→export function getAgentOrchestrator(): AgentOrchestrator {\n   672→  if (!globalAgentOrchestrator) {\n   673→    globalAgentOrchestrator = new AgentOrchestrator();\n   674→  }\n   675→  return globalAgentOrchestrator;\n   676→}\n   677→\n\n</system-reminder>\n"}]},"uuid":"d6aab717-230e-4f50-9dbd-176194ef042c","timestamp":"2026-01-12T06:23:17.223Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/orchestrator.ts","content":"/**\n * Agent Orchestrator for KOMPLETE-KONTROL CLI\n *\n * Provides multi-agent orchestration capabilities including task distribution,\n * agent selection, and coordination across multiple agents.\n * Follows patterns from agent-swarm-kit with simplified architecture.\n */\n\nimport type { AgentDefinition, AgentError, AgentTask, AgentTaskResult } from '../../types';\nimport { Logger } from '../../utils/logger';\nimport { ErrorHandler } from '../../utils/error-handler';\nimport { AgentRegistry, getAgentRegistry } from './registry';\nimport {\n  AgentLifecycleManager,\n  getAgentLifecycleManager,\n  AgentLifecycleState,\n} from './lifecycle';\n\n/**\n * Task priority levels\n */\nexport enum TaskPriority {\n  /**\n   * Low priority task\n   */\n  LOW = 0,\n  /**\n   * Normal priority task\n   */\n  NORMAL = 1,\n  /**\n   * High priority task\n   */\n  HIGH = 2,\n  /**\n   * Critical priority task\n   */\n  CRITICAL = 3,\n}\n\n/**\n * Task status\n */\nexport enum TaskStatus {\n  /**\n   * Task is pending\n   */\n  PENDING = 'pending',\n  /**\n   * Task is assigned to an agent\n   */\n  ASSIGNED = 'assigned',\n  /**\n   * Task is being executed\n   */\n  EXECUTING = 'executing',\n  /**\n   * Task completed successfully\n   */\n  COMPLETED = 'completed',\n  /**\n   * Task failed\n   */\n  FAILED = 'failed',\n  /**\n   * Task was cancelled\n   */\n  CANCELLED = 'cancelled',\n}\n\n/**\n * Orchestrated task\n */\nexport interface OrchestratedTask extends AgentTask {\n  /**\n   * Task ID\n   */\n  id: string;\n  /**\n   * Task priority\n   */\n  priority: TaskPriority;\n  /**\n   * Task status\n   */\n  status: TaskStatus;\n  /**\n   * Assigned agent ID\n   */\n  assignedAgent?: string;\n  /**\n   * Task creation time\n   */\n  createdAt: Date;\n  /**\n   * Task start time\n   */\n  startedAt?: Date;\n  /**\n   * Task completion time\n   */\n  completedAt?: Date;\n  /**\n   * Task error (if any)\n   */\n  error?: Error;\n  /**\n   * Retry count\n   */\n  retryCount: number;\n  /**\n   * Maximum retries\n   */\n  maxRetries: number;\n}\n\n/**\n * Agent selection strategy\n */\nexport enum AgentSelectionStrategy {\n  /**\n   * Select first available agent\n   */\n  FIRST_AVAILABLE = 'first_available',\n  /**\n   * Select agent with highest priority\n   */\n  HIGHEST_PRIORITY = 'highest_priority',\n  /**\n   * Select least recently used agent\n   */\n  LEAST_RECENTLY_USED = 'least_recently_used',\n  /**\n   * Round-robin selection\n   */\n  ROUND_ROBIN = 'round_robin',\n}\n\n/**\n * Agent selection criteria\n */\nexport interface AgentSelectionCriteria {\n  /**\n   * Required capability\n   */\n  capability?: string;\n  /**\n   * Required tag\n   */\n  tag?: string;\n  /**\n   * Selection strategy\n   */\n  strategy?: AgentSelectionStrategy;\n  /**\n   * Exclude specific agents\n   */\n  exclude?: string[];\n}\n\n/**\n * Orchestrator configuration\n */\nexport interface AgentOrchestratorConfig {\n  /**\n   * Maximum concurrent tasks\n   */\n  maxConcurrentTasks?: number;\n  /**\n   * Default task timeout in milliseconds\n   */\n  defaultTaskTimeout?: number;\n  /**\n   * Default task priority\n   */\n  defaultTaskPriority?: TaskPriority;\n  /**\n   * Default agent selection strategy\n   */\n  defaultSelectionStrategy?: AgentSelectionStrategy;\n  /**\n   * Enable task retry on failure\n   */\n  enableRetry?: boolean;\n  /**\n   * Maximum retry attempts\n   */\n  maxRetryAttempts?: number;\n}\n\n/**\n * Agent Orchestrator class\n *\n * Coordinates multiple agents for task distribution and execution.\n * Provides agent selection, task scheduling, and coordination capabilities.\n */\nexport class AgentOrchestrator {\n  private tasks: Map<string, OrchestratedTask> = new Map();\n  private taskQueue: OrchestratedTask[] = [];\n  private executingTasks: Set<string> = new Set();\n  private roundRobinIndex: number = 0;\n  private logger: Logger;\n  private errorHandler: ErrorHandler;\n  private registry: AgentRegistry;\n  private lifecycleManager: AgentLifecycleManager;\n  private config: Required<AgentOrchestratorConfig>;\n\n  constructor(\n    config: AgentOrchestratorConfig = {},\n    logger?: Logger,\n    errorHandler?: ErrorHandler,\n    registry?: AgentRegistry,\n    lifecycleManager?: AgentLifecycleManager\n  ) {\n    this.logger = logger || new Logger();\n    this.errorHandler = errorHandler || new ErrorHandler();\n    this.registry = registry || getAgentRegistry();\n    this.lifecycleManager = lifecycleManager || getAgentLifecycleManager();\n    this.config = {\n      maxConcurrentTasks: config.maxConcurrentTasks ?? 5,\n      defaultTaskTimeout: config.defaultTaskTimeout ?? 30000,\n      defaultTaskPriority: config.defaultTaskPriority ?? TaskPriority.NORMAL,\n      defaultSelectionStrategy: config.defaultSelectionStrategy ?? AgentSelectionStrategy.HIGHEST_PRIORITY,\n      enableRetry: config.enableRetry ?? true,\n      maxRetryAttempts: config.maxRetryAttempts ?? 3,\n    };\n    this.logger.info('AgentOrchestrator initialized', 'AgentOrchestrator');\n  }\n\n  /**\n   * Submit a task for execution\n   *\n   * @param task - Task to submit\n   * @param priority - Task priority (uses default if not specified)\n   * @returns Task ID\n   */\n  submitTask(task: AgentTask, priority?: TaskPriority): string {\n    const taskId = this.generateTaskId();\n\n    const orchestratedTask: OrchestratedTask = {\n      ...task,\n      id: taskId,\n      priority: priority ?? this.config.defaultTaskPriority,\n      status: TaskStatus.PENDING,\n      createdAt: new Date(),\n      retryCount: 0,\n      maxRetries: this.config.maxRetryAttempts,\n    };\n\n    this.tasks.set(taskId, orchestratedTask);\n    this.taskQueue.push(orchestratedTask);\n\n    // Sort queue by priority (descending) then by creation time (ascending)\n    this.taskQueue.sort((a, b) => {\n      const priorityDiff = b.priority - a.priority;\n      if (priorityDiff !== 0) return priorityDiff;\n      return a.createdAt.getTime() - b.createdAt.getTime();\n    });\n\n    this.logger.info(\n      `Task submitted: ${taskId}`,\n      'AgentOrchestrator',\n      {\n        description: task.description,\n        priority: orchestratedTask.priority,\n      }\n    );\n\n    // Process queue\n    this.processQueue();\n\n    return taskId;\n  }\n\n  /**\n   * Get a task by ID\n   *\n   * @param taskId - ID of task to get\n   * @returns Orchestrated task or undefined if not found\n   */\n  getTask(taskId: string): OrchestratedTask | undefined {\n    return this.tasks.get(taskId);\n  }\n\n  /**\n   * Get all tasks\n   *\n   * @param status - Optional status filter\n   * @returns Array of orchestrated tasks\n   */\n  getTasks(status?: TaskStatus): OrchestratedTask[] {\n    const tasks = Array.from(this.tasks.values());\n\n    if (status) {\n      return tasks.filter((task) => task.status === status);\n    }\n\n    return tasks;\n  }\n\n  /**\n   * Cancel a task\n   *\n   * @param taskId - ID of task to cancel\n   * @returns True if task was cancelled, false if not found or already completed\n   */\n  cancelTask(taskId: string): boolean {\n    const task = this.tasks.get(taskId);\n\n    if (!task) {\n      this.logger.warn(`Task not found for cancellation: ${taskId}`, 'AgentOrchestrator');\n      return false;\n    }\n\n    if (\n      task.status === TaskStatus.COMPLETED ||\n      task.status === TaskStatus.FAILED ||\n      task.status === TaskStatus.CANCELLED\n    ) {\n      this.logger.debug(\n        `Task already completed/failed/cancelled: ${taskId}`,\n        'AgentOrchestrator'\n      );\n      return false;\n    }\n\n    // Remove from queue if pending\n    if (task.status === TaskStatus.PENDING) {\n      const index = this.taskQueue.indexOf(task);\n      if (index > -1) {\n        this.taskQueue.splice(index, 1);\n      }\n    }\n\n    // Remove from executing set if executing\n    if (task.status === TaskStatus.EXECUTING) {\n      this.executingTasks.delete(taskId);\n    }\n\n    // Update task status\n    task.status = TaskStatus.CANCELLED;\n    task.completedAt = new Date();\n\n    this.logger.info(`Task cancelled: ${taskId}`, 'AgentOrchestrator');\n\n    // Process queue to potentially start next task\n    this.processQueue();\n\n    return true;\n  }\n\n  /**\n   * Select an agent for task execution\n   *\n   * @param criteria - Agent selection criteria\n   * @returns Selected agent ID or undefined if no agent available\n   */\n  selectAgent(criteria: AgentSelectionCriteria = {}): string | undefined {\n    const {\n      capability,\n      tag,\n      strategy = this.config.defaultSelectionStrategy,\n      exclude = [],\n    } = criteria;\n\n    // Get available agents\n    let agents = this.registry.list();\n\n    // Filter by capability\n    if (capability) {\n      agents = agents.filter((agent) => agent.capabilities.includes(capability));\n    }\n\n    // Filter by tag\n    if (tag) {\n      agents = agents.filter((agent) => agent.tags?.includes(tag));\n    }\n\n    // Filter by active state\n    agents = agents.filter((agent) => {\n      const state = this.lifecycleManager.getState(agent.id);\n      return state === AgentLifecycleState.RUNNING;\n    });\n\n    // Exclude specific agents\n    agents = agents.filter((agent) => !exclude.includes(agent.id));\n\n    if (agents.length === 0) {\n      this.logger.warn(\n        'No available agents matching criteria',\n        'AgentOrchestrator',\n        { capability, tag, exclude }\n      );\n      return undefined;\n    }\n\n    // Apply selection strategy\n    switch (strategy) {\n      case AgentSelectionStrategy.FIRST_AVAILABLE:\n        return agents[0]!.id;\n\n      case AgentSelectionStrategy.HIGHEST_PRIORITY:\n        // Already sorted by priority in registry\n        return agents[0]!.id;\n\n      case AgentSelectionStrategy.LEAST_RECENTLY_USED:\n        // Find agent with oldest lastUsed timestamp\n        // For now, just return the first agent as a simplification\n        // In a full implementation, we'd track lastUsed timestamps\n        return agents[0]!.id;\n\n      case AgentSelectionStrategy.ROUND_ROBIN:\n        const selected = agents[this.roundRobinIndex % agents.length]!;\n        this.roundRobinIndex++;\n        return selected.id;\n\n      default:\n        return agents[0]!.id;\n    }\n  }\n\n  /**\n   * Process task queue\n   */\n  private processQueue(): void {\n    // Check if we can execute more tasks\n    while (\n      this.taskQueue.length > 0 &&\n      this.executingTasks.size < this.config.maxConcurrentTasks\n    ) {\n      const task = this.taskQueue.shift();\n      if (!task) break;\n\n      // Select an agent for the task\n      const agentId = this.selectAgent({\n        capability: task.requiredCapability,\n      });\n\n      if (!agentId) {\n        // No agent available, put task back in queue\n        this.taskQueue.unshift(task);\n        break;\n      }\n\n      // Assign task to agent\n      this.assignTask(task, agentId);\n    }\n  }\n\n  /**\n   * Assign a task to an agent\n   *\n   * @param task - Task to assign\n   * @param agentId - Agent ID to assign to\n   */\n  private assignTask(task: OrchestratedTask, agentId: string): void {\n    task.status = TaskStatus.ASSIGNED;\n    task.assignedAgent = agentId;\n\n    this.logger.info(\n      `Task assigned: ${task.id} -> ${agentId}`,\n      'AgentOrchestrator'\n    );\n\n    // Execute task\n    this.executeTask(task);\n  }\n\n  /**\n   * Execute a task\n   *\n   * @param task - Task to execute\n   */\n  private async executeTask(task: OrchestratedTask): Promise<void> {\n    task.status = TaskStatus.EXECUTING;\n    task.startedAt = new Date();\n    this.executingTasks.add(task.id);\n\n    this.logger.info(\n      `Task executing: ${task.id}`,\n      'AgentOrchestrator',\n      { agentId: task.assignedAgent }\n    );\n\n    try {\n      // Execute task with timeout\n      const result = await this.executeWithTimeout(\n        this.performTaskExecution(task),\n        this.config.defaultTaskTimeout\n      );\n\n      // Mark task as completed\n      task.status = TaskStatus.COMPLETED;\n      task.completedAt = new Date();\n\n      this.logger.info(\n        `Task completed: ${task.id}`,\n        'AgentOrchestrator',\n        {\n          agentId: task.assignedAgent,\n          duration: task.completedAt.getTime() - task.startedAt!.getTime(),\n        }\n      );\n\n      // Mark agent as used\n      if (task.assignedAgent) {\n        this.registry.markUsed(task.assignedAgent);\n      }\n    } catch (error) {\n      task.error = error as Error;\n\n      // Check if we should retry\n      if (\n        this.config.enableRetry &&\n        task.retryCount < task.maxRetries\n      ) {\n        task.retryCount++;\n        task.status = TaskStatus.PENDING;\n        task.assignedAgent = undefined;\n        task.startedAt = undefined;\n\n        this.taskQueue.push(task);\n\n        this.logger.warn(\n          `Task failed, retrying (${task.retryCount}/${task.maxRetries}): ${task.id}`,\n          'AgentOrchestrator',\n          { error: (error as Error).message }\n        );\n      } else {\n        task.status = TaskStatus.FAILED;\n        task.completedAt = new Date();\n\n        this.logger.error(\n          `Task failed: ${task.id}`,\n          'AgentOrchestrator',\n          {\n            agentId: task.assignedAgent,\n            error: (error as Error).message,\n          }\n        );\n      }\n    } finally {\n      this.executingTasks.delete(task.id);\n\n      // Process queue to potentially start next task\n      this.processQueue();\n    }\n  }\n\n  /**\n   * Perform actual task execution\n   *\n   * @param task - Task to execute\n   * @returns Task result\n   */\n  private async performTaskExecution(task: OrchestratedTask): Promise<AgentTaskResult> {\n    // This is a placeholder implementation\n    // In a real implementation, this would call the agent's execute method\n    // For now, we'll just return a success result\n\n    return {\n      taskId: task.id,\n      success: true,\n      output: `Task executed: ${task.description}`,\n      metadata: {\n        agentId: task.assignedAgent,\n      },\n    };\n  }\n\n  /**\n   * Execute with timeout\n   *\n   * @param promise - Promise to execute\n   * @param timeout - Timeout in milliseconds\n   * @returns Promise result\n   * @throws Error if timeout is exceeded\n   */\n  private async executeWithTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Task execution timeout after ${timeout}ms`));\n      }, timeout);\n    });\n\n    return Promise.race([promise, timeoutPromise]);\n  }\n\n  /**\n   * Generate unique task ID\n   *\n   * @returns Unique task ID\n   */\n  private generateTaskId(): string {\n    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get orchestrator statistics\n   *\n   * @returns Orchestrator statistics\n   */\n  getStatistics(): {\n    totalTasks: number;\n    pendingTasks: number;\n    executingTasks: number;\n    completedTasks: number;\n    failedTasks: number;\n    cancelledTasks: number;\n  } {\n    const tasks = Array.from(this.tasks.values());\n\n    return {\n      totalTasks: tasks.length,\n      pendingTasks: tasks.filter((t) => t.status === TaskStatus.PENDING).length,\n      executingTasks: tasks.filter((t) => t.status === TaskStatus.EXECUTING).length,\n      completedTasks: tasks.filter((t) => t.status === TaskStatus.COMPLETED).length,\n      failedTasks: tasks.filter((t) => t.status === TaskStatus.FAILED).length,\n      cancelledTasks: tasks.filter((t) => t.status === TaskStatus.CANCELLED).length,\n    };\n  }\n\n  /**\n   * Clear all tasks\n   */\n  clearTasks(): void {\n    this.tasks.clear();\n    this.taskQueue = [];\n    this.executingTasks.clear();\n    this.logger.info('AgentOrchestrator tasks cleared', 'AgentOrchestrator');\n  }\n}\n\n/**\n * Global agent orchestrator instance\n */\nlet globalAgentOrchestrator: AgentOrchestrator | null = null;\n\n/**\n * Initialize global agent orchestrator\n *\n * @param config - Orchestrator configuration\n * @param logger - Optional logger instance\n * @param errorHandler - Optional error handler instance\n * @param registry - Optional agent registry instance\n * @param lifecycleManager - Optional lifecycle manager instance\n * @returns The global agent orchestrator\n */\nexport function initAgentOrchestrator(\n  config?: AgentOrchestratorConfig,\n  logger?: Logger,\n  errorHandler?: ErrorHandler,\n  registry?: AgentRegistry,\n  lifecycleManager?: AgentLifecycleManager\n): AgentOrchestrator {\n  globalAgentOrchestrator = new AgentOrchestrator(\n    config,\n    logger,\n    errorHandler,\n    registry,\n    lifecycleManager\n  );\n  return globalAgentOrchestrator;\n}\n\n/**\n * Get global agent orchestrator\n *\n * @returns The global agent orchestrator\n */\nexport function getAgentOrchestrator(): AgentOrchestrator {\n  if (!globalAgentOrchestrator) {\n    globalAgentOrchestrator = new AgentOrchestrator();\n  }\n  return globalAgentOrchestrator;\n}\n","numLines":677,"startLine":1,"totalLines":677}}}
{"parentUuid":"d6aab717-230e-4f50-9dbd-176194ef042c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012C26PJAv4rgVDAuAGRWes2","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me continue reading the remaining files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":14145,"cache_read_input_tokens":19298,"cache_creation":{"ephemeral_5m_input_tokens":14145,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BTEUXNqjsbFpe5AFU","type":"assistant","uuid":"6bc3f472-b54d-4431-907a-9d811f57a9d6","timestamp":"2026-01-12T06:23:18.505Z"}
{"parentUuid":"6bc3f472-b54d-4431-907a-9d811f57a9d6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012C26PJAv4rgVDAuAGRWes2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U1yZPNQBErqCM8DmsGePF4","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/lifecycle.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":14145,"cache_read_input_tokens":19298,"cache_creation":{"ephemeral_5m_input_tokens":14145,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BTEUXNqjsbFpe5AFU","type":"assistant","uuid":"37df7d19-7146-4617-887d-036e310a4e1d","timestamp":"2026-01-12T06:23:18.938Z"}
{"parentUuid":"37df7d19-7146-4617-887d-036e310a4e1d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012C26PJAv4rgVDAuAGRWes2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UvHcdDLudmpQryS2PdgHQc","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/communication.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":14145,"cache_read_input_tokens":19298,"cache_creation":{"ephemeral_5m_input_tokens":14145,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BTEUXNqjsbFpe5AFU","type":"assistant","uuid":"c5d225b5-e4a8-4bfc-a961-7e2e20da5726","timestamp":"2026-01-12T06:23:19.182Z"}
{"parentUuid":"c5d225b5-e4a8-4bfc-a961-7e2e20da5726","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012C26PJAv4rgVDAuAGRWes2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V4EByyH3hVXApqJTfojjgi","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/coordination.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":14145,"cache_read_input_tokens":19298,"cache_creation":{"ephemeral_5m_input_tokens":14145,"ephemeral_1h_input_tokens":0},"output_tokens":216,"service_tier":"standard"}},"requestId":"req_011CX31BTEUXNqjsbFpe5AFU","type":"assistant","uuid":"b599698c-3f6d-44ca-8d34-0ede36ea35a8","timestamp":"2026-01-12T06:23:19.426Z"}
{"parentUuid":"b599698c-3f6d-44ca-8d34-0ede36ea35a8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U1yZPNQBErqCM8DmsGePF4","type":"tool_result","content":"     1→/**\n     2→ * Agent Lifecycle Management for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Provides agent lifecycle management including initialization, start, pause, stop, and disposal.\n     5→ * Follows patterns from agent-swarm-kit with simplified architecture.\n     6→ */\n     7→\n     8→import type { AgentDefinition, AgentTask, AgentTaskResult } from '../../types';\n     9→import { AgentError } from '../../types';\n    10→import { Logger } from '../../utils/logger';\n    11→import { ErrorHandler } from '../../utils/error-handler';\n    12→import { AgentRegistry, getAgentRegistry } from './registry';\n    13→\n    14→/**\n    15→ * Agent lifecycle state\n    16→ */\n    17→export enum AgentLifecycleState {\n    18→  /**\n    19→   * Agent has been created but not initialized\n    20→   */\n    21→  CREATED = 'created',\n    22→  /**\n    23→   * Agent is being initialized\n    24→   */\n    25→  INITIALIZING = 'initializing',\n    26→  /**\n    27→   * Agent is initialized and ready\n    28→   */\n    29→  INITIALIZED = 'initialized',\n    30→  /**\n    31→   * Agent is starting\n    32→   */\n    33→  STARTING = 'starting',\n    34→  /**\n    35→   * Agent is running and active\n    36→   */\n    37→  RUNNING = 'running',\n    38→  /**\n    39→   * Agent is pausing\n    40→   */\n    41→  PAUSING = 'pausing',\n    42→  /**\n    43→   * Agent is paused\n    44→   */\n    45→  PAUSED = 'paused',\n    46→  /**\n    47→   * Agent is stopping\n    48→   */\n    49→  STOPPING = 'stopping',\n    50→  /**\n    51→   * Agent is stopped\n    52→   */\n    53→  STOPPED = 'stopped',\n    54→  /**\n    55→   * Agent is being disposed\n    56→   */\n    57→  DISPOSING = 'disposing',\n    58→  /**\n    59→   * Agent has been disposed\n    60→   */\n    61→  DISPOSED = 'disposed',\n    62→  /**\n    63→   * Agent encountered an error\n    64→   */\n    65→  ERROR = 'error',\n    66→}\n    67→\n    68→/**\n    69→ * Agent lifecycle event\n    70→ */\n    71→export enum AgentLifecycleEvent {\n    72→  /**\n    73→   * Agent is about to initialize\n    74→   */\n    75→  BEFORE_INIT = 'before_init',\n    76→  /**\n    77→   * Agent has been initialized\n    78→   */\n    79→  INITIALIZED = 'initialized',\n    80→  /**\n    81→   * Agent initialization failed\n    82→   */\n    83→  INIT_ERROR = 'init_error',\n    84→  /**\n    85→   * Agent is about to start\n    86→   */\n    87→  BEFORE_START = 'before_start',\n    88→  /**\n    89→   * Agent has started\n    90→   */\n    91→  STARTED = 'started',\n    92→  /**\n    93→   * Agent start failed\n    94→   */\n    95→  START_ERROR = 'start_error',\n    96→  /**\n    97→   * Agent is about to pause\n    98→   */\n    99→  BEFORE_PAUSE = 'before_pause',\n   100→  /**\n   101→   * Agent has been paused\n   102→   */\n   103→  PAUSED = 'paused',\n   104→  /**\n   105→   * Agent pause failed\n   106→   */\n   107→  PAUSE_ERROR = 'pause_error',\n   108→  /**\n   109→   * Agent is about to resume\n   110→   */\n   111→  BEFORE_RESUME = 'before_resume',\n   112→  /**\n   113→   * Agent has been resumed\n   114→   */\n   115→  RESUMED = 'resumed',\n   116→  /**\n   117→   * Agent resume failed\n   118→   */\n   119→  RESUME_ERROR = 'resume_error',\n   120→  /**\n   121→   * Agent is about to stop\n   122→   */\n   123→  BEFORE_STOP = 'before_stop',\n   124→  /**\n   125→   * Agent has been stopped\n   126→   */\n   127→  STOPPED = 'stopped',\n   128→  /**\n   129→   * Agent stop failed\n   130→   */\n   131→  STOP_ERROR = 'stop_error',\n   132→  /**\n   133→   * Agent is about to be disposed\n   134→   */\n   135→  BEFORE_DISPOSE = 'before_dispose',\n   136→  /**\n   137→   * Agent has been disposed\n   138→   */\n   139→  DISPOSED = 'disposed',\n   140→  /**\n   141→   * Agent disposal failed\n   142→   */\n   143→  DISPOSE_ERROR = 'dispose_error',\n   144→}\n   145→\n   146→/**\n   147→ * Agent lifecycle event handler\n   148→ */\n   149→export type AgentLifecycleEventHandler = (\n   150→  event: AgentLifecycleEvent,\n   151→  agentId: string,\n   152→  error?: Error\n   153→) => void | Promise<void>;\n   154→\n   155→/**\n   156→ * Agent execution context\n   157→ */\n   158→export interface AgentExecutionContext {\n   159→  /**\n   160→   * Agent ID\n   161→   */\n   162→  agentId: string;\n   163→  /**\n   164→   * Current task being executed\n   165→   */\n   166→  currentTask?: AgentTask;\n   167→  /**\n   168→   * Task execution history\n   169→   */\n   170→  taskHistory: AgentTaskResult[];\n   171→  /**\n   172→   * Custom context data\n   173→   */\n   174→  contextData: Map<string, unknown>;\n   175→}\n   176→\n   177→/**\n   178→ * Agent instance\n   179→ */\n   180→export interface AgentInstance {\n   181→  /**\n   182→   * Agent ID\n   183→   */\n   184→  id: string;\n   185→  /**\n   186→   * Agent definition\n   187→   */\n   188→  definition: AgentDefinition;\n   189→  /**\n   190→   * Current lifecycle state\n   191→   */\n   192→  state: AgentLifecycleState;\n   193→  /**\n   194→   * Execution context\n   195→   */\n   196→  context: AgentExecutionContext;\n   197→  /**\n   198→   * Whether the agent is active\n   199→   */\n   200→  isActive: boolean;\n   201→  /**\n   202→   * Error encountered (if any)\n   203→   */\n   204→  error?: Error;\n   205→}\n   206→\n   207→/**\n   208→ * Agent lifecycle manager configuration\n   209→ */\n   210→export interface AgentLifecycleManagerConfig {\n   211→  /**\n   212→   * Maximum number of concurrent tasks per agent\n   213→   */\n   214→  maxConcurrentTasks?: number;\n   215→  /**\n   216→   * Task timeout in milliseconds\n   217→   */\n   218→  taskTimeout?: number;\n   219→  /**\n   220→   * Enable automatic recovery on error\n   221→   */\n   222→  autoRecovery?: boolean;\n   223→  /**\n   224→   * Maximum recovery attempts\n   225→   */\n   226→  maxRecoveryAttempts?: number;\n   227→}\n   228→\n   229→/**\n   230→ * Agent Lifecycle Manager class\n   231→ *\n   232→ * Manages agent lifecycle including initialization, start, pause, stop, and disposal.\n   233→ * Provides state management and event handling for agents.\n   234→ */\n   235→export class AgentLifecycleManager {\n   236→  private instances: Map<string, AgentInstance> = new Map();\n   237→  private eventHandlers: Map<AgentLifecycleEvent, AgentLifecycleEventHandler[]> =\n   238→    new Map();\n   239→  private logger: Logger;\n   240→  private errorHandler: ErrorHandler;\n   241→  private registry: AgentRegistry;\n   242→  private config: Required<AgentLifecycleManagerConfig>;\n   243→\n   244→  constructor(\n   245→    config: AgentLifecycleManagerConfig = {},\n   246→    logger?: Logger,\n   247→    errorHandler?: ErrorHandler,\n   248→    registry?: AgentRegistry\n   249→  ) {\n   250→    this.logger = logger || new Logger();\n   251→    this.errorHandler = errorHandler || new ErrorHandler();\n   252→    this.registry = registry || getAgentRegistry();\n   253→    this.config = {\n   254→      maxConcurrentTasks: config.maxConcurrentTasks ?? 1,\n   255→      taskTimeout: config.taskTimeout ?? 30000,\n   256→      autoRecovery: config.autoRecovery ?? true,\n   257→      maxRecoveryAttempts: config.maxRecoveryAttempts ?? 3,\n   258→    };\n   259→    this.logger.info('AgentLifecycleManager initialized', 'AgentLifecycleManager');\n   260→  }\n   261→\n   262→  /**\n   263→   * Initialize an agent\n   264→   *\n   265→   * @param agentId - ID of agent to initialize\n   266→   * @returns Promise that resolves when agent is initialized\n   267→   * @throws AgentError if agent not found or initialization fails\n   268→   */\n   269→  async initialize(agentId: string): Promise<void> {\n   270→    const definition = this.registry.get(agentId);\n   271→\n   272→    if (!definition) {\n   273→      throw new AgentError(`Agent '${agentId}' not found in registry`, agentId);\n   274→    }\n   275→\n   276→    // Check if already initialized\n   277→    if (this.instances.has(agentId)) {\n   278→      const instance = this.instances.get(agentId)!;\n   279→      if (instance.state === AgentLifecycleState.INITIALIZED) {\n   280→        this.logger.debug(`Agent '${agentId}' already initialized`, 'AgentLifecycleManager');\n   281→        return;\n   282→      }\n   283→    }\n   284→\n   285→    // Create agent instance\n   286→    const instance: AgentInstance = {\n   287→      id: agentId,\n   288→      definition,\n   289→      state: AgentLifecycleState.INITIALIZING,\n   290→      context: {\n   291→        agentId,\n   292→        taskHistory: [],\n   293→        contextData: new Map(),\n   294→      },\n   295→      isActive: false,\n   296→    };\n   297→\n   298→    this.instances.set(agentId, instance);\n   299→\n   300→    // Emit before_init event\n   301→    await this.emitEvent(AgentLifecycleEvent.BEFORE_INIT, agentId);\n   302→\n   303→    try {\n   304→      // Validate dependencies\n   305→      if (!this.registry.checkDependencies(agentId)) {\n   306→        throw new AgentError(\n   307→          `Agent '${agentId}' has unsatisfied dependencies`,\n   308→          agentId\n   309→        );\n   310→      }\n   311→\n   312→      // Transition to initialized state\n   313→      instance.state = AgentLifecycleState.INITIALIZED;\n   314→\n   315→      // Emit initialized event\n   316→      await this.emitEvent(AgentLifecycleEvent.INITIALIZED, agentId);\n   317→\n   318→      this.logger.info(`Agent initialized: ${agentId}`, 'AgentLifecycleManager', {\n   319→        name: definition.name,\n   320→        capabilities: definition.capabilities,\n   321→      });\n   322→\n   323→      // Update registry status\n   324→      this.registry.updateStatus(agentId, 'registered');\n   325→    } catch (error) {\n   326→      instance.state = AgentLifecycleState.ERROR;\n   327→      instance.error = error as Error;\n   328→\n   329→      await this.emitEvent(\n   330→        AgentLifecycleEvent.INIT_ERROR,\n   331→        agentId,\n   332→        error as Error\n   333→      );\n   334→\n   335→      this.logger.error(\n   336→        `Agent initialization failed: ${agentId}`,\n   337→        'AgentLifecycleManager',\n   338→        { error: (error as Error).message }\n   339→      );\n   340→\n   341→      throw error;\n   342→    }\n   343→  }\n   344→\n   345→  /**\n   346→   * Start an agent\n   347→   *\n   348→   * @param agentId - ID of agent to start\n   349→   * @returns Promise that resolves when agent is started\n   350→   * @throws AgentError if agent not initialized or start fails\n   351→   */\n   352→  async start(agentId: string): Promise<void> {\n   353→    const instance = this.instances.get(agentId);\n   354→\n   355→    if (!instance) {\n   356→      throw new AgentError(\n   357→        `Agent '${agentId}' not initialized. Call initialize() first.`,\n   358→        agentId\n   359→      );\n   360→    }\n   361→\n   362→    if (instance.state === AgentLifecycleState.RUNNING) {\n   363→      this.logger.debug(`Agent '${agentId}' already running`, 'AgentLifecycleManager');\n   364→      return;\n   365→    }\n   366→\n   367→    // Emit before_start event\n   368→    await this.emitEvent(AgentLifecycleEvent.BEFORE_START, agentId);\n   369→\n   370→    try {\n   371→      instance.state = AgentLifecycleState.STARTING;\n   372→\n   373→      // Transition to running state\n   374→      instance.state = AgentLifecycleState.RUNNING;\n   375→      instance.isActive = true;\n   376→\n   377→      // Emit started event\n   378→      await this.emitEvent(AgentLifecycleEvent.STARTED, agentId);\n   379→\n   380→      this.logger.info(`Agent started: ${agentId}`, 'AgentLifecycleManager');\n   381→\n   382→      // Update registry status\n   383→      this.registry.updateStatus(agentId, 'active');\n   384→    } catch (error) {\n   385→      instance.state = AgentLifecycleState.ERROR;\n   386→      instance.error = error as Error;\n   387→\n   388→      await this.emitEvent(AgentLifecycleEvent.START_ERROR, agentId, error as Error);\n   389→\n   390→      this.logger.error(\n   391→        `Agent start failed: ${agentId}`,\n   392→        'AgentLifecycleManager',\n   393→        { error: (error as Error).message }\n   394→      );\n   395→\n   396→      throw error;\n   397→    }\n   398→  }\n   399→\n   400→  /**\n   401→   * Pause an agent\n   402→   *\n   403→   * @param agentId - ID of agent to pause\n   404→   * @returns Promise that resolves when agent is paused\n   405→   * @throws AgentError if agent not running or pause fails\n   406→   */\n   407→  async pause(agentId: string): Promise<void> {\n   408→    const instance = this.instances.get(agentId);\n   409→\n   410→    if (!instance) {\n   411→      throw new AgentError(`Agent '${agentId}' not found`, agentId);\n   412→    }\n   413→\n   414→    if (instance.state !== AgentLifecycleState.RUNNING) {\n   415→      throw new AgentError(\n   416→        `Agent '${agentId}' is not running. Current state: ${instance.state}`,\n   417→        agentId\n   418→      );\n   419→    }\n   420→\n   421→    // Emit before_pause event\n   422→    await this.emitEvent(AgentLifecycleEvent.BEFORE_PAUSE, agentId);\n   423→\n   424→    try {\n   425→      instance.state = AgentLifecycleState.PAUSING;\n   426→\n   427→      // Transition to paused state\n   428→      instance.state = AgentLifecycleState.PAUSED;\n   429→      instance.isActive = false;\n   430→\n   431→      // Emit paused event\n   432→      await this.emitEvent(AgentLifecycleEvent.PAUSED, agentId);\n   433→\n   434→      this.logger.info(`Agent paused: ${agentId}`, 'AgentLifecycleManager');\n   435→\n   436→      // Update registry status\n   437→      this.registry.updateStatus(agentId, 'paused');\n   438→    } catch (error) {\n   439→      instance.state = AgentLifecycleState.ERROR;\n   440→      instance.error = error as Error;\n   441→\n   442→      await this.emitEvent(AgentLifecycleEvent.PAUSE_ERROR, agentId, error as Error);\n   443→\n   444→      this.logger.error(\n   445→        `Agent pause failed: ${agentId}`,\n   446→        'AgentLifecycleManager',\n   447→        { error: (error as Error).message }\n   448→      );\n   449→\n   450→      throw error;\n   451→    }\n   452→  }\n   453→\n   454→  /**\n   455→   * Resume a paused agent\n   456→   *\n   457→   * @param agentId - ID of agent to resume\n   458→   * @returns Promise that resolves when agent is resumed\n   459→   * @throws AgentError if agent not paused or resume fails\n   460→   */\n   461→  async resume(agentId: string): Promise<void> {\n   462→    const instance = this.instances.get(agentId);\n   463→\n   464→    if (!instance) {\n   465→      throw new AgentError(`Agent '${agentId}' not found`, agentId);\n   466→    }\n   467→\n   468→    if (instance.state !== AgentLifecycleState.PAUSED) {\n   469→      throw new AgentError(\n   470→        `Agent '${agentId}' is not paused. Current state: ${instance.state}`,\n   471→        agentId\n   472→      );\n   473→    }\n   474→\n   475→    // Emit before_resume event\n   476→    await this.emitEvent(AgentLifecycleEvent.BEFORE_RESUME, agentId);\n   477→\n   478→    try {\n   479→      instance.state = AgentLifecycleState.STARTING;\n   480→\n   481→      // Transition to running state\n   482→      instance.state = AgentLifecycleState.RUNNING;\n   483→      instance.isActive = true;\n   484→\n   485→      // Emit resumed event\n   486→      await this.emitEvent(AgentLifecycleEvent.RESUMED, agentId);\n   487→\n   488→      this.logger.info(`Agent resumed: ${agentId}`, 'AgentLifecycleManager');\n   489→\n   490→      // Update registry status\n   491→      this.registry.updateStatus(agentId, 'active');\n   492→    } catch (error) {\n   493→      instance.state = AgentLifecycleState.ERROR;\n   494→      instance.error = error as Error;\n   495→\n   496→      await this.emitEvent(AgentLifecycleEvent.RESUME_ERROR, agentId, error as Error);\n   497→\n   498→      this.logger.error(\n   499→        `Agent resume failed: ${agentId}`,\n   500→        'AgentLifecycleManager',\n   501→        { error: (error as Error).message }\n   502→      );\n   503→\n   504→      throw error;\n   505→    }\n   506→  }\n   507→\n   508→  /**\n   509→   * Stop an agent\n   510→   *\n   511→   * @param agentId - ID of agent to stop\n   512→   * @returns Promise that resolves when agent is stopped\n   513→   * @throws AgentError if stop fails\n   514→   */\n   515→  async stop(agentId: string): Promise<void> {\n   516→    const instance = this.instances.get(agentId);\n   517→\n   518→    if (!instance) {\n   519→      this.logger.warn(`Agent '${agentId}' not found for stop`, 'AgentLifecycleManager');\n   520→      return;\n   521→    }\n   522→\n   523→    if (instance.state === AgentLifecycleState.STOPPED) {\n   524→      this.logger.debug(`Agent '${agentId}' already stopped`, 'AgentLifecycleManager');\n   525→      return;\n   526→    }\n   527→\n   528→    // Emit before_stop event\n   529→    await this.emitEvent(AgentLifecycleEvent.BEFORE_STOP, agentId);\n   530→\n   531→    try {\n   532→      instance.state = AgentLifecycleState.STOPPING;\n   533→\n   534→      // Transition to stopped state\n   535→      instance.state = AgentLifecycleState.STOPPED;\n   536→      instance.isActive = false;\n   537→\n   538→      // Clear current task\n   539→      instance.context.currentTask = undefined;\n   540→\n   541→      // Emit stopped event\n   542→      await this.emitEvent(AgentLifecycleEvent.STOPPED, agentId);\n   543→\n   544→      this.logger.info(`Agent stopped: ${agentId}`, 'AgentLifecycleManager');\n   545→    } catch (error) {\n   546→      instance.state = AgentLifecycleState.ERROR;\n   547→      instance.error = error as Error;\n   548→\n   549→      await this.emitEvent(AgentLifecycleEvent.STOP_ERROR, agentId, error as Error);\n   550→\n   551→      this.logger.error(\n   552→        `Agent stop failed: ${agentId}`,\n   553→        'AgentLifecycleManager',\n   554→        { error: (error as Error).message }\n   555→      );\n   556→\n   557→      throw error;\n   558→    }\n   559→  }\n   560→\n   561→  /**\n   562→   * Dispose an agent\n   563→   *\n   564→   * @param agentId - ID of agent to dispose\n   565→   * @returns Promise that resolves when agent is disposed\n   566→   * @throws AgentError if disposal fails\n   567→   */\n   568→  async dispose(agentId: string): Promise<void> {\n   569→    const instance = this.instances.get(agentId);\n   570→\n   571→    if (!instance) {\n   572→      this.logger.warn(`Agent '${agentId}' not found for disposal`, 'AgentLifecycleManager');\n   573→      return;\n   574→    }\n   575→\n   576→    // Stop if running\n   577→    if (instance.state === AgentLifecycleState.RUNNING || instance.state === AgentLifecycleState.PAUSED) {\n   578→      await this.stop(agentId);\n   579→    }\n   580→\n   581→    // Emit before_dispose event\n   582→    await this.emitEvent(AgentLifecycleEvent.BEFORE_DISPOSE, agentId);\n   583→\n   584→    try {\n   585→      instance.state = AgentLifecycleState.DISPOSING;\n   586→\n   587→      // Clear context data\n   588→      instance.context.contextData.clear();\n   589→      instance.context.taskHistory = [];\n   590→\n   591→      // Remove instance\n   592→      this.instances.delete(agentId);\n   593→\n   594→      // Emit disposed event\n   595→      await this.emitEvent(AgentLifecycleEvent.DISPOSED, agentId);\n   596→\n   597→      this.logger.info(`Agent disposed: ${agentId}`, 'AgentLifecycleManager');\n   598→    } catch (error) {\n   599→      await this.emitEvent(AgentLifecycleEvent.DISPOSE_ERROR, agentId, error as Error);\n   600→\n   601→      this.logger.error(\n   602→        `Agent disposal failed: ${agentId}`,\n   603→        'AgentLifecycleManager',\n   604→        { error: (error as Error).message }\n   605→      );\n   606→\n   607→      throw error;\n   608→    }\n   609→  }\n   610→\n   611→  /**\n   612→   * Get an agent instance\n   613→   *\n   614→   * @param agentId - ID of agent to get\n   615→   * @returns Agent instance or undefined if not found\n   616→   */\n   617→  getInstance(agentId: string): AgentInstance | undefined {\n   618→    return this.instances.get(agentId);\n   619→  }\n   620→\n   621→  /**\n   622→   * Get all agent instances\n   623→   *\n   624→   * @returns Map of agent ID to agent instance\n   625→   */\n   626→  getAllInstances(): Map<string, AgentInstance> {\n   627→    return new Map(this.instances);\n   628→  }\n   629→\n   630→  /**\n   631→   * Get agent state\n   632→   *\n   633→   * @param agentId - ID of agent to get state for\n   634→   * @returns Agent state or undefined if not found\n   635→   */\n   636→  getState(agentId: string): AgentLifecycleState | undefined {\n   637→    return this.instances.get(agentId)?.state;\n   638→  }\n   639→\n   640→  /**\n   641→   * Check if agent is active\n   642→   *\n   643→   * @param agentId - ID of agent to check\n   644→   * @returns True if agent is active\n   645→   */\n   646→  isActive(agentId: string): boolean {\n   647→    return this.instances.get(agentId)?.isActive ?? false;\n   648→  }\n   649→\n   650→  /**\n   651→   * Get active agents\n   652→   *\n   653→   * @returns Array of active agent IDs\n   654→   */\n   655→  getActiveAgents(): string[] {\n   656→    const active: string[] = [];\n   657→\n   658→    for (const [id, instance] of this.instances.entries()) {\n   659→      if (instance.isActive) {\n   660→        active.push(id);\n   661→      }\n   662→    }\n   663→\n   664→    return active;\n   665→  }\n   666→\n   667→  /**\n   668→   * Add event handler\n   669→   *\n   670→   * @param event - Event to handle\n   671→   * @param handler - Event handler function\n   672→   */\n   673→  addEventHandler(event: AgentLifecycleEvent, handler: AgentLifecycleEventHandler): void {\n   674→    if (!this.eventHandlers.has(event)) {\n   675→      this.eventHandlers.set(event, []);\n   676→    }\n   677→    this.eventHandlers.get(event)!.push(handler);\n   678→  }\n   679→\n   680→  /**\n   681→   * Remove event handler\n   682→   *\n   683→   * @param event - Event to remove handler for\n   684→   * @param handler - Event handler function to remove\n   685→   */\n   686→  removeEventHandler(event: AgentLifecycleEvent, handler: AgentLifecycleEventHandler): void {\n   687→    const handlers = this.eventHandlers.get(event);\n   688→    if (handlers) {\n   689→      const index = handlers.indexOf(handler);\n   690→      if (index > -1) {\n   691→        handlers.splice(index, 1);\n   692→      }\n   693→    }\n   694→  }\n   695→\n   696→  /**\n   697→   * Emit lifecycle event\n   698→   *\n   699→   * @param event - Event to emit\n   700→   * @param agentId - ID of agent\n   701→   * @param error - Optional error\n   702→   */\n   703→  private async emitEvent(\n   704→    event: AgentLifecycleEvent,\n   705→    agentId: string,\n   706→    error?: Error\n   707→  ): Promise<void> {\n   708→    const handlers = this.eventHandlers.get(event);\n   709→\n   710→    if (handlers) {\n   711→      for (const handler of handlers) {\n   712→        try {\n   713→          await handler(event, agentId, error);\n   714→        } catch (err) {\n   715→          this.logger.error(\n   716→            `Event handler error for event '${event}' on agent '${agentId}'`,\n   717→            'AgentLifecycleManager',\n   718→            { error: (err as Error).message }\n   719→          );\n   720→        }\n   721→      }\n   722→    }\n   723→  }\n   724→\n   725→  /**\n   726→   * Clear all agent instances\n   727→   */\n   728→  clear(): void {\n   729→    this.instances.clear();\n   730→    this.logger.info('AgentLifecycleManager cleared', 'AgentLifecycleManager');\n   731→  }\n   732→}\n   733→\n   734→/**\n   735→ * Global agent lifecycle manager instance\n   736→ */\n   737→let globalAgentLifecycleManager: AgentLifecycleManager | null = null;\n   738→\n   739→/**\n   740→ * Initialize global agent lifecycle manager\n   741→ *\n   742→ * @param config - Lifecycle manager configuration\n   743→ * @param logger - Optional logger instance\n   744→ * @param errorHandler - Optional error handler instance\n   745→ * @param registry - Optional agent registry instance\n   746→ * @returns The global agent lifecycle manager\n   747→ */\n   748→export function initAgentLifecycleManager(\n   749→  config?: AgentLifecycleManagerConfig,\n   750→  logger?: Logger,\n   751→  errorHandler?: ErrorHandler,\n   752→  registry?: AgentRegistry\n   753→): AgentLifecycleManager {\n   754→  globalAgentLifecycleManager = new AgentLifecycleManager(\n   755→    config,\n   756→    logger,\n   757→    errorHandler,\n   758→    registry\n   759→  );\n   760→  return globalAgentLifecycleManager;\n   761→}\n   762→\n   763→/**\n   764→ * Get global agent lifecycle manager\n   765→ *\n   766→ * @returns The global agent lifecycle manager\n   767→ */\n   768→export function getAgentLifecycleManager(): AgentLifecycleManager {\n   769→  if (!globalAgentLifecycleManager) {\n   770→    globalAgentLifecycleManager = new AgentLifecycleManager();\n   771→  }\n   772→  return globalAgentLifecycleManager;\n   773→}\n   774→\n\n</system-reminder>\n"}]},"uuid":"de6903c5-68c1-4729-aa55-0af1eb4b474d","timestamp":"2026-01-12T06:23:19.454Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/lifecycle.ts","content":"/**\n * Agent Lifecycle Management for KOMPLETE-KONTROL CLI\n *\n * Provides agent lifecycle management including initialization, start, pause, stop, and disposal.\n * Follows patterns from agent-swarm-kit with simplified architecture.\n */\n\nimport type { AgentDefinition, AgentTask, AgentTaskResult } from '../../types';\nimport { AgentError } from '../../types';\nimport { Logger } from '../../utils/logger';\nimport { ErrorHandler } from '../../utils/error-handler';\nimport { AgentRegistry, getAgentRegistry } from './registry';\n\n/**\n * Agent lifecycle state\n */\nexport enum AgentLifecycleState {\n  /**\n   * Agent has been created but not initialized\n   */\n  CREATED = 'created',\n  /**\n   * Agent is being initialized\n   */\n  INITIALIZING = 'initializing',\n  /**\n   * Agent is initialized and ready\n   */\n  INITIALIZED = 'initialized',\n  /**\n   * Agent is starting\n   */\n  STARTING = 'starting',\n  /**\n   * Agent is running and active\n   */\n  RUNNING = 'running',\n  /**\n   * Agent is pausing\n   */\n  PAUSING = 'pausing',\n  /**\n   * Agent is paused\n   */\n  PAUSED = 'paused',\n  /**\n   * Agent is stopping\n   */\n  STOPPING = 'stopping',\n  /**\n   * Agent is stopped\n   */\n  STOPPED = 'stopped',\n  /**\n   * Agent is being disposed\n   */\n  DISPOSING = 'disposing',\n  /**\n   * Agent has been disposed\n   */\n  DISPOSED = 'disposed',\n  /**\n   * Agent encountered an error\n   */\n  ERROR = 'error',\n}\n\n/**\n * Agent lifecycle event\n */\nexport enum AgentLifecycleEvent {\n  /**\n   * Agent is about to initialize\n   */\n  BEFORE_INIT = 'before_init',\n  /**\n   * Agent has been initialized\n   */\n  INITIALIZED = 'initialized',\n  /**\n   * Agent initialization failed\n   */\n  INIT_ERROR = 'init_error',\n  /**\n   * Agent is about to start\n   */\n  BEFORE_START = 'before_start',\n  /**\n   * Agent has started\n   */\n  STARTED = 'started',\n  /**\n   * Agent start failed\n   */\n  START_ERROR = 'start_error',\n  /**\n   * Agent is about to pause\n   */\n  BEFORE_PAUSE = 'before_pause',\n  /**\n   * Agent has been paused\n   */\n  PAUSED = 'paused',\n  /**\n   * Agent pause failed\n   */\n  PAUSE_ERROR = 'pause_error',\n  /**\n   * Agent is about to resume\n   */\n  BEFORE_RESUME = 'before_resume',\n  /**\n   * Agent has been resumed\n   */\n  RESUMED = 'resumed',\n  /**\n   * Agent resume failed\n   */\n  RESUME_ERROR = 'resume_error',\n  /**\n   * Agent is about to stop\n   */\n  BEFORE_STOP = 'before_stop',\n  /**\n   * Agent has been stopped\n   */\n  STOPPED = 'stopped',\n  /**\n   * Agent stop failed\n   */\n  STOP_ERROR = 'stop_error',\n  /**\n   * Agent is about to be disposed\n   */\n  BEFORE_DISPOSE = 'before_dispose',\n  /**\n   * Agent has been disposed\n   */\n  DISPOSED = 'disposed',\n  /**\n   * Agent disposal failed\n   */\n  DISPOSE_ERROR = 'dispose_error',\n}\n\n/**\n * Agent lifecycle event handler\n */\nexport type AgentLifecycleEventHandler = (\n  event: AgentLifecycleEvent,\n  agentId: string,\n  error?: Error\n) => void | Promise<void>;\n\n/**\n * Agent execution context\n */\nexport interface AgentExecutionContext {\n  /**\n   * Agent ID\n   */\n  agentId: string;\n  /**\n   * Current task being executed\n   */\n  currentTask?: AgentTask;\n  /**\n   * Task execution history\n   */\n  taskHistory: AgentTaskResult[];\n  /**\n   * Custom context data\n   */\n  contextData: Map<string, unknown>;\n}\n\n/**\n * Agent instance\n */\nexport interface AgentInstance {\n  /**\n   * Agent ID\n   */\n  id: string;\n  /**\n   * Agent definition\n   */\n  definition: AgentDefinition;\n  /**\n   * Current lifecycle state\n   */\n  state: AgentLifecycleState;\n  /**\n   * Execution context\n   */\n  context: AgentExecutionContext;\n  /**\n   * Whether the agent is active\n   */\n  isActive: boolean;\n  /**\n   * Error encountered (if any)\n   */\n  error?: Error;\n}\n\n/**\n * Agent lifecycle manager configuration\n */\nexport interface AgentLifecycleManagerConfig {\n  /**\n   * Maximum number of concurrent tasks per agent\n   */\n  maxConcurrentTasks?: number;\n  /**\n   * Task timeout in milliseconds\n   */\n  taskTimeout?: number;\n  /**\n   * Enable automatic recovery on error\n   */\n  autoRecovery?: boolean;\n  /**\n   * Maximum recovery attempts\n   */\n  maxRecoveryAttempts?: number;\n}\n\n/**\n * Agent Lifecycle Manager class\n *\n * Manages agent lifecycle including initialization, start, pause, stop, and disposal.\n * Provides state management and event handling for agents.\n */\nexport class AgentLifecycleManager {\n  private instances: Map<string, AgentInstance> = new Map();\n  private eventHandlers: Map<AgentLifecycleEvent, AgentLifecycleEventHandler[]> =\n    new Map();\n  private logger: Logger;\n  private errorHandler: ErrorHandler;\n  private registry: AgentRegistry;\n  private config: Required<AgentLifecycleManagerConfig>;\n\n  constructor(\n    config: AgentLifecycleManagerConfig = {},\n    logger?: Logger,\n    errorHandler?: ErrorHandler,\n    registry?: AgentRegistry\n  ) {\n    this.logger = logger || new Logger();\n    this.errorHandler = errorHandler || new ErrorHandler();\n    this.registry = registry || getAgentRegistry();\n    this.config = {\n      maxConcurrentTasks: config.maxConcurrentTasks ?? 1,\n      taskTimeout: config.taskTimeout ?? 30000,\n      autoRecovery: config.autoRecovery ?? true,\n      maxRecoveryAttempts: config.maxRecoveryAttempts ?? 3,\n    };\n    this.logger.info('AgentLifecycleManager initialized', 'AgentLifecycleManager');\n  }\n\n  /**\n   * Initialize an agent\n   *\n   * @param agentId - ID of agent to initialize\n   * @returns Promise that resolves when agent is initialized\n   * @throws AgentError if agent not found or initialization fails\n   */\n  async initialize(agentId: string): Promise<void> {\n    const definition = this.registry.get(agentId);\n\n    if (!definition) {\n      throw new AgentError(`Agent '${agentId}' not found in registry`, agentId);\n    }\n\n    // Check if already initialized\n    if (this.instances.has(agentId)) {\n      const instance = this.instances.get(agentId)!;\n      if (instance.state === AgentLifecycleState.INITIALIZED) {\n        this.logger.debug(`Agent '${agentId}' already initialized`, 'AgentLifecycleManager');\n        return;\n      }\n    }\n\n    // Create agent instance\n    const instance: AgentInstance = {\n      id: agentId,\n      definition,\n      state: AgentLifecycleState.INITIALIZING,\n      context: {\n        agentId,\n        taskHistory: [],\n        contextData: new Map(),\n      },\n      isActive: false,\n    };\n\n    this.instances.set(agentId, instance);\n\n    // Emit before_init event\n    await this.emitEvent(AgentLifecycleEvent.BEFORE_INIT, agentId);\n\n    try {\n      // Validate dependencies\n      if (!this.registry.checkDependencies(agentId)) {\n        throw new AgentError(\n          `Agent '${agentId}' has unsatisfied dependencies`,\n          agentId\n        );\n      }\n\n      // Transition to initialized state\n      instance.state = AgentLifecycleState.INITIALIZED;\n\n      // Emit initialized event\n      await this.emitEvent(AgentLifecycleEvent.INITIALIZED, agentId);\n\n      this.logger.info(`Agent initialized: ${agentId}`, 'AgentLifecycleManager', {\n        name: definition.name,\n        capabilities: definition.capabilities,\n      });\n\n      // Update registry status\n      this.registry.updateStatus(agentId, 'registered');\n    } catch (error) {\n      instance.state = AgentLifecycleState.ERROR;\n      instance.error = error as Error;\n\n      await this.emitEvent(\n        AgentLifecycleEvent.INIT_ERROR,\n        agentId,\n        error as Error\n      );\n\n      this.logger.error(\n        `Agent initialization failed: ${agentId}`,\n        'AgentLifecycleManager',\n        { error: (error as Error).message }\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Start an agent\n   *\n   * @param agentId - ID of agent to start\n   * @returns Promise that resolves when agent is started\n   * @throws AgentError if agent not initialized or start fails\n   */\n  async start(agentId: string): Promise<void> {\n    const instance = this.instances.get(agentId);\n\n    if (!instance) {\n      throw new AgentError(\n        `Agent '${agentId}' not initialized. Call initialize() first.`,\n        agentId\n      );\n    }\n\n    if (instance.state === AgentLifecycleState.RUNNING) {\n      this.logger.debug(`Agent '${agentId}' already running`, 'AgentLifecycleManager');\n      return;\n    }\n\n    // Emit before_start event\n    await this.emitEvent(AgentLifecycleEvent.BEFORE_START, agentId);\n\n    try {\n      instance.state = AgentLifecycleState.STARTING;\n\n      // Transition to running state\n      instance.state = AgentLifecycleState.RUNNING;\n      instance.isActive = true;\n\n      // Emit started event\n      await this.emitEvent(AgentLifecycleEvent.STARTED, agentId);\n\n      this.logger.info(`Agent started: ${agentId}`, 'AgentLifecycleManager');\n\n      // Update registry status\n      this.registry.updateStatus(agentId, 'active');\n    } catch (error) {\n      instance.state = AgentLifecycleState.ERROR;\n      instance.error = error as Error;\n\n      await this.emitEvent(AgentLifecycleEvent.START_ERROR, agentId, error as Error);\n\n      this.logger.error(\n        `Agent start failed: ${agentId}`,\n        'AgentLifecycleManager',\n        { error: (error as Error).message }\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Pause an agent\n   *\n   * @param agentId - ID of agent to pause\n   * @returns Promise that resolves when agent is paused\n   * @throws AgentError if agent not running or pause fails\n   */\n  async pause(agentId: string): Promise<void> {\n    const instance = this.instances.get(agentId);\n\n    if (!instance) {\n      throw new AgentError(`Agent '${agentId}' not found`, agentId);\n    }\n\n    if (instance.state !== AgentLifecycleState.RUNNING) {\n      throw new AgentError(\n        `Agent '${agentId}' is not running. Current state: ${instance.state}`,\n        agentId\n      );\n    }\n\n    // Emit before_pause event\n    await this.emitEvent(AgentLifecycleEvent.BEFORE_PAUSE, agentId);\n\n    try {\n      instance.state = AgentLifecycleState.PAUSING;\n\n      // Transition to paused state\n      instance.state = AgentLifecycleState.PAUSED;\n      instance.isActive = false;\n\n      // Emit paused event\n      await this.emitEvent(AgentLifecycleEvent.PAUSED, agentId);\n\n      this.logger.info(`Agent paused: ${agentId}`, 'AgentLifecycleManager');\n\n      // Update registry status\n      this.registry.updateStatus(agentId, 'paused');\n    } catch (error) {\n      instance.state = AgentLifecycleState.ERROR;\n      instance.error = error as Error;\n\n      await this.emitEvent(AgentLifecycleEvent.PAUSE_ERROR, agentId, error as Error);\n\n      this.logger.error(\n        `Agent pause failed: ${agentId}`,\n        'AgentLifecycleManager',\n        { error: (error as Error).message }\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Resume a paused agent\n   *\n   * @param agentId - ID of agent to resume\n   * @returns Promise that resolves when agent is resumed\n   * @throws AgentError if agent not paused or resume fails\n   */\n  async resume(agentId: string): Promise<void> {\n    const instance = this.instances.get(agentId);\n\n    if (!instance) {\n      throw new AgentError(`Agent '${agentId}' not found`, agentId);\n    }\n\n    if (instance.state !== AgentLifecycleState.PAUSED) {\n      throw new AgentError(\n        `Agent '${agentId}' is not paused. Current state: ${instance.state}`,\n        agentId\n      );\n    }\n\n    // Emit before_resume event\n    await this.emitEvent(AgentLifecycleEvent.BEFORE_RESUME, agentId);\n\n    try {\n      instance.state = AgentLifecycleState.STARTING;\n\n      // Transition to running state\n      instance.state = AgentLifecycleState.RUNNING;\n      instance.isActive = true;\n\n      // Emit resumed event\n      await this.emitEvent(AgentLifecycleEvent.RESUMED, agentId);\n\n      this.logger.info(`Agent resumed: ${agentId}`, 'AgentLifecycleManager');\n\n      // Update registry status\n      this.registry.updateStatus(agentId, 'active');\n    } catch (error) {\n      instance.state = AgentLifecycleState.ERROR;\n      instance.error = error as Error;\n\n      await this.emitEvent(AgentLifecycleEvent.RESUME_ERROR, agentId, error as Error);\n\n      this.logger.error(\n        `Agent resume failed: ${agentId}`,\n        'AgentLifecycleManager',\n        { error: (error as Error).message }\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Stop an agent\n   *\n   * @param agentId - ID of agent to stop\n   * @returns Promise that resolves when agent is stopped\n   * @throws AgentError if stop fails\n   */\n  async stop(agentId: string): Promise<void> {\n    const instance = this.instances.get(agentId);\n\n    if (!instance) {\n      this.logger.warn(`Agent '${agentId}' not found for stop`, 'AgentLifecycleManager');\n      return;\n    }\n\n    if (instance.state === AgentLifecycleState.STOPPED) {\n      this.logger.debug(`Agent '${agentId}' already stopped`, 'AgentLifecycleManager');\n      return;\n    }\n\n    // Emit before_stop event\n    await this.emitEvent(AgentLifecycleEvent.BEFORE_STOP, agentId);\n\n    try {\n      instance.state = AgentLifecycleState.STOPPING;\n\n      // Transition to stopped state\n      instance.state = AgentLifecycleState.STOPPED;\n      instance.isActive = false;\n\n      // Clear current task\n      instance.context.currentTask = undefined;\n\n      // Emit stopped event\n      await this.emitEvent(AgentLifecycleEvent.STOPPED, agentId);\n\n      this.logger.info(`Agent stopped: ${agentId}`, 'AgentLifecycleManager');\n    } catch (error) {\n      instance.state = AgentLifecycleState.ERROR;\n      instance.error = error as Error;\n\n      await this.emitEvent(AgentLifecycleEvent.STOP_ERROR, agentId, error as Error);\n\n      this.logger.error(\n        `Agent stop failed: ${agentId}`,\n        'AgentLifecycleManager',\n        { error: (error as Error).message }\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Dispose an agent\n   *\n   * @param agentId - ID of agent to dispose\n   * @returns Promise that resolves when agent is disposed\n   * @throws AgentError if disposal fails\n   */\n  async dispose(agentId: string): Promise<void> {\n    const instance = this.instances.get(agentId);\n\n    if (!instance) {\n      this.logger.warn(`Agent '${agentId}' not found for disposal`, 'AgentLifecycleManager');\n      return;\n    }\n\n    // Stop if running\n    if (instance.state === AgentLifecycleState.RUNNING || instance.state === AgentLifecycleState.PAUSED) {\n      await this.stop(agentId);\n    }\n\n    // Emit before_dispose event\n    await this.emitEvent(AgentLifecycleEvent.BEFORE_DISPOSE, agentId);\n\n    try {\n      instance.state = AgentLifecycleState.DISPOSING;\n\n      // Clear context data\n      instance.context.contextData.clear();\n      instance.context.taskHistory = [];\n\n      // Remove instance\n      this.instances.delete(agentId);\n\n      // Emit disposed event\n      await this.emitEvent(AgentLifecycleEvent.DISPOSED, agentId);\n\n      this.logger.info(`Agent disposed: ${agentId}`, 'AgentLifecycleManager');\n    } catch (error) {\n      await this.emitEvent(AgentLifecycleEvent.DISPOSE_ERROR, agentId, error as Error);\n\n      this.logger.error(\n        `Agent disposal failed: ${agentId}`,\n        'AgentLifecycleManager',\n        { error: (error as Error).message }\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get an agent instance\n   *\n   * @param agentId - ID of agent to get\n   * @returns Agent instance or undefined if not found\n   */\n  getInstance(agentId: string): AgentInstance | undefined {\n    return this.instances.get(agentId);\n  }\n\n  /**\n   * Get all agent instances\n   *\n   * @returns Map of agent ID to agent instance\n   */\n  getAllInstances(): Map<string, AgentInstance> {\n    return new Map(this.instances);\n  }\n\n  /**\n   * Get agent state\n   *\n   * @param agentId - ID of agent to get state for\n   * @returns Agent state or undefined if not found\n   */\n  getState(agentId: string): AgentLifecycleState | undefined {\n    return this.instances.get(agentId)?.state;\n  }\n\n  /**\n   * Check if agent is active\n   *\n   * @param agentId - ID of agent to check\n   * @returns True if agent is active\n   */\n  isActive(agentId: string): boolean {\n    return this.instances.get(agentId)?.isActive ?? false;\n  }\n\n  /**\n   * Get active agents\n   *\n   * @returns Array of active agent IDs\n   */\n  getActiveAgents(): string[] {\n    const active: string[] = [];\n\n    for (const [id, instance] of this.instances.entries()) {\n      if (instance.isActive) {\n        active.push(id);\n      }\n    }\n\n    return active;\n  }\n\n  /**\n   * Add event handler\n   *\n   * @param event - Event to handle\n   * @param handler - Event handler function\n   */\n  addEventHandler(event: AgentLifecycleEvent, handler: AgentLifecycleEventHandler): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, []);\n    }\n    this.eventHandlers.get(event)!.push(handler);\n  }\n\n  /**\n   * Remove event handler\n   *\n   * @param event - Event to remove handler for\n   * @param handler - Event handler function to remove\n   */\n  removeEventHandler(event: AgentLifecycleEvent, handler: AgentLifecycleEventHandler): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit lifecycle event\n   *\n   * @param event - Event to emit\n   * @param agentId - ID of agent\n   * @param error - Optional error\n   */\n  private async emitEvent(\n    event: AgentLifecycleEvent,\n    agentId: string,\n    error?: Error\n  ): Promise<void> {\n    const handlers = this.eventHandlers.get(event);\n\n    if (handlers) {\n      for (const handler of handlers) {\n        try {\n          await handler(event, agentId, error);\n        } catch (err) {\n          this.logger.error(\n            `Event handler error for event '${event}' on agent '${agentId}'`,\n            'AgentLifecycleManager',\n            { error: (err as Error).message }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Clear all agent instances\n   */\n  clear(): void {\n    this.instances.clear();\n    this.logger.info('AgentLifecycleManager cleared', 'AgentLifecycleManager');\n  }\n}\n\n/**\n * Global agent lifecycle manager instance\n */\nlet globalAgentLifecycleManager: AgentLifecycleManager | null = null;\n\n/**\n * Initialize global agent lifecycle manager\n *\n * @param config - Lifecycle manager configuration\n * @param logger - Optional logger instance\n * @param errorHandler - Optional error handler instance\n * @param registry - Optional agent registry instance\n * @returns The global agent lifecycle manager\n */\nexport function initAgentLifecycleManager(\n  config?: AgentLifecycleManagerConfig,\n  logger?: Logger,\n  errorHandler?: ErrorHandler,\n  registry?: AgentRegistry\n): AgentLifecycleManager {\n  globalAgentLifecycleManager = new AgentLifecycleManager(\n    config,\n    logger,\n    errorHandler,\n    registry\n  );\n  return globalAgentLifecycleManager;\n}\n\n/**\n * Get global agent lifecycle manager\n *\n * @returns The global agent lifecycle manager\n */\nexport function getAgentLifecycleManager(): AgentLifecycleManager {\n  if (!globalAgentLifecycleManager) {\n    globalAgentLifecycleManager = new AgentLifecycleManager();\n  }\n  return globalAgentLifecycleManager;\n}\n","numLines":774,"startLine":1,"totalLines":774}}}
{"parentUuid":"de6903c5-68c1-4729-aa55-0af1eb4b474d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UvHcdDLudmpQryS2PdgHQc","type":"tool_result","content":"     1→/**\n     2→ * Agent Communication for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Provides message passing and communication capabilities between agents.\n     5→ * Follows patterns from agent-swarm-kit with simplified architecture.\n     6→ */\n     7→\n     8→import { AgentError } from '../../types';\n     9→import { Logger } from '../../utils/logger';\n    10→\n    11→/**\n    12→ * Message types\n    13→ */\n    14→export enum MessageType {\n    15→  /**\n    16→   * Request message (expects response)\n    17→   */\n    18→  REQUEST = 'request',\n    19→  /**\n    20→   * Response message\n    21→   */\n    22→  RESPONSE = 'response',\n    23→  /**\n    24→   * Notification message (no response expected)\n    25→   */\n    26→  NOTIFICATION = 'notification',\n    27→  /**\n    28→   * Broadcast message (sent to all agents)\n    29→   */\n    30→  BROADCAST = 'broadcast',\n    31→}\n    32→\n    33→/**\n    34→ * Message priority\n    35→ */\n    36→export enum MessagePriority {\n    37→  /**\n    38→   * Low priority message\n    39→   */\n    40→  LOW = 0,\n    41→  /**\n    42→   * Normal priority message\n    43→   */\n    44→  NORMAL = 1,\n    45→  /**\n    46→   * High priority message\n    47→   */\n    48→  HIGH = 2,\n    49→  /**\n    50→   * Critical priority message\n    51→   */\n    52→  CRITICAL = 3,\n    53→}\n    54→\n    55→/**\n    56→ * Agent message\n    57→ */\n    58→export interface AgentMessage {\n    59→  /**\n    60→   * Message ID\n    61→   */\n    62→  id: string;\n    63→  /**\n    64→   * Message type\n    65→   */\n    66→  type: MessageType;\n    67→  /**\n    68→   * Sender agent ID\n    69→   */\n    70→  from: string;\n    71→  /**\n    72→   * Recipient agent ID (undefined for broadcast)\n    73→   */\n    74→  to?: string;\n    75→  /**\n    76→   * Message subject\n    77→   */\n    78→  subject: string;\n    79→  /**\n    80→   * Message payload\n    81→   */\n    82→  payload: unknown;\n    83→  /**\n    84→   * Message priority\n    85→   */\n    86→  priority: MessagePriority;\n    87→  /**\n    88→   * Message timestamp\n    89→   */\n    90→  timestamp: Date;\n    91→  /**\n    92→   * Correlation ID for request-response pattern\n    93→   */\n    94→  correlationId?: string;\n    95→  /**\n    96→   * Reply-to agent ID\n    97→   */\n    98→  replyTo?: string;\n    99→  /**\n   100→   * TTL (time to live) in milliseconds\n   101→   */\n   102→  ttl?: number;\n   103→  /**\n   104→   * Message metadata\n   105→   */\n   106→  metadata?: Record<string, unknown>;\n   107→}\n   108→\n   109→/**\n   110→ * Message handler function\n   111→ */\n   112→export type MessageHandler = (message: AgentMessage) => void | Promise<void>;\n   113→\n   114→/**\n   115→ * Message filter function\n   116→ */\n   117→export type MessageFilter = (message: AgentMessage) => boolean;\n   118→\n   119→/**\n   120→ * Pending request\n   121→ */\n   122→interface PendingRequest {\n   123→  resolve: (value: AgentMessage) => void;\n   124→  reject: (error: Error) => void;\n   125→  timeout: NodeJS.Timeout;\n   126→}\n   127→\n   128→/**\n   129→ * Communication channel configuration\n   130→ */\n   131→export interface CommunicationChannelConfig {\n   132→  /**\n   133→   * Channel name\n   134→   */\n   135→  name: string;\n   136→  /**\n   137→   * Message TTL in milliseconds\n   138→   */\n   139→  defaultTtl?: number;\n   140→  /**\n   141→   * Maximum message queue size\n   142→   */\n   143→  maxQueueSize?: number;\n   144→  /**\n   145→   * Enable message persistence\n   146→   */\n   147→  enablePersistence?: boolean;\n   148→}\n   149→\n   150→/**\n   151→ * Agent Communication Manager class\n   152→ *\n   153→ * Provides message passing and communication capabilities between agents.\n   154→ * Supports request-response pattern, notifications, and broadcasting.\n   155→ */\n   156→export class AgentCommunicationManager {\n   157→  private messageHandlers: Map<string, MessageHandler[]> = new Map();\n   158→  private messageFilters: Map<string, MessageFilter[]> = new Map();\n   159→  private pendingRequests: Map<string, PendingRequest> = new Map();\n   160→  private messageHistory: AgentMessage[] = [];\n   161→  private logger: Logger;\n   162→  private config: Required<CommunicationChannelConfig>;\n   163→\n   164→  constructor(\n   165→    config: CommunicationChannelConfig = { name: 'default' },\n   166→    logger?: Logger\n   167→  ) {\n   168→    this.logger = logger || new Logger();\n   169→    this.config = {\n   170→      name: config.name,\n   171→      defaultTtl: config.defaultTtl ?? 60000,\n   172→      maxQueueSize: config.maxQueueSize ?? 1000,\n   173→      enablePersistence: config.enablePersistence ?? false,\n   174→    };\n   175→    this.logger.info(\n   176→      `AgentCommunicationManager initialized: ${this.config.name}`,\n   177→      'AgentCommunicationManager'\n   178→    );\n   179→  }\n   180→\n   181→  /**\n   182→   * Send a message to an agent\n   183→   *\n   184→   * @param message - Message to send\n   185→   * @throws AgentError if message validation fails\n   186→   */\n   187→  async send(message: AgentMessage): Promise<void> {\n   188→    this.validateMessage(message);\n   189→\n   190→    // Handle response messages\n   191→    if (message.type === MessageType.RESPONSE) {\n   192→      this.handleResponse(message);\n   193→      return;\n   194→    }\n   195→\n   196→    // Check TTL\n   197→    if (message.ttl && Date.now() - message.timestamp.getTime() > message.ttl) {\n   198→      this.logger.warn(`Message expired: ${message.id}`, 'AgentCommunicationManager');\n   199→      return;\n   200→    }\n   201→\n   202→    // Add to history\n   203→    this.addToHistory(message);\n   204→\n   205→    // Find handlers for recipient\n   206→    const handlers = this.getHandlers(message.to);\n   207→\n   208→    if (handlers.length === 0) {\n   209→      this.logger.warn(\n   210→        `No handlers found for recipient: ${message.to}`,\n   211→        'AgentCommunicationManager'\n   212→      );\n   213→      return;\n   214→    }\n   215→\n   216→    // Apply filters\n   217→    const filters = this.getFilters(message.to);\n   218→    const shouldProcess = filters.every((filter) => filter(message));\n   219→\n   220→    if (!shouldProcess) {\n   221→      this.logger.debug(`Message filtered out: ${message.id}`, 'AgentCommunicationManager');\n   222→      return;\n   223→    }\n   224→\n   225→    // Deliver message to handlers\n   226→    for (const handler of handlers) {\n   227→      try {\n   228→        await handler(message);\n   229→      } catch (error) {\n   230→        this.logger.error(\n   231→          `Message handler error: ${message.id}`,\n   232→          'AgentCommunicationManager',\n   233→          { error: (error as Error).message }\n   234→        );\n   235→      }\n   236→    }\n   237→\n   238→    this.logger.debug(\n   239→      `Message sent: ${message.id} from ${message.from} to ${message.to}`,\n   240→      'AgentCommunicationManager'\n   241→    );\n   242→  }\n   243→\n   244→  /**\n   245→   * Send a request and wait for response\n   246→   *\n   247→   * @param from - Sender agent ID\n   248→   * @param to - Recipient agent ID\n   249→   * @param subject - Message subject\n   250→   * @param payload - Message payload\n   251→   * @param timeout - Request timeout in milliseconds\n   252→   * @returns Response message\n   253→   * @throws AgentError if request times out or fails\n   254→   */\n   255→  async request(\n   256→    from: string,\n   257→    to: string,\n   258→    subject: string,\n   259→    payload: unknown,\n   260→    timeout: number = 30000\n   261→  ): Promise<AgentMessage> {\n   262→    const correlationId = this.generateMessageId();\n   263→    const message: AgentMessage = {\n   264→      id: this.generateMessageId(),\n   265→      type: MessageType.REQUEST,\n   266→      from,\n   267→      to,\n   268→      subject,\n   269→      payload,\n   270→      priority: MessagePriority.NORMAL,\n   271→      timestamp: new Date(),\n   272→      correlationId,\n   273→      ttl: this.config.defaultTtl,\n   274→    };\n   275→\n   276→    // Create promise for response\n   277→    return new Promise((resolve, reject) => {\n   278→      const timeoutHandle = setTimeout(() => {\n   279→        this.pendingRequests.delete(correlationId);\n   280→        reject(new AgentError(`Request timeout: ${message.id}`, from));\n   281→      }, timeout);\n   282→\n   283→      this.pendingRequests.set(correlationId, {\n   284→        resolve,\n   285→        reject,\n   286→        timeout: timeoutHandle,\n   287→      });\n   288→\n   289→      // Send request\n   290→      this.send(message).catch((error) => {\n   291→        this.pendingRequests.delete(correlationId);\n   292→        clearTimeout(timeoutHandle);\n   293→        reject(error);\n   294→      });\n   295→    });\n   296→  }\n   297→\n   298→  /**\n   299→   * Send a response to a request\n   300→   *\n   301→   * @param from - Sender agent ID\n   302→   * @param to - Recipient agent ID\n   303→   * @param subject - Message subject\n   304→   * @param payload - Message payload\n   305→   * @param correlationId - Correlation ID from original request\n   306→   */\n   307→  async respond(\n   308→    from: string,\n   309→    to: string,\n   310→    subject: string,\n   311→    payload: unknown,\n   312→    correlationId: string\n   313→  ): Promise<void> {\n   314→    const message: AgentMessage = {\n   315→      id: this.generateMessageId(),\n   316→      type: MessageType.RESPONSE,\n   317→      from,\n   318→      to,\n   319→      subject,\n   320→      payload,\n   321→      priority: MessagePriority.NORMAL,\n   322→      timestamp: new Date(),\n   323→      correlationId,\n   324→      ttl: this.config.defaultTtl,\n   325→    };\n   326→\n   327→    await this.send(message);\n   328→  }\n   329→\n   330→  /**\n   331→   * Send a notification (no response expected)\n   332→   *\n   333→   * @param from - Sender agent ID\n   334→   * @param to - Recipient agent ID\n   335→   * @param subject - Message subject\n   336→   * @param payload - Message payload\n   337→   * @param priority - Message priority\n   338→   */\n   339→  async notify(\n   340→    from: string,\n   341→    to: string,\n   342→    subject: string,\n   343→    payload: unknown,\n   344→    priority: MessagePriority = MessagePriority.NORMAL\n   345→  ): Promise<void> {\n   346→    const message: AgentMessage = {\n   347→      id: this.generateMessageId(),\n   348→      type: MessageType.NOTIFICATION,\n   349→      from,\n   350→      to,\n   351→      subject,\n   352→      payload,\n   353→      priority,\n   354→      timestamp: new Date(),\n   355→      ttl: this.config.defaultTtl,\n   356→    };\n   357→\n   358→    await this.send(message);\n   359→  }\n   360→\n   361→  /**\n   362→   * Broadcast a message to all agents\n   363→   *\n   364→   * @param from - Sender agent ID\n   365→   * @param subject - Message subject\n   366→   * @param payload - Message payload\n   367→   * @param priority - Message priority\n   368→   */\n   369→  async broadcast(\n   370→    from: string,\n   371→    subject: string,\n   372→    payload: unknown,\n   373→    priority: MessagePriority = MessagePriority.NORMAL\n   374→  ): Promise<void> {\n   375→    const message: AgentMessage = {\n   376→      id: this.generateMessageId(),\n   377→      type: MessageType.BROADCAST,\n   378→      from,\n   379→      subject,\n   380→      payload,\n   381→      priority,\n   382→      timestamp: new Date(),\n   383→      ttl: this.config.defaultTtl,\n   384→    };\n   385→\n   386→    // Add to history\n   387→    this.addToHistory(message);\n   388→\n   389→    // Deliver to all handlers\n   390→    for (const [agentId, handlers] of this.messageHandlers.entries()) {\n   391→      // Skip sender\n   392→      if (agentId === from) continue;\n   393→\n   394→      // Apply filters\n   395→      const filters = this.getFilters(agentId);\n   396→      const shouldProcess = filters.every((filter) => filter(message));\n   397→\n   398→      if (!shouldProcess) continue;\n   399→\n   400→      // Deliver message to handlers\n   401→      for (const handler of handlers) {\n   402→        try {\n   403→          await handler(message);\n   404→        } catch (error) {\n   405→          this.logger.error(\n   406→            `Broadcast handler error: ${message.id}`,\n   407→            'AgentCommunicationManager',\n   408→            { error: (error as Error).message }\n   409→          );\n   410→        }\n   411→      }\n   412→    }\n   413→\n   414→    this.logger.debug(\n   415→      `Message broadcast: ${message.id} from ${message.from}`,\n   416→      'AgentCommunicationManager'\n   417→    );\n   418→  }\n   419→\n   420→  /**\n   421→   * Register a message handler for an agent\n   422→   *\n   423→   * @param agentId - Agent ID to register handler for\n   424→   * @param handler - Message handler function\n   425→   */\n   426→  registerHandler(agentId: string, handler: MessageHandler): void {\n   427→    if (!this.messageHandlers.has(agentId)) {\n   428→      this.messageHandlers.set(agentId, []);\n   429→    }\n   430→    this.messageHandlers.get(agentId)!.push(handler);\n   431→\n   432→    this.logger.debug(\n   433→      `Message handler registered for agent: ${agentId}`,\n   434→      'AgentCommunicationManager'\n   435→    );\n   436→  }\n   437→\n   438→  /**\n   439→   * Unregister a message handler for an agent\n   440→   *\n   441→   * @param agentId - Agent ID to unregister handler for\n   442→   * @param handler - Message handler function to remove\n   443→   */\n   444→  unregisterHandler(agentId: string, handler: MessageHandler): void {\n   445→    const handlers = this.messageHandlers.get(agentId);\n   446→    if (handlers) {\n   447→      const index = handlers.indexOf(handler);\n   448→      if (index > -1) {\n   449→        handlers.splice(index, 1);\n   450→      }\n   451→    }\n   452→  }\n   453→\n   454→  /**\n   455→   * Register a message filter for an agent\n   456→   *\n   457→   * @param agentId - Agent ID to register filter for\n   458→   * @param filter - Message filter function\n   459→   */\n   460→  registerFilter(agentId: string, filter: MessageFilter): void {\n   461→    if (!this.messageFilters.has(agentId)) {\n   462→      this.messageFilters.set(agentId, []);\n   463→    }\n   464→    this.messageFilters.get(agentId)!.push(filter);\n   465→\n   466→    this.logger.debug(\n   467→      `Message filter registered for agent: ${agentId}`,\n   468→      'AgentCommunicationManager'\n   469→    );\n   470→  }\n   471→\n   472→  /**\n   473→   * Unregister a message filter for an agent\n   474→   *\n   475→   * @param agentId - Agent ID to unregister filter for\n   476→   * @param filter - Message filter function to remove\n   477→   */\n   478→  unregisterFilter(agentId: string, filter: MessageFilter): void {\n   479→    const filters = this.messageFilters.get(agentId);\n   480→    if (filters) {\n   481→      const index = filters.indexOf(filter);\n   482→      if (index > -1) {\n   483→        filters.splice(index, 1);\n   484→      }\n   485→    }\n   486→  }\n   487→\n   488→  /**\n   489→   * Get message history\n   490→   *\n   491→   * @param agentId - Optional agent ID to filter by\n   492→   * @param limit - Maximum number of messages to return\n   493→   * @returns Array of messages\n   494→   */\n   495→  getHistory(agentId?: string, limit?: number): AgentMessage[] {\n   496→    let messages = this.messageHistory;\n   497→\n   498→    if (agentId) {\n   499→      messages = messages.filter(\n   500→        (msg) => msg.from === agentId || msg.to === agentId\n   501→      );\n   502→    }\n   503→\n   504→    if (limit) {\n   505→      messages = messages.slice(-limit);\n   506→    }\n   507→\n   508→    return messages;\n   509→  }\n   510→\n   511→  /**\n   512→   * Clear message history\n   513→   */\n   514→  clearHistory(): void {\n   515→    this.messageHistory = [];\n   516→    this.logger.info('Message history cleared', 'AgentCommunicationManager');\n   517→  }\n   518→\n   519→  /**\n   520→   * Handle response message\n   521→   *\n   522→   * @param message - Response message\n   523→   */\n   524→  private handleResponse(message: AgentMessage): void {\n   525→    if (message.correlationId && this.pendingRequests.has(message.correlationId)) {\n   526→      const pending = this.pendingRequests.get(message.correlationId)!;\n   527→      clearTimeout(pending.timeout);\n   528→      this.pendingRequests.delete(message.correlationId);\n   529→      pending.resolve(message);\n   530→    }\n   531→  }\n   532→\n   533→  /**\n   534→   * Get handlers for an agent\n   535→   *\n   536→   * @param agentId - Agent ID to get handlers for\n   537→   * @returns Array of message handlers\n   538→   */\n   539→  private getHandlers(agentId?: string): MessageHandler[] {\n   540→    if (!agentId) return [];\n   541→\n   542→    const handlers = this.messageHandlers.get(agentId);\n   543→    return handlers ? [...handlers] : [];\n   544→  }\n   545→\n   546→  /**\n   547→   * Get filters for an agent\n   548→   *\n   549→   * @param agentId - Agent ID to get filters for\n   550→   * @returns Array of message filters\n   551→   */\n   552→  private getFilters(agentId?: string): MessageFilter[] {\n   553→    if (!agentId) return [];\n   554→\n   555→    const filters = this.messageFilters.get(agentId);\n   556→    return filters ? [...filters] : [];\n   557→  }\n   558→\n   559→  /**\n   560→   * Add message to history\n   561→   *\n   562→   * @param message - Message to add\n   563→   */\n   564→  private addToHistory(message: AgentMessage): void {\n   565→    this.messageHistory.push(message);\n   566→\n   567→    // Trim history if exceeds max size\n   568→    if (this.messageHistory.length > this.config.maxQueueSize) {\n   569→      this.messageHistory.shift();\n   570→    }\n   571→  }\n   572→\n   573→  /**\n   574→   * Validate message\n   575→   *\n   576→   * @param message - Message to validate\n   577→   * @throws AgentError if validation fails\n   578→   */\n   579→  private validateMessage(message: AgentMessage): void {\n   580→    if (!message.id || message.id.trim() === '') {\n   581→      throw new AgentError('Message ID is required', 'communication');\n   582→    }\n   583→\n   584→    if (!message.from || message.from.trim() === '') {\n   585→      throw new AgentError('Message sender is required', 'communication');\n   586→    }\n   587→\n   588→    if (!message.subject || message.subject.trim() === '') {\n   589→      throw new AgentError('Message subject is required', 'communication');\n   590→    }\n   591→\n   592→    if (message.type === MessageType.REQUEST && !message.to) {\n   593→      throw new AgentError('Request message must have a recipient', 'communication');\n   594→    }\n   595→  }\n   596→\n   597→  /**\n   598→   * Generate unique message ID\n   599→   *\n   600→   * @returns Unique message ID\n   601→   */\n   602→  private generateMessageId(): string {\n   603→    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   604→  }\n   605→\n   606→  /**\n   607→   * Clear all handlers and filters\n   608→   */\n   609→  clear(): void {\n   610→    this.messageHandlers.clear();\n   611→    this.messageFilters.clear();\n   612→    this.pendingRequests.forEach((pending) => {\n   613→      clearTimeout(pending.timeout);\n   614→    });\n   615→    this.pendingRequests.clear();\n   616→    this.messageHistory = [];\n   617→    this.logger.info('AgentCommunicationManager cleared', 'AgentCommunicationManager');\n   618→  }\n   619→}\n   620→\n   621→/**\n   622→ * Global agent communication manager instance\n   623→ */\n   624→let globalAgentCommunicationManager: AgentCommunicationManager | null = null;\n   625→\n   626→/**\n   627→ * Initialize global agent communication manager\n   628→ *\n   629→ * @param config - Communication channel configuration\n   630→ * @param logger - Optional logger instance\n   631→ * @returns The global agent communication manager\n   632→ */\n   633→export function initAgentCommunicationManager(\n   634→  config?: CommunicationChannelConfig,\n   635→  logger?: Logger\n   636→): AgentCommunicationManager {\n   637→  globalAgentCommunicationManager = new AgentCommunicationManager(config, logger);\n   638→  return globalAgentCommunicationManager;\n   639→}\n   640→\n   641→/**\n   642→ * Get global agent communication manager\n   643→ *\n   644→ * @returns The global agent communication manager\n   645→ */\n   646→export function getAgentCommunicationManager(): AgentCommunicationManager {\n   647→  if (!globalAgentCommunicationManager) {\n   648→    globalAgentCommunicationManager = new AgentCommunicationManager();\n   649→  }\n   650→  return globalAgentCommunicationManager;\n   651→}\n   652→\n\n</system-reminder>\n"}]},"uuid":"99e17028-5a61-4fe4-9f04-6b092094e9ce","timestamp":"2026-01-12T06:23:19.454Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/communication.ts","content":"/**\n * Agent Communication for KOMPLETE-KONTROL CLI\n *\n * Provides message passing and communication capabilities between agents.\n * Follows patterns from agent-swarm-kit with simplified architecture.\n */\n\nimport { AgentError } from '../../types';\nimport { Logger } from '../../utils/logger';\n\n/**\n * Message types\n */\nexport enum MessageType {\n  /**\n   * Request message (expects response)\n   */\n  REQUEST = 'request',\n  /**\n   * Response message\n   */\n  RESPONSE = 'response',\n  /**\n   * Notification message (no response expected)\n   */\n  NOTIFICATION = 'notification',\n  /**\n   * Broadcast message (sent to all agents)\n   */\n  BROADCAST = 'broadcast',\n}\n\n/**\n * Message priority\n */\nexport enum MessagePriority {\n  /**\n   * Low priority message\n   */\n  LOW = 0,\n  /**\n   * Normal priority message\n   */\n  NORMAL = 1,\n  /**\n   * High priority message\n   */\n  HIGH = 2,\n  /**\n   * Critical priority message\n   */\n  CRITICAL = 3,\n}\n\n/**\n * Agent message\n */\nexport interface AgentMessage {\n  /**\n   * Message ID\n   */\n  id: string;\n  /**\n   * Message type\n   */\n  type: MessageType;\n  /**\n   * Sender agent ID\n   */\n  from: string;\n  /**\n   * Recipient agent ID (undefined for broadcast)\n   */\n  to?: string;\n  /**\n   * Message subject\n   */\n  subject: string;\n  /**\n   * Message payload\n   */\n  payload: unknown;\n  /**\n   * Message priority\n   */\n  priority: MessagePriority;\n  /**\n   * Message timestamp\n   */\n  timestamp: Date;\n  /**\n   * Correlation ID for request-response pattern\n   */\n  correlationId?: string;\n  /**\n   * Reply-to agent ID\n   */\n  replyTo?: string;\n  /**\n   * TTL (time to live) in milliseconds\n   */\n  ttl?: number;\n  /**\n   * Message metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Message handler function\n */\nexport type MessageHandler = (message: AgentMessage) => void | Promise<void>;\n\n/**\n * Message filter function\n */\nexport type MessageFilter = (message: AgentMessage) => boolean;\n\n/**\n * Pending request\n */\ninterface PendingRequest {\n  resolve: (value: AgentMessage) => void;\n  reject: (error: Error) => void;\n  timeout: NodeJS.Timeout;\n}\n\n/**\n * Communication channel configuration\n */\nexport interface CommunicationChannelConfig {\n  /**\n   * Channel name\n   */\n  name: string;\n  /**\n   * Message TTL in milliseconds\n   */\n  defaultTtl?: number;\n  /**\n   * Maximum message queue size\n   */\n  maxQueueSize?: number;\n  /**\n   * Enable message persistence\n   */\n  enablePersistence?: boolean;\n}\n\n/**\n * Agent Communication Manager class\n *\n * Provides message passing and communication capabilities between agents.\n * Supports request-response pattern, notifications, and broadcasting.\n */\nexport class AgentCommunicationManager {\n  private messageHandlers: Map<string, MessageHandler[]> = new Map();\n  private messageFilters: Map<string, MessageFilter[]> = new Map();\n  private pendingRequests: Map<string, PendingRequest> = new Map();\n  private messageHistory: AgentMessage[] = [];\n  private logger: Logger;\n  private config: Required<CommunicationChannelConfig>;\n\n  constructor(\n    config: CommunicationChannelConfig = { name: 'default' },\n    logger?: Logger\n  ) {\n    this.logger = logger || new Logger();\n    this.config = {\n      name: config.name,\n      defaultTtl: config.defaultTtl ?? 60000,\n      maxQueueSize: config.maxQueueSize ?? 1000,\n      enablePersistence: config.enablePersistence ?? false,\n    };\n    this.logger.info(\n      `AgentCommunicationManager initialized: ${this.config.name}`,\n      'AgentCommunicationManager'\n    );\n  }\n\n  /**\n   * Send a message to an agent\n   *\n   * @param message - Message to send\n   * @throws AgentError if message validation fails\n   */\n  async send(message: AgentMessage): Promise<void> {\n    this.validateMessage(message);\n\n    // Handle response messages\n    if (message.type === MessageType.RESPONSE) {\n      this.handleResponse(message);\n      return;\n    }\n\n    // Check TTL\n    if (message.ttl && Date.now() - message.timestamp.getTime() > message.ttl) {\n      this.logger.warn(`Message expired: ${message.id}`, 'AgentCommunicationManager');\n      return;\n    }\n\n    // Add to history\n    this.addToHistory(message);\n\n    // Find handlers for recipient\n    const handlers = this.getHandlers(message.to);\n\n    if (handlers.length === 0) {\n      this.logger.warn(\n        `No handlers found for recipient: ${message.to}`,\n        'AgentCommunicationManager'\n      );\n      return;\n    }\n\n    // Apply filters\n    const filters = this.getFilters(message.to);\n    const shouldProcess = filters.every((filter) => filter(message));\n\n    if (!shouldProcess) {\n      this.logger.debug(`Message filtered out: ${message.id}`, 'AgentCommunicationManager');\n      return;\n    }\n\n    // Deliver message to handlers\n    for (const handler of handlers) {\n      try {\n        await handler(message);\n      } catch (error) {\n        this.logger.error(\n          `Message handler error: ${message.id}`,\n          'AgentCommunicationManager',\n          { error: (error as Error).message }\n        );\n      }\n    }\n\n    this.logger.debug(\n      `Message sent: ${message.id} from ${message.from} to ${message.to}`,\n      'AgentCommunicationManager'\n    );\n  }\n\n  /**\n   * Send a request and wait for response\n   *\n   * @param from - Sender agent ID\n   * @param to - Recipient agent ID\n   * @param subject - Message subject\n   * @param payload - Message payload\n   * @param timeout - Request timeout in milliseconds\n   * @returns Response message\n   * @throws AgentError if request times out or fails\n   */\n  async request(\n    from: string,\n    to: string,\n    subject: string,\n    payload: unknown,\n    timeout: number = 30000\n  ): Promise<AgentMessage> {\n    const correlationId = this.generateMessageId();\n    const message: AgentMessage = {\n      id: this.generateMessageId(),\n      type: MessageType.REQUEST,\n      from,\n      to,\n      subject,\n      payload,\n      priority: MessagePriority.NORMAL,\n      timestamp: new Date(),\n      correlationId,\n      ttl: this.config.defaultTtl,\n    };\n\n    // Create promise for response\n    return new Promise((resolve, reject) => {\n      const timeoutHandle = setTimeout(() => {\n        this.pendingRequests.delete(correlationId);\n        reject(new AgentError(`Request timeout: ${message.id}`, from));\n      }, timeout);\n\n      this.pendingRequests.set(correlationId, {\n        resolve,\n        reject,\n        timeout: timeoutHandle,\n      });\n\n      // Send request\n      this.send(message).catch((error) => {\n        this.pendingRequests.delete(correlationId);\n        clearTimeout(timeoutHandle);\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Send a response to a request\n   *\n   * @param from - Sender agent ID\n   * @param to - Recipient agent ID\n   * @param subject - Message subject\n   * @param payload - Message payload\n   * @param correlationId - Correlation ID from original request\n   */\n  async respond(\n    from: string,\n    to: string,\n    subject: string,\n    payload: unknown,\n    correlationId: string\n  ): Promise<void> {\n    const message: AgentMessage = {\n      id: this.generateMessageId(),\n      type: MessageType.RESPONSE,\n      from,\n      to,\n      subject,\n      payload,\n      priority: MessagePriority.NORMAL,\n      timestamp: new Date(),\n      correlationId,\n      ttl: this.config.defaultTtl,\n    };\n\n    await this.send(message);\n  }\n\n  /**\n   * Send a notification (no response expected)\n   *\n   * @param from - Sender agent ID\n   * @param to - Recipient agent ID\n   * @param subject - Message subject\n   * @param payload - Message payload\n   * @param priority - Message priority\n   */\n  async notify(\n    from: string,\n    to: string,\n    subject: string,\n    payload: unknown,\n    priority: MessagePriority = MessagePriority.NORMAL\n  ): Promise<void> {\n    const message: AgentMessage = {\n      id: this.generateMessageId(),\n      type: MessageType.NOTIFICATION,\n      from,\n      to,\n      subject,\n      payload,\n      priority,\n      timestamp: new Date(),\n      ttl: this.config.defaultTtl,\n    };\n\n    await this.send(message);\n  }\n\n  /**\n   * Broadcast a message to all agents\n   *\n   * @param from - Sender agent ID\n   * @param subject - Message subject\n   * @param payload - Message payload\n   * @param priority - Message priority\n   */\n  async broadcast(\n    from: string,\n    subject: string,\n    payload: unknown,\n    priority: MessagePriority = MessagePriority.NORMAL\n  ): Promise<void> {\n    const message: AgentMessage = {\n      id: this.generateMessageId(),\n      type: MessageType.BROADCAST,\n      from,\n      subject,\n      payload,\n      priority,\n      timestamp: new Date(),\n      ttl: this.config.defaultTtl,\n    };\n\n    // Add to history\n    this.addToHistory(message);\n\n    // Deliver to all handlers\n    for (const [agentId, handlers] of this.messageHandlers.entries()) {\n      // Skip sender\n      if (agentId === from) continue;\n\n      // Apply filters\n      const filters = this.getFilters(agentId);\n      const shouldProcess = filters.every((filter) => filter(message));\n\n      if (!shouldProcess) continue;\n\n      // Deliver message to handlers\n      for (const handler of handlers) {\n        try {\n          await handler(message);\n        } catch (error) {\n          this.logger.error(\n            `Broadcast handler error: ${message.id}`,\n            'AgentCommunicationManager',\n            { error: (error as Error).message }\n          );\n        }\n      }\n    }\n\n    this.logger.debug(\n      `Message broadcast: ${message.id} from ${message.from}`,\n      'AgentCommunicationManager'\n    );\n  }\n\n  /**\n   * Register a message handler for an agent\n   *\n   * @param agentId - Agent ID to register handler for\n   * @param handler - Message handler function\n   */\n  registerHandler(agentId: string, handler: MessageHandler): void {\n    if (!this.messageHandlers.has(agentId)) {\n      this.messageHandlers.set(agentId, []);\n    }\n    this.messageHandlers.get(agentId)!.push(handler);\n\n    this.logger.debug(\n      `Message handler registered for agent: ${agentId}`,\n      'AgentCommunicationManager'\n    );\n  }\n\n  /**\n   * Unregister a message handler for an agent\n   *\n   * @param agentId - Agent ID to unregister handler for\n   * @param handler - Message handler function to remove\n   */\n  unregisterHandler(agentId: string, handler: MessageHandler): void {\n    const handlers = this.messageHandlers.get(agentId);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Register a message filter for an agent\n   *\n   * @param agentId - Agent ID to register filter for\n   * @param filter - Message filter function\n   */\n  registerFilter(agentId: string, filter: MessageFilter): void {\n    if (!this.messageFilters.has(agentId)) {\n      this.messageFilters.set(agentId, []);\n    }\n    this.messageFilters.get(agentId)!.push(filter);\n\n    this.logger.debug(\n      `Message filter registered for agent: ${agentId}`,\n      'AgentCommunicationManager'\n    );\n  }\n\n  /**\n   * Unregister a message filter for an agent\n   *\n   * @param agentId - Agent ID to unregister filter for\n   * @param filter - Message filter function to remove\n   */\n  unregisterFilter(agentId: string, filter: MessageFilter): void {\n    const filters = this.messageFilters.get(agentId);\n    if (filters) {\n      const index = filters.indexOf(filter);\n      if (index > -1) {\n        filters.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Get message history\n   *\n   * @param agentId - Optional agent ID to filter by\n   * @param limit - Maximum number of messages to return\n   * @returns Array of messages\n   */\n  getHistory(agentId?: string, limit?: number): AgentMessage[] {\n    let messages = this.messageHistory;\n\n    if (agentId) {\n      messages = messages.filter(\n        (msg) => msg.from === agentId || msg.to === agentId\n      );\n    }\n\n    if (limit) {\n      messages = messages.slice(-limit);\n    }\n\n    return messages;\n  }\n\n  /**\n   * Clear message history\n   */\n  clearHistory(): void {\n    this.messageHistory = [];\n    this.logger.info('Message history cleared', 'AgentCommunicationManager');\n  }\n\n  /**\n   * Handle response message\n   *\n   * @param message - Response message\n   */\n  private handleResponse(message: AgentMessage): void {\n    if (message.correlationId && this.pendingRequests.has(message.correlationId)) {\n      const pending = this.pendingRequests.get(message.correlationId)!;\n      clearTimeout(pending.timeout);\n      this.pendingRequests.delete(message.correlationId);\n      pending.resolve(message);\n    }\n  }\n\n  /**\n   * Get handlers for an agent\n   *\n   * @param agentId - Agent ID to get handlers for\n   * @returns Array of message handlers\n   */\n  private getHandlers(agentId?: string): MessageHandler[] {\n    if (!agentId) return [];\n\n    const handlers = this.messageHandlers.get(agentId);\n    return handlers ? [...handlers] : [];\n  }\n\n  /**\n   * Get filters for an agent\n   *\n   * @param agentId - Agent ID to get filters for\n   * @returns Array of message filters\n   */\n  private getFilters(agentId?: string): MessageFilter[] {\n    if (!agentId) return [];\n\n    const filters = this.messageFilters.get(agentId);\n    return filters ? [...filters] : [];\n  }\n\n  /**\n   * Add message to history\n   *\n   * @param message - Message to add\n   */\n  private addToHistory(message: AgentMessage): void {\n    this.messageHistory.push(message);\n\n    // Trim history if exceeds max size\n    if (this.messageHistory.length > this.config.maxQueueSize) {\n      this.messageHistory.shift();\n    }\n  }\n\n  /**\n   * Validate message\n   *\n   * @param message - Message to validate\n   * @throws AgentError if validation fails\n   */\n  private validateMessage(message: AgentMessage): void {\n    if (!message.id || message.id.trim() === '') {\n      throw new AgentError('Message ID is required', 'communication');\n    }\n\n    if (!message.from || message.from.trim() === '') {\n      throw new AgentError('Message sender is required', 'communication');\n    }\n\n    if (!message.subject || message.subject.trim() === '') {\n      throw new AgentError('Message subject is required', 'communication');\n    }\n\n    if (message.type === MessageType.REQUEST && !message.to) {\n      throw new AgentError('Request message must have a recipient', 'communication');\n    }\n  }\n\n  /**\n   * Generate unique message ID\n   *\n   * @returns Unique message ID\n   */\n  private generateMessageId(): string {\n    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Clear all handlers and filters\n   */\n  clear(): void {\n    this.messageHandlers.clear();\n    this.messageFilters.clear();\n    this.pendingRequests.forEach((pending) => {\n      clearTimeout(pending.timeout);\n    });\n    this.pendingRequests.clear();\n    this.messageHistory = [];\n    this.logger.info('AgentCommunicationManager cleared', 'AgentCommunicationManager');\n  }\n}\n\n/**\n * Global agent communication manager instance\n */\nlet globalAgentCommunicationManager: AgentCommunicationManager | null = null;\n\n/**\n * Initialize global agent communication manager\n *\n * @param config - Communication channel configuration\n * @param logger - Optional logger instance\n * @returns The global agent communication manager\n */\nexport function initAgentCommunicationManager(\n  config?: CommunicationChannelConfig,\n  logger?: Logger\n): AgentCommunicationManager {\n  globalAgentCommunicationManager = new AgentCommunicationManager(config, logger);\n  return globalAgentCommunicationManager;\n}\n\n/**\n * Get global agent communication manager\n *\n * @returns The global agent communication manager\n */\nexport function getAgentCommunicationManager(): AgentCommunicationManager {\n  if (!globalAgentCommunicationManager) {\n    globalAgentCommunicationManager = new AgentCommunicationManager();\n  }\n  return globalAgentCommunicationManager;\n}\n","numLines":652,"startLine":1,"totalLines":652}}}
{"parentUuid":"99e17028-5a61-4fe4-9f04-6b092094e9ce","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V4EByyH3hVXApqJTfojjgi","type":"tool_result","content":"     1→/**\n     2→ * Agent Coordination for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Provides coordination primitives including task queues, state sharing,\n     5→ * and synchronization mechanisms for multi-agent systems.\n     6→ * Follows patterns from agent-swarm-kit with simplified architecture.\n     7→ */\n     8→\n     9→import { AgentError } from '../../types';\n    10→import { Logger } from '../../utils/logger';\n    11→\n    12→/**\n    13→ * Task queue priority\n    14→ */\n    15→export enum QueuePriority {\n    16→  /**\n    17→   * Low priority\n    18→   */\n    19→  LOW = 0,\n    20→  /**\n    21→   * Normal priority\n    22→   */\n    23→  NORMAL = 1,\n    24→  /**\n    25→   * High priority\n    26→   */\n    27→  HIGH = 2,\n    28→  /**\n    29→   * Critical priority\n    30→   */\n    31→  CRITICAL = 3,\n    32→}\n    33→\n    34→/**\n    35→ * Queue item\n    36→ */\n    37→export interface QueueItem<T> {\n    38→  /**\n    39→   * Item ID\n    40→   */\n    41→  id: string;\n    42→  /**\n    43→   * Item data\n    44→   */\n    45→  data: T;\n    46→  /**\n    47→   * Item priority\n    48→   */\n    49→  priority: QueuePriority;\n    50→  /**\n    51→   * Item creation time\n    52→   */\n    53→  createdAt: Date;\n    54→  /**\n    55→   * Item metadata\n    56→   */\n    57→  metadata?: Record<string, unknown>;\n    58→}\n    59→\n    60→/**\n    61→ * Queue statistics\n    62→ */\n    63→export interface QueueStatistics {\n    64→  /**\n    65→   * Total items in queue\n    66→   */\n    67→  totalItems: number;\n    68→  /**\n    69→   * Number of items by priority\n    70→   */\n    71→  itemsByPriority: Record<QueuePriority, number>;\n    72→  /**\n    73→   * Number of processed items\n    74→   */\n    75→  processedItems: number;\n    76→  /**\n    77→   * Number of failed items\n    78→   */\n    79→  failedItems: number;\n    80→}\n    81→\n    82→/**\n    83→ * Task queue configuration\n    84→ */\n    85→export interface TaskQueueConfig {\n    86→  /**\n    87→   * Maximum queue size\n    88→   */\n    89→  maxSize?: number;\n    90→  /**\n    91→   * Enable priority queue\n    92→   */\n    93→  enablePriority?: boolean;\n    94→  /**\n    95→   * Queue name\n    96→   */\n    97→  name?: string;\n    98→}\n    99→\n   100→/**\n   101→ * Task Queue class\n   102→ *\n   103→ * Provides a priority-based task queue for agent coordination.\n   104→ */\n   105→export class TaskQueue<T> {\n   106→  private queue: QueueItem<T>[] = [];\n   107→  private processedCount: number = 0;\n   108→  private failedCount: number = 0;\n   109→  private logger: Logger;\n   110→  private config: Required<TaskQueueConfig>;\n   111→\n   112→  constructor(config: TaskQueueConfig = {}, logger?: Logger) {\n   113→    this.logger = logger || new Logger();\n   114→    this.config = {\n   115→      maxSize: config.maxSize ?? 1000,\n   116→      enablePriority: config.enablePriority ?? true,\n   117→      name: config.name ?? 'default',\n   118→    };\n   119→    this.logger.info(\n   120→      `TaskQueue initialized: ${this.config.name}`,\n   121→      'TaskQueue'\n   122→    );\n   123→  }\n   124→\n   125→  /**\n   126→   * Add an item to the queue\n   127→   *\n   128→   * @param data - Item data\n   129→   * @param priority - Item priority\n   130→   * @param metadata - Optional metadata\n   131→   * @returns Item ID\n   132→   * @throws AgentError if queue is full\n   133→   */\n   134→  enqueue(data: T, priority: QueuePriority = QueuePriority.NORMAL, metadata?: Record<string, unknown>): string {\n   135→    if (this.queue.length >= this.config.maxSize) {\n   136→      throw new AgentError(`Queue '${this.config.name}' is full`, this.config.name);\n   137→    }\n   138→\n   139→    const item: QueueItem<T> = {\n   140→      id: this.generateItemId(),\n   141→      data,\n   142→      priority,\n   143→      createdAt: new Date(),\n   144→      metadata,\n   145→    };\n   146→\n   147→    this.queue.push(item);\n   148→\n   149→    // Sort by priority if enabled\n   150→    if (this.config.enablePriority) {\n   151→      this.queue.sort((a, b) => {\n   152→        const priorityDiff = b.priority - a.priority;\n   153→        if (priorityDiff !== 0) return priorityDiff;\n   154→        return a.createdAt.getTime() - b.createdAt.getTime();\n   155→      });\n   156→    }\n   157→\n   158→    this.logger.debug(\n   159→      `Item enqueued: ${item.id}`,\n   160→      'TaskQueue',\n   161→      { priority, queueSize: this.queue.length }\n   162→    );\n   163→\n   164→    return item.id;\n   165→  }\n   166→\n   167→  /**\n   168→   * Remove and return the next item from the queue\n   169→   *\n   170→   * @returns Queue item or undefined if queue is empty\n   171→   */\n   172→  dequeue(): QueueItem<T> | undefined {\n   173→    const item = this.queue.shift();\n   174→\n   175→    if (item) {\n   176→      this.processedCount++;\n   177→      this.logger.debug(\n   178→        `Item dequeued: ${item.id}`,\n   179→        'TaskQueue',\n   180→        { priority: item.priority, queueSize: this.queue.length }\n   181→      );\n   182→    }\n   183→\n   184→    return item;\n   185→  }\n   186→\n   187→  /**\n   188→   * Peek at the next item without removing it\n   189→   *\n   190→   * @returns Queue item or undefined if queue is empty\n   191→   */\n   192→  peek(): QueueItem<T> | undefined {\n   193→    return this.queue[0];\n   194→  }\n   195→\n   196→  /**\n   197→   * Remove an item by ID\n   198→   *\n   199→   * @param itemId - Item ID to remove\n   200→   * @returns True if item was removed, false if not found\n   201→   */\n   202→  remove(itemId: string): boolean {\n   203→    const index = this.queue.findIndex((item) => item.id === itemId);\n   204→\n   205→    if (index > -1) {\n   206→      this.queue.splice(index, 1);\n   207→      this.logger.debug(`Item removed: ${itemId}`, 'TaskQueue');\n   208→      return true;\n   209→    }\n   210→\n   211→    return false;\n   212→  }\n   213→\n   214→  /**\n   215→   * Get an item by ID\n   216→   *\n   217→   * @param itemId - Item ID to get\n   218→   * @returns Queue item or undefined if not found\n   219→   */\n   220→  get(itemId: string): QueueItem<T> | undefined {\n   221→    return this.queue.find((item) => item.id === itemId);\n   222→  }\n   223→\n   224→  /**\n   225→   * Get all items\n   226→   *\n   227→   * @returns Array of queue items\n   228→   */\n   229→  getAll(): QueueItem<T>[] {\n   230→    return [...this.queue];\n   231→  }\n   232→\n   233→  /**\n   234→   * Get queue size\n   235→   *\n   236→   * @returns Number of items in queue\n   237→   */\n   238→  size(): number {\n   239→    return this.queue.length;\n   240→  }\n   241→\n   242→  /**\n   243→   * Check if queue is empty\n   244→   *\n   245→   * @returns True if queue is empty\n   246→   */\n   247→  isEmpty(): boolean {\n   248→    return this.queue.length === 0;\n   249→  }\n   250→\n   251→  /**\n   252→   * Check if queue is full\n   253→   *\n   254→   * @returns True if queue is full\n   255→   */\n   256→  isFull(): boolean {\n   257→    return this.queue.length >= this.config.maxSize;\n   258→  }\n   259→\n   260→  /**\n   261→   * Mark an item as failed\n   262→   *\n   263→   * @param itemId - Item ID to mark as failed\n   264→   * @returns True if item was marked as failed, false if not found\n   265→   */\n   266→  markFailed(itemId: string): boolean {\n   267→    const index = this.queue.findIndex((item) => item.id === itemId);\n   268→\n   269→    if (index > -1) {\n   270→      this.queue.splice(index, 1);\n   271→      this.failedCount++;\n   272→      this.logger.debug(`Item marked as failed: ${itemId}`, 'TaskQueue');\n   273→      return true;\n   274→    }\n   275→\n   276→    return false;\n   277→  }\n   278→\n   279→  /**\n   280→   * Get queue statistics\n   281→   *\n   282→   * @returns Queue statistics\n   283→   */\n   284→  getStatistics(): QueueStatistics {\n   285→    const itemsByPriority: Record<QueuePriority, number> = {\n   286→      [QueuePriority.LOW]: 0,\n   287→      [QueuePriority.NORMAL]: 0,\n   288→      [QueuePriority.HIGH]: 0,\n   289→      [QueuePriority.CRITICAL]: 0,\n   290→    };\n   291→\n   292→    for (const item of this.queue) {\n   293→      itemsByPriority[item.priority]++;\n   294→    }\n   295→\n   296→    return {\n   297→      totalItems: this.queue.length,\n   298→      itemsByPriority,\n   299→      processedItems: this.processedCount,\n   300→      failedItems: this.failedCount,\n   301→    };\n   302→  }\n   303→\n   304→  /**\n   305→   * Clear the queue\n   306→   */\n   307→  clear(): void {\n   308→    this.queue = [];\n   309→    this.processedCount = 0;\n   310→    this.failedCount = 0;\n   311→    this.logger.info(`Queue cleared: ${this.config.name}`, 'TaskQueue');\n   312→  }\n   313→\n   314→  /**\n   315→   * Generate unique item ID\n   316→   *\n   317→   * @returns Unique item ID\n   318→   */\n   319→  private generateItemId(): string {\n   320→    return `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   321→  }\n   322→}\n   323→\n   324→/**\n   325→ * Shared state value\n   326→ */\n   327→interface StateValue<T> {\n   328→  value: T;\n   329→  version: number;\n   330→  updatedAt: Date;\n   331→  updatedBy?: string;\n   332→}\n   333→\n   334→/**\n   335→ * Shared state configuration\n   336→ */\n   337→export interface SharedStateConfig {\n   338→  /**\n   339→   * State name\n   340→   */\n   341→  name?: string;\n   342→  /**\n   343→   * Enable versioning\n   344→   */\n   345→  enableVersioning?: boolean;\n   346→  /**\n   347→   * Maximum history size\n   348→   */\n   349→  maxHistorySize?: number;\n   350→}\n   351→\n   352→/**\n   353→ * Shared State class\n   354→ *\n   355→ * Provides shared state management for agent coordination.\n   356→ */\n   357→export class SharedState {\n   358→  private state: Map<string, StateValue<unknown>> = new Map();\n   359→  private history: Array<{ key: string; value: StateValue<unknown> }> = [];\n   360→  private logger: Logger;\n   361→  private config: Required<SharedStateConfig>;\n   362→\n   363→  constructor(config: SharedStateConfig = {}, logger?: Logger) {\n   364→    this.logger = logger || new Logger();\n   365→    this.config = {\n   366→      name: config.name ?? 'default',\n   367→      enableVersioning: config.enableVersioning ?? true,\n   368→      maxHistorySize: config.maxHistorySize ?? 100,\n   369→    };\n   370→    this.logger.info(\n   371→      `SharedState initialized: ${this.config.name}`,\n   372→      'SharedState'\n   373→    );\n   374→  }\n   375→\n   376→  /**\n   377→   * Set a value in the shared state\n   378→   *\n   379→   * @param key - State key\n   380→   * @param value - State value\n   381→   * @param updatedBy - Optional agent ID that updated the value\n   382→   */\n   383→  set<T>(key: string, value: T, updatedBy?: string): void {\n   384→    const currentValue = this.state.get(key);\n   385→    const version = currentValue ? currentValue.version + 1 : 1;\n   386→\n   387→    const stateValue: StateValue<T> = {\n   388→      value,\n   389→      version,\n   390→      updatedAt: new Date(),\n   391→      updatedBy,\n   392→    };\n   393→\n   394→    // Add to history if versioning is enabled\n   395→    if (this.config.enableVersioning && currentValue) {\n   396→      this.history.push({ key, value: currentValue });\n   397→      this.trimHistory();\n   398→    }\n   399→\n   400→    this.state.set(key, stateValue as StateValue<unknown>);\n   401→\n   402→    this.logger.debug(\n   403→      `State set: ${key}`,\n   404→      'SharedState',\n   405→      { version, updatedBy }\n   406→    );\n   407→  }\n   408→\n   409→  /**\n   410→   * Get a value from the shared state\n   411→   *\n   412→   * @param key - State key\n   413→   * @param defaultValue - Default value if key doesn't exist\n   414→   * @returns State value or default value\n   415→   */\n   416→  get<T>(key: string, defaultValue?: T): T | undefined {\n   417→    const stateValue = this.state.get(key);\n   418→    return stateValue ? (stateValue.value as T) : defaultValue;\n   419→  }\n   420→\n   421→  /**\n   422→   * Get a value with version information\n   423→   *\n   424→   * @param key - State key\n   425→   * @returns State value with metadata or undefined\n   426→   */\n   427→  getWithVersion<T>(key: string): StateValue<T> | undefined {\n   428→    const stateValue = this.state.get(key);\n   429→    return stateValue as StateValue<T> | undefined;\n   430→  }\n   431→\n   432→  /**\n   433→   * Check if a key exists in the shared state\n   434→   *\n   435→   * @param key - State key\n   436→   * @returns True if key exists\n   437→   */\n   438→  has(key: string): boolean {\n   439→    return this.state.has(key);\n   440→  }\n   441→\n   442→  /**\n   443→   * Delete a value from the shared state\n   444→   *\n   445→   * @param key - State key\n   446→   * @returns True if key was deleted, false if not found\n   447→   */\n   448→  delete(key: string): boolean {\n   449→    const existed = this.state.has(key);\n   450→\n   451→    if (existed) {\n   452→      // Add to history before deleting\n   453→      if (this.config.enableVersioning) {\n   454→        const currentValue = this.state.get(key)!;\n   455→        this.history.push({ key, value: currentValue });\n   456→        this.trimHistory();\n   457→      }\n   458→\n   459→      this.state.delete(key);\n   460→      this.logger.debug(`State deleted: ${key}`, 'SharedState');\n   461→    }\n   462→\n   463→    return existed;\n   464→  }\n   465→\n   466→  /**\n   467→   * Get all keys in the shared state\n   468→   *\n   469→   * @returns Array of keys\n   470→   */\n   471→  keys(): string[] {\n   472→    return Array.from(this.state.keys());\n   473→  }\n   474→\n   475→  /**\n   476→   * Get all values in the shared state\n   477→   *\n   478→   * @returns Map of key to value\n   479→   */\n   480→  values(): Map<string, unknown> {\n   481→    const result = new Map<string, unknown>();\n   482→\n   483→    for (const [key, stateValue] of this.state.entries()) {\n   484→      result.set(key, stateValue.value);\n   485→    }\n   486→\n   487→    return result;\n   488→  }\n   489→\n   490→  /**\n   491→   * Get all entries in the shared state\n   492→   *\n   493→   * @returns Array of [key, value] tuples\n   494→   */\n   495→  entries(): Array<[string, unknown]> {\n   496→    const result: Array<[string, unknown]> = [];\n   497→\n   498→    for (const [key, stateValue] of this.state.entries()) {\n   499→      result.push([key, stateValue.value]);\n   500→    }\n   501→\n   502→    return result;\n   503→  }\n   504→\n   505→  /**\n   506→   * Get history for a key\n   507→   *\n   508→   * @param key - State key\n   509→   * @param limit - Maximum number of history entries\n   510→   * @returns Array of historical values\n   511→   */\n   512→  getHistory<T>(key: string, limit?: number): StateValue<T>[] {\n   513→    const keyHistory = this.history.filter((entry) => entry.key === key);\n   514→\n   515→    if (limit) {\n   516→      return keyHistory.slice(-limit).map((entry) => entry.value as StateValue<T>);\n   517→    }\n   518→\n   519→    return keyHistory.map((entry) => entry.value as StateValue<T>);\n   520→  }\n   521→\n   522→  /**\n   523→   * Clear the shared state\n   524→   */\n   525→  clear(): void {\n   526→    this.state.clear();\n   527→    this.history = [];\n   528→    this.logger.info(`SharedState cleared: ${this.config.name}`, 'SharedState');\n   529→  }\n   530→\n   531→  /**\n   532→   * Trim history to max size\n   533→   */\n   534→  private trimHistory(): void {\n   535→    if (this.history.length > this.config.maxHistorySize) {\n   536→      this.history = this.history.slice(-this.config.maxHistorySize);\n   537→    }\n   538→  }\n   539→}\n   540→\n   541→/**\n   542→ * Barrier configuration\n   543→ */\n   544→export interface BarrierConfig {\n   545→  /**\n   546→   * Barrier name\n   547→   */\n   548→  name?: string;\n   549→  /**\n   550→   * Timeout in milliseconds\n   551→   */\n   552→  timeout?: number;\n   553→}\n   554→\n   555→/**\n   556→ * Barrier class\n   557→ *\n   558→ * Provides a synchronization barrier for agent coordination.\n   559→ * Agents can wait at the barrier until all expected agents arrive.\n   560→ */\n   561→export class Barrier {\n   562→  private expected: number;\n   563→  private arrived: Set<string> = new Set();\n   564→  private resolve: (() => void) | null = null;\n   565→  private reject: ((error: Error) => void) | null = null;\n   566→  private timeoutHandle: NodeJS.Timeout | null = null;\n   567→  private logger: Logger;\n   568→  private config: Required<BarrierConfig>;\n   569→\n   570→  constructor(expected: number, config: BarrierConfig = {}, logger?: Logger) {\n   571→    this.expected = expected;\n   572→    this.logger = logger || new Logger();\n   573→    this.config = {\n   574→      name: config.name ?? 'default',\n   575→      timeout: config.timeout ?? 30000,\n   576→    };\n   577→    this.logger.info(\n   578→      `Barrier initialized: ${this.config.name} (expected: ${expected})`,\n   579→      'Barrier'\n   580→    );\n   581→  }\n   582→\n   583→  /**\n   584→   * Wait for all agents to arrive at the barrier\n   585→   *\n   586→   * @param agentId - Agent ID\n   587→   * @returns Promise that resolves when all agents have arrived\n   588→   * @throws AgentError if timeout is exceeded\n   589→   */\n   590→  async wait(agentId: string): Promise<void> {\n   591→    return new Promise((resolve, reject) => {\n   592→      // Check if already arrived\n   593→      if (this.arrived.has(agentId)) {\n   594→        resolve();\n   595→        return;\n   596→      }\n   597→\n   598→      // Set up timeout\n   599→      this.timeoutHandle = setTimeout(() => {\n   600→        const error = new AgentError(\n   601→          `Barrier '${this.config.name}' timeout: ${this.arrived.size}/${this.expected} agents arrived`,\n   602→          this.config.name\n   603→        );\n   604→        this.cleanup();\n   605→        reject(error);\n   606→      }, this.config.timeout);\n   607→\n   608→      // Set resolve/reject handlers\n   609→      this.resolve = resolve;\n   610→      this.reject = reject;\n   611→\n   612→      // Mark agent as arrived\n   613→      this.arrived.add(agentId);\n   614→      this.logger.debug(\n   615→        `Agent arrived at barrier: ${agentId}`,\n   616→        'Barrier',\n   617→        { arrived: this.arrived.size, expected: this.expected }\n   618→      );\n   619→\n   620→      // Check if all agents have arrived\n   621→      if (this.arrived.size >= this.expected) {\n   622→        this.cleanup();\n   623→        resolve();\n   624→      }\n   625→    });\n   626→  }\n   627→\n   628→  /**\n   629→   * Reset the barrier\n   630→   */\n   631→  reset(): void {\n   632→    this.arrived.clear();\n   633→    this.cleanup();\n   634→    this.logger.debug(`Barrier reset: ${this.config.name}`, 'Barrier');\n   635→  }\n   636→\n   637→  /**\n   638→   * Get the number of arrived agents\n   639→   *\n   640→   * @returns Number of arrived agents\n   641→   */\n   642→  getArrivedCount(): number {\n   643→    return this.arrived.size;\n   644→  }\n   645→\n   646→  /**\n   647→   * Get the number of expected agents\n   648→   *\n   649→   * @returns Number of expected agents\n   650→   */\n   651→  getExpectedCount(): number {\n   652→    return this.expected;\n   653→  }\n   654→\n   655→  /**\n   656→   * Check if all agents have arrived\n   657→   *\n   658→   * @returns True if all agents have arrived\n   659→   */\n   660→  isComplete(): boolean {\n   661→    return this.arrived.size >= this.expected;\n   662→  }\n   663→\n   664→  /**\n   665→   * Cleanup resources\n   666→   */\n   667→  private cleanup(): void {\n   668→    if (this.timeoutHandle) {\n   669→      clearTimeout(this.timeoutHandle);\n   670→      this.timeoutHandle = null;\n   671→    }\n   672→    this.resolve = null;\n   673→    this.reject = null;\n   674→  }\n   675→}\n   676→\n   677→/**\n   678→ * Semaphore configuration\n   679→ */\n   680→export interface SemaphoreConfig {\n   681→  /**\n   682→   * Semaphore name\n   683→   */\n   684→  name?: string;\n   685→}\n   686→\n   687→/**\n   688→ * Semaphore class\n   689→ *\n   690→ * Provides a counting semaphore for resource management.\n   691→ */\n   692→export class Semaphore {\n   693→  private permits: number;\n   694→  private queue: Array<{ resolve: (permit: boolean) => void }> = [];\n   695→  private logger: Logger;\n   696→  private config: Required<SemaphoreConfig>;\n   697→\n   698→  constructor(permits: number, config: SemaphoreConfig = {}, logger?: Logger) {\n   699→    this.permits = permits;\n   700→    this.logger = logger || new Logger();\n   701→    this.config = {\n   702→      name: config.name ?? 'default',\n   703→    };\n   704→    this.logger.info(\n   705→      `Semaphore initialized: ${this.config.name} (permits: ${permits})`,\n   706→      'Semaphore'\n   707→    );\n   708→  }\n   709→\n   710→  /**\n   711→   * Acquire a permit\n   712→   *\n   713→   * @returns Promise that resolves when a permit is acquired\n   714→   */\n   715→  async acquire(): Promise<boolean> {\n   716→    if (this.permits > 0) {\n   717→      this.permits--;\n   718→      this.logger.debug(\n   719→        `Permit acquired: ${this.config.name}`,\n   720→        'Semaphore',\n   721→        { available: this.permits }\n   722→      );\n   723→      return true;\n   724→    }\n   725→\n   726→    // Wait for a permit\n   727→    return new Promise((resolve) => {\n   728→      this.queue.push({ resolve });\n   729→      this.logger.debug(\n   730→        `Waiting for permit: ${this.config.name}`,\n   731→        'Semaphore',\n   732→        { queueSize: this.queue.length }\n   733→      );\n   734→    });\n   735→  }\n   736→\n   737→  /**\n   738→   * Release a permit\n   739→   */\n   740→  release(): void {\n   741→    if (this.queue.length > 0) {\n   742→      // Grant permit to next waiting agent\n   743→      const next = this.queue.shift()!;\n   744→      next.resolve(true);\n   745→      this.logger.debug(\n   746→        `Permit granted to waiting agent: ${this.config.name}`,\n   747→        'Semaphore',\n   748→        { queueSize: this.queue.length }\n   749→      );\n   750→    } else {\n   751→      this.permits++;\n   752→      this.logger.debug(\n   753→        `Permit released: ${this.config.name}`,\n   754→        'Semaphore',\n   755→        { available: this.permits }\n   756→      );\n   757→    }\n   758→  }\n   759→\n   760→  /**\n   761→   * Get the number of available permits\n   762→   *\n   763→   * @returns Number of available permits\n   764→   */\n   765→  availablePermits(): number {\n   766→    return this.permits;\n   767→  }\n   768→\n   769→  /**\n   770→   * Get the number of waiting agents\n   771→   *\n   772→   * @returns Number of waiting agents\n   773→   */\n   774→  getWaitingCount(): number {\n   775→    return this.queue.length;\n   776→  }\n   777→}\n   778→\n   779→/**\n   780→ * Agent Coordination Manager class\n   781→ *\n   782→ * Provides coordination primitives including task queues, shared state,\n   783→ * barriers, and semaphores for multi-agent systems.\n   784→ */\n   785→export class AgentCoordinationManager {\n   786→  private queues: Map<string, TaskQueue<unknown>> = new Map();\n   787→  private states: Map<string, SharedState> = new Map();\n   788→  private barriers: Map<string, Barrier> = new Map();\n   789→  private semaphores: Map<string, Semaphore> = new Map();\n   790→  private logger: Logger;\n   791→\n   792→  constructor(logger?: Logger) {\n   793→    this.logger = logger || new Logger();\n   794→    this.logger.info('AgentCoordinationManager initialized', 'AgentCoordinationManager');\n   795→  }\n   796→\n   797→  /**\n   798→   * Create or get a task queue\n   799→   *\n   800→   * @param name - Queue name\n   801→   * @param config - Queue configuration\n   802→   * @returns Task queue\n   803→   */\n   804→  getQueue<T>(name: string, config?: TaskQueueConfig): TaskQueue<T> {\n   805→    if (!this.queues.has(name)) {\n   806→      this.queues.set(name, new TaskQueue<T>(config || { name }, this.logger));\n   807→    }\n   808→    return this.queues.get(name) as TaskQueue<T>;\n   809→  }\n   810→\n   811→  /**\n   812→   * Create or get a shared state\n   813→   *\n   814→   * @param name - State name\n   815→   * @param config - State configuration\n   816→   * @returns Shared state\n   817→   */\n   818→  getState(name: string, config?: SharedStateConfig): SharedState {\n   819→    if (!this.states.has(name)) {\n   820→      this.states.set(name, new SharedState(config || { name }, this.logger));\n   821→    }\n   822→    return this.states.get(name)!;\n   823→  }\n   824→\n   825→  /**\n   826→   * Create or get a barrier\n   827→   *\n   828→   * @param name - Barrier name\n   829→   * @param expected - Expected number of agents\n   830→   * @param config - Barrier configuration\n   831→   * @returns Barrier\n   832→   */\n   833→  getBarrier(name: string, expected: number, config?: BarrierConfig): Barrier {\n   834→    if (!this.barriers.has(name)) {\n   835→      this.barriers.set(name, new Barrier(expected, config || { name }, this.logger));\n   836→    }\n   837→    return this.barriers.get(name)!;\n   838→  }\n   839→\n   840→  /**\n   841→   * Create or get a semaphore\n   842→   *\n   843→   * @param name - Semaphore name\n   844→   * @param permits - Number of permits\n   845→   * @param config - Semaphore configuration\n   846→   * @returns Semaphore\n   847→   */\n   848→  getSemaphore(name: string, permits: number, config?: SemaphoreConfig): Semaphore {\n   849→    if (!this.semaphores.has(name)) {\n   850→      this.semaphores.set(name, new Semaphore(permits, config || { name }, this.logger));\n   851→    }\n   852→    return this.semaphores.get(name)!;\n   853→  }\n   854→\n   855→  /**\n   856→   * Delete a task queue\n   857→   *\n   858→   * @param name - Queue name\n   859→   * @returns True if queue was deleted, false if not found\n   860→   */\n   861→  deleteQueue(name: string): boolean {\n   862→    const queue = this.queues.get(name);\n   863→    if (queue) {\n   864→      queue.clear();\n   865→      this.queues.delete(name);\n   866→      return true;\n   867→    }\n   868→    return false;\n   869→  }\n   870→\n   871→  /**\n   872→   * Delete a shared state\n   873→   *\n   874→   * @param name - State name\n   875→   * @returns True if state was deleted, false if not found\n   876→   */\n   877→  deleteState(name: string): boolean {\n   878→    const state = this.states.get(name);\n   879→    if (state) {\n   880→      state.clear();\n   881→      this.states.delete(name);\n   882→      return true;\n   883→    }\n   884→    return false;\n   885→  }\n   886→\n   887→  /**\n   888→   * Delete a barrier\n   889→   *\n   890→   * @param name - Barrier name\n   891→   * @returns True if barrier was deleted, false if not found\n   892→   */\n   893→  deleteBarrier(name: string): boolean {\n   894→    return this.barriers.delete(name);\n   895→  }\n   896→\n   897→  /**\n   898→   * Delete a semaphore\n   899→   *\n   900→   * @param name - Semaphore name\n   901→   * @returns True if semaphore was deleted, false if not found\n   902→   */\n   903→  deleteSemaphore(name: string): boolean {\n   904→    return this.semaphores.delete(name);\n   905→  }\n   906→\n   907→  /**\n   908→   * Clear all coordination primitives\n   909→   */\n   910→  clear(): void {\n   911→    for (const queue of this.queues.values()) {\n   912→      queue.clear();\n   913→    }\n   914→    for (const state of this.states.values()) {\n   915→      state.clear();\n   916→    }\n   917→    this.queues.clear();\n   918→    this.states.clear();\n   919→    this.barriers.clear();\n   920→    this.semaphores.clear();\n   921→    this.logger.info('AgentCoordinationManager cleared', 'AgentCoordinationManager');\n   922→  }\n   923→}\n   924→\n   925→/**\n   926→ * Global agent coordination manager instance\n   927→ */\n   928→let globalAgentCoordinationManager: AgentCoordinationManager | null = null;\n   929→\n   930→/**\n   931→ * Initialize global agent coordination manager\n   932→ *\n   933→ * @param logger - Optional logger instance\n   934→ * @returns The global agent coordination manager\n   935→ */\n   936→export function initAgentCoordinationManager(logger?: Logger): AgentCoordinationManager {\n   937→  globalAgentCoordinationManager = new AgentCoordinationManager(logger);\n   938→  return globalAgentCoordinationManager;\n   939→}\n   940→\n   941→/**\n   942→ * Get global agent coordination manager\n   943→ *\n   944→ * @returns The global agent coordination manager\n   945→ */\n   946→export function getAgentCoordinationManager(): AgentCoordinationManager {\n   947→  if (!globalAgentCoordinationManager) {\n   948→    globalAgentCoordinationManager = new AgentCoordinationManager();\n   949→  }\n   950→  return globalAgentCoordinationManager;\n   951→}\n   952→\n\n</system-reminder>\n"}]},"uuid":"f206bbfe-826b-4533-a528-28577d3445f3","timestamp":"2026-01-12T06:23:19.454Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/coordination.ts","content":"/**\n * Agent Coordination for KOMPLETE-KONTROL CLI\n *\n * Provides coordination primitives including task queues, state sharing,\n * and synchronization mechanisms for multi-agent systems.\n * Follows patterns from agent-swarm-kit with simplified architecture.\n */\n\nimport { AgentError } from '../../types';\nimport { Logger } from '../../utils/logger';\n\n/**\n * Task queue priority\n */\nexport enum QueuePriority {\n  /**\n   * Low priority\n   */\n  LOW = 0,\n  /**\n   * Normal priority\n   */\n  NORMAL = 1,\n  /**\n   * High priority\n   */\n  HIGH = 2,\n  /**\n   * Critical priority\n   */\n  CRITICAL = 3,\n}\n\n/**\n * Queue item\n */\nexport interface QueueItem<T> {\n  /**\n   * Item ID\n   */\n  id: string;\n  /**\n   * Item data\n   */\n  data: T;\n  /**\n   * Item priority\n   */\n  priority: QueuePriority;\n  /**\n   * Item creation time\n   */\n  createdAt: Date;\n  /**\n   * Item metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Queue statistics\n */\nexport interface QueueStatistics {\n  /**\n   * Total items in queue\n   */\n  totalItems: number;\n  /**\n   * Number of items by priority\n   */\n  itemsByPriority: Record<QueuePriority, number>;\n  /**\n   * Number of processed items\n   */\n  processedItems: number;\n  /**\n   * Number of failed items\n   */\n  failedItems: number;\n}\n\n/**\n * Task queue configuration\n */\nexport interface TaskQueueConfig {\n  /**\n   * Maximum queue size\n   */\n  maxSize?: number;\n  /**\n   * Enable priority queue\n   */\n  enablePriority?: boolean;\n  /**\n   * Queue name\n   */\n  name?: string;\n}\n\n/**\n * Task Queue class\n *\n * Provides a priority-based task queue for agent coordination.\n */\nexport class TaskQueue<T> {\n  private queue: QueueItem<T>[] = [];\n  private processedCount: number = 0;\n  private failedCount: number = 0;\n  private logger: Logger;\n  private config: Required<TaskQueueConfig>;\n\n  constructor(config: TaskQueueConfig = {}, logger?: Logger) {\n    this.logger = logger || new Logger();\n    this.config = {\n      maxSize: config.maxSize ?? 1000,\n      enablePriority: config.enablePriority ?? true,\n      name: config.name ?? 'default',\n    };\n    this.logger.info(\n      `TaskQueue initialized: ${this.config.name}`,\n      'TaskQueue'\n    );\n  }\n\n  /**\n   * Add an item to the queue\n   *\n   * @param data - Item data\n   * @param priority - Item priority\n   * @param metadata - Optional metadata\n   * @returns Item ID\n   * @throws AgentError if queue is full\n   */\n  enqueue(data: T, priority: QueuePriority = QueuePriority.NORMAL, metadata?: Record<string, unknown>): string {\n    if (this.queue.length >= this.config.maxSize) {\n      throw new AgentError(`Queue '${this.config.name}' is full`, this.config.name);\n    }\n\n    const item: QueueItem<T> = {\n      id: this.generateItemId(),\n      data,\n      priority,\n      createdAt: new Date(),\n      metadata,\n    };\n\n    this.queue.push(item);\n\n    // Sort by priority if enabled\n    if (this.config.enablePriority) {\n      this.queue.sort((a, b) => {\n        const priorityDiff = b.priority - a.priority;\n        if (priorityDiff !== 0) return priorityDiff;\n        return a.createdAt.getTime() - b.createdAt.getTime();\n      });\n    }\n\n    this.logger.debug(\n      `Item enqueued: ${item.id}`,\n      'TaskQueue',\n      { priority, queueSize: this.queue.length }\n    );\n\n    return item.id;\n  }\n\n  /**\n   * Remove and return the next item from the queue\n   *\n   * @returns Queue item or undefined if queue is empty\n   */\n  dequeue(): QueueItem<T> | undefined {\n    const item = this.queue.shift();\n\n    if (item) {\n      this.processedCount++;\n      this.logger.debug(\n        `Item dequeued: ${item.id}`,\n        'TaskQueue',\n        { priority: item.priority, queueSize: this.queue.length }\n      );\n    }\n\n    return item;\n  }\n\n  /**\n   * Peek at the next item without removing it\n   *\n   * @returns Queue item or undefined if queue is empty\n   */\n  peek(): QueueItem<T> | undefined {\n    return this.queue[0];\n  }\n\n  /**\n   * Remove an item by ID\n   *\n   * @param itemId - Item ID to remove\n   * @returns True if item was removed, false if not found\n   */\n  remove(itemId: string): boolean {\n    const index = this.queue.findIndex((item) => item.id === itemId);\n\n    if (index > -1) {\n      this.queue.splice(index, 1);\n      this.logger.debug(`Item removed: ${itemId}`, 'TaskQueue');\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get an item by ID\n   *\n   * @param itemId - Item ID to get\n   * @returns Queue item or undefined if not found\n   */\n  get(itemId: string): QueueItem<T> | undefined {\n    return this.queue.find((item) => item.id === itemId);\n  }\n\n  /**\n   * Get all items\n   *\n   * @returns Array of queue items\n   */\n  getAll(): QueueItem<T>[] {\n    return [...this.queue];\n  }\n\n  /**\n   * Get queue size\n   *\n   * @returns Number of items in queue\n   */\n  size(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Check if queue is empty\n   *\n   * @returns True if queue is empty\n   */\n  isEmpty(): boolean {\n    return this.queue.length === 0;\n  }\n\n  /**\n   * Check if queue is full\n   *\n   * @returns True if queue is full\n   */\n  isFull(): boolean {\n    return this.queue.length >= this.config.maxSize;\n  }\n\n  /**\n   * Mark an item as failed\n   *\n   * @param itemId - Item ID to mark as failed\n   * @returns True if item was marked as failed, false if not found\n   */\n  markFailed(itemId: string): boolean {\n    const index = this.queue.findIndex((item) => item.id === itemId);\n\n    if (index > -1) {\n      this.queue.splice(index, 1);\n      this.failedCount++;\n      this.logger.debug(`Item marked as failed: ${itemId}`, 'TaskQueue');\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get queue statistics\n   *\n   * @returns Queue statistics\n   */\n  getStatistics(): QueueStatistics {\n    const itemsByPriority: Record<QueuePriority, number> = {\n      [QueuePriority.LOW]: 0,\n      [QueuePriority.NORMAL]: 0,\n      [QueuePriority.HIGH]: 0,\n      [QueuePriority.CRITICAL]: 0,\n    };\n\n    for (const item of this.queue) {\n      itemsByPriority[item.priority]++;\n    }\n\n    return {\n      totalItems: this.queue.length,\n      itemsByPriority,\n      processedItems: this.processedCount,\n      failedItems: this.failedCount,\n    };\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear(): void {\n    this.queue = [];\n    this.processedCount = 0;\n    this.failedCount = 0;\n    this.logger.info(`Queue cleared: ${this.config.name}`, 'TaskQueue');\n  }\n\n  /**\n   * Generate unique item ID\n   *\n   * @returns Unique item ID\n   */\n  private generateItemId(): string {\n    return `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n/**\n * Shared state value\n */\ninterface StateValue<T> {\n  value: T;\n  version: number;\n  updatedAt: Date;\n  updatedBy?: string;\n}\n\n/**\n * Shared state configuration\n */\nexport interface SharedStateConfig {\n  /**\n   * State name\n   */\n  name?: string;\n  /**\n   * Enable versioning\n   */\n  enableVersioning?: boolean;\n  /**\n   * Maximum history size\n   */\n  maxHistorySize?: number;\n}\n\n/**\n * Shared State class\n *\n * Provides shared state management for agent coordination.\n */\nexport class SharedState {\n  private state: Map<string, StateValue<unknown>> = new Map();\n  private history: Array<{ key: string; value: StateValue<unknown> }> = [];\n  private logger: Logger;\n  private config: Required<SharedStateConfig>;\n\n  constructor(config: SharedStateConfig = {}, logger?: Logger) {\n    this.logger = logger || new Logger();\n    this.config = {\n      name: config.name ?? 'default',\n      enableVersioning: config.enableVersioning ?? true,\n      maxHistorySize: config.maxHistorySize ?? 100,\n    };\n    this.logger.info(\n      `SharedState initialized: ${this.config.name}`,\n      'SharedState'\n    );\n  }\n\n  /**\n   * Set a value in the shared state\n   *\n   * @param key - State key\n   * @param value - State value\n   * @param updatedBy - Optional agent ID that updated the value\n   */\n  set<T>(key: string, value: T, updatedBy?: string): void {\n    const currentValue = this.state.get(key);\n    const version = currentValue ? currentValue.version + 1 : 1;\n\n    const stateValue: StateValue<T> = {\n      value,\n      version,\n      updatedAt: new Date(),\n      updatedBy,\n    };\n\n    // Add to history if versioning is enabled\n    if (this.config.enableVersioning && currentValue) {\n      this.history.push({ key, value: currentValue });\n      this.trimHistory();\n    }\n\n    this.state.set(key, stateValue as StateValue<unknown>);\n\n    this.logger.debug(\n      `State set: ${key}`,\n      'SharedState',\n      { version, updatedBy }\n    );\n  }\n\n  /**\n   * Get a value from the shared state\n   *\n   * @param key - State key\n   * @param defaultValue - Default value if key doesn't exist\n   * @returns State value or default value\n   */\n  get<T>(key: string, defaultValue?: T): T | undefined {\n    const stateValue = this.state.get(key);\n    return stateValue ? (stateValue.value as T) : defaultValue;\n  }\n\n  /**\n   * Get a value with version information\n   *\n   * @param key - State key\n   * @returns State value with metadata or undefined\n   */\n  getWithVersion<T>(key: string): StateValue<T> | undefined {\n    const stateValue = this.state.get(key);\n    return stateValue as StateValue<T> | undefined;\n  }\n\n  /**\n   * Check if a key exists in the shared state\n   *\n   * @param key - State key\n   * @returns True if key exists\n   */\n  has(key: string): boolean {\n    return this.state.has(key);\n  }\n\n  /**\n   * Delete a value from the shared state\n   *\n   * @param key - State key\n   * @returns True if key was deleted, false if not found\n   */\n  delete(key: string): boolean {\n    const existed = this.state.has(key);\n\n    if (existed) {\n      // Add to history before deleting\n      if (this.config.enableVersioning) {\n        const currentValue = this.state.get(key)!;\n        this.history.push({ key, value: currentValue });\n        this.trimHistory();\n      }\n\n      this.state.delete(key);\n      this.logger.debug(`State deleted: ${key}`, 'SharedState');\n    }\n\n    return existed;\n  }\n\n  /**\n   * Get all keys in the shared state\n   *\n   * @returns Array of keys\n   */\n  keys(): string[] {\n    return Array.from(this.state.keys());\n  }\n\n  /**\n   * Get all values in the shared state\n   *\n   * @returns Map of key to value\n   */\n  values(): Map<string, unknown> {\n    const result = new Map<string, unknown>();\n\n    for (const [key, stateValue] of this.state.entries()) {\n      result.set(key, stateValue.value);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get all entries in the shared state\n   *\n   * @returns Array of [key, value] tuples\n   */\n  entries(): Array<[string, unknown]> {\n    const result: Array<[string, unknown]> = [];\n\n    for (const [key, stateValue] of this.state.entries()) {\n      result.push([key, stateValue.value]);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get history for a key\n   *\n   * @param key - State key\n   * @param limit - Maximum number of history entries\n   * @returns Array of historical values\n   */\n  getHistory<T>(key: string, limit?: number): StateValue<T>[] {\n    const keyHistory = this.history.filter((entry) => entry.key === key);\n\n    if (limit) {\n      return keyHistory.slice(-limit).map((entry) => entry.value as StateValue<T>);\n    }\n\n    return keyHistory.map((entry) => entry.value as StateValue<T>);\n  }\n\n  /**\n   * Clear the shared state\n   */\n  clear(): void {\n    this.state.clear();\n    this.history = [];\n    this.logger.info(`SharedState cleared: ${this.config.name}`, 'SharedState');\n  }\n\n  /**\n   * Trim history to max size\n   */\n  private trimHistory(): void {\n    if (this.history.length > this.config.maxHistorySize) {\n      this.history = this.history.slice(-this.config.maxHistorySize);\n    }\n  }\n}\n\n/**\n * Barrier configuration\n */\nexport interface BarrierConfig {\n  /**\n   * Barrier name\n   */\n  name?: string;\n  /**\n   * Timeout in milliseconds\n   */\n  timeout?: number;\n}\n\n/**\n * Barrier class\n *\n * Provides a synchronization barrier for agent coordination.\n * Agents can wait at the barrier until all expected agents arrive.\n */\nexport class Barrier {\n  private expected: number;\n  private arrived: Set<string> = new Set();\n  private resolve: (() => void) | null = null;\n  private reject: ((error: Error) => void) | null = null;\n  private timeoutHandle: NodeJS.Timeout | null = null;\n  private logger: Logger;\n  private config: Required<BarrierConfig>;\n\n  constructor(expected: number, config: BarrierConfig = {}, logger?: Logger) {\n    this.expected = expected;\n    this.logger = logger || new Logger();\n    this.config = {\n      name: config.name ?? 'default',\n      timeout: config.timeout ?? 30000,\n    };\n    this.logger.info(\n      `Barrier initialized: ${this.config.name} (expected: ${expected})`,\n      'Barrier'\n    );\n  }\n\n  /**\n   * Wait for all agents to arrive at the barrier\n   *\n   * @param agentId - Agent ID\n   * @returns Promise that resolves when all agents have arrived\n   * @throws AgentError if timeout is exceeded\n   */\n  async wait(agentId: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Check if already arrived\n      if (this.arrived.has(agentId)) {\n        resolve();\n        return;\n      }\n\n      // Set up timeout\n      this.timeoutHandle = setTimeout(() => {\n        const error = new AgentError(\n          `Barrier '${this.config.name}' timeout: ${this.arrived.size}/${this.expected} agents arrived`,\n          this.config.name\n        );\n        this.cleanup();\n        reject(error);\n      }, this.config.timeout);\n\n      // Set resolve/reject handlers\n      this.resolve = resolve;\n      this.reject = reject;\n\n      // Mark agent as arrived\n      this.arrived.add(agentId);\n      this.logger.debug(\n        `Agent arrived at barrier: ${agentId}`,\n        'Barrier',\n        { arrived: this.arrived.size, expected: this.expected }\n      );\n\n      // Check if all agents have arrived\n      if (this.arrived.size >= this.expected) {\n        this.cleanup();\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Reset the barrier\n   */\n  reset(): void {\n    this.arrived.clear();\n    this.cleanup();\n    this.logger.debug(`Barrier reset: ${this.config.name}`, 'Barrier');\n  }\n\n  /**\n   * Get the number of arrived agents\n   *\n   * @returns Number of arrived agents\n   */\n  getArrivedCount(): number {\n    return this.arrived.size;\n  }\n\n  /**\n   * Get the number of expected agents\n   *\n   * @returns Number of expected agents\n   */\n  getExpectedCount(): number {\n    return this.expected;\n  }\n\n  /**\n   * Check if all agents have arrived\n   *\n   * @returns True if all agents have arrived\n   */\n  isComplete(): boolean {\n    return this.arrived.size >= this.expected;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  private cleanup(): void {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n      this.timeoutHandle = null;\n    }\n    this.resolve = null;\n    this.reject = null;\n  }\n}\n\n/**\n * Semaphore configuration\n */\nexport interface SemaphoreConfig {\n  /**\n   * Semaphore name\n   */\n  name?: string;\n}\n\n/**\n * Semaphore class\n *\n * Provides a counting semaphore for resource management.\n */\nexport class Semaphore {\n  private permits: number;\n  private queue: Array<{ resolve: (permit: boolean) => void }> = [];\n  private logger: Logger;\n  private config: Required<SemaphoreConfig>;\n\n  constructor(permits: number, config: SemaphoreConfig = {}, logger?: Logger) {\n    this.permits = permits;\n    this.logger = logger || new Logger();\n    this.config = {\n      name: config.name ?? 'default',\n    };\n    this.logger.info(\n      `Semaphore initialized: ${this.config.name} (permits: ${permits})`,\n      'Semaphore'\n    );\n  }\n\n  /**\n   * Acquire a permit\n   *\n   * @returns Promise that resolves when a permit is acquired\n   */\n  async acquire(): Promise<boolean> {\n    if (this.permits > 0) {\n      this.permits--;\n      this.logger.debug(\n        `Permit acquired: ${this.config.name}`,\n        'Semaphore',\n        { available: this.permits }\n      );\n      return true;\n    }\n\n    // Wait for a permit\n    return new Promise((resolve) => {\n      this.queue.push({ resolve });\n      this.logger.debug(\n        `Waiting for permit: ${this.config.name}`,\n        'Semaphore',\n        { queueSize: this.queue.length }\n      );\n    });\n  }\n\n  /**\n   * Release a permit\n   */\n  release(): void {\n    if (this.queue.length > 0) {\n      // Grant permit to next waiting agent\n      const next = this.queue.shift()!;\n      next.resolve(true);\n      this.logger.debug(\n        `Permit granted to waiting agent: ${this.config.name}`,\n        'Semaphore',\n        { queueSize: this.queue.length }\n      );\n    } else {\n      this.permits++;\n      this.logger.debug(\n        `Permit released: ${this.config.name}`,\n        'Semaphore',\n        { available: this.permits }\n      );\n    }\n  }\n\n  /**\n   * Get the number of available permits\n   *\n   * @returns Number of available permits\n   */\n  availablePermits(): number {\n    return this.permits;\n  }\n\n  /**\n   * Get the number of waiting agents\n   *\n   * @returns Number of waiting agents\n   */\n  getWaitingCount(): number {\n    return this.queue.length;\n  }\n}\n\n/**\n * Agent Coordination Manager class\n *\n * Provides coordination primitives including task queues, shared state,\n * barriers, and semaphores for multi-agent systems.\n */\nexport class AgentCoordinationManager {\n  private queues: Map<string, TaskQueue<unknown>> = new Map();\n  private states: Map<string, SharedState> = new Map();\n  private barriers: Map<string, Barrier> = new Map();\n  private semaphores: Map<string, Semaphore> = new Map();\n  private logger: Logger;\n\n  constructor(logger?: Logger) {\n    this.logger = logger || new Logger();\n    this.logger.info('AgentCoordinationManager initialized', 'AgentCoordinationManager');\n  }\n\n  /**\n   * Create or get a task queue\n   *\n   * @param name - Queue name\n   * @param config - Queue configuration\n   * @returns Task queue\n   */\n  getQueue<T>(name: string, config?: TaskQueueConfig): TaskQueue<T> {\n    if (!this.queues.has(name)) {\n      this.queues.set(name, new TaskQueue<T>(config || { name }, this.logger));\n    }\n    return this.queues.get(name) as TaskQueue<T>;\n  }\n\n  /**\n   * Create or get a shared state\n   *\n   * @param name - State name\n   * @param config - State configuration\n   * @returns Shared state\n   */\n  getState(name: string, config?: SharedStateConfig): SharedState {\n    if (!this.states.has(name)) {\n      this.states.set(name, new SharedState(config || { name }, this.logger));\n    }\n    return this.states.get(name)!;\n  }\n\n  /**\n   * Create or get a barrier\n   *\n   * @param name - Barrier name\n   * @param expected - Expected number of agents\n   * @param config - Barrier configuration\n   * @returns Barrier\n   */\n  getBarrier(name: string, expected: number, config?: BarrierConfig): Barrier {\n    if (!this.barriers.has(name)) {\n      this.barriers.set(name, new Barrier(expected, config || { name }, this.logger));\n    }\n    return this.barriers.get(name)!;\n  }\n\n  /**\n   * Create or get a semaphore\n   *\n   * @param name - Semaphore name\n   * @param permits - Number of permits\n   * @param config - Semaphore configuration\n   * @returns Semaphore\n   */\n  getSemaphore(name: string, permits: number, config?: SemaphoreConfig): Semaphore {\n    if (!this.semaphores.has(name)) {\n      this.semaphores.set(name, new Semaphore(permits, config || { name }, this.logger));\n    }\n    return this.semaphores.get(name)!;\n  }\n\n  /**\n   * Delete a task queue\n   *\n   * @param name - Queue name\n   * @returns True if queue was deleted, false if not found\n   */\n  deleteQueue(name: string): boolean {\n    const queue = this.queues.get(name);\n    if (queue) {\n      queue.clear();\n      this.queues.delete(name);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Delete a shared state\n   *\n   * @param name - State name\n   * @returns True if state was deleted, false if not found\n   */\n  deleteState(name: string): boolean {\n    const state = this.states.get(name);\n    if (state) {\n      state.clear();\n      this.states.delete(name);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Delete a barrier\n   *\n   * @param name - Barrier name\n   * @returns True if barrier was deleted, false if not found\n   */\n  deleteBarrier(name: string): boolean {\n    return this.barriers.delete(name);\n  }\n\n  /**\n   * Delete a semaphore\n   *\n   * @param name - Semaphore name\n   * @returns True if semaphore was deleted, false if not found\n   */\n  deleteSemaphore(name: string): boolean {\n    return this.semaphores.delete(name);\n  }\n\n  /**\n   * Clear all coordination primitives\n   */\n  clear(): void {\n    for (const queue of this.queues.values()) {\n      queue.clear();\n    }\n    for (const state of this.states.values()) {\n      state.clear();\n    }\n    this.queues.clear();\n    this.states.clear();\n    this.barriers.clear();\n    this.semaphores.clear();\n    this.logger.info('AgentCoordinationManager cleared', 'AgentCoordinationManager');\n  }\n}\n\n/**\n * Global agent coordination manager instance\n */\nlet globalAgentCoordinationManager: AgentCoordinationManager | null = null;\n\n/**\n * Initialize global agent coordination manager\n *\n * @param logger - Optional logger instance\n * @returns The global agent coordination manager\n */\nexport function initAgentCoordinationManager(logger?: Logger): AgentCoordinationManager {\n  globalAgentCoordinationManager = new AgentCoordinationManager(logger);\n  return globalAgentCoordinationManager;\n}\n\n/**\n * Get global agent coordination manager\n *\n * @returns The global agent coordination manager\n */\nexport function getAgentCoordinationManager(): AgentCoordinationManager {\n  if (!globalAgentCoordinationManager) {\n    globalAgentCoordinationManager = new AgentCoordinationManager();\n  }\n  return globalAgentCoordinationManager;\n}\n","numLines":952,"startLine":1,"totalLines":952}}}
{"parentUuid":"f206bbfe-826b-4533-a528-28577d3445f3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015adWNJfhdA8Q7mhq3AxmSE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the test-agents file and look at the types to understand the complete picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":25259,"cache_read_input_tokens":33443,"cache_creation":{"ephemeral_5m_input_tokens":25259,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31Bct9YQE9iTvjTRaP8","type":"assistant","uuid":"c32be655-6410-4d64-a19e-505139312b53","timestamp":"2026-01-12T06:23:21.225Z"}
{"parentUuid":"c32be655-6410-4d64-a19e-505139312b53","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015adWNJfhdA8Q7mhq3AxmSE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017n5WAoaM1XaaNZmosqz7gA","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/test-agents.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":25259,"cache_read_input_tokens":33443,"cache_creation":{"ephemeral_5m_input_tokens":25259,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31Bct9YQE9iTvjTRaP8","type":"assistant","uuid":"49329945-238f-405d-8403-c1a49a37a5f8","timestamp":"2026-01-12T06:23:21.835Z"}
{"parentUuid":"49329945-238f-405d-8403-c1a49a37a5f8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015adWNJfhdA8Q7mhq3AxmSE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GMQkePGNFYVYbPpwmVQWTo","name":"Grep","input":{"pattern":"export type AgentDefinition|export interface AgentTask|export interface AgentTaskResult","path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/types"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":25259,"cache_read_input_tokens":33443,"cache_creation":{"ephemeral_5m_input_tokens":25259,"ephemeral_1h_input_tokens":0},"output_tokens":194,"service_tier":"standard"}},"requestId":"req_011CX31Bct9YQE9iTvjTRaP8","type":"assistant","uuid":"588382ce-f50b-48e0-8e66-a440d04d65cb","timestamp":"2026-01-12T06:23:22.310Z"}
{"parentUuid":"588382ce-f50b-48e0-8e66-a440d04d65cb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017n5WAoaM1XaaNZmosqz7gA","type":"tool_result","content":"     1→/**\n     2→ * Test Agents for KOMPLETE-KONTROL CLI\n     3→ *\n     4→ * Provides basic test agents for testing the agent system.\n     5→ * These agents demonstrate the agent system capabilities.\n     6→ */\n     7→\n     8→import type { AgentDefinition } from '../../types';\n     9→import { getAgentRegistry } from './registry';\n    10→import { getAgentLifecycleManager } from './lifecycle';\n    11→\n    12→/**\n    13→ * General mode agent definition\n    14→ */\n    15→export const GENERAL_AGENT: AgentDefinition = {\n    16→  id: 'general',\n    17→  name: 'General Assistant',\n    18→  description: 'A general-purpose AI assistant for everyday tasks and questions',\n    19→  capabilities: ['chat', 'code-assist', 'analysis', 'research'],\n    20→  systemPrompt: `You are a helpful, knowledgeable AI assistant. You provide clear, accurate, and thoughtful responses to a wide variety of questions and tasks. You are friendly, professional, and always strive to be helpful while being honest about your limitations.`,\n    21→  dependencies: [],\n    22→};\n    23→\n    24→/**\n    25→ * Coder mode agent definition\n    26→ */\n    27→export const CODER_AGENT: AgentDefinition = {\n    28→  id: 'coder',\n    29→  name: 'Code Assistant',\n    30→  description: 'Specialized AI assistant for coding, debugging, and software development tasks',\n    31→  capabilities: ['code', 'debug', 'refactor', 'code-review', 'documentation'],\n    32→  systemPrompt: `You are an expert software development assistant. You help with writing, reviewing, debugging, and refactoring code. You follow best practices, write clean and maintainable code, and provide clear explanations. You are familiar with multiple programming languages and frameworks.`,\n    33→  dependencies: ['general'],\n    34→};\n    35→\n    36→/**\n    37→ * Reverse engineer mode agent definition\n    38→ */\n    39→export const REVERSE_ENGINEER_AGENT: AgentDefinition = {\n    40→  id: 'reverse-engineer',\n    41→  name: 'Reverse Engineering Assistant',\n    42→  description: 'Specialized AI assistant for reverse engineering, binary analysis, and system internals exploration',\n    43→  capabilities: ['reverse-engineering', 'binary-analysis', 'decompilation', 'system-analysis'],\n    44→  systemPrompt: `You are an expert in reverse engineering and system analysis. You help understand how software and systems work internally, analyze binaries, and explore undocumented behavior. You approach tasks methodically and provide detailed technical explanations.`,\n    45→  dependencies: ['coder', 'general'],\n    46→};\n    47→\n    48→/**\n    49→ * Test agent definitions\n    50→ */\n    51→export const TEST_AGENTS: AgentDefinition[] = [\n    52→  GENERAL_AGENT,\n    53→  CODER_AGENT,\n    54→  REVERSE_ENGINEER_AGENT,\n    55→];\n    56→\n    57→/**\n    58→ * Initialize test agents\n    59→ *\n    60→ * Registers all test agents with the registry and initializes them.\n    61→ */\n    62→export async function initializeTestAgents(): Promise<void> {\n    63→  const registry = getAgentRegistry();\n    64→  const lifecycleManager = getAgentLifecycleManager();\n    65→\n    66→  for (const agent of TEST_AGENTS) {\n    67→    try {\n    68→      // Register agent\n    69→      registry.register(agent, {\n    70→        autoStart: false,\n    71→        priority: 0,\n    72→        tags: ['test', agent.capabilities[0] ?? 'general'],\n    73→      });\n    74→\n    75→      // Initialize agent\n    76→      await lifecycleManager.initialize(agent.id);\n    77→    } catch (error) {\n    78→      console.error(`Failed to initialize agent '${agent.id}':`, error);\n    79→    }\n    80→  }\n    81→}\n    82→\n    83→/**\n    84→ * Get test agent by ID\n    85→ *\n    86→ * @param agentId - Agent ID to get\n    87→ * @returns Agent definition or undefined if not found\n    88→ */\n    89→export function getTestAgent(agentId: string): AgentDefinition | undefined {\n    90→  return TEST_AGENTS.find((agent) => agent.id === agentId);\n    91→}\n    92→\n\n</system-reminder>\n"}]},"uuid":"d4b24f68-b70a-4c32-a09d-eaa46be8e9a1","timestamp":"2026-01-12T06:23:22.349Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/test-agents.ts","content":"/**\n * Test Agents for KOMPLETE-KONTROL CLI\n *\n * Provides basic test agents for testing the agent system.\n * These agents demonstrate the agent system capabilities.\n */\n\nimport type { AgentDefinition } from '../../types';\nimport { getAgentRegistry } from './registry';\nimport { getAgentLifecycleManager } from './lifecycle';\n\n/**\n * General mode agent definition\n */\nexport const GENERAL_AGENT: AgentDefinition = {\n  id: 'general',\n  name: 'General Assistant',\n  description: 'A general-purpose AI assistant for everyday tasks and questions',\n  capabilities: ['chat', 'code-assist', 'analysis', 'research'],\n  systemPrompt: `You are a helpful, knowledgeable AI assistant. You provide clear, accurate, and thoughtful responses to a wide variety of questions and tasks. You are friendly, professional, and always strive to be helpful while being honest about your limitations.`,\n  dependencies: [],\n};\n\n/**\n * Coder mode agent definition\n */\nexport const CODER_AGENT: AgentDefinition = {\n  id: 'coder',\n  name: 'Code Assistant',\n  description: 'Specialized AI assistant for coding, debugging, and software development tasks',\n  capabilities: ['code', 'debug', 'refactor', 'code-review', 'documentation'],\n  systemPrompt: `You are an expert software development assistant. You help with writing, reviewing, debugging, and refactoring code. You follow best practices, write clean and maintainable code, and provide clear explanations. You are familiar with multiple programming languages and frameworks.`,\n  dependencies: ['general'],\n};\n\n/**\n * Reverse engineer mode agent definition\n */\nexport const REVERSE_ENGINEER_AGENT: AgentDefinition = {\n  id: 'reverse-engineer',\n  name: 'Reverse Engineering Assistant',\n  description: 'Specialized AI assistant for reverse engineering, binary analysis, and system internals exploration',\n  capabilities: ['reverse-engineering', 'binary-analysis', 'decompilation', 'system-analysis'],\n  systemPrompt: `You are an expert in reverse engineering and system analysis. You help understand how software and systems work internally, analyze binaries, and explore undocumented behavior. You approach tasks methodically and provide detailed technical explanations.`,\n  dependencies: ['coder', 'general'],\n};\n\n/**\n * Test agent definitions\n */\nexport const TEST_AGENTS: AgentDefinition[] = [\n  GENERAL_AGENT,\n  CODER_AGENT,\n  REVERSE_ENGINEER_AGENT,\n];\n\n/**\n * Initialize test agents\n *\n * Registers all test agents with the registry and initializes them.\n */\nexport async function initializeTestAgents(): Promise<void> {\n  const registry = getAgentRegistry();\n  const lifecycleManager = getAgentLifecycleManager();\n\n  for (const agent of TEST_AGENTS) {\n    try {\n      // Register agent\n      registry.register(agent, {\n        autoStart: false,\n        priority: 0,\n        tags: ['test', agent.capabilities[0] ?? 'general'],\n      });\n\n      // Initialize agent\n      await lifecycleManager.initialize(agent.id);\n    } catch (error) {\n      console.error(`Failed to initialize agent '${agent.id}':`, error);\n    }\n  }\n}\n\n/**\n * Get test agent by ID\n *\n * @param agentId - Agent ID to get\n * @returns Agent definition or undefined if not found\n */\nexport function getTestAgent(agentId: string): AgentDefinition | undefined {\n  return TEST_AGENTS.find((agent) => agent.id === agentId);\n}\n","numLines":92,"startLine":1,"totalLines":92}}}
{"parentUuid":"d4b24f68-b70a-4c32-a09d-eaa46be8e9a1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GMQkePGNFYVYbPpwmVQWTo","type":"tool_result","content":"Found 1 file\nsrc/types/index.ts"}]},"uuid":"aa63fb8a-ce41-4a8f-b87a-1563ecde2f7b","timestamp":"2026-01-12T06:23:22.369Z","toolUseResult":{"mode":"files_with_matches","filenames":["src/types/index.ts"],"numFiles":1}}
{"parentUuid":"aa63fb8a-ce41-4a8f-b87a-1563ecde2f7b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PtmQBiKiTdc2pYkhFMRz8z","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the types file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1848,"cache_read_input_tokens":58702,"cache_creation":{"ephemeral_5m_input_tokens":1848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BqCpCZbYc5WCdH6YG","type":"assistant","uuid":"5b5618b8-c809-47f7-a5e8-27eefb323033","timestamp":"2026-01-12T06:23:23.597Z"}
{"parentUuid":"5b5618b8-c809-47f7-a5e8-27eefb323033","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PtmQBiKiTdc2pYkhFMRz8z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xuj55KZXxDyfodjuTwvEi1","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/types/index.ts","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1848,"cache_read_input_tokens":58702,"cache_creation":{"ephemeral_5m_input_tokens":1848,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31BqCpCZbYc5WCdH6YG","type":"assistant","uuid":"d6933d39-7de1-4b86-87b5-24d8b5663980","timestamp":"2026-01-12T06:23:23.992Z"}
{"parentUuid":"d6933d39-7de1-4b86-87b5-24d8b5663980","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xuj55KZXxDyfodjuTwvEi1","type":"tool_result","content":"     1→/**\n     2→ * Core type definitions for KOMPLETE-KONTROL CLI\n     3→ * \n     4→ * This file contains all shared type definitions used across the application.\n     5→ */\n     6→\n     7→/**\n     8→ * Message role types for AI interactions\n     9→ */\n    10→export type MessageRole = 'user' | 'assistant' | 'system' | 'tool';\n    11→\n    12→/**\n    13→ * Content types for messages\n    14→ */\n    15→export type ContentType = 'text' | 'image' | 'tool_use' | 'tool_result';\n    16→\n    17→/**\n    18→ * Base message content interface\n    19→ */\n    20→export interface MessageContent {\n    21→  type: ContentType;\n    22→}\n    23→\n    24→/**\n    25→ * Text content\n    26→ */\n    27→export interface TextContent extends MessageContent {\n    28→  type: 'text';\n    29→  text: string;\n    30→}\n    31→\n    32→/**\n    33→ * Image content\n    34→ */\n    35→export interface ImageContent extends MessageContent {\n    36→  type: 'image';\n    37→  source: {\n    38→    type: 'url' | 'base64';\n    39→    data: string;\n    40→    media_type?: string;\n    41→  };\n    42→}\n    43→\n    44→/**\n    45→ * Tool use content\n    46→ */\n    47→export interface ToolUseContent extends MessageContent {\n    48→  type: 'tool_use';\n    49→  id: string;\n    50→  name: string;\n    51→  input: Record<string, unknown>;\n    52→}\n    53→\n    54→/**\n    55→ * Tool result content\n    56→ */\n    57→export interface ToolResultContent extends MessageContent {\n    58→  type: 'tool_result';\n    59→  tool_use_id: string;\n    60→  content?: string | Array<MessageContent>;\n    61→  is_error?: boolean;\n    62→}\n    63→\n    64→/**\n    65→ * Complete message structure\n    66→ */\n    67→export interface Message {\n    68→  role: MessageRole;\n    69→  content: MessageContent | Array<MessageContent>;\n    70→}\n    71→\n    72→/**\n    73→ * Tool definition\n    74→ */\n    75→export interface Tool {\n    76→  name: string;\n    77→  description: string;\n    78→  inputSchema: Record<string, unknown>;\n    79→}\n    80→\n    81→/**\n    82→ * Provider prefix types\n    83→ */\n    84→export type ProviderPrefix =\n    85→  | 'or'   // OpenRouter\n    86→  | 'g'    // Groq\n    87→  | 'oai'  // OpenAI\n    88→  | 'anthropic'  // Anthropic\n    89→  | 'ollama'  // Ollama\n    90→  | 'fl';  // Featherless\n    91→\n    92→/**\n    93→ * Model configuration\n    94→ */\n    95→export interface ModelConfig {\n    96→  name: string;\n    97→  prefix: ProviderPrefix;\n    98→  maxTokens: number;\n    99→  supportsVision: boolean;\n   100→  supportsTools: boolean;\n   101→  costPer1kTokens: number;\n   102→}\n   103→\n   104→/**\n   105→ * Provider capabilities\n   106→ */\n   107→export interface ProviderCapabilities {\n   108→  streaming: boolean;\n   109→  tools: boolean;\n   110→  vision: boolean;\n   111→  maxTokens: number;\n   112→}\n   113→\n   114→/**\n   115→ * AI Provider interface\n   116→ */\n   117→export interface AIProvider {\n   118→  name: string;\n   119→  prefix: ProviderPrefix;\n   120→  capabilities: ProviderCapabilities;\n   121→  complete(model: string, messages: Message[], options?: CompletionOptions): Promise<CompletionResult>;\n   122→  stream(model: string, messages: Message[], options?: CompletionOptions): AsyncGenerator<StreamChunk>;\n   123→  countTokens(messages: Message[]): Promise<number>;\n   124→}\n   125→\n   126→/**\n   127→ * Completion options\n   128→ */\n   129→export interface CompletionOptions {\n   130→  maxTokens?: number;\n   131→  temperature?: number;\n   132→  topP?: number;\n   133→  tools?: Tool[];\n   134→  stream?: boolean;\n   135→}\n   136→\n   137→/**\n   138→ * Completion result\n   139→ */\n   140→export interface CompletionResult {\n   141→  content: MessageContent | Array<MessageContent>;\n   142→  model: string;\n   143→  stopReason?: string;\n   144→  usage?: {\n   145→    inputTokens: number;\n   146→    outputTokens: number;\n   147→    totalTokens: number;\n   148→  };\n   149→}\n   150→\n\n</system-reminder>\n"}]},"uuid":"ba000583-2e85-46b4-ae90-758361ee6b7e","timestamp":"2026-01-12T06:23:24.029Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/types/index.ts","content":"/**\n * Core type definitions for KOMPLETE-KONTROL CLI\n * \n * This file contains all shared type definitions used across the application.\n */\n\n/**\n * Message role types for AI interactions\n */\nexport type MessageRole = 'user' | 'assistant' | 'system' | 'tool';\n\n/**\n * Content types for messages\n */\nexport type ContentType = 'text' | 'image' | 'tool_use' | 'tool_result';\n\n/**\n * Base message content interface\n */\nexport interface MessageContent {\n  type: ContentType;\n}\n\n/**\n * Text content\n */\nexport interface TextContent extends MessageContent {\n  type: 'text';\n  text: string;\n}\n\n/**\n * Image content\n */\nexport interface ImageContent extends MessageContent {\n  type: 'image';\n  source: {\n    type: 'url' | 'base64';\n    data: string;\n    media_type?: string;\n  };\n}\n\n/**\n * Tool use content\n */\nexport interface ToolUseContent extends MessageContent {\n  type: 'tool_use';\n  id: string;\n  name: string;\n  input: Record<string, unknown>;\n}\n\n/**\n * Tool result content\n */\nexport interface ToolResultContent extends MessageContent {\n  type: 'tool_result';\n  tool_use_id: string;\n  content?: string | Array<MessageContent>;\n  is_error?: boolean;\n}\n\n/**\n * Complete message structure\n */\nexport interface Message {\n  role: MessageRole;\n  content: MessageContent | Array<MessageContent>;\n}\n\n/**\n * Tool definition\n */\nexport interface Tool {\n  name: string;\n  description: string;\n  inputSchema: Record<string, unknown>;\n}\n\n/**\n * Provider prefix types\n */\nexport type ProviderPrefix =\n  | 'or'   // OpenRouter\n  | 'g'    // Groq\n  | 'oai'  // OpenAI\n  | 'anthropic'  // Anthropic\n  | 'ollama'  // Ollama\n  | 'fl';  // Featherless\n\n/**\n * Model configuration\n */\nexport interface ModelConfig {\n  name: string;\n  prefix: ProviderPrefix;\n  maxTokens: number;\n  supportsVision: boolean;\n  supportsTools: boolean;\n  costPer1kTokens: number;\n}\n\n/**\n * Provider capabilities\n */\nexport interface ProviderCapabilities {\n  streaming: boolean;\n  tools: boolean;\n  vision: boolean;\n  maxTokens: number;\n}\n\n/**\n * AI Provider interface\n */\nexport interface AIProvider {\n  name: string;\n  prefix: ProviderPrefix;\n  capabilities: ProviderCapabilities;\n  complete(model: string, messages: Message[], options?: CompletionOptions): Promise<CompletionResult>;\n  stream(model: string, messages: Message[], options?: CompletionOptions): AsyncGenerator<StreamChunk>;\n  countTokens(messages: Message[]): Promise<number>;\n}\n\n/**\n * Completion options\n */\nexport interface CompletionOptions {\n  maxTokens?: number;\n  temperature?: number;\n  topP?: number;\n  tools?: Tool[];\n  stream?: boolean;\n}\n\n/**\n * Completion result\n */\nexport interface CompletionResult {\n  content: MessageContent | Array<MessageContent>;\n  model: string;\n  stopReason?: string;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalTokens: number;\n  };\n}\n","numLines":150,"startLine":1,"totalLines":610}}}
{"parentUuid":"ba000583-2e85-46b4-ae90-758361ee6b7e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01WsYJkTL73hLhJzHm3K2FBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QetL5ozaZ5Rsx6fw2wdBQz","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/types/index.ts","offset":150,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1520,"cache_read_input_tokens":60550,"cache_creation":{"ephemeral_5m_input_tokens":1520,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CX31BxHDQrtJCajuJGbtF","type":"assistant","uuid":"b1b77745-7afb-4e74-8d2e-3aaa279e6aab","timestamp":"2026-01-12T06:23:25.625Z"}
{"parentUuid":"b1b77745-7afb-4e74-8d2e-3aaa279e6aab","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QetL5ozaZ5Rsx6fw2wdBQz","type":"tool_result","content":"   150→\n   151→/**\n   152→ * Stream chunk\n   153→ */\n   154→export interface StreamChunk {\n   155→  content?: MessageContent;\n   156→  delta?: string;\n   157→  done?: boolean;\n   158→  usage?: {\n   159→    inputTokens: number;\n   160→    outputTokens: number;\n   161→    totalTokens: number;\n   162→  };\n   163→}\n   164→\n   165→/**\n   166→ * Agent definition\n   167→ */\n   168→export interface AgentDefinition {\n   169→  id: string;\n   170→  name: string;\n   171→  description: string;\n   172→  capabilities: string[];\n   173→  systemPrompt: string;\n   174→  dependencies?: string[];\n   175→  tags?: string[];\n   176→}\n   177→\n   178→/**\n   179→ * Agent task\n   180→ */\n   181→export interface AgentTask {\n   182→  id: string;\n   183→  agentId: string;\n   184→  description: string;\n   185→  type: 'cpu-bound' | 'io-bound' | 'isolated';\n   186→  priority: number;\n   187→  requiredCapability?: string;\n   188→  input: Record<string, unknown>;\n   189→}\n   190→\n   191→/**\n   192→ * Agent task result\n   193→ */\n   194→export interface AgentTaskResult {\n   195→  taskId: string;\n   196→  success: boolean;\n   197→  output?: unknown;\n   198→  error?: string;\n   199→  metadata?: Record<string, unknown>;\n   200→}\n   201→\n   202→/**\n   203→ * Context message with metadata\n   204→ */\n   205→export interface ContextMessage {\n   206→  id: string;\n   207→  role: MessageRole;\n   208→  content: MessageContent | Array<MessageContent>;\n   209→  timestamp?: Date;\n   210→  tokens?: number;\n   211→  priority?: number;\n   212→  message?: string;\n   213→}\n   214→\n   215→/**\n   216→ * Context window configuration\n   217→ */\n   218→export interface ContextWindowConfig {\n   219→  maxTokens: number;\n   220→  maxMessages: number;\n   221→  preserveToolUse: boolean;\n   222→}\n   223→\n   224→/**\n   225→ * Token counting method\n   226→ */\n   227→export type TokenCountMethod = 'char' | 'word' | 'model';\n   228→\n   229→/**\n   230→ * Token pricing\n   231→ */\n   232→export interface TokenPricing {\n   233→  inputPrice: number;\n   234→  outputPrice: number;\n   235→  currency?: string;\n   236→}\n   237→\n   238→/**\n   239→ * Token usage\n   240→ */\n   241→export interface TokenUsage {\n   242→  totalTokens: number;\n   243→  totalCost: number;\n   244→  sessions: number;\n   245→}\n   246→\n   247→/**\n   248→ * Token budget configuration\n   249→ */\n   250→export interface TokenBudgetConfig {\n   251→  limit: number;\n   252→  alertThreshold?: number;\n   253→}\n   254→\n   255→/**\n   256→ * Abstract condenser interface\n   257→ */\n   258→export interface ICondenser {\n   259→  condense(messages: ContextMessage[], targetSize: number): ContextMessage[];\n   260→  shouldPreserve(message: ContextMessage): boolean;\n   261→  updateConfig(config: Partial<CondensationConfig>): void;\n   262→  getConfig(): CondensationConfig;\n   263→}\n   264→\n   265→/**\n   266→ * Token-based condenser configuration\n   267→ */\n   268→export interface TokenBasedConfig extends CondensationConfig {\n   269→  strategy: 'token-based';\n   270→  minTokensPerMessage?: number;\n   271→  maxTokensPerMessage?: number;\n   272→  preferRecent?: boolean;\n   273→  recentWindowMs?: number;\n   274→}\n   275→\n   276→/**\n   277→ * Semantic condenser configuration\n   278→ */\n   279→export interface SemanticConfig extends CondensationConfig {\n   280→  strategy: 'semantic';\n   281→  embeddingModel: string;\n   282→  similarityThreshold: number;\n   283→  clusterSize: number;\n   284→  preserveKeyMessages?: boolean;\n   285→  keyMessageKeywords?: string[];\n   286→}\n   287→\n   288→/**\n   289→ * Context sharing configuration\n   290→ */\n   291→export interface ContextSharingConfig {\n   292→  enabled: boolean;\n   293→  shareAcrossSessions: boolean;\n   294→  shareKeywords: string[];\n   295→  maxSharedMessages: number;\n   296→  sharedMessageTtl: number;\n   297→}\n   298→\n   299→/**\n   300→ * Shared context entry\n   301→ */\n   302→export interface SharedContextEntry {\n   303→  id: string;\n   304→  sourceSessionId: string;\n   305→  message: ContextMessage;\n   306→  relevanceScore: number;\n   307→  createdAt: Date;\n   308→  expiresAt: Date;\n   309→  keywords: string[];\n   310→}\n   311→\n   312→/**\n   313→ * Tool selection criteria\n   314→ */\n   315→export interface ToolSelectionCriteria {\n   316→  contextKeywords: string[];\n   317→  recentToolUsage: Map<string, number>;\n   318→  toolSuccessRate: Map<string, number>;\n   319→  contextComplexity: 'simple' | 'medium' | 'complex';\n   320→  taskType?: string;\n   321→}\n   322→\n   323→/**\n   324→ * Tool recommendation\n   325→ */\n   326→export interface ToolRecommendation {\n   327→  tool: string;\n   328→  confidence: number;\n   329→  reason: string;\n   330→  estimatedTokens: number;\n   331→}\n   332→\n   333→/**\n   334→ * Context optimization result\n   335→ */\n   336→export interface ContextOptimizationResult {\n   337→  optimizedMessages: ContextMessage[];\n   338→  removedCount: number;\n   339→  preservedCount: number;\n   340→  summaryCount: number;\n   341→  tokenSavings: number;\n   342→  compressionRatio: number;\n   343→}\n   344→\n   345→/**\n   346→ * Context optimization configuration\n   347→ */\n   348→export interface ContextOptimizationConfig {\n   349→  aggressiveMode: boolean;\n\n</system-reminder>\n"}]},"uuid":"2a2bbac7-f8f2-412d-b134-02a35d3f13cf","timestamp":"2026-01-12T06:23:25.665Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/types/index.ts","content":"\n/**\n * Stream chunk\n */\nexport interface StreamChunk {\n  content?: MessageContent;\n  delta?: string;\n  done?: boolean;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalTokens: number;\n  };\n}\n\n/**\n * Agent definition\n */\nexport interface AgentDefinition {\n  id: string;\n  name: string;\n  description: string;\n  capabilities: string[];\n  systemPrompt: string;\n  dependencies?: string[];\n  tags?: string[];\n}\n\n/**\n * Agent task\n */\nexport interface AgentTask {\n  id: string;\n  agentId: string;\n  description: string;\n  type: 'cpu-bound' | 'io-bound' | 'isolated';\n  priority: number;\n  requiredCapability?: string;\n  input: Record<string, unknown>;\n}\n\n/**\n * Agent task result\n */\nexport interface AgentTaskResult {\n  taskId: string;\n  success: boolean;\n  output?: unknown;\n  error?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Context message with metadata\n */\nexport interface ContextMessage {\n  id: string;\n  role: MessageRole;\n  content: MessageContent | Array<MessageContent>;\n  timestamp?: Date;\n  tokens?: number;\n  priority?: number;\n  message?: string;\n}\n\n/**\n * Context window configuration\n */\nexport interface ContextWindowConfig {\n  maxTokens: number;\n  maxMessages: number;\n  preserveToolUse: boolean;\n}\n\n/**\n * Token counting method\n */\nexport type TokenCountMethod = 'char' | 'word' | 'model';\n\n/**\n * Token pricing\n */\nexport interface TokenPricing {\n  inputPrice: number;\n  outputPrice: number;\n  currency?: string;\n}\n\n/**\n * Token usage\n */\nexport interface TokenUsage {\n  totalTokens: number;\n  totalCost: number;\n  sessions: number;\n}\n\n/**\n * Token budget configuration\n */\nexport interface TokenBudgetConfig {\n  limit: number;\n  alertThreshold?: number;\n}\n\n/**\n * Abstract condenser interface\n */\nexport interface ICondenser {\n  condense(messages: ContextMessage[], targetSize: number): ContextMessage[];\n  shouldPreserve(message: ContextMessage): boolean;\n  updateConfig(config: Partial<CondensationConfig>): void;\n  getConfig(): CondensationConfig;\n}\n\n/**\n * Token-based condenser configuration\n */\nexport interface TokenBasedConfig extends CondensationConfig {\n  strategy: 'token-based';\n  minTokensPerMessage?: number;\n  maxTokensPerMessage?: number;\n  preferRecent?: boolean;\n  recentWindowMs?: number;\n}\n\n/**\n * Semantic condenser configuration\n */\nexport interface SemanticConfig extends CondensationConfig {\n  strategy: 'semantic';\n  embeddingModel: string;\n  similarityThreshold: number;\n  clusterSize: number;\n  preserveKeyMessages?: boolean;\n  keyMessageKeywords?: string[];\n}\n\n/**\n * Context sharing configuration\n */\nexport interface ContextSharingConfig {\n  enabled: boolean;\n  shareAcrossSessions: boolean;\n  shareKeywords: string[];\n  maxSharedMessages: number;\n  sharedMessageTtl: number;\n}\n\n/**\n * Shared context entry\n */\nexport interface SharedContextEntry {\n  id: string;\n  sourceSessionId: string;\n  message: ContextMessage;\n  relevanceScore: number;\n  createdAt: Date;\n  expiresAt: Date;\n  keywords: string[];\n}\n\n/**\n * Tool selection criteria\n */\nexport interface ToolSelectionCriteria {\n  contextKeywords: string[];\n  recentToolUsage: Map<string, number>;\n  toolSuccessRate: Map<string, number>;\n  contextComplexity: 'simple' | 'medium' | 'complex';\n  taskType?: string;\n}\n\n/**\n * Tool recommendation\n */\nexport interface ToolRecommendation {\n  tool: string;\n  confidence: number;\n  reason: string;\n  estimatedTokens: number;\n}\n\n/**\n * Context optimization result\n */\nexport interface ContextOptimizationResult {\n  optimizedMessages: ContextMessage[];\n  removedCount: number;\n  preservedCount: number;\n  summaryCount: number;\n  tokenSavings: number;\n  compressionRatio: number;\n}\n\n/**\n * Context optimization configuration\n */\nexport interface ContextOptimizationConfig {\n  aggressiveMode: boolean;","numLines":200,"startLine":150,"totalLines":610}}}
{"parentUuid":"2a2bbac7-f8f2-412d-b134-02a35d3f13cf","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016pXq8sDwoBppy1c11Rzh5F","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check if there are any utilities or examples that show how these components integrate:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":2057,"cache_read_input_tokens":62070,"cache_creation":{"ephemeral_5m_input_tokens":2057,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX31C5EAsc3rUC8p4rrbk","type":"assistant","uuid":"b55011ab-88a4-40e0-8910-8ce5dbb19801","timestamp":"2026-01-12T06:23:27.060Z"}
{"parentUuid":"b55011ab-88a4-40e0-8910-8ce5dbb19801","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016pXq8sDwoBppy1c11Rzh5F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017LJx3B5ziPXxpzneWhTxVZ","name":"Bash","input":{"command":"find /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src -name \"*agent*\" -o -name \"*provider*\" | grep -E \"\\.(ts|tsx)$\" | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":2057,"cache_read_input_tokens":62070,"cache_creation":{"ephemeral_5m_input_tokens":2057,"ephemeral_1h_input_tokens":0},"output_tokens":121,"service_tier":"standard"}},"requestId":"req_011CX31C5EAsc3rUC8p4rrbk","type":"assistant","uuid":"dfff7e8f-1453-4ec6-a8e5-bf8914573f7c","timestamp":"2026-01-12T06:23:27.778Z"}
{"parentUuid":"dfff7e8f-1453-4ec6-a8e5-bf8914573f7c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017LJx3B5ziPXxpzneWhTxVZ","type":"tool_result","content":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/test-agents.ts","is_error":false}]},"uuid":"80907e5c-8046-44ca-9974-8daa38da5c76","timestamp":"2026-01-12T06:23:27.881Z","toolUseResult":{"stdout":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/agents/test-agents.ts","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"80907e5c-8046-44ca-9974-8daa38da5c76","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01LJ6WNaNB2gACjDxWKR3K6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WvXNoTbigmbJo5awkCskup","name":"Bash","input":{"command":"find /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/providers -type f -name \"*.ts\" | head -10"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":443,"cache_read_input_tokens":64127,"cache_creation":{"ephemeral_5m_input_tokens":443,"ephemeral_1h_input_tokens":0},"output_tokens":87,"service_tier":"standard"}},"requestId":"req_011CX31CEghA41pxXtTaTnn6","type":"assistant","uuid":"6387eb8f-58d6-47e9-9914-1a87fda845fe","timestamp":"2026-01-12T06:23:29.501Z"}
{"parentUuid":"6387eb8f-58d6-47e9-9914-1a87fda845fe","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WvXNoTbigmbJo5awkCskup","type":"tool_result","content":"find: /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/providers: No such file or directory","is_error":false}]},"uuid":"57a78c5e-70d9-45a6-b528-f2ed013e1a8f","timestamp":"2026-01-12T06:23:29.592Z","toolUseResult":{"stdout":"find: /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/providers: No such file or directory","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"57a78c5e-70d9-45a6-b528-f2ed013e1a8f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GgMAYmH6Us59rdvCN1yTc3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018WmuPoSoaCUVsin3PhMBwv","name":"Bash","input":{"command":"ls -la /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":269,"cache_read_input_tokens":64570,"cache_creation":{"ephemeral_5m_input_tokens":269,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"}},"requestId":"req_011CX31CMzjE3tRY1tmaFrCr","type":"assistant","uuid":"8de28a90-06c4-4933-afb7-361853e2fcfd","timestamp":"2026-01-12T06:23:31.053Z"}
{"parentUuid":"8de28a90-06c4-4933-afb7-361853e2fcfd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018WmuPoSoaCUVsin3PhMBwv","type":"tool_result","content":"total 0\ndrwxr-xr-x@ 10 imorgado  staff  320 Jan 11 22:49 .\ndrwxr-xr-x@ 10 imorgado  staff  320 Jan 11 20:18 ..\ndrwxr-xr-x@  9 imorgado  staff  288 Jan 11 15:43 agents\ndrwxr-xr-x@  7 imorgado  staff  224 Jan 11 20:04 commands\ndrwxr-xr-x@ 12 imorgado  staff  384 Jan 11 23:09 context\ndrwxr-xr-x@  2 imorgado  staff   64 Jan 11 12:10 indexing\ndrwxr-xr-x@ 10 imorgado  staff  320 Jan 12 00:40 providers\ndrwxr-xr-x@  2 imorgado  staff   64 Jan 11 12:10 router\ndrwxr-xr-x@  2 imorgado  staff   64 Jan 11 12:10 session\ndrwxr-xr-x@  7 imorgado  staff  224 Jan 11 22:55 tasks","is_error":false}]},"uuid":"fbbc2c5c-bc28-4453-8812-b59daf1ab1e1","timestamp":"2026-01-12T06:23:31.144Z","toolUseResult":{"stdout":"total 0\ndrwxr-xr-x@ 10 imorgado  staff  320 Jan 11 22:49 .\ndrwxr-xr-x@ 10 imorgado  staff  320 Jan 11 20:18 ..\ndrwxr-xr-x@  9 imorgado  staff  288 Jan 11 15:43 agents\ndrwxr-xr-x@  7 imorgado  staff  224 Jan 11 20:04 commands\ndrwxr-xr-x@ 12 imorgado  staff  384 Jan 11 23:09 context\ndrwxr-xr-x@  2 imorgado  staff   64 Jan 11 12:10 indexing\ndrwxr-xr-x@ 10 imorgado  staff  320 Jan 12 00:40 providers\ndrwxr-xr-x@  2 imorgado  staff   64 Jan 11 12:10 router\ndrwxr-xr-x@  2 imorgado  staff   64 Jan 11 12:10 session\ndrwxr-xr-x@  7 imorgado  staff  224 Jan 11 22:55 tasks","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"fbbc2c5c-bc28-4453-8812-b59daf1ab1e1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01H3nXw7t7ssmqrTZMZASMJm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TmqEx9QiLUor8jk5rCuwJC","name":"Bash","input":{"command":"ls -la /Users/imorgado/Desktop/Projects/komplete-kontrol-cli/src/core/providers/ | head -20"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":438,"cache_read_input_tokens":64839,"cache_creation":{"ephemeral_5m_input_tokens":438,"ephemeral_1h_input_tokens":0},"output_tokens":83,"service_tier":"standard"}},"requestId":"req_011CX31CUd6SA7MpVooo3omU","type":"assistant","uuid":"990b160c-3afe-467e-af61-977098e7c682","timestamp":"2026-01-12T06:23:32.379Z"}
{"parentUuid":"990b160c-3afe-467e-af61-977098e7c682","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TmqEx9QiLUor8jk5rCuwJC","type":"tool_result","content":"total 128\ndrwxr-xr-x@ 10 imorgado  staff    320 Jan 12 00:40 .\ndrwxr-xr-x@ 10 imorgado  staff    320 Jan 11 22:49 ..\ndrwxr-xr-x@  8 imorgado  staff    256 Jan 12 00:40 advanced\n-rw-r--r--@  1 imorgado  staff  11877 Jan 11 19:25 anthropic.ts\n-rw-r--r--@  1 imorgado  staff   7288 Jan 11 19:22 base.ts\n-rw-r--r--@  1 imorgado  staff   2773 Jan 11 19:25 index.ts\n-rw-r--r--@  1 imorgado  staff  10258 Jan 11 19:25 ollama.ts\n-rw-r--r--@  1 imorgado  staff   9177 Jan 11 19:24 openai.ts\n-rw-r--r--@  1 imorgado  staff   6169 Jan 11 19:23 registry.ts\n-rw-r--r--@  1 imorgado  staff   5438 Jan 11 19:23 router.ts","is_error":false}]},"uuid":"b144497e-ea8c-4e89-bd4e-c0ecd25589f3","timestamp":"2026-01-12T06:23:32.476Z","toolUseResult":{"stdout":"total 128\ndrwxr-xr-x@ 10 imorgado  staff    320 Jan 12 00:40 .\ndrwxr-xr-x@ 10 imorgado  staff    320 Jan 11 22:49 ..\ndrwxr-xr-x@  8 imorgado  staff    256 Jan 12 00:40 advanced\n-rw-r--r--@  1 imorgado  staff  11877 Jan 11 19:25 anthropic.ts\n-rw-r--r--@  1 imorgado  staff   7288 Jan 11 19:22 base.ts\n-rw-r--r--@  1 imorgado  staff   2773 Jan 11 19:25 index.ts\n-rw-r--r--@  1 imorgado  staff  10258 Jan 11 19:25 ollama.ts\n-rw-r--r--@  1 imorgado  staff   9177 Jan 11 19:24 openai.ts\n-rw-r--r--@  1 imorgado  staff   6169 Jan 11 19:23 registry.ts\n-rw-r--r--@  1 imorgado  staff   5438 Jan 11 19:23 router.ts","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"b144497e-ea8c-4e89-bd4e-c0ecd25589f3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/Desktop/Projects/komplete-kontrol-cli","sessionId":"506a47cb-9d2e-42bf-b69c-a397de5890e7","version":"2.0.76","gitBranch":"","agentId":"abaa801","slug":"humming-honking-breeze","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JLVwrUgMdseLQonk6PR1iP","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding of the agent system. Let me compile my detailed analysis:\n\n## Comprehensive Agent System Analysis\n\nBased on my thorough review of the agent system in `src/core/agents/`, here's a detailed breakdown:\n\n---\n\n### **1. WHAT'S ALREADY IMPLEMENTED**\n\n#### **A. Agent Registry (`registry.ts`)**\n- **Purpose**: Central agent discovery and management\n- **Current Features**:\n  - Agent registration with metadata (priorities, tags)\n  - Agent lookup by ID, capability, tag\n  - Status management (registered, active, paused, unregistered)\n  - Dependency tracking (validates dependencies between agents)\n  - Statistics collection (agent counts, capability distribution)\n  - Priority-based sorting for agent selection\n  - Last-used timestamp tracking\n\n- **Key Methods**:\n  - `register()` - Register agents with auto-start option\n  - `list()` - Filter by capability, tag, status, priority\n  - `findByCapability()` / `findByTag()`\n  - `checkDependencies()` - Validates agent dependencies\n  - `getDependents()` - Find agents depending on a given agent\n  - `updateStatus()` - Change agent state\n  - `getStatistics()` - Registry health metrics\n\n#### **B. Agent Lifecycle Manager (`lifecycle.ts`)**\n- **Purpose**: Control agent state transitions and lifecycle events\n- **State Machine** (11 states):\n  - CREATED → INITIALIZING → INITIALIZED → STARTING → RUNNING\n  - RUNNING → PAUSING → PAUSED → RUNNING\n  - RUNNING/PAUSED → STOPPING → STOPPED\n  - Any state → DISPOSING → DISPOSED\n  - Any state → ERROR\n\n- **Event System** (18 lifecycle events):\n  - Before/after events: BEFORE_INIT, INITIALIZED, INIT_ERROR\n  - Status changes emit events with handlers\n  - Async event handler support\n\n- **Execution Context** per agent:\n  - Task history tracking\n  - Custom context data (key-value)\n  - Current task reference\n  - Error tracking\n\n- **Key Methods**:\n  - `initialize()` - Prep agent with dependency checking\n  - `start()` - Transition to running\n  - `pause()` / `resume()` - Pause/resume execution\n  - `stop()` - Stop without disposal\n  - `dispose()` - Full cleanup\n  - `getActiveAgents()` - List all active agents\n  - Event handler registration\n\n#### **C. Agent Orchestrator (`orchestrator.ts`)**\n- **Purpose**: Multi-agent task distribution and scheduling\n- **Task Management**:\n  - Task queue with priority-based sorting (LOW=0 to CRITICAL=3)\n  - Task status tracking (PENDING → ASSIGNED → EXECUTING → COMPLETED/FAILED)\n  - Max concurrent tasks limit (default 5)\n  - Task timeout with configurable defaults (30s)\n  - Automatic retry on failure (up to 3 retries by default)\n\n- **Agent Selection Strategies**:\n  - FIRST_AVAILABLE - Pick first qualified agent\n  - HIGHEST_PRIORITY - Use registered priority order\n  - LEAST_RECENTLY_USED - Load balancing\n  - ROUND_ROBIN - Distribute evenly\n\n- **Task Features**:\n  - Selection based on required capability\n  - Task assignment tracking\n  - Execution timing (createdAt, startedAt, completedAt)\n  - Error capture and retry logic\n  - Statistics (pending, executing, completed, failed, cancelled)\n\n- **Limitations**:\n  - `performTaskExecution()` is a PLACEHOLDER - doesn't actually call agent methods\n  - No persistent task storage between sessions\n  - No priority-based queue re-sorting after assignment\n\n#### **D. Agent Communication Manager (`communication.ts`)**\n- **Purpose**: Inter-agent messaging system\n- **Message Types**:\n  - REQUEST (expects response)\n  - RESPONSE (reply to request)\n  - NOTIFICATION (fire-and-forget)\n  - BROADCAST (to all agents)\n\n- **Message Priorities**: LOW (0) to CRITICAL (3)\n\n- **Features**:\n  - Request-response pattern with correlation IDs\n  - TTL (time-to-live) for message expiration\n  - Message history tracking (capped at 1000 messages by default)\n  - Handler and filter registration per agent\n  - Message validation\n\n- **Key Methods**:\n  - `send()` - Send message to specific agent\n  - `request()` - Request-response with timeout (30s)\n  - `respond()` - Send response to request\n  - `notify()` - Send notification\n  - `broadcast()` - Send to all agents\n  - `registerHandler()` / `registerFilter()` - Set up message handling\n\n- **Message Filtering**:\n  - Can register multiple filters per agent\n  - All filters must pass for message delivery\n\n#### **E. Agent Coordination Manager (`coordination.ts`)**\n- **Purpose**: Synchronization and shared state primitives\n- **Components**:\n\n  1. **TaskQueue** - Priority task queue\n     - Generic type support\n     - Priority-based ordering\n     - Enqueue/dequeue operations\n     - Item metadata support\n     - Statistics per priority level\n     \n  2. **SharedState** - Distributed state management\n     - Versioning support (automatic version increments)\n     - Update tracking (who updated, when)\n     - History tracking (up to 100 entries by default)\n     - Get/set with defaults\n     \n  3. **Barrier** - Synchronization primitive\n     - Wait for N agents to arrive\n     - Timeout support (30s default)\n     - Reset capability\n     - Count tracking (arrived vs expected)\n     \n  4. **Semaphore** - Resource management\n     - Counting semaphore with permits\n     - Acquire/release operations\n     - Queue-based waiting agents\n\n---\n\n### **2. HOW AGENTS ARE REGISTERED AND MANAGED**\n\n**Registration Flow**:\n```\n1. Create AgentDefinition (id, name, capabilities, systemPrompt)\n2. Call registry.register() with options (priority, tags, autoStart)\n3. Registry validates (non-empty fields, dependencies exist)\n4. Optionally auto-start or manual start via lifecycle manager\n5. Agent transitions through states: INITIALIZING → INITIALIZED → RUNNING\n```\n\n**Test Agents Included**:\n- GENERAL_AGENT (chat, code-assist, analysis, research)\n- CODER_AGENT (code, debug, refactor, code-review) - depends on general\n- REVERSE_ENGINEER_AGENT (reverse-engineering, binary-analysis) - depends on coder & general\n\n**Management**:\n- Each agent has an AgentInstance with state, context, and error tracking\n- Status updates sync between registry and lifecycle manager\n- Dependency checking prevents invalid states\n\n---\n\n### **3. HOW TASK DISTRIBUTION WORKS**\n\n**Task Flow**:\n```\nsubmitTask(task, priority)\n  ↓\nAdd to taskQueue with priority sort\n  ↓\nprocessQueue()\n  ↓\nselectAgent(criteria) - Based on capability, tag, strategy\n  ↓\nassignTask(task, agentId)\n  ↓\nexecuteTask(task) - WITH TIMEOUT\n  ↓\nOn success: Mark COMPLETED, mark agent as used\nOn failure: Retry if count < maxRetries, else FAILED\n```\n\n**Queue Management**:\n- Tasks sorted by: priority (descending) → creation time (ascending)\n- Max 5 concurrent tasks by default (configurable)\n- Task IDs auto-generated: `task_${timestamp}_${random}`\n- No inter-task dependencies or workflow chaining\n\n---\n\n### **4. HOW AGENTS COMMUNICATE**\n\n**Patterns Supported**:\n\n1. **Request-Response**:\n   - Sender calls `request(from, to, subject, payload, timeout)`\n   - Returns Promise that resolves with response\n   - Uses correlationId for matching\n   - 30s default timeout\n\n2. **Notification**:\n   - Fire-and-forget message\n   - Priority levels supported\n   - No response expected\n\n3. **Broadcast**:\n   - One-to-many messaging\n   - Skips sender\n   - All non-sender handlers receive it\n\n4. **Message Filtering**:\n   - Multiple filters per agent\n   - All must pass for delivery\n   - Custom logic can inspect and drop messages\n\n**Message Structure**:\n- id, type, from, to, subject, payload\n- priority, timestamp, correlationId, replyTo\n- TTL with automatic expiration\n- metadata for custom data\n\n---\n\n### **5. COORDINATION AND SYNCHRONIZATION**\n\n**Shared State**:\n```typescript\nconst state = coordinator.getState('myState');\nstate.set('key', value, 'agent-id'); // Versioned\nconst val = state.get('key', defaultValue);\nstate.getHistory('key'); // Full version history\n```\n\n**Barriers** (Wait for N agents):\n```typescript\nconst barrier = coordinator.getBarrier('sync-point', 3); // 3 agents\nawait barrier.wait('agent-1');\n// Resolves when 3 agents call wait()\n```\n\n**Semaphores** (Resource pools):\n```typescript\nconst semaphore = coordinator.getSemaphore('resource-pool', 2); // 2 permits\nawait semaphore.acquire(); // Blocks if none available\nsemaphore.release();\n```\n\n**Task Queues** (Producer-consumer):\n```typescript\nconst queue = coordinator.getQueue('tasks');\nconst id = queue.enqueue(data, QueuePriority.HIGH);\nconst item = queue.dequeue();\n```\n\n---\n\n### **6. MAJOR GAPS AND AREAS FOR ENHANCEMENT**\n\n#### **Critical Gaps**:\n\n1. **No Agent Execution Implementation**\n   - `performTaskExecution()` in orchestrator is a placeholder\n   - Doesn't actually invoke agent capabilities\n   - No connection to providers or MCP servers\n   - Tasks don't call agent methods or system prompts\n   - **MISSING**: Integration point between orchestrator and actual agent execution\n\n2. **No Workflow/Pipeline Support**\n   - No inter-task dependencies\n   - No agent chaining (Agent A output → Agent B input)\n   - No conditional task flows\n   - Can't express \"run A then B then C\"\n   - **MISSING**: Workflow definition and execution engine\n\n3. **No Agent Tool/Capability Linking**\n   - Capabilities are just strings in a list\n   - No mapping to actual functions/tools\n   - Can't specify what each capability does\n   - **MISSING**: Tool registry or capability handlers\n\n4. **Limited Orchestration Logic**\n   - Agent selection is basic (priority, capability, tag)\n   - No skill-based matching\n   - No load balancing metrics\n   - No resource constraints (memory, CPU)\n   - No agent performance tracking\n   - **MISSING**: Intelligent agent selection based on task complexity\n\n5. **No Provider Integration**\n   - Agents don't connect to LLM providers (Anthropic, OpenAI, Ollama)\n   - No message/tool generation for agents\n   - Can't access provider capabilities\n   - **MISSING**: Bridge between agents and `src/core/providers`\n\n6. **No MCP Support**\n   - No Model Context Protocol integration\n   - Agents can't use external tools/resources\n   - No dynamic tool discovery\n   - **MISSING**: MCP server connection and tool exposure\n\n7. **No Context Management**\n   - Agents don't have conversation histories\n   - No context window management\n   - No message condensation\n   - Can't share context across agents\n   - **MISSING**: Link to `src/core/context` system\n\n8. **No Persistence**\n   - Agent state lost on restart\n   - Task execution not logged\n   - No checkpoint/resume capability\n   - **MISSING**: Database integration or state snapshots\n\n9. **No Monitoring/Observability**\n   - No metrics on agent performance\n   - No latency tracking\n   - No error rate analysis\n   - No cost tracking (if using paid providers)\n   - **MISSING**: Comprehensive observability system\n\n10. **Limited Error Handling**\n    - Basic retry logic (count only)\n    - No exponential backoff\n    - No circuit breaker pattern\n    - No fallback agent selection\n    - **MISSING**: Sophisticated error recovery\n\n11. **No Agent Specialization**\n    - Agents are generic containers\n    - No base class or specialized agent types\n    - No role-based constraints\n    - **MISSING**: Domain-specific agent types (SearchAgent, CodingAgent, etc.)\n\n12. **No Time-Series Support**\n    - Barriers wait indefinitely or timeout\n    - No periodic task scheduling\n    - No recurring/scheduled tasks\n    - No time-based coordination\n    - **MISSING**: Scheduling system (cron-like)\n\n---\n\n### **7. CODE PATTERNS BEING USED**\n\n**Architecture Patterns**:\n- **Singleton Pattern**: Global instances with getters (`getAgentRegistry()`, `getAgentOrchestrator()`)\n- **State Machine**: Lifecycle manager with explicit state transitions\n- **Observer Pattern**: Event handlers for lifecycle events\n- **Message Queue**: Task queue with priority-based dispatch\n- **Pub-Sub**: Communication manager with broadcast capability\n- **Resource Pool**: Semaphores for coordinating limited resources\n\n**Type Safety**:\n- Comprehensive TypeScript interfaces for all public APIs\n- Enums for well-defined values (TaskPriority, TaskStatus, AgentLifecycleState)\n- Generics for flexible components (TaskQueue<T>, SharedState)\n\n**Configuration**:\n- Builder-like pattern with optional configs and sensible defaults\n- Config interfaces that separate concerns (registry doesn't know about orchestrator)\n\n**Logging**:\n- Logger instance passed through components\n- Contextual logging with component names and metadata\n- Debug, info, warn, error levels\n\n**Error Handling**:\n- Custom AgentError class with agent ID and metadata\n- Try-catch with error propagation\n- Validation before state changes\n\n---\n\n### **8. CONNECTIONS AND INTEGRATION POINTS**\n\n**Provider Integration** (MISSING):\n- Agents need to connect to `/src/core/providers/` for LLM execution\n- Should use provider registry to get appropriate LLM\n- Execute agent system prompts with provider\n\n**MCP Integration** (MISSING):\n- Agents should expose tools/capabilities to MCP servers\n- Should discover and use external tools via MCP\n\n**Context Integration** (MISSING):\n- Agents should use context manager from `/src/core/context/`\n- Share conversation history and context windows\n- Use message condensation for long conversations\n\n**Task Integration** (MISSING):\n- Orchestrator tasks should integrate with `/src/core/tasks/`\n- Track task execution in persistent store\n- Support task lifecycle beyond memory\n\n**Command Integration** (POSSIBLE):\n- CLI commands in `/src/core/commands/` could submit tasks to orchestrator\n- Orchestrator could provide status updates to commands\n\n---\n\n### **SUMMARY**\n\nThe agent system has a **solid foundation** with:\n- Clean separation of concerns (registry, lifecycle, orchestration, communication, coordination)\n- Good abstraction layers and interfaces\n- Multiple communication patterns supported\n- Synchronization primitives for coordination\n- Extensible design with global instances\n\nHowever, it's **incomplete** because:\n- No actual agent execution (placeholder only)\n- No provider/LLM integration\n- No workflow/chaining support\n- No tool/capability mapping\n- No context management integration\n- Missing integration with MCP servers\n- No persistence layer\n- Minimal observability\n\n**To make it production-ready**, the key missing piece is the **execution engine** that bridges agents → providers → actual task execution, along with workflow orchestration and context management."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":460,"cache_read_input_tokens":65277,"cache_creation":{"ephemeral_5m_input_tokens":460,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX31CaKe5r5vu61LUA78p","type":"assistant","uuid":"e2bf1df6-b02c-46b5-91c6-e1099262d046","timestamp":"2026-01-12T06:24:07.212Z"}
