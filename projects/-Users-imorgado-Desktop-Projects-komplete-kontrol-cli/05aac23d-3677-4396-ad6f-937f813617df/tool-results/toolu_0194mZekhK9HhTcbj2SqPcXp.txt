     1â†’#!/bin/bash
     2â†’# Auto-Continue Hook - Fully automated context management with quality awareness
     3â†’# V2 Enhanced with: context event tracking, sliding window fallback
     4â†’# When context hits threshold:
     5â†’# 1. Checks if build is in progress
     6â†’# 2. Runs validation before checkpoint
     7â†’# 3. Saves state and creates continuation prompt
     8â†’# 4. Feeds prompt back to keep running
     9â†’
    10â†’set -euo pipefail
    11â†’
    12â†’THRESHOLD=${CLAUDE_CONTEXT_THRESHOLD:-40}
    13â†’LOG_FILE="${HOME}/.claude/auto-continue.log"
    14â†’STATE_FILE=".claude/auto-continue.local.md"
    15â†’BUILD_STATE=".claude/current-build.local.md"
    16â†’
    17â†’# V2 Integration
    18â†’SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    19â†’EVENT_TRACKER="${SCRIPT_DIR}/context-event-tracker.sh"
    20â†’SLIDING_WINDOW="${SCRIPT_DIR}/sliding-window.sh"
    21â†’
    22â†’log() {
    23â†’    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
    24â†’}
    25â†’
    26â†’# Read hook input
    27â†’HOOK_INPUT=$(cat)
    28â†’
    29â†’# Extract context info
    30â†’CONTEXT_SIZE=$(echo "$HOOK_INPUT" | jq -r '.context_window.context_window_size // 200000')
    31â†’USAGE=$(echo "$HOOK_INPUT" | jq '.context_window.current_usage // null')
    32â†’TRANSCRIPT_PATH=$(echo "$HOOK_INPUT" | jq -r '.transcript_path // ""')
    33â†’
    34â†’if [[ "$USAGE" == "null" ]]; then
    35â†’    log "No usage data - allowing stop"
    36â†’    exit 0
    37â†’fi
    38â†’
    39â†’# Calculate percentage
    40â†’INPUT_TOKENS=$(echo "$USAGE" | jq -r '.input_tokens // 0')
    41â†’CACHE_CREATE=$(echo "$USAGE" | jq -r '.cache_creation_input_tokens // 0')
    42â†’CACHE_READ=$(echo "$USAGE" | jq -r '.cache_read_input_tokens // 0')
    43â†’CURRENT_TOKENS=$((INPUT_TOKENS + CACHE_CREATE + CACHE_READ))
    44â†’PERCENT=$((CURRENT_TOKENS * 100 / CONTEXT_SIZE))
    45â†’
    46â†’log "Context: ${PERCENT}% (${CURRENT_TOKENS}/${CONTEXT_SIZE})"
    47â†’
    48â†’# Check if auto-continue is disabled
    49â†’if [[ -f ".claude/auto-continue-disabled" ]]; then
    50â†’    log "Auto-continue disabled - allowing stop"
    51â†’    exit 0
    52â†’fi
    53â†’
    54â†’# Check for stop words in last message
    55â†’if [[ -n "$TRANSCRIPT_PATH" ]] && [[ -f "$TRANSCRIPT_PATH" ]]; then
    56â†’    LAST_USER=$(grep '"role":"user"' "$TRANSCRIPT_PATH" | tail -1 | jq -r '.message.content[0].text // ""' 2>/dev/null || echo "")
    57â†’    if echo "$LAST_USER" | grep -qiE '\b(stop|pause|hold|wait|quit)\b'; then
    58â†’        log "Stop word detected - allowing stop"
    59â†’        exit 0
    60â†’    fi
    61â†’fi
    62â†’
    63â†’# Below threshold - allow normal stop
    64â†’if [[ $PERCENT -lt $THRESHOLD ]]; then
    65â†’    exit 0
    66â†’fi
    67â†’
    68â†’log "Threshold reached (${PERCENT}% >= ${THRESHOLD}%) - triggering auto-continue"
    69â†’
    70â†’# PHASE 1 & 4 INTEGRATION: Check context budget and create checkpoint
    71â†’log "Checking memory context budget..."
    72â†’MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
    73â†’CHECKPOINT_ID=""
    74â†’
    75â†’if [[ -x "$MEMORY_MANAGER" ]]; then
    76â†’    # PHASE 4: Check context budget
    77â†’    CONTEXT_USAGE=$("$MEMORY_MANAGER" context-usage 2>/dev/null || echo "{}")
    78â†’    CONTEXT_STATUS=$(echo "$CONTEXT_USAGE" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
    79â†’
    80â†’    if [[ "$CONTEXT_STATUS" == "critical" || "$CONTEXT_STATUS" == "warning" ]]; then
    81â†’        log "âš ï¸  Memory context budget at warning/critical - compacting memory..."
    82â†’
    83â†’        # V2: Log event before compaction
    84â†’        local before_tokens=$CURRENT_TOKENS
    85â†’
    86â†’        # Attempt compaction
    87â†’        if "$MEMORY_MANAGER" context-compact 2>/dev/null; then
    88â†’            log "âœ… Memory compaction successful"
    89â†’
    90â†’            # V2: Log successful compaction event
    91â†’            if [[ -x "$EVENT_TRACKER" ]]; then
    92â†’                local after_tokens=$((CURRENT_TOKENS * 70 / 100))  # Estimate 30% reduction
    93â†’                "$EVENT_TRACKER" log compact_memory "$before_tokens" "$after_tokens" "auto" "true" "" 2>/dev/null || true
    94â†’            fi
    95â†’        else
    96â†’            log "âš ï¸  Memory compact failed - trying sliding window fallback"
    97â†’
    98â†’            # V2: Sliding window fallback
    99â†’            if [[ -x "$SLIDING_WINDOW" ]]; then
   100â†’                local strategy=$("$SLIDING_WINDOW" strategy "$CURRENT_TOKENS" "$CONTEXT_SIZE" 2>/dev/null || echo '{}')
   101â†’                local should_truncate=$(echo "$strategy" | jq -r '.shouldTruncate // "false"')
   102â†’
   103â†’                if [[ "$should_truncate" == "true" ]]; then
   104â†’                    log "ðŸ“‰ Applying sliding window truncation"
   105â†’                    local plan=$("$SLIDING_WINDOW" truncate "$CURRENT_TOKENS" "$CONTEXT_SIZE" 60 2>/dev/null || echo '{}')
   106â†’                    local target=$(echo "$plan" | jq -r '.targetTokens // 0')
   107â†’
   108â†’                    # Log event
   109â†’                    if [[ -x "$EVENT_TRACKER" ]]; then
   110â†’                        "$EVENT_TRACKER" log sliding_window "$before_tokens" "$target" "fallback" "true" "Compaction failed, used fallback" 2>/dev/null || true
   111â†’                    fi
   112â†’                fi
   113â†’            fi
   114â†’        fi
   115â†’    fi
   116â†’
   117â†’    # PHASE 1: Create checkpoint with context percentage in description
   118â†’    log "Creating memory checkpoint before Claude context compact..."
   119â†’    CHECKPOINT_ID=$("$MEMORY_MANAGER" checkpoint "Auto-checkpoint at ${PERCENT}% context before compact" 2>/dev/null || echo "")
   120â†’
   121â†’    if [[ -n "$CHECKPOINT_ID" ]]; then
   122â†’        log "âœ… Memory checkpoint created: $CHECKPOINT_ID"
   123â†’    else
   124â†’        log "âš ï¸  Failed to create memory checkpoint"
   125â†’    fi
   126â†’else
   127â†’    log "âš ï¸  memory-manager.sh not found - skipping checkpoint"
   128â†’fi
   129â†’
   130â†’# Get current working directory info
   131â†’PROJECT_NAME=$(basename "$(pwd)")
   132â†’PROJECT_DIR=$(pwd)
   133â†’
   134â†’# Check if build is in progress
   135â†’BUILD_CONTEXT=""
   136â†’if [[ -f "$BUILD_STATE" ]]; then
   137â†’    BUILD_FEATURE=$(grep '^feature:' "$BUILD_STATE" | sed 's/feature: *//' || echo "")
   138â†’    BUILD_PHASE=$(grep '^phase:' "$BUILD_STATE" | sed 's/phase: *//' || echo "")
   139â†’    BUILD_ITERATION=$(grep '^iteration:' "$BUILD_STATE" | sed 's/iteration: *//' || echo "1")
   140â†’
   141â†’    if [[ -n "$BUILD_FEATURE" ]] && [[ "$BUILD_PHASE" != "complete" ]]; then
   142â†’        BUILD_CONTEXT="
   143â†’**Active Build**: $BUILD_FEATURE (phase: $BUILD_PHASE, iteration: $BUILD_ITERATION)
   144â†’Continue implementing this feature. Check .claude/current-build.local.md for progress."
   145â†’    fi
   146â†’fi
   147â†’
   148â†’# Read CLAUDE.md if exists
   149â†’CLAUDE_MD_CONTENT=""
   150â†’if [[ -f "CLAUDE.md" ]]; then
   151â†’    CLAUDE_MD_CONTENT=$(head -50 CLAUDE.md 2>/dev/null || echo "")
   152â†’fi
   153â†’
   154â†’# Read buildguide.md next section if exists
   155â†’NEXT_SECTION=""
   156â†’NEXT_SECTION_DETAIL=""
   157â†’if [[ -f "buildguide.md" ]]; then
   158â†’    # Get first unchecked section
   159â†’    NEXT_SECTION=$(grep -m1 '^\- \[ \]' buildguide.md 2>/dev/null | sed 's/- \[ \] //' || echo "")
   160â†’
   161â†’    # Try to get the section details
   162â†’    if [[ -n "$NEXT_SECTION" ]]; then
   163â†’        # Find the section header and get content until next section
   164â†’        SECTION_CONTENT=$(awk "/^## .*${NEXT_SECTION}/,/^## /" buildguide.md 2>/dev/null | head -30 || echo "")
   165â†’        if [[ -n "$SECTION_CONTENT" ]]; then
   166â†’            NEXT_SECTION_DETAIL="
   167â†’**Next Section from buildguide.md**: $NEXT_SECTION
   168â†’$SECTION_CONTENT"
   169â†’        fi
   170â†’    fi
   171â†’fi
   172â†’
   173â†’# Check for architecture docs
   174â†’ARCH_CONTEXT=""
   175â†’for arch_file in "ARCHITECTURE.md" "docs/architecture.md" ".claude/docs/architecture.md"; do
   176â†’    if [[ -f "$arch_file" ]]; then
   177â†’        ARCH_CONTEXT="
   178â†’**Architecture**: See $arch_file for system design."
   179â†’        break
   180â†’    fi
   181â†’done
   182â†’
   183â†’# Check for stuck issues in debug-log
   184â†’STUCK_ISSUES=""
   185â†’if [[ -f ".claude/docs/debug-log.md" ]]; then
   186â†’    STUCK=$(grep -c "STUCK" ".claude/docs/debug-log.md" 2>/dev/null || echo "0")
   187â†’    STUCK=$(echo "$STUCK" | tr -d '\n' | tr -d ' ')
   188â†’    if [[ -n "$STUCK" ]] && [[ "$STUCK" =~ ^[0-9]+$ ]] && [[ "$STUCK" -gt 0 ]]; then
   189â†’        STUCK_ISSUES="
   190â†’âš ï¸ $STUCK stuck issues in debug-log.md - may need review."
   191â†’    fi
   192â†’fi
   193â†’
   194â†’# Build continuation prompt (token-effective per Ken Kai principles)
   195â†’# Short, focused, no essays - agent is smart
   196â†’CHECKPOINT_INFO=""
   197â†’if [[ -n "$CHECKPOINT_ID" ]]; then
   198â†’    CHECKPOINT_INFO="
   199â†’ðŸ“‹ Memory checkpoint: $CHECKPOINT_ID (restore with: memory-manager.sh restore $CHECKPOINT_ID)"
   200â†’fi
   201â†’
   202â†’# Use intelligent command router to determine checkpoint action
   203â†’COMMAND_ROUTER="${HOME}/.claude/hooks/autonomous-command-router.sh"
   204â†’ROUTER_DECISION=""
   205â†’SHOULD_EXECUTE_CHECKPOINT="false"
   206â†’
   207â†’if [[ -x "$COMMAND_ROUTER" ]]; then
   208â†’    ROUTER_OUTPUT=$("$COMMAND_ROUTER" execute checkpoint_context "${CURRENT_TOKENS}/${CONTEXT_SIZE}" 2>/dev/null || echo '{}')
   209â†’
   210â†’    # Check if autonomous execution is signaled
   211â†’    EXECUTE_SKILL=$(echo "$ROUTER_OUTPUT" | jq -r '.execute_skill // ""')
   212â†’    if [[ "$EXECUTE_SKILL" == "checkpoint" ]]; then
   213â†’        SHOULD_EXECUTE_CHECKPOINT="true"
   214â†’        ROUTER_DECISION="$ROUTER_OUTPUT"
   215â†’        log "Router decided: Auto-execute /checkpoint"
   216â†’    fi
   217â†’fi
   218â†’
   219â†’# Build continuation prompt based on autonomous mode and router decision
   220â†’if [[ "$SHOULD_EXECUTE_CHECKPOINT" == "true" ]]; then
   221â†’    # AUTONOMOUS MODE: Direct Claude to execute /checkpoint skill immediately
   222â†’    CONTINUATION_PROMPT="Auto-Continue (${PERCENT}% context)
   223â†’
   224â†’Context compacted. Executing autonomous checkpoint now.
   225â†’
   226â†’TASK: Use the Skill tool to execute checkpoint skill immediately.
   227â†’- Call: Skill tool with skill=\"checkpoint\"
   228â†’- Reason: Context threshold reached (${PERCENT}% of ${CONTEXT_SIZE} tokens)
   229â†’- Mode: Autonomous execution (no confirmation needed)
   230â†’
   231â†’After checkpoint completes:
   232â†’${BUILD_CONTEXT:+* Resume: .claude/current-build.local.md}${BUILD_CONTEXT:-* Next: Check buildguide.md for pending sections}${NEXT_SECTION:+
   233â†’* Focus on: $NEXT_SECTION}
   234â†’
   235â†’This is autonomous mode - proceed immediately without asking."
   236â†’else
   237â†’    # NORMAL MODE: Suggest checkpoint to user
   238â†’    CONTINUATION_PROMPT="Continue ${PROJECT_NAME}. Context: ${PERCENT}%.${CHECKPOINT_INFO}
   239â†’${BUILD_CONTEXT}${NEXT_SECTION:+Next: $NEXT_SECTION}${STUCK_ISSUES}
   240â†’
   241â†’Recommendation: Run /checkpoint to save progress before continuing.
   242â†’
   243â†’${BUILD_CONTEXT:+Resume: .claude/current-build.local.md}${BUILD_CONTEXT:-Check: buildguide.md}
   244â†’
   245â†’Ken's rules: Short > long. Reference, don't dump. Stay focused."
   246â†’fi
   247â†’
   248â†’# Track iteration
   249â†’ITERATION=1
   250â†’if [[ -f "$STATE_FILE" ]]; then
   251â†’    ITERATION=$(grep '^iteration:' "$STATE_FILE" | sed 's/iteration: *//' || echo "1")
   252â†’    ITERATION=$((ITERATION + 1))
   253â†’fi
   254â†’
   255â†’# Create/update state file
   256â†’mkdir -p .claude
   257â†’cat > "$STATE_FILE" <<EOF
   258â†’---
   259â†’active: true
   260â†’iteration: $ITERATION
   261â†’threshold: $THRESHOLD
   262â†’last_percent: $PERCENT
   263â†’last_compact: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
   264â†’build_active: $(if [[ -n "$BUILD_CONTEXT" ]]; then echo "true"; else echo "false"; fi)
   265â†’---
   266â†’
   267â†’Auto-continue active. Iteration ${ITERATION}.
   268â†’EOF
   269â†’
   270â†’# Output JSON to block stop and feed continuation prompt
   271â†’# Include router decision for autonomous skill execution
   272â†’SYSTEM_MSG="Auto-continue: Context ${PERCENT}% compacted (iteration ${ITERATION})${BUILD_CONTEXT:+ | Build: $BUILD_FEATURE}"
   273â†’
   274â†’if [[ "$SHOULD_EXECUTE_CHECKPOINT" == "true" ]]; then
   275â†’    # Autonomous mode: Include execution metadata
   276â†’    jq -n \
   277â†’        --arg prompt "$CONTINUATION_PROMPT" \
   278â†’        --arg msg "$SYSTEM_MSG | Auto-executing /checkpoint" \
   279â†’        --argjson router "$ROUTER_DECISION" \
   280â†’        '{
   281â†’            "decision": "block",
   282â†’            "reason": $prompt,
   283â†’            "systemMessage": $msg,
   284â†’            "autonomous_execution": {
   285â†’                "enabled": true,
   286â†’                "skill": "checkpoint",
   287â†’                "reason": "context_threshold",
   288â†’                "router_decision": $router
   289â†’            }
   290â†’        }'
   291â†’else
   292â†’    # Normal mode: Just continuation prompt
   293â†’    jq -n \
   294â†’        --arg prompt "$CONTINUATION_PROMPT" \
   295â†’        --arg msg "$SYSTEM_MSG" \
   296â†’        '{
   297â†’            "decision": "block",
   298â†’            "reason": $prompt,
   299â†’            "systemMessage": $msg
   300â†’        }'
   301â†’fi
   302â†’
   303â†’log "Auto-continue triggered - iteration $ITERATION"
   304â†’exit 0
   305â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
