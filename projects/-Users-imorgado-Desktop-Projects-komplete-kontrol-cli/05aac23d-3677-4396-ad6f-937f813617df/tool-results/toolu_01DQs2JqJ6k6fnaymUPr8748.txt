     1â†’#!/bin/bash
     2â†’# Central Coordinator - Orchestrates all autonomous systems
     3â†’# The intelligence layer that connects everything
     4â†’
     5â†’set -uo pipefail
     6â†’
     7â†’COORD_DIR="${HOME}/.claude/coordination"
     8â†’COORD_STATE="$COORD_DIR/state.json"
     9â†’EXECUTION_LOG="$COORD_DIR/execution.log"
    10â†’LOG_FILE="${HOME}/.claude/coordinator.log"
    11â†’
    12â†’# All integrated hooks (Phase 1-3 - Existing)
    13â†’ORCHESTRATOR="${HOME}/.claude/hooks/autonomous-orchestrator-v2.sh"
    14â†’AGENT_LOOP="${HOME}/.claude/hooks/agent-loop.sh"
    15â†’LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
    16â†’FEEDBACK_LOOP="${HOME}/.claude/hooks/feedback-loop.sh"
    17â†’RISK_PREDICTOR="${HOME}/.claude/hooks/risk-predictor.sh"
    18â†’PATTERN_MINER="${HOME}/.claude/hooks/pattern-miner.sh"
    19â†’STRATEGY_SELECTOR="${HOME}/.claude/hooks/strategy-selector.sh"
    20â†’META_REFLECTION="${HOME}/.claude/hooks/meta-reflection.sh"
    21â†’HYPOTHESIS_TESTER="${HOME}/.claude/hooks/hypothesis-tester.sh"
    22â†’CONTEXT_OPTIMIZER="${HOME}/.claude/hooks/context-optimizer.sh"
    23â†’SELF_HEALING="${HOME}/.claude/hooks/self-healing.sh"
    24â†’THINKING_FRAMEWORK="${HOME}/.claude/hooks/thinking-framework.sh"
    25â†’MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
    26â†’ERROR_HANDLER="${HOME}/.claude/hooks/error-handler.sh"
    27â†’PLAN_EXECUTE="${HOME}/.claude/hooks/plan-execute.sh"
    28â†’TASK_QUEUE="${HOME}/.claude/hooks/task-queue.sh"
    29â†’
    30â†’# New integrated hooks (10 Advanced Features)
    31â†’REASONING_MODE_SWITCHER="${HOME}/.claude/hooks/reasoning-mode-switcher.sh"
    32â†’BOUNDED_AUTONOMY="${HOME}/.claude/hooks/bounded-autonomy.sh"
    33â†’TREE_OF_THOUGHTS="${HOME}/.claude/hooks/tree-of-thoughts.sh"
    34â†’MULTI_AGENT_ORCHESTRATOR="${HOME}/.claude/hooks/multi-agent-orchestrator.sh"
    35â†’REACT_REFLEXION="${HOME}/.claude/hooks/react-reflexion.sh"
    36â†’CONSTITUTIONAL_AI="${HOME}/.claude/hooks/constitutional-ai.sh"
    37â†’AUTO_EVALUATOR="${HOME}/.claude/hooks/auto-evaluator.sh"
    38â†’REINFORCEMENT_LEARNING="${HOME}/.claude/hooks/reinforcement-learning.sh"
    39â†’ENHANCED_AUDIT_TRAIL="${HOME}/.claude/hooks/enhanced-audit-trail.sh"
    40â†’PARALLEL_EXECUTION_PLANNER="${HOME}/.claude/hooks/parallel-execution-planner.sh"
    41â†’SWARM_ORCHESTRATOR="${HOME}/.claude/hooks/swarm-orchestrator.sh"
    42â†’RE_TOOL_DETECTOR="${HOME}/.claude/hooks/re-tool-detector.sh"
    43â†’RE_AUTOMATION="${HOME}/.claude/hooks/re-automation.sh"
    44â†’RE_SKILL="${HOME}/.claude/skills/re.sh"
    45â†’
    46â†’log() {
    47â†’    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
    48â†’}
    49â†’
    50â†’log_failure() {
    51â†’    local component="$1"
    52â†’    local action="$2"
    53â†’    echo "[$(date '+%Y-%m-%d %H:%M:%S')] âš ï¸  FAILURE: $component $action" >> "$LOG_FILE"
    54â†’}
    55â†’
    56â†’show_advisory() {
    57â†’    local message="$1"
    58â†’    echo "âš ï¸  $message" >&2
    59â†’}
    60â†’
    61â†’init_coordinator() {
    62â†’    mkdir -p "$COORD_DIR"
    63â†’
    64â†’    if [[ ! -f "$COORD_STATE" ]]; then
    65â†’        cat > "$COORD_STATE" << 'EOF'
    66â†’{
    67â†’    "status": "idle",
    68â†’    "currentTask": null,
    69â†’    "initialized": false,
    70â†’    "systems": {
    71â†’        "learning": false,
    72â†’        "memory": false,
    73â†’        "agentLoop": false,
    74â†’        "orchestrator": false
    75â†’    }
    76â†’}
    77â†’EOF
    78â†’    fi
    79â†’
    80â†’    # Initialize all systems
    81â†’    if [[ -x "$LEARNING_ENGINE" ]]; then
    82â†’        if "$LEARNING_ENGINE" init 2>/dev/null; then
    83â†’            update_system_status "learning" true
    84â†’        else
    85â†’            log_failure "learning-engine" "initialization failed"
    86â†’            show_advisory "Learning engine initialization failed - system may have reduced intelligence"
    87â†’        fi
    88â†’    fi
    89â†’
    90â†’    if [[ -x "$MEMORY_MANAGER" ]]; then
    91â†’        if "$MEMORY_MANAGER" init 2>/dev/null; then
    92â†’            update_system_status "memory" true
    93â†’        else
    94â†’            log_failure "memory-manager" "initialization failed"
    95â†’            show_advisory "Memory manager initialization failed - running stateless"
    96â†’        fi
    97â†’    fi
    98â†’
    99â†’    update_coordinator_status "initialized" true
   100â†’    log "Coordinator initialized"
   101â†’}
   102â†’
   103â†’update_system_status() {
   104â†’    local system="$1"
   105â†’    local status="$2"
   106â†’
   107â†’    local temp_file
   108â†’    temp_file=$(mktemp)
   109â†’
   110â†’    jq --arg system "$system" --argjson status "$status" \
   111â†’        '.systems[$system] = $status' "$COORD_STATE" > "$temp_file"
   112â†’    mv "$temp_file" "$COORD_STATE"
   113â†’}
   114â†’
   115â†’update_coordinator_status() {
   116â†’    local key="$1"
   117â†’    local value="$2"
   118â†’
   119â†’    local temp_file
   120â†’    temp_file=$(mktemp)
   121â†’
   122â†’    jq --arg key "$key" --arg value "$value" \
   123â†’        '.[$key] = $value' "$COORD_STATE" > "$temp_file"
   124â†’    mv "$temp_file" "$COORD_STATE"
   125â†’}
   126â†’
   127â†’# =============================================================================
   128â†’# TASK COORDINATION (MAIN ENTRY POINT)
   129â†’# =============================================================================
   130â†’
   131â†’coordinate_task() {
   132â†’    local task="$1"
   133â†’    local task_type="${2:-general}"
   134â†’    local context="${3:-}"
   135â†’
   136â†’    init_coordinator
   137â†’    log "Coordinating task: $task (type: $task_type)"
   138â†’
   139â†’    local start_time
   140â†’    start_time=$(date +%s)
   141â†’
   142â†’    # Phase 1: PRE-EXECUTION INTELLIGENCE
   143â†’    log "Phase 1: Pre-execution analysis"
   144â†’
   145â†’    # 1.0: Select reasoning mode (reflexive/deliberate/reactive)
   146â†’    local reasoning_mode="deliberate"
   147â†’    local mode_info=""
   148â†’    if [[ -x "$REASONING_MODE_SWITCHER" ]]; then
   149â†’        # Assess task characteristics for mode selection
   150â†’        local complexity="normal"
   151â†’        local urgency="normal"
   152â†’
   153â†’        # Simple heuristics for now
   154â†’        [[ "$task" =~ (fix|bug|error|urgent) ]] && urgency="critical"
   155â†’        [[ "$task" =~ (implement|architecture|design|complex) ]] && complexity="high"
   156â†’        [[ "$task" =~ (typo|comment|simple|quick) ]] && complexity="low"
   157â†’
   158â†’        local risk_for_mode="low"
   159â†’        [[ "$task" =~ (security|auth|payment|data|production) ]] && risk_for_mode="high"
   160â†’
   161â†’        mode_info=$("$REASONING_MODE_SWITCHER" select "$task" "$context" "$urgency" "$complexity" "$risk_for_mode" 2>/dev/null || echo '{"selected_mode":"deliberate"}')
   162â†’        reasoning_mode=$(echo "$mode_info" | jq -r '.selected_mode // "deliberate"')
   163â†’        log "Selected reasoning mode: $reasoning_mode (complexity: $complexity, risk: $risk_for_mode, urgency: $urgency)"
   164â†’
   165â†’        # Log decision to audit trail
   166â†’        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   167â†’            if ! "$ENHANCED_AUDIT_TRAIL" log "select_reasoning_mode" \
   168â†’                "Task characteristics suggest $reasoning_mode mode" \
   169â†’                "reflexive,deliberate,reactive" \
   170â†’                "$reasoning_mode balances thoroughness with efficiency for this task" \
   171â†’                "0.85" 2>/dev/null; then
   172â†’                log_failure "enhanced-audit-trail" "failed to log reasoning mode selection"
   173â†’            fi
   174â†’        fi
   175â†’    fi
   176â†’
   177â†’    # 1.1: State hypothesis
   178â†’    local hypothesis_id=""
   179â†’    if [[ -x "$HYPOTHESIS_TESTER" ]]; then
   180â†’        local hypothesis="Task '$task' will succeed using recommended strategy"
   181â†’        hypothesis_id=$("$HYPOTHESIS_TESTER" state "$hypothesis" "success" "$task" 2>/dev/null | jq -r '.id' || echo "")
   182â†’        log "Stated hypothesis: $hypothesis_id"
   183â†’    fi
   184â†’
   185â†’    # 1.2: Get strategy recommendation
   186â†’    local strategy="default"
   187â†’    local strategy_confidence=0
   188â†’    if [[ -x "$STRATEGY_SELECTOR" ]]; then
   189â†’        local strategy_result
   190â†’        strategy_result=$("$STRATEGY_SELECTOR" select "$task" "$task_type" "$context" 2>/dev/null || echo '{"strategy":"default","confidence":0}')
   191â†’        strategy=$(echo "$strategy_result" | jq -r '.strategy')
   192â†’        strategy_confidence=$(echo "$strategy_result" | jq -r '.confidence')
   193â†’        log "Selected strategy: $strategy (confidence: $strategy_confidence)"
   194â†’    fi
   195â†’
   196â†’    # 1.3: Assess risk
   197â†’    local risk_level="low"
   198â†’    local risk_score=10
   199â†’    if [[ -x "$RISK_PREDICTOR" ]]; then
   200â†’        local risk_result
   201â†’        risk_result=$("$RISK_PREDICTOR" assess "$task" "$task_type" "" "$context" 2>/dev/null || echo '{"riskLevel":"low","totalRisk":10}')
   202â†’        risk_level=$(echo "$risk_result" | jq -r '.riskLevel')
   203â†’        risk_score=$(echo "$risk_result" | jq -r '.totalRisk')
   204â†’        log "Risk assessment: $risk_level ($risk_score/100)"
   205â†’    fi
   206â†’
   207â†’    # 1.4: Mine relevant patterns (PHASE 2 INTEGRATION: Use hybrid search for patterns)
   208â†’    local patterns="[]"
   209â†’    if [[ -x "$PATTERN_MINER" ]]; then
   210â†’        patterns=$("$PATTERN_MINER" mine "$task_type" 2>/dev/null || echo '[]')
   211â†’        local pattern_count
   212â†’        pattern_count=$(echo "$patterns" | jq 'length')
   213â†’        log "Found $pattern_count relevant patterns"
   214â†’    fi
   215â†’
   216â†’    # PHASE 2 INTEGRATION: Also retrieve relevant memories using hybrid search
   217â†’    local memory_patterns="[]"
   218â†’    if [[ -x "$MEMORY_MANAGER" ]]; then
   219â†’        memory_patterns=$("$MEMORY_MANAGER" remember-hybrid "$task" 5 2>/dev/null || echo '[]')
   220â†’        local memory_count
   221â†’        memory_count=$(echo "$memory_patterns" | jq 'length' 2>/dev/null || echo "0")
   222â†’        if [[ $memory_count -gt 0 ]]; then
   223â†’            log "Retrieved $memory_count relevant memories using hybrid search"
   224â†’        fi
   225â†’    fi
   226â†’
   227â†’    # 1.4a: AUTO-RESEARCH: Check for unfamiliar libraries and execute GitHub search
   228â†’    local github_search_results="[]"
   229â†’    if [[ -x "$ORCHESTRATOR" ]]; then
   230â†’        local task_analysis
   231â†’        task_analysis=$("$ORCHESTRATOR" analyze "$task" 2>/dev/null || echo '{}')
   232â†’
   233â†’        local needs_research=$(echo "$task_analysis" | jq -r '.research.needsResearch // false')
   234â†’        if [[ "$needs_research" == "true" ]]; then
   235â†’            local library=$(echo "$task_analysis" | jq -r '.research.library')
   236â†’            local search_instruction=$(echo "$task_analysis" | jq -r '.githubSearch.instruction')
   237â†’
   238â†’            log "ðŸ“š Auto-research triggered for library: $library"
   239â†’            log "ðŸ’¡ Recommendation: $search_instruction"
   240â†’
   241â†’            # Note: The GitHub search will be executed by Claude in autonomous mode
   242â†’            # The search parameters are provided in task_analysis.githubSearch
   243â†’            # This allows Claude to invoke mcp__grep__searchGitHub with the prepared query
   244â†’            github_search_results=$(echo "$task_analysis" | jq -c '.githubSearch')
   245â†’        fi
   246â†’    fi
   247â†’
   248â†’    # 1.4b: AUTO-DETECT RE TOOLS: Check if task matches reverse engineering patterns
   249â†’    local re_tool_detected="[]"
   250â†’    local re_execution_result=""
   251â†’
   252â†’    # First try the RE automation hook (higher-level, can execute directly)
   253â†’    if [[ -x "$RE_AUTOMATION" ]]; then
   254â†’        log "Checking RE automation for task patterns..."
   255â†’
   256â†’        # Quick check if this is an RE task
   257â†’        local is_re_task
   258â†’        is_re_task=$("$RE_AUTOMATION" is-re "$task" 2>/dev/null || echo "false")
   259â†’
   260â†’        if [[ "$is_re_task" == "true" ]]; then
   261â†’            log "RE task detected by automation hook"
   262â†’
   263â†’            # Get recommendation (includes skill command)
   264â†’            local re_recommendation
   265â†’            re_recommendation=$("$RE_AUTOMATION" recommend "$task" "$context" 2>/dev/null || echo '{}')
   266â†’
   267â†’            local re_detected=$(echo "$re_recommendation" | jq -r '.detected // false')
   268â†’            if [[ "$re_detected" == "true" ]]; then
   269â†’                local re_command=$(echo "$re_recommendation" | jq -r '.command // ""')
   270â†’                local re_target=$(echo "$re_recommendation" | jq -r '.target // ""')
   271â†’                local re_description=$(echo "$re_recommendation" | jq -r '.description // ""')
   272â†’                local skill_cmd=$(echo "$re_recommendation" | jq -r '.skill_command // ""')
   273â†’
   274â†’                log "RE Automation: command=$re_command, target=$re_target"
   275â†’                log "Skill Command: $skill_cmd"
   276â†’
   277â†’                # Store for execution or Claude to use
   278â†’                re_tool_detected=$(echo "$re_recommendation" | jq -c .)
   279â†’
   280â†’                # If target exists and skill is executable, execute automatically
   281â†’                if [[ -n "$re_target" && -e "$re_target" && -x "$RE_SKILL" ]]; then
   282â†’                    log "Auto-executing RE skill: $RE_SKILL $re_command $re_target"
   283â†’
   284â†’                    re_execution_result=$("$RE_SKILL" "$re_command" "$re_target" 2>&1 || echo '{"error":"execution_failed"}')
   285â†’
   286â†’                    # Extract JSON result (last JSON block in output)
   287â†’                    local re_json_result
   288â†’                    re_json_result=$(echo "$re_execution_result" | grep -E '^\{' | tail -1 || echo '{}')
   289â†’
   290â†’                    log "RE Skill execution completed"
   291â†’                    re_tool_detected=$(jq -n \
   292â†’                        --argjson recommendation "$re_recommendation" \
   293â†’                        --argjson result "$re_json_result" \
   294â†’                        '$recommendation + {"executed":true,"result":$result}')
   295â†’
   296â†’                    # Log to audit trail
   297â†’                    if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   298â†’                        "$ENHANCED_AUDIT_TRAIL" log "re_skill_execution" \
   299â†’                            "Auto-executed RE skill: $re_command on $re_target" \
   300â†’                            "chrome,electron,deobfuscate,macos,api,analyze" \
   301â†’                            "$re_description - Results saved to ~/Desktop/re-output" \
   302â†’                            "0.95" 2>/dev/null || log_failure "audit-trail" "failed to log RE execution"
   303â†’                    fi
   304â†’                else
   305â†’                    log "RE target not found or skill not executable - providing recommendation only"
   306â†’                fi
   307â†’
   308â†’                # Add to memory
   309â†’                if [[ -x "$MEMORY_MANAGER" ]]; then
   310â†’                    "$MEMORY_MANAGER" add-fact "re_tools" "$re_command" \
   311â†’                        "Used for: $re_description" \
   312â†’                        "0.9" 2>/dev/null || log_failure "memory-manager" "failed to record RE tool"
   313â†’                fi
   314â†’            fi
   315â†’        fi
   316â†’    fi
   317â†’
   318â†’    # Fall back to RE tool detector for more specific tool recommendations
   319â†’    if [[ "$re_tool_detected" == "[]" && -x "$RE_TOOL_DETECTOR" ]]; then
   320â†’        log "Analyzing task for reverse engineering tool requirements..."
   321â†’
   322â†’        # Collect file context if available
   323â†’        local file_context="[]"
   324â†’        if [[ -n "$context" ]]; then
   325â†’            # Try to extract file paths from context
   326â†’            file_context=$(echo "$context" | jq -R 'split(" ") | map(select(test("\\.\\w+$")))' 2>/dev/null || echo '[]')
   327â†’        fi
   328â†’
   329â†’        # Run detection
   330â†’        local detection_result
   331â†’        detection_result=$("$RE_TOOL_DETECTOR" detect "$task" "$context" "$file_context" 2>/dev/null || echo '{}')
   332â†’
   333â†’        # Check if a tool was detected
   334â†’        local detected_tool=$(echo "$detection_result" | jq -r '.tool // ""')
   335â†’        if [[ -n "$detected_tool" && "$detected_tool" != "null" ]]; then
   336â†’            local confidence=$(echo "$detection_result" | jq -r '.confidence // 0')
   337â†’            local command=$(echo "$detection_result" | jq -r '.command // ""')
   338â†’            local description=$(echo "$detection_result" | jq -r '.description // ""')
   339â†’            local doc_ref=$(echo "$detection_result" | jq -r '.doc_ref // ""')
   340â†’
   341â†’            log "RE Tool Detected: $detected_tool (confidence: $confidence)"
   342â†’            log "Doc Reference: $doc_ref"
   343â†’            log "Command: $command"
   344â†’
   345â†’            # Store detection result for Claude to use
   346â†’            re_tool_detected=$(echo "$detection_result" | jq -c .)
   347â†’
   348â†’            # Log to audit trail
   349â†’            if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   350â†’                if ! "$ENHANCED_AUDIT_TRAIL" log "re_tool_detection" \
   351â†’                    "Detected RE tool: $detected_tool - $description" \
   352â†’                    "network,protocol,mobile,binary,os,web" \
   353â†’                    "Task patterns match $detected_tool usage: $command" \
   354â†’                    "$confidence" 2>/dev/null; then
   355â†’                    log_failure "enhanced-audit-trail" "failed to log RE tool detection"
   356â†’                fi
   357â†’            fi
   358â†’
   359â†’            # Add to memory as a fact
   360â†’            if [[ -x "$MEMORY_MANAGER" ]]; then
   361â†’                if ! "$MEMORY_MANAGER" add-fact "re_tools" "$detected_tool" \
   362â†’                    "Used for: $description (confidence: $confidence)" \
   363â†’                    "$confidence" 2>/dev/null; then
   364â†’                    log_failure "memory-manager" "failed to record RE tool detection"
   365â†’                fi
   366â†’            fi
   367â†’        else
   368â†’            log "No RE tool detected for this task"
   369â†’        fi
   370â†’    fi
   371â†’
   372â†’    # 1.4c: Reasoning mode execution strategy
   373â†’    local tot_result=""
   374â†’    local selected_approach=""
   375â†’
   376â†’    if [[ "$reasoning_mode" == "reflexive" ]]; then
   377â†’        # REFLEXIVE MODE: Fast-path execution, skip Tree of Thoughts
   378â†’        log "Reflexive mode: Fast-path execution (skipping Tree of Thoughts for speed)"
   379â†’
   380â†’        # Log decision to audit trail
   381â†’        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   382â†’            if ! "$ENHANCED_AUDIT_TRAIL" log "reflexive_fast_path" \
   383â†’                "Task classified as low complexity/risk - using fast execution" \
   384â†’                "skip_tree_of_thoughts" \
   385â†’                "Reflexive mode prioritizes speed over thorough exploration" \
   386â†’                "0.90" 2>/dev/null; then
   387â†’                log_failure "enhanced-audit-trail" "failed to log reflexive mode decision"
   388â†’            fi
   389â†’        fi
   390â†’
   391â†’    elif [[ "$reasoning_mode" == "reactive" ]]; then
   392â†’        # REACTIVE MODE: Immediate action, minimal planning
   393â†’        log "Reactive mode: Immediate action for urgent task (minimal deliberation)"
   394â†’
   395â†’        # Log decision to audit trail
   396â†’        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   397â†’            if ! "$ENHANCED_AUDIT_TRAIL" log "reactive_immediate_action" \
   398â†’                "Task classified as urgent - executing immediately" \
   399â†’                "minimal_planning" \
   400â†’                "Reactive mode prioritizes urgency over thoroughness" \
   401â†’                "0.85" 2>/dev/null; then
   402â†’                log_failure "enhanced-audit-trail" "failed to log reactive mode decision"
   403â†’            fi
   404â†’        fi
   405â†’
   406â†’    elif [[ "$reasoning_mode" == "deliberate" && -x "$TREE_OF_THOUGHTS" ]]; then
   407â†’        # DELIBERATE MODE: Thorough exploration with Tree of Thoughts
   408â†’        log "Deliberate mode: Exploring multiple solution paths with Tree of Thoughts"
   409â†’
   410â†’        # Generate multiple branches
   411â†’        tot_result=$("$TREE_OF_THOUGHTS" generate "$task" "$context" 3 2>/dev/null || echo '{}')
   412â†’
   413â†’        # Evaluate and select best branch
   414â†’        local tot_eval
   415â†’        tot_eval=$("$TREE_OF_THOUGHTS" evaluate "$tot_result" 2>/dev/null || echo '{"selected_branch":null}')
   416â†’        selected_approach=$(echo "$tot_eval" | jq -r '.selected_branch.strategy // ""')
   417â†’
   418â†’        if [[ -n "$selected_approach" ]]; then
   419â†’            log "Tree of Thoughts selected approach: $selected_approach"
   420â†’
   421â†’            # Log to audit trail
   422â†’            if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   423â†’                local alternatives
   424â†’                alternatives=$(echo "$tot_eval" | jq -r '.branches[] | .strategy' | tr '\n' ',' | sed 's/,$//')
   425â†’                if ! "$ENHANCED_AUDIT_TRAIL" log "tot_approach_selection" \
   426â†’                    "Evaluated multiple approaches using Tree of Thoughts" \
   427â†’                    "$alternatives" \
   428â†’                    "Selected approach has best weighted score across feasibility, quality, risk, and effort" \
   429â†’                    "$(echo "$tot_eval" | jq -r '.selected_branch.weighted_score / 10 // 0.75')" 2>/dev/null; then
   430â†’                    log_failure "enhanced-audit-trail" "failed to log Tree of Thoughts selection"
   431â†’                fi
   432â†’            fi
   433â†’
   434â†’            # Override strategy if ToT found better approach
   435â†’            if [[ -n "$selected_approach" && "$selected_approach" != "null" ]]; then
   436â†’                strategy="$selected_approach"
   437â†’                strategy_confidence=0.85
   438â†’            fi
   439â†’        fi
   440â†’    fi
   441â†’
   442â†’    # 1.5: Start thinking session
   443â†’    local thinking_id=""
   444â†’    if [[ -x "$THINKING_FRAMEWORK" ]]; then
   445â†’        thinking_id=$("$THINKING_FRAMEWORK" start "$task" "$context" 2>/dev/null || echo "")
   446â†’        [[ -n "$thinking_id" ]] && log "Started thinking session: $thinking_id"
   447â†’    fi
   448â†’
   449â†’    # 1.6: Check system health
   450â†’    if [[ -x "$SELF_HEALING" ]]; then
   451â†’        local health
   452â†’        health=$("$SELF_HEALING" health 2>/dev/null || echo "unknown")
   453â†’        log "System health: $health"
   454â†’
   455â†’        if [[ "$health" == "unhealthy" ]]; then
   456â†’            log "System unhealthy, recovering..."
   457â†’            "$SELF_HEALING" recover 2>/dev/null || true
   458â†’        fi
   459â†’    fi
   460â†’
   461â†’    # Phase 2: EXECUTION WITH MONITORING
   462â†’    log "Phase 2: Execution"
   463â†’
   464â†’    # 2.0: Bounded autonomy check (safety layer)
   465â†’    local autonomy_check=""
   466â†’    local action_allowed="true"
   467â†’    local requires_approval="false"
   468â†’    if [[ -x "$BOUNDED_AUTONOMY" ]]; then
   469â†’        autonomy_check=$("$BOUNDED_AUTONOMY" check "$task" "$context,strategy:$strategy,risk:$risk_level" 2>/dev/null || echo '{"allowed":true,"requires_approval":false}')
   470â†’        action_allowed=$(echo "$autonomy_check" | jq -r '.allowed // true')
   471â†’        requires_approval=$(echo "$autonomy_check" | jq -r '.requires_approval // false')
   472â†’
   473â†’        if [[ "$action_allowed" == "false" ]]; then
   474â†’            log "BLOCKED: Task prohibited by bounded autonomy rules"
   475â†’            echo '{"error":"action_prohibited","task":"'"$task"'","reason":"Bounded autonomy safety check failed"}'
   476â†’            return 1
   477â†’        fi
   478â†’
   479â†’        if [[ "$requires_approval" == "true" ]]; then
   480â†’            log "ESCALATION: Task requires user approval (confidence < 70% or high risk)"
   481â†’            # Log to audit trail
   482â†’            if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   483â†’                if ! "$ENHANCED_AUDIT_TRAIL" log "escalate_for_approval" \
   484â†’                    "Task requires user approval due to: $(echo "$autonomy_check" | jq -r '.reason // "high risk or low confidence"')" \
   485â†’                    "auto-proceed,escalate" \
   486â†’                    "Safety-first approach dictates human review for uncertain or risky operations" \
   487â†’                    "0.95" 2>/dev/null; then
   488â†’                    log_failure "enhanced-audit-trail" "failed to log escalation decision"
   489â†’                fi
   490â†’            fi
   491â†’            echo '{"status":"requires_approval","task":"'"$task"'","reason":"'"$(echo "$autonomy_check" | jq -r '.reason')"'"}'
   492â†’            return 0
   493â†’        fi
   494â†’
   495â†’        log "Bounded autonomy check: ALLOWED (category: $(echo "$autonomy_check" | jq -r '.category // "unknown"'))"
   496â†’    fi
   497â†’
   498â†’    update_coordinator_status "status" "executing"
   499â†’    update_coordinator_status "currentTask" "$task"
   500â†’
   501â†’    # 2.1: Create execution plan
   502â†’    local plan_id=""
   503â†’    if [[ -x "$PLAN_EXECUTE" ]]; then
   504â†’        plan_id=$("$PLAN_EXECUTE" create "$task" "$context" 2>/dev/null || echo "")
   505â†’        if [[ -n "$plan_id" ]]; then
   506â†’            # Decompose and add steps
   507â†’            "$PLAN_EXECUTE" decompose "$task" "$task_type" 2>/dev/null | while read -r step; do
   508â†’                if [[ -n "$step" ]]; then
   509â†’                    if ! "$PLAN_EXECUTE" add-step "${step#* }" "shell" "" "" 2>/dev/null; then
   510â†’                        log_failure "plan-execute" "failed to add step: $step"
   511â†’                    fi
   512â†’                fi
   513â†’            done
   514â†’            log "Created plan: $plan_id"
   515â†’        fi
   516â†’    fi
   517â†’
   518â†’    # 2.2: Route to appropriate agent (multi-agent orchestration)
   519â†’    local assigned_agent="general"
   520â†’    local agent_info=""
   521â†’    if [[ -x "$MULTI_AGENT_ORCHESTRATOR" ]]; then
   522â†’        local routing_result
   523â†’        routing_result=$("$MULTI_AGENT_ORCHESTRATOR" route "$task" 2>/dev/null || echo '{"selected_agent":"general"}')
   524â†’        assigned_agent=$(echo "$routing_result" | jq -r '.selected_agent // "general"')
   525â†’        agent_info=$(echo "$routing_result" | jq -r '.agent_info.description // ""')
   526â†’        log "Multi-agent routing: Assigned to $assigned_agent agent ($agent_info)"
   527â†’
   528â†’        # Log to audit trail
   529â†’        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   530â†’            local all_agents
   531â†’            all_agents=$("$MULTI_AGENT_ORCHESTRATOR" agents 2>/dev/null | jq -r '.agents | keys | join(",")')
   532â†’            if ! "$ENHANCED_AUDIT_TRAIL" log "agent_routing" \
   533â†’                "Routed task to specialist $assigned_agent agent" \
   534â†’                "$all_agents" \
   535â†’                "Task keywords match $assigned_agent expertise: $agent_info" \
   536â†’                "$(echo "$routing_result" | jq -r '.routing_confidence / 100 // 0.7')" 2>/dev/null; then
   537â†’                log_failure "enhanced-audit-trail" "failed to log agent routing"
   538â†’            fi
   539â†’        fi
   540â†’    fi
   541â†’
   542â†’    # 2.3: Start ReAct + Reflexion cycle
   543â†’    local reflexion_iteration=1
   544â†’    local reflexion_goal="$task"
   545â†’    if [[ -x "$REACT_REFLEXION" ]]; then
   546â†’        log "Starting ReAct + Reflexion cycle (Think â†’ Act â†’ Observe â†’ Reflect)"
   547â†’
   548â†’        # Generate reasoning before action
   549â†’        local thought_result
   550â†’        thought_result=$("$REACT_REFLEXION" think "$reflexion_goal" "$context" "$reflexion_iteration" 2>/dev/null || echo '{}')
   551â†’        log "ReAct thought generated for iteration $reflexion_iteration"
   552â†’    fi
   553â†’
   554â†’    # ============================================================================
   555â†’    # PARALLEL EXECUTION ANALYSIS: Check if tasks can be parallelized
   556â†’    # ============================================================================
   557â†’    local parallel_groups="[]"
   558â†’    local can_parallelize="false"
   559â†’    if [[ -x "$PARALLEL_EXECUTION_PLANNER" ]]; then
   560â†’        log "Analyzing task for parallel execution opportunities..."
   561â†’        local parallel_analysis
   562â†’        parallel_analysis=$("$PARALLEL_EXECUTION_PLANNER" analyze "$task" "$context" 2>/dev/null || echo '{}')
   563â†’
   564â†’        can_parallelize=$(echo "$parallel_analysis" | jq -r '.canParallelize // false')
   565â†’        parallel_groups=$(echo "$parallel_analysis" | jq -c '.groups // []')
   566â†’
   567â†’        # Declare execution_result here to avoid scope collision
   568â†’        local execution_result=""
   569â†’
   570â†’        if [[ "$can_parallelize" == "true" ]]; then
   571â†’            local group_count
   572â†’            group_count=$(echo "$parallel_groups" | jq 'length')
   573â†’            log "Task can be parallelized into $group_count groups"
   574â†’
   575â†’            # AUTO-SPAWN SWARM: If 3+ independent parallel groups detected
   576â†’            if [[ $group_count -ge 3 ]] && [[ -x "$SWARM_ORCHESTRATOR" ]]; then
   577â†’                log "âš¡ AUTO-SPAWNING SWARM: $group_count agents for parallel execution"
   578â†’                local swarm_id
   579â†’                swarm_id=$("$SWARM_ORCHESTRATOR" spawn "$group_count" "$task" 2>/dev/null || echo "")
   580â†’
   581â†’                if [[ -n "$swarm_id" ]]; then
   582â†’                    log "âœ… Swarm $swarm_id spawned with $group_count agents"
   583â†’                    # Update execution result to indicate swarm execution
   584â†’                    execution_result="swarm:$swarm_id"
   585â†’                else
   586â†’                    log_failure "swarm-orchestrator" "failed to spawn swarm"
   587â†’                fi
   588â†’            fi
   589â†’        else
   590â†’            log "Task will execute sequentially (no parallelization opportunities)"
   591â†’        fi
   592â†’    fi
   593â†’    # ============================================================================
   594â†’
   595â†’    # 2.4: Check context budget before launching agents
   596â†’    if [[ -x "$MEMORY_MANAGER" ]]; then
   597â†’        log "Checking context budget before agent launch..."
   598â†’        local budget_status
   599â†’        budget_status=$("$MEMORY_MANAGER" context-check 2>/dev/null || echo "")
   600â†’
   601â†’        if [[ -n "$budget_status" ]]; then
   602â†’            log "$budget_status"
   603â†’
   604â†’            # Auto-compact if needed (prevents agent launch failure)
   605â†’            "$MEMORY_MANAGER" auto-compact-if-needed 2>/dev/null || true
   606â†’        fi
   607â†’    fi
   608â†’
   609â†’    # 2.5: Start agent loop with specialist context
   610â†’    local agent_id=""
   611â†’    # Use execution_result from outer scope (set by swarm or default to pending)
   612â†’    [[ -z "$execution_result" ]] && execution_result="pending"
   613â†’    if [[ -x "$AGENT_LOOP" ]]; then
   614â†’        # Build structured context that agent-loop can use
   615â†’        local agent_context="Execution strategy: $strategy | Risk level: $risk_level | Plan: $plan_id | Agent: $assigned_agent | Mode: $reasoning_mode | Parallel: $can_parallelize"
   616â†’
   617â†’        # Pass autoResearch data via temp file if available (avoids JSON escaping issues)
   618â†’        local agent_dir="${HOME}/.claude/agent"
   619â†’        mkdir -p "$agent_dir"
   620â†’        if [[ "$github_search_results" != "[]" && "$github_search_results" != "{}" ]]; then
   621â†’            echo "$github_search_results" > "${agent_dir}/.pending-research.json"
   622â†’            log "ðŸ“š Passing auto-research data to agent-loop via temp file"
   623â†’        fi
   624â†’
   625â†’        agent_id=$("$AGENT_LOOP" start "$task" "$agent_context" 2>/dev/null || echo "")
   626â†’        log "Started agent loop: $agent_id (via $assigned_agent agent in $reasoning_mode mode)"
   627â†’
   628â†’        # Monitor execution (in real implementation, this would be event-driven)
   629â†’        # For now, just record that we started it
   630â†’        execution_result="started"
   631â†’    fi
   632â†’
   633â†’    # Phase 3: POST-EXECUTION LEARNING
   634â†’    log "Phase 3: Post-execution learning"
   635â†’
   636â†’    local end_time
   637â†’    end_time=$(date +%s)
   638â†’    local duration
   639â†’    duration=$((end_time - start_time))
   640â†’
   641â†’    # 3.1: Complete ReAct + Reflexion cycle
   642â†’    local quality_score=7.0
   643â†’    if [[ -x "$REACT_REFLEXION" ]]; then
   644â†’        log "Completing ReAct + Reflexion: Reflect on execution outcome"
   645â†’
   646â†’        # Reflect on the outcome
   647â†’        local reflection_result
   648â†’        reflection_result=$("$REACT_REFLEXION" reflect "$execution_result" "$task" "$context" 2>/dev/null || echo '{"quality_score":7.0}')
   649â†’        quality_score=$(echo "$reflection_result" | jq -r '.quality_score // 7.0')
   650â†’
   651â†’        # Process and store reflection
   652â†’        if [[ "$execution_result" =~ (success|completed|started) ]]; then
   653â†’            if ! "$REACT_REFLEXION" process "$reflection_result" "true" 2>/dev/null; then
   654â†’                log_failure "react-reflexion" "failed to store reflection"
   655â†’            fi
   656â†’            log "ReAct reflexion complete: quality=$quality_score/10, reflection stored"
   657â†’        fi
   658â†’    fi
   659â†’
   660â†’    # 3.2: Constitutional AI validation WITH AUTO-REVISION
   661â†’    local constitutional_violations=""
   662â†’    local revision_count=0
   663â†’    if [[ -x "$CONSTITUTIONAL_AI" ]]; then
   664â†’        log "Running Constitutional AI validation against principles"
   665â†’
   666â†’        # Critique output against principles
   667â†’        local critique_json
   668â†’        critique_json=$("$CONSTITUTIONAL_AI" critique "$execution_result" all 2>/dev/null || echo '{}')
   669â†’
   670â†’        # Parse critique results
   671â†’        local assessment=$(echo "$critique_json" | jq -r '.overall_assessment // "safe"' 2>/dev/null || echo "safe")
   672â†’        local violations=$(echo "$critique_json" | jq -r '.violations | length' 2>/dev/null || echo "0")
   673â†’
   674â†’        if [[ "$assessment" != "safe" ]] && [[ "$violations" -gt 0 ]]; then
   675â†’            log "âš ï¸  Constitutional AI: $violations violations found - initiating auto-revision"
   676â†’
   677â†’            # AUTO-REVISION LOOP (max 2 iterations)
   678â†’            while [[ $revision_count -lt 2 ]] && [[ "$assessment" != "safe" ]]; do
   679â†’                revision_count=$((revision_count + 1))
   680â†’                log "Auto-revision attempt $revision_count/2..."
   681â†’
   682â†’                # Generate revision
   683â†’                local revision_json
   684â†’                revision_json=$("$CONSTITUTIONAL_AI" revise "$execution_result" "$critique_json" 2>/dev/null || echo '{}')
   685â†’
   686â†’                # Extract revised content from JSON response
   687â†’                local revised
   688â†’                revised=$(echo "$revision_json" | jq -r '.revised_content // ""' 2>/dev/null || echo "")
   689â†’                local changes_made
   690â†’                changes_made=$(echo "$revision_json" | jq -r '.changes_made | join(", ") // ""' 2>/dev/null || echo "")
   691â†’
   692â†’                if [[ -n "$revised" && "$revised" != "null" && "$revised" != "{}" ]]; then
   693â†’                    execution_result="$revised"
   694â†’                    log "âœ… Constitutional AI: Auto-revision $revision_count applied - Changes: $changes_made"
   695â†’
   696â†’                    # Re-evaluate revised output
   697â†’                    critique_json=$("$CONSTITUTIONAL_AI" critique "$execution_result" all 2>/dev/null || echo '{}')
   698â†’                    assessment=$(echo "$critique_json" | jq -r '.overall_assessment // "safe"' 2>/dev/null || echo "safe")
   699â†’                    violations=$(echo "$critique_json" | jq -r '.violations | length' 2>/dev/null || echo "0")
   700â†’                else
   701â†’                    log "âŒ Constitutional AI: Revision generation failed"
   702â†’                    break
   703â†’                fi
   704â†’            done
   705â†’
   706â†’            if [[ "$assessment" == "safe" ]]; then
   707â†’                log "âœ… Constitutional AI: All violations resolved after $revision_count revision(s)"
   708â†’            else
   709â†’                log "âš ï¸  Constitutional AI: $violations violations remain after $revision_count revisions"
   710â†’            fi
   711â†’        else
   712â†’            log "âœ… Constitutional AI check complete: $assessment (no violations)"
   713â†’        fi
   714â†’
   715â†’        # Log to audit trail
   716â†’        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   717â†’            if ! "$ENHANCED_AUDIT_TRAIL" log "constitutional_validation" \
   718â†’                "Validated and revised: $assessment, $violations violations, $revision_count revisions" \
   719â†’                "skip-validation,run-validation,auto-revise" \
   720â†’                "Ensures code quality, security, testing, error handling, compatibility, documentation, simplicity, and no data loss" \
   721â†’                "0.90" 2>/dev/null; then
   722â†’                log_failure "enhanced-audit-trail" "failed to log constitutional validation"
   723â†’            fi
   724â†’        fi
   725â†’    fi
   726â†’
   727â†’    # 3.3: Auto-evaluator quality gates
   728â†’    local eval_score=7.0
   729â†’    local eval_decision="continue"
   730â†’    if [[ -x "$AUTO_EVALUATOR" ]]; then
   731â†’        log "Running auto-evaluator quality assessment"
   732â†’
   733â†’        # Get evaluation criteria
   734â†’        local eval_criteria
   735â†’        eval_criteria=$("$AUTO_EVALUATOR" criteria "$task_type" 2>/dev/null || echo '{}')
   736â†’
   737â†’        # Use reflexion quality score with proper default handling
   738â†’        # If reflexion failed or returned no score, use a conservative 6.0 to trigger review
   739â†’        if [[ -n "$quality_score" && "$quality_score" != "null" && "$quality_score" != "7.0" ]]; then
   740â†’            eval_score="$quality_score"
   741â†’        elif [[ "$execution_result" =~ (failed|error|incomplete) ]]; then
   742â†’            # Failed execution gets low score to trigger revision
   743â†’            eval_score=5.0
   744â†’        elif [[ -z "$quality_score" || "$quality_score" == "null" ]]; then
   745â†’            # No quality assessment available, use conservative score
   746â†’            eval_score=6.5
   747â†’        fi
   748â†’
   749â†’        # Determine if revision needed (threshold 7.0)
   750â†’        if (( $(echo "$eval_score < 7.0" | bc -l 2>/dev/null || echo 0) )); then
   751â†’            eval_decision="revise"
   752â†’            log "Auto-evaluator: Quality below threshold ($eval_score < 7.0), revision recommended"
   753â†’        else
   754â†’            eval_decision="continue"
   755â†’            log "Auto-evaluator: Quality acceptable ($eval_score >= 7.0)"
   756â†’        fi
   757â†’
   758â†’        # Log to audit trail
   759â†’        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
   760â†’            if ! "$ENHANCED_AUDIT_TRAIL" log "quality_evaluation" \
   761â†’                "Evaluated output quality: $eval_score/10" \
   762â†’                "accept,revise,reject" \
   763â†’                "Score meets/exceeds threshold of 7.0 for $task_type tasks" \
   764â†’                "$(echo "$eval_score / 10" | bc -l 2>/dev/null || echo 0.7)" 2>/dev/null; then
   765â†’                log_failure "enhanced-audit-trail" "failed to log quality evaluation"
   766â†’            fi
   767â†’        fi
   768â†’    fi
   769â†’
   770â†’    # 3.4: Record to reinforcement learning
   771â†’    if [[ -x "$REINFORCEMENT_LEARNING" ]]; then
   772â†’        # Determine reward based on execution result and quality
   773â†’        local reward=0.0
   774â†’        if [[ "$execution_result" =~ (success|completed|started) ]]; then
   775â†’            reward=$(echo "scale=2; $eval_score / 10" | bc -l 2>/dev/null || echo "0.7")
   776â†’        else
   777â†’            reward=0.0
   778â†’        fi
   779â†’
   780â†’        if ! "$REINFORCEMENT_LEARNING" record "$task_type" "$context" "$execution_result" "$reward" 2>/dev/null; then
   781â†’            log_failure "reinforcement-learning" "failed to record outcome"
   782â†’        fi
   783â†’        log "Recorded RL outcome: $task_type -> $execution_result (reward: $reward)"
   784â†’    fi
   785â†’
   786â†’    # 3.5: Verify hypothesis
   787â†’    if [[ -n "$hypothesis_id" && -x "$HYPOTHESIS_TESTER" ]]; then
   788â†’        if ! "$HYPOTHESIS_TESTER" verify "$hypothesis_id" "$execution_result" "Execution completed" 2>/dev/null; then
   789â†’            log_failure "hypothesis-tester" "failed to verify hypothesis"
   790â†’        fi
   791â†’        log "Verified hypothesis: $hypothesis_id"
   792â†’    fi
   793â†’
   794â†’    # 3.6: Record outcome to feedback loop
   795â†’    if [[ -x "$FEEDBACK_LOOP" ]]; then
   796â†’        if ! "$FEEDBACK_LOOP" record "$task" "$task_type" "$strategy" "$execution_result" "$duration" "" "$context" 2>/dev/null; then
   797â†’            log_failure "feedback-loop" "failed to record outcome"
   798â†’        fi
   799â†’        log "Recorded feedback"
   800â†’    fi
   801â†’
   802â†’    # 3.3: Create meta-reflection
   803â†’    if [[ -x "$META_REFLECTION" ]]; then
   804â†’        if ! "$META_REFLECTION" reflect "what_learned" "$task" "$execution_result" "Used $strategy strategy with $risk_level risk" 2>/dev/null; then
   805â†’            log_failure "meta-reflection" "failed to create reflection"
   806â†’        fi
   807â†’        log "Created meta-reflection"
   808â†’    fi
   809â†’
   810â†’    # 3.4: Complete thinking session
   811â†’    if [[ -n "$thinking_id" && -x "$THINKING_FRAMEWORK" ]]; then
   812â†’        if ! "$THINKING_FRAMEWORK" complete "Completed: $execution_result" 0.8 2>/dev/null; then
   813â†’            log_failure "thinking-framework" "failed to complete session"
   814â†’        fi
   815â†’        log "Completed thinking session"
   816â†’    fi
   817â†’
   818â†’    # 3.5: Complete plan
   819â†’    if [[ -n "$plan_id" && -x "$PLAN_EXECUTE" ]]; then
   820â†’        if ! "$PLAN_EXECUTE" finish "$execution_result" "Coordination complete" 2>/dev/null; then
   821â†’            log_failure "plan-execute" "failed to finish plan"
   822â†’        fi
   823â†’    fi
   824â†’
   825â†’    update_coordinator_status "status" "idle"
   826â†’    update_coordinator_status "currentTask" "null"
   827â†’
   828â†’    # Return comprehensive result with full intelligence data
   829â†’    jq -n \
   830â†’        --arg task "$task" \
   831â†’        --arg strategy "$strategy" \
   832â†’        --argjson strategyConf "$strategy_confidence" \
   833â†’        --arg riskLevel "$risk_level" \
   834â†’        --argjson riskScore "$risk_score" \
   835â†’        --arg agentId "$agent_id" \
   836â†’        --arg planId "$plan_id" \
   837â†’        --arg thinkingId "$thinking_id" \
   838â†’        --argjson duration "$duration" \
   839â†’        --arg result "$execution_result" \
   840â†’        --argjson patternCount "$(echo "$patterns" | jq 'length')" \
   841â†’        --arg reasoningMode "$reasoning_mode" \
   842â†’        --arg assignedAgent "$assigned_agent" \
   843â†’        --argjson qualityScore "$quality_score" \
   844â†’        --argjson evalScore "$eval_score" \
   845â†’        --arg evalDecision "$eval_decision" \
   846â†’        --arg totApproach "$selected_approach" \
   847â†’        --argjson githubSearch "$github_search_results" \
   848â†’        '{
   849â†’            task: $task,
   850â†’            autoResearch: $githubSearch,
   851â†’            execution: {
   852â†’                agentId: $agentId,
   853â†’                planId: $planId,
   854â†’                thinkingId: $thinkingId,
   855â†’                result: $result,
   856â†’                duration: $duration
   857â†’            },
   858â†’            intelligence: {
   859â†’                strategy: $strategy,
   860â†’                strategyConfidence: $strategyConf,
   861â†’                riskLevel: $riskLevel,
   862â†’                riskScore: $riskScore,
   863â†’                patternsFound: $patternCount,
   864â†’                reasoningMode: $reasoningMode,
   865â†’                assignedAgent: $assignedAgent,
   866â†’                totSelectedApproach: $totApproach
   867â†’            },
   868â†’            quality: {
   869â†’                reflexionScore: $qualityScore,
   870â†’                evaluatorScore: $evalScore,
   871â†’                decision: $evalDecision,
   872â†’                constitutionalValidation: "completed"
   873â†’            },
   874â†’            learning: {
   875â†’                reinforcementLearning: "recorded",
   876â†’                reflexionLessons: "extracted",
   877â†’                auditTrail: "logged"
   878â†’            },
   879â†’            timestamp: (now | todate)
   880â†’        }'
   881â†’
   882â†’    log "Coordination complete for: $task (result: $execution_result, duration: ${duration}s)"
   883â†’}
   884â†’
   885â†’# =============================================================================
   886â†’# AUTONOMOUS ORCHESTRATION
   887â†’# =============================================================================
   888â†’
   889â†’orchestrate_autonomous() {
   890â†’    init_coordinator
   891â†’
   892â†’    log "Starting autonomous orchestration"
   893â†’
   894â†’    # Get orchestration decisions
   895â†’    if [[ ! -x "$ORCHESTRATOR" ]]; then
   896â†’        log "Orchestrator not available"
   897â†’        echo '{"error":"orchestrator_unavailable"}'
   898â†’        return 1
   899â†’    fi
   900â†’
   901â†’    local orchestration
   902â†’    orchestration=$("$ORCHESTRATOR" smart 2>/dev/null || echo '{"decisions":[],"actions":[]}')
   903â†’
   904â†’    log "Orchestration: $(echo "$orchestration" | jq -c '.')"
   905â†’
   906â†’    # Get actions to execute
   907â†’    local actions
   908â†’    actions=$(echo "$orchestration" | jq -r '.actions[]' 2>/dev/null || true)
   909â†’
   910â†’    if [[ -z "$actions" ]]; then
   911â†’        log "No actions to execute"
   912â†’        echo '{"status":"no_actions","orchestration":'"$orchestration"'}'
   913â†’        return
   914â†’    fi
   915â†’
   916â†’    # Execute each action through coordinator
   917â†’    while IFS= read -r action; do
   918â†’        [[ -z "$action" ]] && continue
   919â†’
   920â†’        case "$action" in
   921â†’            start_task:*)
   922â†’                local task_id
   923â†’                task_id=$(echo "$action" | cut -d: -f2)
   924â†’                local task_name
   925â†’                task_name=$(echo "$action" | cut -d: -f3-)
   926â†’
   927â†’                log "Executing action: start_task $task_name"
   928â†’
   929â†’                # Coordinate the task
   930â†’                coordinate_task "$task_name" "general" "from buildguide"
   931â†’                ;;
   932â†’            *)
   933â†’                log "Unknown action: $action"
   934â†’                ;;
   935â†’        esac
   936â†’    done <<< "$actions"
   937â†’
   938â†’    echo '{"status":"completed","orchestration":'"$orchestration"'}'
   939â†’}
   940â†’
   941â†’# =============================================================================
   942â†’# COMMAND INTERFACE
   943â†’# =============================================================================
   944â†’
   945â†’case "${1:-help}" in
   946â†’    init)
   947â†’        init_coordinator
   948â†’        ;;
   949â†’    coordinate)
   950â†’        coordinate_task "${2:-task}" "${3:-general}" "${4:-}"
   951â†’        ;;
   952â†’    orchestrate)
   953â†’        orchestrate_autonomous
   954â†’        ;;
   955â†’    status)
   956â†’        cat "$COORD_STATE"
   957â†’        ;;
   958â†’    help|*)
   959â†’        echo "Central Coordinator - Intelligence Layer"
   960â†’        echo ""
   961â†’        echo "Usage: $0 <command> [args]"
   962â†’        echo ""
   963â†’        echo "Commands:"
   964â†’        echo "  init                                  - Initialize coordinator"
   965â†’        echo "  coordinate <task> [type] [context]    - Coordinate single task"
   966â†’        echo "  orchestrate                           - Autonomous orchestration"
   967â†’        echo "  status                                - Get coordinator status"
   968â†’        echo ""
   969â†’        echo "Examples:"
   970â†’        echo "  $0 coordinate 'implement auth' feature"
   971â†’        echo "  $0 orchestrate  # Run autonomous orchestration"
   972â†’        ;;
   973â†’esac
   974â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
