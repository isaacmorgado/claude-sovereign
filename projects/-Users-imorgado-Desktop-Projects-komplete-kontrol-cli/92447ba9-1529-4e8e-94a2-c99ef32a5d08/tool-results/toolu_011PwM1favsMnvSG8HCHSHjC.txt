     1→/**
     2→ * CLI Framework for KOMPLETE-KONTROL CLI
     3→ *
     4→ * Provides command-line interface using yargs with subcommands and options.
     5→ */
     6→
     7→import yargs, { type Argv } from 'yargs';
     8→import { hideBin } from 'yargs/helpers';
     9→import chalk from 'chalk';
    10→import { Logger, LogLevel } from '../utils/logger';
    11→import { ConfigManager } from '../config';
    12→import { handleError, ErrorHandler } from '../utils/error-handler';
    13→import {
    14→  getAgentRegistry,
    15→  getAgentLifecycleManager,
    16→  AgentLifecycleState,
    17→  initializeTestAgents,
    18→} from '../core/agents';
    19→import {
    20→  SessionManager,
    21→  createSessionManager,
    22→  ContextWindow,
    23→  createContextWindow,
    24→  TokenCounter,
    25→  TokenBudget,
    26→  createTokenBudget,
    27→  TokenTracker,
    28→  createTokenTracker,
    29→  MemoryFileHandler,
    30→  createMemoryFileHandler,
    31→  type ContextMessage,
    32→  type Session,
    33→} from '../core/context';
    34→import type { Message, MessageRole, MessageContent, TextContent } from '../types';
    35→import {
    36→  CommandRegistry,
    37→  createCommandRegistry,
    38→  CommandParser,
    39→  type CommandListOptions,
    40→} from '../core/commands';
    41→import {
    42→  getProviderRegistry,
    43→  getModelRouter,
    44→  initializeProviders,
    45→  type ParsedModel,
    46→} from '../core/providers';
    47→import {
    48→  getMCPRegistry,
    49→  createMCPClient,
    50→  connectToMCPServer,
    51→  type MCPServerState,
    52→  type MCPTool,
    53→} from '../mcp';
    54→
    55→/**
    56→ * CLI configuration
    57→ */
    58→interface CLIConfig {
    59→  logger: Logger;
    60→  configManager: ConfigManager;
    61→  sessionManager?: SessionManager;
    62→  tokenBudget?: TokenBudget;
    63→  tokenTracker?: TokenTracker;
    64→  memoryFileHandler?: MemoryFileHandler;
    65→  commandRegistry?: CommandRegistry;
    66→  providerRegistry?: ReturnType<typeof getProviderRegistry>;
    67→  modelRouter?: ReturnType<typeof getModelRouter>;
    68→  mcpRegistry?: ReturnType<typeof getMCPRegistry>;
    69→}
    70→
    71→/**
    72→ * CLI class
    73→ */
    74→export class CLI {
    75→  private config: CLIConfig;
    76→  private initialized: boolean = false;
    77→
    78→  constructor(config: CLIConfig) {
    79→    this.config = config;
    80→    
    81→    // Initialize context managers if not provided
    82→    if (!this.config.sessionManager) {
    83→      this.config.sessionManager = createSessionManager();
    84→    }
    85→    if (!this.config.tokenBudget) {
    86→      this.config.tokenBudget = createTokenBudget();
    87→    }
    88→    if (!this.config.tokenTracker) {
    89→      this.config.tokenTracker = createTokenTracker();
    90→    }
    91→    if (!this.config.memoryFileHandler) {
    92→      this.config.memoryFileHandler = createMemoryFileHandler();
    93→    }
    94→    if (!this.config.commandRegistry) {
    95→      const errorHandler = new ErrorHandler({ logger: this.config.logger });
    96→      const parser = new CommandParser(this.config.logger, errorHandler);
    97→      this.config.commandRegistry = createCommandRegistry(
    98→        this.config.logger,
    99→        errorHandler,
   100→        parser
   101→      );
   102→    }
   103→    // Initialize provider registry if not provided
   104→    if (!this.config.providerRegistry) {
   105→      this.config.providerRegistry = getProviderRegistry();
   106→    }
   107→    // Initialize model router if not provided
   108→    if (!this.config.modelRouter) {
   109→      this.config.modelRouter = getModelRouter(undefined, this.config.logger);
   110→    }
   111→    // Initialize MCP registry if not provided
   112→    if (!this.config.mcpRegistry) {
   113→      this.config.mcpRegistry = getMCPRegistry();
   114→    }
   115→  }
   116→
   117→  /**
   118→   * Initialize CLI components
   119→   */
   120→  async initialize(): Promise<void> {
   121→    if (this.initialized) {
   122→      return;
   123→    }
   124→
   125→    // Initialize session manager
   126→    try {
   127→      await this.config.sessionManager!.initialize();
   128→      this.config.logger.info('Session manager initialized', 'CLI', {
   129→        sessionCount: this.config.sessionManager!.listSessions().length,
   130→      });
   131→    } catch (error) {
   132→      this.config.logger.error('Failed to initialize session manager', 'CLI', { error });
   133→    }
   134→
   135→    // Initialize command registry
   136→    try {
   137→      await this.config.commandRegistry!.initialize();
   138→      this.config.logger.info('Command registry initialized', 'CLI', {
   139→        commandCount: this.config.commandRegistry!.listCommands().length,
   140→      });
   141→    } catch (error) {
   142→      this.config.logger.error('Failed to initialize command registry', 'CLI', { error });
   143→    }
   144→
   145→    this.initialized = true;
   146→  }
   147→
   148→  /**
   149→   * Parse and execute CLI command
   150→   */
   151→  async parse(): Promise<void> {
   152→    await this.buildYargs().parseAsync();
   153→  }
   154→
   155→  /**
   156→   * Build yargs instance with all commands
   157→   */
   158→  private buildYargs(): Argv {
   159→    return yargs(hideBin(process.argv))
   160→      .scriptName('komplete-kontrol')
   161→      .version('1.0.0')
   162→      .alias('v', 'version')
   163→      .help('help')
   164→      .alias('h', 'help')
   165→      .wrap(Math.min(120, process.stdout.columns || 80))
   166→      .strict()
   167→      .fail((msg, err) => {
   168→        if (err) {
   169→          handleError(err, { operation: 'CLI' });
   170→        } else {
   171→          console.error(chalk.red(msg));
   172→        }
   173→        process.exit(1);
   174→      })
   175→      // Global options
   176→      .option('verbose', {
   177→        alias: 'V',
   178→        type: 'boolean',
   179→        description: 'Enable verbose output',
   180→        global: true,
   181→      })
   182→      .option('quiet', {
   183→        alias: 'q',
   184→        type: 'boolean',
   185→        description: 'Suppress non-error output',
   186→        global: true,
   187→      })
   188→      .option('config', {
   189→        alias: 'c',
   190→        type: 'string',
   191→        description: 'Path to configuration file',
   192→        global: true,
   193→      })
   194→      .option('log-level', {
   195→        type: 'string',
   196→        choices: ['debug', 'info', 'warn', 'error'] as const,
   197→        description: 'Set log level',
   198→        global: true,
   199→      })
   200→      // Chat command
   201→      .command(
   202→        'chat',
   203→        'Start an interactive chat session',
   204→        (yargs) => {
   205→          return yargs
   206→            .option('model', {
   207→              alias: 'm',
   208→              type: 'string',
   209→              description: 'Model to use (e.g., or/claude-3.5-sonnet)',
   210→            })
   211→            .option('mode', {
   212→              type: 'string',
   213→              choices: ['general', 'coder', 'intense-research', 'reverse-engineer', 'spark'] as const,
   214→              description: 'Agent mode to use',
   215→            })
   216→            .option('session', {
   217→              alias: 's',
   218→              type: 'string',
   219→              description: 'Session ID to resume',
   220→            })
   221→            .option('max-cost', {
   222→              type: 'number',
   223→              description: 'Maximum cost for this command',
   224→            });
   225→        },
   226→        async (argv) => {
   227→          await this.applyGlobalOptions(argv as any);
   228→          await this.handleChat(argv as any);
   229→        }
   230→      )
   231→      // Agent command
   232→      .command(
   233→        'agent',
   234→        'Manage and interact with agents',
   235→        (yargs) => {
   236→          return yargs
   237→            .command('list', 'List available agents', {}, async (argv) => {
   238→              await this.applyGlobalOptions(argv as any);
   239→              await this.handleAgentList();
   240→            })
   241→            .command('info <agent-id>', 'Show agent information', {}, async (argv) => {
   242→              await this.applyGlobalOptions(argv as any);
   243→              await this.handleAgentInfo(argv as any);
   244→            })
   245→            .demandCommand(1, 'Please specify a subcommand');
   246→        },
   247→        async (argv) => {
   248→          await this.applyGlobalOptions(argv as any);
   249→        }
   250→      )
   251→      // Config command
   252→      .command(
   253→        'config',
   254→        'Manage configuration',
   255→        (yargs) => {
   256→          return yargs
   257→            .command('show', 'Show current configuration', {}, async (argv) => {
   258→              await this.applyGlobalOptions(argv as any);
   259→              await this.handleConfigShow();
   260→            })
   261→            .command('set <key> <value>', 'Set configuration value', {}, async (argv) => {
   262→              await this.applyGlobalOptions(argv as any);
   263→              await this.handleConfigSet(argv as any);
   264→            })
   265→            .command('get <key>', 'Get configuration value', {}, async (argv) => {
   266→              await this.applyGlobalOptions(argv as any);
   267→              await this.handleConfigGet(argv as any);
   268→            })
   269→            .command('init', 'Initialize configuration file', {}, async (argv) => {
   270→              await this.applyGlobalOptions(argv as any);
   271→              await this.handleConfigInit();
   272→            })
   273→            .demandCommand(1, 'Please specify a subcommand');
   274→        },
   275→        async (argv) => {
   276→          await this.applyGlobalOptions(argv as any);
   277→        }
   278→      )
   279→      // Provider command
   280→      .command(
   281→        'provider',
   282→        'Manage AI providers',
   283→        (yargs) => {
   284→          return yargs
   285→            .command('list', 'List available providers', {}, async (argv) => {
   286→              await this.applyGlobalOptions(argv as any);
   287→              await this.handleProviderList();
   288→            })
   289→            .command('test <provider>', 'Test provider connection', {}, async (argv) => {
   290→              await this.applyGlobalOptions(argv as any);
   291→              await this.handleProviderTest(argv as any);
   292→            })
   293→            .demandCommand(1, 'Please specify a subcommand');
   294→        },
   295→        async (argv) => {
   296→          await this.applyGlobalOptions(argv as any);
   297→        }
   298→      )
   299→      // Session command
   300→      .command(
   301→        'session',
   302→        'Manage sessions',
   303→        (yargs) => {
   304→          return yargs
   305→            .command('create', 'Create a new session', {}, async (argv) => {
   306→              await this.applyGlobalOptions(argv as any);
   307→              await this.handleSessionCreate(argv as any);
   308→            })
   309→            .command('list', 'List sessions', {}, async (argv) => {
   310→              await this.applyGlobalOptions(argv as any);
   311→              await this.handleSessionList();
   312→            })
   313→            .command('show <session-id>', 'Show session details', {}, async (argv) => {
   314→              await this.applyGlobalOptions(argv as any);
   315→              await this.handleSessionShow(argv as any);
   316→            })
   317→            .command('delete <session-id>', 'Delete a session', {}, async (argv) => {
   318→              await this.applyGlobalOptions(argv as any);
   319→              await this.handleSessionDelete(argv as any);
   320→            })
   321→            .demandCommand(1, 'Please specify a subcommand');
   322→        },
   323→        async (argv) => {
   324→          await this.applyGlobalOptions(argv as any);
   325→        }
   326→      )
   327→      // MCP command
   328→      .command(
   329→        'mcp',
   330→        'Manage MCP servers',
   331→        (yargs) => {
   332→          return yargs
   333→            .command('list', 'List MCP servers', {}, async (argv) => {
   334→              await this.applyGlobalOptions(argv as any);
   335→              await this.handleMCPList();
   336→            })
   337→            .command('start <server-id>', 'Start MCP server', {}, async (argv) => {
   338→              await this.applyGlobalOptions(argv as any);
   339→              await this.handleMCPStart(argv as any);
   340→            })
   341→            .command('stop <server-id>', 'Stop MCP server', {}, async (argv) => {
   342→              await this.applyGlobalOptions(argv as any);
   343→              await this.handleMCPStop(argv as any);
   344→            })
   345→            .demandCommand(1, 'Please specify a subcommand');
   346→        },
   347→        async (argv) => {
   348→          await this.applyGlobalOptions(argv as any);
   349→        }
   350→      )
   351→      // Context command
   352→      .command(
   353→        'context',
   354→        'Manage context and memory',
   355→        (yargs) => {
   356→          return yargs
   357→            .command('show <session-id>', 'Show context for session', {}, async (argv) => {
   358→              await this.applyGlobalOptions(argv as any);
   359→              await this.handleContextShow(argv as any);
   360→            })
   361→            .command('clear <session-id>', 'Clear context for session', {}, async (argv) => {
   362→              await this.applyGlobalOptions(argv as any);
   363→              await this.handleContextClear(argv as any);
   364→            })
   365→            .demandCommand(1, 'Please specify a subcommand');
   366→        },
   367→        async (argv) => {
   368→          await this.applyGlobalOptions(argv as any);
   369→        }
   370→      )
   371→      // Memory command
   372→      .command(
   373→        'memory',
   374→        'Manage .memory.md files',
   375→        (yargs) => {
   376→          return yargs
   377→            .command('show', 'Show current memory file', {}, async (argv) => {
   378→              await this.applyGlobalOptions(argv as any);
   379→              await this.handleMemoryShow();
   380→            })
   381→            .command('edit', 'Edit memory file', {}, async (argv) => {
   382→              await this.applyGlobalOptions(argv as any);
   383→              await this.handleMemoryEdit();
   384→            })
   385→            .demandCommand(1, 'Please specify a subcommand');
   386→        },
   387→        async (argv) => {
   388→          await this.applyGlobalOptions(argv as any);
   389→        }
   390→      )
   391→      // Budget command
   392→      .command(
   393→        'budget',
   394→        'Manage cost budget',
   395→        (yargs) => {
   396→          return yargs
   397→            .command('show', 'Show budget status', {}, async (argv) => {
   398→              await this.applyGlobalOptions(argv as any);
   399→              await this.handleBudgetShow();
   400→            })
   401→            .command('reset', 'Reset daily budget', {}, async (argv) => {
   402→              await this.applyGlobalOptions(argv as any);
   403→              await this.handleBudgetReset();
   404→            })
   405→            .demandCommand(1, 'Please specify a subcommand');
   406→        },
   407→        async (argv) => {
   408→          await this.applyGlobalOptions(argv as any);
   409→        }
   410→      )
   411→      // Parallel command
   412→      .command(
   413→        'parallel',
   414→        'Execute parallel tasks',
   415→        (yargs) => {
   416→          return yargs
   417→            .option('tasks', {
   418→              alias: 't',
   419→              type: 'string',
   420→              description: 'Comma-separated task descriptions',
   421→            })
   422→            .option('file', {
   423→              alias: 'f',
   424→              type: 'string',
   425→              description: 'File containing task definitions',
   426→            })
   427→            .demandOption(['tasks', 'file'], 'Please provide either --tasks or --file');
   428→        },
   429→        async (argv) => {
   430→          await this.applyGlobalOptions(argv as any);
   431→          await this.handleParallel(argv as any);
   432→        }
   433→      )
   434→      // Debug command
   435→      .command(
   436→        'debug',
   437→        'Debug and troubleshooting tools',
   438→        (yargs) => {
   439→          return yargs
   440→            .command('logs', 'Show recent logs', {}, async (argv) => {
   441→              await this.applyGlobalOptions(argv as any);
   442→              await this.handleDebugLogs();
   443→            })
   444→            .command('status', 'Show system status', {}, async (argv) => {
   445→              await this.applyGlobalOptions(argv as any);
   446→              await this.handleDebugStatus();
   447→            })
   448→            .demandCommand(1, 'Please specify a subcommand');
   449→        },
   450→        async (argv) => {
   451→          await this.applyGlobalOptions(argv as any);
   452→        }
   453→      )
   454→      // Slash command
   455→      .command(
   456→        'slash <command>',
   457→        'Execute a slash command',
   458→        (yargs) => {
   459→          return yargs
   460→            .positional('command', {
   461→              type: 'string',
   462→              description: 'Slash command to execute (e.g., help, context-show, session-list)',
   463→            })
   464→            .option('args', {
   465→              alias: 'a',
   466→              type: 'string',
   467→              description: 'Arguments to pass to command',
   468→            });
   469→        },
   470→        async (argv) => {
   471→          await this.applyGlobalOptions(argv as any);
   472→          await this.handleSlashCommand(argv as any);
   473→        }
   474→      );
   475→  }
   476→
   477→  /**
   478→   * Apply global options
   479→   */
   480→  private async applyGlobalOptions(argv: any): Promise<void> {
   481→    // Set log level
   482→    if (argv.logLevel) {
   483→      const levelMap: Record<string, LogLevel> = {
   484→        debug: LogLevel.DEBUG,
   485→        info: LogLevel.INFO,
   486→        warn: LogLevel.WARN,
   487→        error: LogLevel.ERROR,
   488→      };
   489→      this.config.logger.config.level = levelMap[argv.logLevel] ?? this.config.logger.config.level;
   490→    }
   491→
   492→    // Verbose mode
   493→    if (argv.verbose) {
   494→      this.config.logger.config.level = LogLevel.DEBUG;
   495→    }
   496→
   497→    // Quiet mode
   498→    if (argv.quiet) {
   499→      this.config.logger.config.level = LogLevel.ERROR;
   500→    }
   501→
   502→    // Load custom config
   503→    if (argv.config) {
   504→      await this.config.configManager.load(argv.config);
   505→    } else if (!this.config.configManager.getAll()) {
   506→      // Try to load default config
   507→      try {
   508→        await this.config.configManager.load();
   509→      } catch (error) {
   510→        // Config not found, continue with defaults
   511→      }
   512→    }
   513→  }
   514→
   515→  /**
   516→   * Handle chat command
   517→   */
   518→  private async handleChat(argv: any): Promise<void> {
   519→    this.config.logger.info('Starting chat session', 'CLI', {
   520→      model: argv.model,
   521→      mode: argv.mode,
   522→      session: argv.session,
   523→    });
   524→
   525→    console.log(chalk.cyan('KOMPLETE-KONTROL Chat'));
   526→    console.log(chalk.gray('Press Ctrl+C to exit\n'));
   527→
   528→    // TODO: Implement chat session
   529→    console.log(chalk.yellow('Chat session not yet implemented'));
   530→  }
   531→
   532→  /**
   533→   * Handle agent list command
   534→   */
   535→  private async handleAgentList(): Promise<void> {
   536→    this.config.logger.info('Listing agents', 'CLI');
   537→
   538→    const registry = getAgentRegistry();
   539→    const lifecycleManager = getAgentLifecycleManager();
   540→
   541→    const agents = registry.list();
   542→    const stats = registry.getStatistics();
   543→
   544→    console.log(chalk.cyan('Available Agents:'));
   545→    console.log(chalk.gray(`Total: ${stats.totalAgents} | Active: ${stats.activeAgents} | Paused: ${stats.pausedAgents}\n`));
   546→
   547→    if (agents.length === 0) {
   548→      console.log(chalk.yellow('No agents registered'));
   549→      return;
   550→    }
   551→
   552→    for (const agent of agents) {
   553→      const state = lifecycleManager.getState(agent.id);
   554→      const isActive = lifecycleManager.isActive(agent.id);
   555→
   556→      const statusColor = isActive ? chalk.green : chalk.yellow;
   557→      const statusText = state || 'unknown';
   558→
   559→      console.log(`  ${chalk.cyan(agent.id)}`);
   560→      console.log(`    ${chalk.gray('Name:')} ${agent.name}`);
   561→      console.log(`    ${chalk.gray('Description:')} ${agent.description}`);
   562→      console.log(`    ${chalk.gray('Capabilities:')} ${agent.capabilities.join(', ')}`);
   563→      console.log(`    ${chalk.gray('Status:')} ${statusColor(statusText)}`);
   564→
   565→      if (agent.dependencies && agent.dependencies.length > 0) {
   566→        console.log(`    ${chalk.gray('Dependencies:')} ${agent.dependencies.join(', ')}`);
   567→      }
   568→
   569→      console.log('');
   570→    }
   571→  }
   572→
   573→  /**
   574→   * Handle agent info command
   575→   */
   576→  private async handleAgentInfo(argv: any): Promise<void> {
   577→    this.config.logger.info('Showing agent info', 'CLI', { agentId: argv.agentId });
   578→
   579→    const registry = getAgentRegistry();
   580→    const lifecycleManager = getAgentLifecycleManager();
   581→
   582→    const agent = registry.get(argv.agentId);
   583→
   584→    if (!agent) {
   585→      console.log(chalk.red(`Agent '${argv.agentId}' not found`));
   586→      return;
   587→    }
   588→
   589→    const state = lifecycleManager.getState(agent.id);
   590→    const instance = lifecycleManager.getInstance(agent.id);
   591→
   592→    console.log(chalk.cyan(`Agent: ${agent.id}`));
   593→    console.log('');
   594→    console.log(`  ${chalk.gray('Name:')} ${agent.name}`);
   595→    console.log(`  ${chalk.gray('Description:')} ${agent.description}`);
   596→    console.log(`  ${chalk.gray('Capabilities:')} ${agent.capabilities.join(', ')}`);
   597→    console.log(`  ${chalk.gray('System Prompt:')} ${agent.systemPrompt.substring(0, 100)}${agent.systemPrompt.length > 100 ? '...' : ''}`);
   598→    console.log(`  ${chalk.gray('Status:')} ${state || 'unknown'}`);
   599→    console.log(`  ${chalk.gray('Active:')} ${instance?.isActive ? chalk.green('Yes') : chalk.red('No')}`);
   600→
   601→    if (agent.dependencies && agent.dependencies.length > 0) {
   602→      console.log(`  ${chalk.gray('Dependencies:')} ${agent.dependencies.join(', ')}`);
   603→    }
   604→
   605→    if (instance) {
   606→      console.log('');
   607→      console.log(chalk.cyan('Execution Context:'));
   608→      console.log(`  ${chalk.gray('Task History:')} ${instance.context.taskHistory.length} tasks`);
   609→      console.log(`  ${chalk.gray('Context Data:')} ${instance.context.contextData.size} entries`);
   610→
   611→      if (instance.context.currentTask) {
   612→        console.log('');
   613→        console.log(chalk.cyan('Current Task:'));
   614→        console.log(`  ${chalk.gray('Description:')} ${instance.context.currentTask.description}`);
   615→        if (instance.context.currentTask.requiredCapability) {
   616→          console.log(`  ${chalk.gray('Required Capability:')} ${instance.context.currentTask.requiredCapability}`);
   617→        }
   618→      }
   619→    }
   620→
   621→    if (instance?.error) {
   622→      console.log('');
   623→      console.log(chalk.red('Error:'));
   624→      console.log(`  ${instance.error.message}`);
   625→    }
   626→  }
   627→
   628→  /**
   629→   * Handle config show command
   630→   */
   631→  private async handleConfigShow(): Promise<void> {
   632→    this.config.logger.info('Showing configuration', 'CLI');
   633→
   634→    const config = this.config.configManager.getAll();
   635→    console.log(chalk.cyan('Current Configuration:'));
   636→    console.log(JSON.stringify(config, null, 2));
   637→  }
   638→
   639→  /**
   640→   * Handle config set command
   641→   */
   642→  private async handleConfigSet(argv: any): Promise<void> {
   643→    this.config.logger.info('Setting configuration', 'CLI', { key: argv.key, value: argv.value });
   644→
   645→    // TODO: Implement config set
   646→    console.log(chalk.yellow('Config set not yet implemented'));
   647→  }
   648→
   649→  /**
   650→   * Handle config get command
   651→   */
   652→  private async handleConfigGet(argv: any): Promise<void> {
   653→    this.config.logger.info('Getting configuration', 'CLI', { key: argv.key });
   654→
   655→    // TODO: Implement config get
   656→    console.log(chalk.yellow('Config get not yet implemented'));
   657→  }
   658→
   659→  /**
   660→   * Handle config init command
   661→   */
   662→  private async handleConfigInit(): Promise<void> {
   663→    this.config.logger.info('Initializing configuration', 'CLI');
   664→
   665→    // TODO: Implement config init
   666→    console.log(chalk.yellow('Config init not yet implemented'));
   667→  }
   668→
   669→  /**
   670→   * Handle provider list command
   671→   */
   672→  private async handleProviderList(): Promise<void> {
   673→    this.config.logger.info('Listing providers', 'CLI');
   674→
   675→    console.log(chalk.cyan('Registered Providers:'));
   676→    
   677→    const providers = this.config.providerRegistry!.list();
   678→    
   679→    if (providers.length === 0) {
   680→      console.log(chalk.yellow('No providers registered'));
   681→      console.log('');
   682→      console.log(chalk.gray('To register providers, ensure your configuration has API keys set.'));
   683→      console.log(chalk.gray('Use: komplete-kontrol config show'));
   684→      return;
   685→    }
   686→
   687→    for (const provider of providers) {
   688→      const statusColor = provider.capabilities.streaming ? chalk.green : chalk.gray;
   689→      const toolsStatus = provider.capabilities.tools ? chalk.green('Yes') : chalk.gray('No');
   690→      const visionStatus = provider.capabilities.vision ? chalk.green('Yes') : chalk.gray('No');
   691→      
   692→      console.log('');
   693→      console.log(`  ${chalk.cyan(provider.name)} [${chalk.gray(provider.prefix)}]`);
   694→      console.log(`    ${chalk.gray('Streaming:')} ${statusColor(provider.capabilities.streaming ? 'Yes' : 'No')}`);
   695→      console.log(`    ${chalk.gray('Tools:')} ${toolsStatus}`);
   696→      console.log(`    ${chalk.gray('Vision:')} ${visionStatus}`);
   697→      console.log(`    ${chalk.gray('Max Tokens:')} ${provider.capabilities.maxTokens.toLocaleString()}`);
   698→      console.log(`    ${chalk.gray('Priority:')} ${provider.priority}`);
   699→      console.log(`    ${chalk.gray('Registered:')} ${provider.registeredAt.toLocaleString()}`);
   700→    }
   701→
   702→    console.log('');
   703→    console.log(chalk.gray('Model format: <prefix>/<model-name>'));
   704→    console.log(chalk.gray('Examples:'));
   705→    console.log(chalk.gray('  oai/gpt-4o'));
   706→    console.log(chalk.gray('  anthropic/claude-3.5-sonnet'));
   707→    console.log(chalk.gray('  ollama/llama3'));
   708→  }
   709→
   710→  /**
   711→   * Handle provider test command
   712→   */
   713→  private async handleProviderTest(argv: any): Promise<void> {
   714→    this.config.logger.info('Testing provider', 'CLI', { provider: argv.provider });
   715→
   716→    console.log(chalk.cyan(`Testing provider: ${argv.provider}`));
   717→    
   718→    try {
   719→      // Parse the provider prefix
   720→      let prefix: string;
   721→      if (argv.provider.includes('/')) {
   722→        const parsed = this.config.modelRouter!.parseModel(argv.provider);
   723→        prefix = parsed.prefix;
   724→      } else {
   725→        prefix = argv.provider;
   726→      }
   727→
   728→      // Get the provider from registry
   729→      const provider = this.config.providerRegistry!.get(prefix as any);
   730→      
   731→      if (!provider) {
   732→        console.log(chalk.red(`Provider '${argv.provider}' is not registered`));
   733→        console.log('');
   734→        console.log(chalk.gray('Available providers:'));
   735→        const providers = this.config.providerRegistry!.list();
   736→        providers.forEach(p => {
   737→          console.log(chalk.gray(`  ${p.prefix} - ${p.name}`));
   738→        });
   739→        return;
   740→      }
   741→
   742→      console.log('');
   743→      console.log(chalk.cyan(`Provider: ${provider.name}`));
   744→      console.log(chalk.gray(`Prefix: ${provider.prefix}`));
   745→      console.log(chalk.gray(`Streaming: ${provider.capabilities.streaming ? 'Yes' : 'No'}`));
   746→      console.log(chalk.gray(`Tools: ${provider.capabilities.tools ? 'Yes' : 'No'}`));
   747→      console.log(chalk.gray(`Vision: ${provider.capabilities.vision ? 'Yes' : 'No'}`));
   748→      console.log(chalk.gray(`Max Tokens: ${provider.capabilities.maxTokens.toLocaleString()}`));
   749→      
   750→      // Test token counting
   751→      console.log('');
   752→      console.log(chalk.cyan('Testing token counting...'));
   753→      const testMessages: Message[] = [
   754→        { role: 'user', content: { type: 'text', text: 'Hello, world!' } },
   755→      ];
   756→      const tokenCount = await provider.countTokens(testMessages);
   757→      console.log(chalk.green(`✓ Token count: ${tokenCount}`));
   758→      
   759→      console.log('');
   760→      console.log(chalk.green('Provider test successful!'));
   761→      
   762→    } catch (error) {
   763→      console.log('');
   764→      console.log(chalk.red(`Provider test failed: ${(error as Error).message}`));
   765→      this.config.logger.error('Provider test failed', 'CLI', { error });
   766→    }
   767→  }
   768→
   769→  /**
   770→   * Handle session list command
   771→   */
   772→  private async handleSessionList(): Promise<void> {
   773→    this.config.logger.info('Listing sessions', 'CLI');
   774→
   775→    console.log(chalk.cyan('Sessions:'));
   776→    
   777→    const sessions = this.config.sessionManager!.listSessions();
   778→    
   779→    if (sessions.length === 0) {
   780→      console.log(chalk.yellow('No sessions found'));
   781→      return;
   782→    }
   783→
   784→    console.log(chalk.gray(`Total: ${sessions.length}\n`));
   785→
   786→    const activeSession = this.config.sessionManager!.getActiveSession();
   787→
   788→    sessions.forEach((session: Session, index: number) => {
   789→      const isActive = activeSession?.id === session.id;
   790→      const statusColor = isActive ? chalk.green : chalk.gray;
   791→      console.log(`  ${chalk.cyan(`${index + 1}. ${session.id}`)}`);
   792→      console.log(`    ${chalk.gray('Agent:')} ${session.agent || 'N/A'}`);
   793→      console.log(`    ${chalk.gray('Model:')} ${session.model || 'N/A'}`);
   794→      console.log(`    ${chalk.gray('Created:')} ${new Date(session.created).toLocaleString()}`);
   795→      console.log(`    ${chalk.gray('Updated:')} ${new Date(session.updated).toLocaleString()}`);
   796→      console.log(`    ${chalk.gray('Status:')} ${statusColor(isActive ? 'Active' : 'Inactive')}`);
   797→      console.log(`    ${chalk.gray('Messages:')} ${session.messages.length}`);
   798→      console.log(`    ${chalk.gray('Tokens:')} ${session.totalTokens ?? 0}`);
   799→      console.log('');
   800→    });
   801→  }
   802→
   803→  /**
   804→   * Handle session show command
   805→   */
   806→  private async handleSessionShow(argv: any): Promise<void> {
   807→    this.config.logger.info('Showing session', 'CLI', { sessionId: argv.sessionId });
   808→
   809→    console.log(chalk.cyan(`Session: ${argv.sessionId}`));
   810→    
   811→    const session = await this.config.sessionManager!.getSession(argv.sessionId);
   812→    
   813→    if (!session) {
   814→      console.log(chalk.red(`Session '${argv.sessionId}' not found`));
   815→      return;
   816→    }
   817→
   818→    const activeSession = this.config.sessionManager!.getActiveSession();
   819→    const isActive = activeSession?.id === session.id;
   820→
   821→    console.log('');
   822→    console.log(`  ${chalk.gray('Agent:')} ${session.agent || 'N/A'}`);
   823→    console.log(`  ${chalk.gray('Model:')} ${session.model || 'N/A'}`);
   824→    console.log(`  ${chalk.gray('Created:')} ${new Date(session.created).toLocaleString()}`);
   825→    console.log(`  ${chalk.gray('Updated:')} ${new Date(session.updated).toLocaleString()}`);
   826→    console.log(`  ${chalk.gray('Active:')} ${isActive ? chalk.green('Yes') : chalk.red('No')}`);
   827→    console.log(`  ${chalk.gray('Messages:')} ${session.messages.length}`);
   828→    console.log(`  ${chalk.gray('Total Tokens:')} ${session.totalTokens ?? 0}`);
   829→    console.log('');
   830→    console.log(chalk.cyan('Messages:'));
   831→    
   832→    session.messages.forEach((msg: { role: string; content: string }, index: number) => {
   833→      const roleColor = msg.role === 'user' ? chalk.green :
   834→                      msg.role === 'assistant' ? chalk.blue :
   835→                      msg.role === 'system' ? chalk.yellow : chalk.gray;
   836→      const preview = msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : '');
   837→      console.log(`  ${index + 1}. ${roleColor(msg.role)}: ${preview}`);
   838→    });
   839→  }
   840→
   841→  /**
   842→   * Handle session create command
   843→   */
   844→  private async handleSessionCreate(argv: any): Promise<void> {
   845→    this.config.logger.info('Creating session', 'CLI');
   846→
   847→    console.log(chalk.cyan('Creating new session'));
   848→    
   849→    try {
   850→      const session = await this.config.sessionManager!.createSession('New Session');
   851→      console.log(chalk.green(`Session '${session.id}' created successfully`));
   852→      console.log(chalk.gray(`Use 'session show ${session.id}' to view details`));
   853→    } catch (error) {
   854→      console.log(chalk.red(`Failed to create session: ${(error as Error).message}`));
   855→    }
   856→  }
   857→
   858→  /**
   859→   * Handle session delete command
   860→   */
   861→  private async handleSessionDelete(argv: any): Promise<void> {
   862→    this.config.logger.info('Deleting session', 'CLI', { sessionId: argv.sessionId });
   863→
   864→    console.log(chalk.cyan(`Deleting session: ${argv.sessionId}`));
   865→    
   866→    try {
   867→      await this.config.sessionManager!.deleteSession(argv.sessionId);
   868→      console.log(chalk.green(`Session '${argv.sessionId}' deleted successfully`));
   869→    } catch (error) {
   870→      console.log(chalk.red(`Failed to delete session '${argv.sessionId}': ${(error as Error).message}`));
   871→    }
   872→  }
   873→
   874→  /**
   875→   * Handle MCP list command
   876→   */
   877→  private async handleMCPList(): Promise<void> {
   878→    this.config.logger.info('Listing MCP servers', 'CLI');
   879→
   880→    const registry = getMCPRegistry();
   881→    const servers = registry.list();
   882→    const stats = registry.getStatistics();
   883→
   884→    console.log(chalk.cyan('MCP Servers:'));
   885→    console.log(chalk.gray(`Total: ${stats.totalServers} | Active: ${stats.activeServers}\n`));
   886→
   887→    if (servers.length === 0) {
   888→      console.log(chalk.yellow('No MCP servers registered'));
   889→      console.log('');
   890→      console.log(chalk.gray('To register servers, add them to your configuration file.'));
   891→      console.log(chalk.gray('Example:'));
   892→      console.log(chalk.gray('  mcp:'));
   893→      console.log(chalk.gray('    servers:'));
   894→      console.log(chalk.gray('      - id: echo-server'));
   895→      console.log(chalk.gray('        name: Echo Server'));
   896→      console.log(chalk.gray('        command: bun'));
   897→      console.log(chalk.gray('        args: ["run", "src/mcp/servers/echo-server.ts"]'));
   898→      return;
   899→    }
   900→
   901→    for (const server of servers) {
   902→      const statusColor = server.status === 'running' ? chalk.green :
   903→                       server.status === 'error' ? chalk.red :
   904→                       chalk.gray;
   905→      const statusText = server.status.toUpperCase();
   906→
   907→      console.log(`  ${chalk.cyan(server.id)}`);
   908→      console.log(`    ${chalk.gray('Name:')} ${server.config.name}`);
   909→      console.log(`    ${chalk.gray('Command:')} ${server.config.command}`);
   910→      if (server.config.args && server.config.args.length > 0) {
   911→        console.log(`    ${chalk.gray('Args:')} ${server.config.args.join(' ')}`);
   912→      }
   913→      console.log(`    ${chalk.gray('Status:')} ${statusColor(statusText)}`);
   914→      console.log(`    ${chalk.gray('Tools:')} ${server.tools.length}`);
   915→
   916→      if (server.tools.length > 0) {
   917→        for (const tool of server.tools) {
   918→          console.log(`      ${chalk.gray('-')} ${tool.name}: ${tool.description}`);
   919→        }
   920→      }
   921→
   922→      if (server.status === 'running' && server.pid) {
   923→        console.log(`    ${chalk.gray('PID:')} ${server.pid}`);
   924→      }
   925→
   926→      if (server.lastError) {
   927→        console.log(`    ${chalk.red('Error:')} ${server.lastError}`);
   928→      }
   929→
   930→      console.log('');
   931→    }
   932→  }
   933→
   934→  /**
   935→   * Handle MCP start command
   936→   */
   937→  private async handleMCPStart(argv: any): Promise<void> {
   938→    this.config.logger.info('Starting MCP server', 'CLI', { serverId: argv.serverId });
   939→
   940→    const registry = getMCPRegistry();
   941→    const server = registry.get(argv.serverId);
   942→
   943→    if (!server) {
   944→      console.log(chalk.red(`MCP server '${argv.serverId}' not found`));
   945→      console.log('');
   946→      console.log(chalk.gray('Available servers:'));
   947→      const servers = registry.list();
   948→      if (servers.length === 0) {
   949→        console.log(chalk.gray('  None'));
   950→      } else {
   951→        servers.forEach((s) => {
   952→          console.log(chalk.gray(`  ${s.id} - ${s.config.name}`));
   953→        });
   954→      }
   955→      return;
   956→    }
   957→
   958→    if (server.status === 'running') {
   959→      console.log(chalk.yellow(`MCP server '${argv.serverId}' is already running`));
   960→      console.log('');
   961→      console.log(chalk.gray(`PID: ${server.pid}`));
   962→      console.log(chalk.gray(`Tools: ${server.tools.length}`));
   963→      return;
   964→    }
   965→
   966→    console.log(chalk.cyan(`Starting MCP server: ${argv.serverId}`));
   967→
   968→    try {
   969→      const client = await connectToMCPServer(argv.serverId, 30000, this.config.logger);
   970→
   971→      console.log(chalk.green(`MCP server '${argv.serverId}' started successfully`));
   972→      console.log('');
   973→      console.log(chalk.gray('Server Information:'));
   974→      console.log(chalk.gray(`  Name: ${server.config.name}`));
   975→      console.log(chalk.gray(`  PID: ${client.getServerConfig()?.command}`));
   976→      console.log(chalk.gray(`  Tools: ${client.getToolCount()}`));
   977→      console.log('');
   978→      console.log(chalk.gray('Available Tools:'));
   979→      const tools = client.listTools();
   980→      for (const tool of tools) {
   981→        console.log(chalk.gray(`  ${tool.name}: ${tool.description}`));
   982→      }
   983→
   984→    } catch (error) {
   985→      console.log('');
   986→      console.log(chalk.red(`Failed to start MCP server '${argv.serverId}'`));
   987→      console.log(chalk.red(`Error: ${(error as Error).message}`));
   988→      this.config.logger.error('Failed to start MCP server', 'CLI', { error });
   989→    }
   990→  }
   991→
   992→  /**
   993→   * Handle MCP stop command
   994→   */
   995→  private async handleMCPStop(argv: any): Promise<void> {
   996→    this.config.logger.info('Stopping MCP server', 'CLI', { serverId: argv.serverId });
   997→
   998→    const registry = getMCPRegistry();
   999→    const server = registry.get(argv.serverId);
  1000→
  1001→    if (!server) {
  1002→      console.log(chalk.red(`MCP server '${argv.serverId}' not found`));
  1003→      return;
  1004→    }
  1005→
  1006→    if (server.status !== 'running') {
  1007→      console.log(chalk.yellow(`MCP server '${argv.serverId}' is not running`));
  1008→      console.log(chalk.gray(`Current status: ${server.status}`));
  1009→      return;
  1010→    }
  1011→
  1012→    console.log(chalk.cyan(`Stopping MCP server: ${argv.serverId}`));
  1013→
  1014→    try {
  1015→      const client = createMCPClient({ serverId: argv.serverId }, this.config.logger);
  1016→      await client.disconnect();
  1017→
  1018→      console.log(chalk.green(`MCP server '${argv.serverId}' stopped successfully`));
  1019→
  1020→    } catch (error) {
  1021→      console.log('');
  1022→      console.log(chalk.red(`Failed to stop MCP server '${argv.serverId}'`));
  1023→      console.log(chalk.red(`Error: ${(error as Error).message}`));
  1024→      this.config.logger.error('Failed to stop MCP server', 'CLI', { error });
  1025→    }
  1026→  }
  1027→
  1028→  /**
  1029→   * Handle context show command
  1030→   */
  1031→  private async handleContextShow(argv: any): Promise<void> {
  1032→    this.config.logger.info('Showing context', 'CLI', { sessionId: argv.sessionId });
  1033→
  1034→    console.log(chalk.cyan(`Context for session: ${argv.sessionId}`));
  1035→    
  1036→    const session = await this.config.sessionManager!.getSession(argv.sessionId);
  1037→    
  1038→    if (!session) {
  1039→      console.log(chalk.red(`Session '${argv.sessionId}' not found`));
  1040→      return;
  1041→    }
  1042→
  1043→    const contextWindow = createContextWindow({ maxTokens: 200000 });
  1044→
  1045→    // Add session messages to context window
  1046→    session.messages.forEach(msg => {
  1047→      // Convert string content to MessageContent format
  1048→      const textContent: TextContent = { type: 'text', text: msg.content };
  1049→      contextWindow.addMessage({
  1050→        role: msg.role as MessageRole,
  1051→        content: textContent,
  1052→      });
  1053→    });
  1054→
  1055→    // Calculate stats manually
  1056→    const messages = contextWindow.getMessages();
  1057→    const totalMessages = messages.length;
  1058→    const currentSize = contextWindow.getCurrentSize();
  1059→    const maxTokens = 200000; // Default max size
  1060→    const utilizationPercent = (currentSize / maxTokens) * 100;
  1061→    
  1062→    console.log('');
  1063→    console.log(`  ${chalk.gray('Current Size:')} ${currentSize.toLocaleString()} tokens`);
  1064→    console.log(`  ${chalk.gray('Max Size:')} ${maxTokens.toLocaleString()} tokens`);
  1065→    console.log(`  ${chalk.gray('Message Count:')} ${totalMessages}`);
  1066→    console.log(`  ${chalk.gray('Utilization:')} ${utilizationPercent.toFixed(1)}%`);
  1067→    console.log('');
  1068→    console.log(chalk.cyan('Messages:'));
  1069→    
  1070→    messages.forEach((msg: Message, index: number) => {
  1071→      const roleColor = msg.role === 'user' ? chalk.green :
  1072→                      msg.role === 'assistant' ? chalk.blue :
  1073→                      msg.role === 'system' ? chalk.yellow : chalk.gray;
  1074→      const preview = this.extractTextPreview(msg.content, 80);
  1075→      console.log(`  ${index + 1}. ${roleColor(msg.role)}: ${preview}`);
  1076→    });
  1077→  }
  1078→
  1079→  /**
  1080→   * Handle context clear command
  1081→   */
  1082→  private async handleContextClear(argv: any): Promise<void> {
  1083→    this.config.logger.info('Clearing context', 'CLI', { sessionId: argv.sessionId });
  1084→
  1085→    console.log(chalk.cyan(`Clearing context for session: ${argv.sessionId}`));
  1086→    
  1087→    const session = await this.config.sessionManager!.getSession(argv.sessionId);
  1088→    
  1089→    if (!session) {
  1090→      console.log(chalk.red(`Session '${argv.sessionId}' not found`));
  1091→      return;
  1092→    }
  1093→
  1094→    // Clear messages from session
  1095→    await this.config.sessionManager!.clearMessages(argv.sessionId);
  1096→    
  1097→    console.log(chalk.green(`Context cleared for session '${argv.sessionId}'`));
  1098→  }
  1099→
  1100→  /**
  1101→   * Handle memory show command
  1102→   */
  1103→  private async handleMemoryShow(): Promise<void> {
  1104→    this.config.logger.info('Showing memory file', 'CLI');
  1105→
  1106→    console.log(chalk.cyan('.memory.md file:'));
  1107→    
  1108→    try {
  1109→      await this.config.memoryFileHandler!.load();
  1110→      const memoryFile = this.config.memoryFileHandler!.getMemory();
  1111→      
  1112→      console.log('');
  1113→      console.log(chalk.cyan('Frontmatter:'));
  1114→      console.log(`  ${chalk.gray('Version:')} ${memoryFile.frontmatter.version}`);
  1115→      console.log(`  ${chalk.gray('Created:')} ${new Date(memoryFile.frontmatter.created).toLocaleString()}`);
  1116→      console.log(`  ${chalk.gray('Updated:')} ${new Date(memoryFile.frontmatter.updated).toLocaleString()}`);
  1117→      console.log(`  ${chalk.gray('Project:')} ${memoryFile.frontmatter.project || 'N/A'}`);
  1118→      if (memoryFile.frontmatter.tags && memoryFile.frontmatter.tags.length > 0) {
  1119→        console.log(`  ${chalk.gray('Tags:')} ${memoryFile.frontmatter.tags.join(', ')}`);
  1120→      }
  1121→      console.log('');
  1122→      console.log(chalk.cyan('Sections:'));
  1123→      
  1124→      memoryFile.sections.forEach(section => {
  1125→        const priorityIndicator = section.priority ? ` [${section.priority}]` : '';
  1126→        console.log(`  ${chalk.cyan(section.name)}${priorityIndicator}`);
  1127→        if (section.content) {
  1128→          const preview = section.content.substring(0, 100) + (section.content.length > 100 ? '...' : '');
  1129→          console.log(`    ${chalk.gray(preview)}`);
  1130→        }
  1131→      });
  1132→      
  1133→    } catch (error) {
  1134→      console.log(chalk.yellow('No .memory.md file found in current directory'));
  1135→    }
  1136→  }
  1137→
  1138→  /**
  1139→   * Handle memory edit command
  1140→   */
  1141→  private async handleMemoryEdit(): Promise<void> {
  1142→    this.config.logger.info('Editing memory file', 'CLI');
  1143→
  1144→    console.log(chalk.cyan('Opening .memory.md for editing'));
  1145→    
  1146→    try {
  1147→      await this.config.memoryFileHandler!.load();
  1148→      const memoryFile = this.config.memoryFileHandler!.getMemory();
  1149→      
  1150→      console.log('');
  1151→      console.log(chalk.cyan('Current .memory.md sections:'));
  1152→      
  1153→      if (memoryFile.sections.length === 0) {
  1154→        console.log(chalk.yellow('No sections found. Creating default sections...'));
  1155→        // Create default sections for new memory file
  1156→        this.config.memoryFileHandler!.addSection('Project Context', 'Describe project context here...', 10);
  1157→        this.config.memoryFileHandler!.addSection('Key Decisions', 'Document key decisions made during development...', 10);
  1158→        this.config.memoryFileHandler!.addSection('Notes', 'Add any notes or reminders here...', 5);
  1159→        await this.config.memoryFileHandler!.save();
  1160→        console.log(chalk.green('Default sections created'));
  1161→      } else {
  1162→        memoryFile.sections.forEach(section => {
  1163→          const priorityIndicator = section.priority ? ` [${section.priority}]` : '';
  1164→          console.log(`  ${chalk.cyan(section.name)}${priorityIndicator}`);
  1165→        });
  1166→      }
  1167→      console.log('');
  1168→      console.log(chalk.yellow('To edit the memory file, modify .memory.md directly in your editor'));
  1169→      console.log(chalk.yellow('Or use memory add/update commands (coming soon)'));
  1170→    } catch (error) {
  1171→      console.log(chalk.red(`Error: ${(error as Error).message}`));
  1172→    }
  1173→  }
  1174→
  1175→  /**
  1176→   * Handle budget show command
  1177→   */
  1178→  private async handleBudgetShow(): Promise<void> {
  1179→    this.config.logger.info('Showing budget status', 'CLI');
  1180→
  1181→    console.log(chalk.cyan('Budget Status:'));
  1182→    
  1183→    const budgetStatus = this.config.tokenBudget!.getStatus();
  1184→    const config = this.config.tokenBudget!.getConfig();
  1185→    
  1186→    console.log('');
  1187→    console.log(chalk.cyan('Session Budget:'));
  1188→    console.log(`  ${chalk.gray('Limit:')} ${config.limit.toLocaleString()} tokens`);
  1189→    console.log(`  ${chalk.gray('Used:')} ${budgetStatus.used.toLocaleString()} tokens`);
  1190→    console.log(`  ${chalk.gray('Remaining:')} ${budgetStatus.remaining.toLocaleString()} tokens`);
  1191→    console.log(`  ${chalk.gray('Utilization:')} ${budgetStatus.percentUsed.toFixed(1)}%`);
  1192→    console.log(`  ${chalk.gray('Near Limit:')} ${budgetStatus.isNearLimit ? chalk.yellow('Yes') : chalk.gray('No')}`);
  1193→    console.log(`  ${chalk.gray('Over Budget:')} ${budgetStatus.isOverBudget ? chalk.red('Yes') : chalk.gray('No')}`);
  1194→  }
  1195→
  1196→  /**
  1197→   * Handle budget reset command
  1198→   */
  1199→  private async handleBudgetReset(): Promise<void> {
  1200→    this.config.logger.info('Resetting budget', 'CLI');
  1201→
  1202→    console.log(chalk.cyan('Resetting daily budget'));
  1203→    
  1204→    await this.config.tokenBudget!.reset();
  1205→    
  1206→    console.log(chalk.green('Budget reset successfully'));
  1207→  }
  1208→
  1209→  /**
  1210→   * Handle parallel command
  1211→   */
  1212→  private async handleParallel(argv: any): Promise<void> {
  1213→    this.config.logger.info('Executing parallel tasks', 'CLI', {
  1214→      tasks: argv.tasks,
  1215→      file: argv.file,
  1216→    });
  1217→
  1218→    console.log(chalk.cyan('Executing parallel tasks'));
  1219→    // TODO: Implement parallel execution
  1220→    console.log(chalk.yellow('Parallel execution not yet implemented'));
  1221→  }
  1222→
  1223→  /**
  1224→   * Handle debug logs command
  1225→   */
  1226→  private async handleDebugLogs(): Promise<void> {
  1227→    this.config.logger.info('Showing logs', 'CLI');
  1228→
  1229→    const logs = this.config.logger.getLogs();
  1230→    console.log(chalk.cyan('Recent Logs:'));
  1231→    logs.slice(-20).forEach((log) => {
  1232→      console.log(`[${log.timestamp.toISOString()}] ${LogLevel[log.level]}: ${log.message}`);
  1233→    });
  1234→  }
  1235→
  1236→  /**
  1237→   * Handle debug status command
  1238→   */
  1239→  private async handleDebugStatus(): Promise<void> {
  1240→    this.config.logger.info('Showing system status', 'CLI');
  1241→
  1242→    console.log(chalk.cyan('System Status:'));
  1243→    console.log(`  Version: 1.0.0`);
  1244→    console.log(`  Config path: ${this.config.configManager.getPath() || 'Not loaded'}`);
  1245→    console.log(`  Log level: ${LogLevel[this.config.logger.config.level]}`);
  1246→    console.log(chalk.yellow('Full status not yet implemented'));
  1247→  }
  1248→
  1249→  /**
  1250→   * Extract text preview from message content
  1251→   */
  1252→  private extractTextPreview(content: Message['content'], maxLength: number): string {
  1253→    const text = this.extractTextContent(content);
  1254→    return text.substring(0, maxLength) + (text.length > maxLength ? '...' : '');
  1255→  }
  1256→
  1257→  /**
  1258→   * Extract text content from message content
  1259→   */
  1260→  private extractTextContent(content: Message['content']): string {
  1261→    // Helper function to extract text from a single MessageContent item
  1262→    const extractFromItem = (item: string | { type: string; [key: string]: any }): string => {
  1263→      // Handle string case (legacy support)
  1264→      if (typeof item === 'string') {
  1265→        return item;
  1266→      }
  1267→
  1268→      // Type guards for MessageContent subtypes
  1269→      if (item.type === 'text') {
  1270→        return item.text || '';
  1271→      }
  1272→      if (item.type === 'image') {
  1273→        return '[Image]';
  1274→      }
  1275→      if (item.type === 'tool_use') {
  1276→        return `Tool: ${item.name || 'unknown'}`;
  1277→      }
  1278→      if (item.type === 'tool_result') {
  1279→        const resultContent = item.content;
  1280→        if (typeof resultContent === 'string') {
  1281→          return `Result: ${resultContent}`;
  1282→        }
  1283→        if (Array.isArray(resultContent)) {
  1284→          return `Result: ${resultContent.map(extractFromItem).join(' ')}`;
  1285→        }
  1286→        return 'Result';
  1287→      }
  1288→
  1289→      return '';
  1290→    };
  1291→
  1292→    // Handle array of MessageContent
  1293→    if (Array.isArray(content)) {
  1294→      return content.map(extractFromItem).join(' ');
  1295→    }
  1296→
  1297→    // Handle single MessageContent (object)
  1298→    if (typeof content === 'object' && content !== null) {
  1299→      return extractFromItem(content);
  1300→    }
  1301→
  1302→    // Handle string content
  1303→    return content;
  1304→  }
  1305→
  1306→  /**
  1307→   * Handle slash command
  1308→   */
  1309→  private async handleSlashCommand(argv: any): Promise<void> {
  1310→    const commandName = argv.command;
  1311→    const args = argv.args ? argv.args.split(' ') : [];
  1312→
  1313→    this.config.logger.info('Executing slash command', 'CLI', { command: commandName, args });
  1314→
  1315→    console.log(chalk.cyan(`Executing slash command: ${commandName}`));
  1316→
  1317→    try {
  1318→      const resolution = this.config.commandRegistry!.resolveCommand(commandName);
  1319→      const result = await this.config.commandRegistry!.executeCommand(
  1320→        resolution.command,
  1321→        {
  1322→          cwd: process.cwd(),
  1323→          sessionId: this.config.sessionManager!.getActiveSession()?.id,
  1324→          arguments: resolution.arguments,
  1325→        }
  1326→      );
  1327→
  1328→      if (result.success) {
  1329→        console.log(chalk.green('Command executed successfully'));
  1330→        if (result.output) {
  1331→          console.log(result.output);
  1332→        }
  1333→      } else {
  1334→        console.log(chalk.red(`Command failed: ${result.error}`));
  1335→      }
  1336→
  1337→      if (result.metadata) {
  1338→        this.config.logger.debug('Command metadata', 'CLI', result.metadata);
  1339→      }
  1340→    } catch (error) {
  1341→      console.log(chalk.red(`Error executing command: ${(error as Error).message}`));
  1342→      this.config.logger.error('Slash command error', 'CLI', { error });
  1343→    }
  1344→  }
  1345→}
  1346→
  1347→/**
  1348→ * Create CLI instance
  1349→ */
  1350→export function createCLI(logger?: Logger, configManager?: ConfigManager): CLI {
  1351→  const cliLogger = logger ?? new Logger();
  1352→  const cliConfigManager = configManager ?? new ConfigManager(cliLogger);
  1353→  return new CLI({ logger: cliLogger, configManager: cliConfigManager });
  1354→}
  1355→
  1356→/**
  1357→ * Run CLI
  1358→ */
  1359→export async function runCLI(): Promise<void> {
  1360→  console.log('[DEBUG] runCLI called');
  1361→  const logger = new Logger();
  1362→  const configManager = new ConfigManager(logger);
  1363→
  1364→  try {
  1365→    await configManager.load();
  1366→  } catch (error) {
  1367→    console.warn(chalk.yellow('Warning: Could not load configuration. Using defaults.'));
  1368→  }
  1369→
  1370→  // Initialize test agents
  1371→  try {
  1372→    await initializeTestAgents();
  1373→    logger.info('Test agents initialized', 'CLI');
  1374→  } catch (error) {
  1375→    logger.warn('Failed to initialize test agents', 'CLI', { error });
  1376→  }
  1377→
  1378→  // Initialize providers with configuration
  1379→  try {
  1380→    const config = configManager.getAll();
  1381→    await initializeProviders(
  1382→      {
  1383→        openai: {
  1384→          apiKey: config.openai?.apiKey || process.env.OPENAI_API_KEY,
  1385→          baseUrl: config.openai?.baseUrl,
  1386→          defaultModel: config.openai?.defaultModel,
  1387→        },
  1388→        anthropic: {
  1389→          apiKey: config.anthropic?.apiKey || process.env.ANTHROPIC_API_KEY,
  1390→          baseUrl: config.anthropic?.baseUrl,
  1391→          defaultModel: config.anthropic?.defaultModel,
  1392→        },
  1393→        ollama: {
  1394→          baseUrl: config.ollama?.baseUrl || 'http://localhost:11434',
  1395→          defaultModel: config.ollama?.defaultModel,
  1396→        },
  1397→      },
  1398→      logger
  1399→    );
  1400→    logger.info('Providers initialized', 'CLI');
  1401→  } catch (error) {
  1402→    logger.warn('Failed to initialize providers', 'CLI', { error });
  1403→  }
  1404→
  1405→  // Load MCP servers from configuration
  1406→  try {
  1407→    const config = configManager.getAll();
  1408→    const mcpRegistry = getMCPRegistry();
  1409→    if (config.mcp?.servers && config.mcp.servers.length > 0) {
  1410→      mcpRegistry.loadFromConfig(config.mcp.servers);
  1411→      logger.info('MCP servers loaded from configuration', 'CLI', {
  1412→        count: config.mcp.servers.length,
  1413→      });
  1414→    }
  1415→  } catch (error) {
  1416→    logger.warn('Failed to load MCP servers from configuration', 'CLI', { error });
  1417→  }
  1418→
  1419→  const cli = createCLI(logger, configManager);
  1420→  await cli.initialize();
  1421→  await cli.parse();
  1422→}
  1423→

</system-reminder>
