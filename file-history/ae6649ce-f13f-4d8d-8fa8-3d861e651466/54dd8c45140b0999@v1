import type { AutomationDefinition, AutomationTriggerType } from "@multi-agent/types"
import { BaseTrigger, TriggerEventPayload } from "./triggers/BaseTrigger"
import { FileWatcherTrigger } from "./triggers/FileWatcherTrigger"
import { CronTrigger } from "./triggers/CronTrigger"
import { GitHookTrigger } from "./triggers/GitHookTrigger"

export type TriggerFactory = (
	automationId: string,
	workspacePath: string,
	automation: AutomationDefinition
) => BaseTrigger | null

/**
 * Registry for automation triggers.
 * Manages creation, lifecycle, and event routing for all trigger types.
 */
export class TriggerRegistry {
	private triggers: Map<string, BaseTrigger> = new Map()
	private listeners: Map<string, ((payload: TriggerEventPayload) => void)[]> = new Map()
	private workspacePath: string

	constructor(workspacePath: string) {
		this.workspacePath = workspacePath
	}

	/**
	 * Register a trigger for an automation
	 */
	async registerTrigger(automation: AutomationDefinition): Promise<BaseTrigger | null> {
		// Remove existing trigger for this automation if any
		await this.unregisterTrigger(automation.id)

		const trigger = this.createTrigger(automation)
		if (!trigger) {
			console.warn(`Unsupported trigger type: ${automation.trigger.type}`)
			return null
		}

		// Set up event forwarding
		trigger.on("triggered", (payload: TriggerEventPayload) => {
			this.handleTriggerEvent(payload)
		})

		this.triggers.set(automation.id, trigger)
		return trigger
	}

	/**
	 * Unregister a trigger by automation ID
	 */
	async unregisterTrigger(automationId: string): Promise<void> {
		const trigger = this.triggers.get(automationId)
		if (trigger) {
			await trigger.dispose()
			this.triggers.delete(automationId)
		}
	}

	/**
	 * Start a specific trigger
	 */
	async startTrigger(automationId: string): Promise<void> {
		const trigger = this.triggers.get(automationId)
		if (trigger && !trigger.isActive) {
			await trigger.start()
		}
	}

	/**
	 * Stop a specific trigger
	 */
	async stopTrigger(automationId: string): Promise<void> {
		const trigger = this.triggers.get(automationId)
		if (trigger && trigger.isActive) {
			await trigger.stop()
		}
	}

	/**
	 * Start all registered triggers
	 */
	async startAll(): Promise<void> {
		const startPromises = Array.from(this.triggers.values()).map((trigger) => {
			if (!trigger.isActive) {
				return trigger.start()
			}
			return Promise.resolve()
		})
		await Promise.all(startPromises)
	}

	/**
	 * Stop all registered triggers
	 */
	async stopAll(): Promise<void> {
		const stopPromises = Array.from(this.triggers.values()).map((trigger) => {
			if (trigger.isActive) {
				return trigger.stop()
			}
			return Promise.resolve()
		})
		await Promise.all(stopPromises)
	}

	/**
	 * Get a trigger by automation ID
	 */
	getTrigger(automationId: string): BaseTrigger | undefined {
		return this.triggers.get(automationId)
	}

	/**
	 * Get all registered triggers
	 */
	getAllTriggers(): BaseTrigger[] {
		return Array.from(this.triggers.values())
	}

	/**
	 * Get triggers by type
	 */
	getTriggersByType(type: AutomationTriggerType): BaseTrigger[] {
		return Array.from(this.triggers.values()).filter((trigger) => trigger.type === type)
	}

	/**
	 * Add a listener for trigger events
	 */
	onTrigger(automationId: string, callback: (payload: TriggerEventPayload) => void): void {
		const listeners = this.listeners.get(automationId) || []
		listeners.push(callback)
		this.listeners.set(automationId, listeners)
	}

	/**
	 * Add a global listener for all trigger events
	 */
	onAnyTrigger(callback: (payload: TriggerEventPayload) => void): void {
		this.onTrigger("*", callback)
	}

	/**
	 * Remove a listener
	 */
	offTrigger(automationId: string, callback: (payload: TriggerEventPayload) => void): void {
		const listeners = this.listeners.get(automationId) || []
		const index = listeners.indexOf(callback)
		if (index !== -1) {
			listeners.splice(index, 1)
		}
	}

	/**
	 * Create a trigger instance based on automation definition
	 */
	private createTrigger(automation: AutomationDefinition): BaseTrigger | null {
		const { trigger } = automation

		switch (trigger.type) {
			case "file_watcher":
				return new FileWatcherTrigger({
					automationId: automation.id,
					workspacePath: this.workspacePath,
					trigger: trigger,
				})

			case "cron":
				return new CronTrigger({
					automationId: automation.id,
					workspacePath: this.workspacePath,
					trigger: trigger,
				})

			case "git_hook":
				// TODO: Implement GitHookTrigger
				console.warn("Git hook triggers not yet implemented")
				return null

			case "manual":
				// Manual triggers don't need a watcher
				return null

			case "event":
				// Event triggers are handled separately
				return null

			default:
				return null
		}
	}

	/**
	 * Handle a trigger event from any registered trigger
	 */
	private handleTriggerEvent(payload: TriggerEventPayload): void {
		// Notify specific listeners
		const specificListeners = this.listeners.get(payload.automationId) || []
		for (const listener of specificListeners) {
			try {
				listener(payload)
			} catch (error) {
				console.error(`Error in trigger listener for ${payload.automationId}:`, error)
			}
		}

		// Notify global listeners
		const globalListeners = this.listeners.get("*") || []
		for (const listener of globalListeners) {
			try {
				listener(payload)
			} catch (error) {
				console.error("Error in global trigger listener:", error)
			}
		}
	}

	/**
	 * Dispose of all triggers and clear the registry
	 */
	async dispose(): Promise<void> {
		await this.stopAll()
		for (const trigger of this.triggers.values()) {
			await trigger.dispose()
		}
		this.triggers.clear()
		this.listeners.clear()
	}
}
