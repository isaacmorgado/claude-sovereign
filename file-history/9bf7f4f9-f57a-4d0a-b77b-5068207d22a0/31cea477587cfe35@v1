/**
 * Reframe Routes
 *
 * Social reframe and face detection endpoints
 */

const express = require('express');

/**
 * Create reframe routes
 * @param {Object} options - Route configuration options
 * @param {Object} options.middleware - Shared middleware (requireCredits)
 * @returns {express.Router}
 */
function createReframeRoutes(options = {}) {
  const router = express.Router();
  const { requireCredits, requireFeature } = options.middleware || {};

  /**
   * POST /analyze - Analyze video for reframe with face tracking
   * Requires: Pro tier or higher (social_reframe feature)
   */
  router.post('/analyze', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {
    const { videoPath, options: analyzeOptions = {} } = req.body;

    if (!videoPath) {
      return res.status(400).json({ error: 'videoPath is required' });
    }

    try {
      const { analyzeForReframe } = require('../services/socialReframe');
      const result = await analyzeForReframe(videoPath, analyzeOptions);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(1.0); // 1 credit for analysis
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Reframe analyze error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /calculate - Calculate crop positions for aspect ratio
   */
  router.post('/calculate', requireCredits({ endpoint: 'reframe' }), async (req, res) => {
    const { tracking, targetAspect } = req.body;

    if (!tracking) {
      return res.status(400).json({ error: 'tracking data is required' });
    }

    if (!targetAspect) {
      return res.status(400).json({ error: 'targetAspect is required' });
    }

    try {
      const { calculateReframeCrops } = require('../services/socialReframe');
      const result = calculateReframeCrops(tracking, targetAspect);

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.25); // 0.25 credits
      }

      res.json({ success: true, crops: result });
    } catch (err) {
      console.error('[SPLICE] Reframe calculate error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /motion-path - Generate smooth motion path
   */
  router.post('/motion-path', requireCredits({ endpoint: 'reframe' }), async (req, res) => {
    const { crops, duration, frameRate } = req.body;

    if (!crops || !Array.isArray(crops)) {
      return res.status(400).json({ error: 'crops array is required' });
    }

    if (!duration || !frameRate) {
      return res.status(400).json({ error: 'duration and frameRate are required' });
    }

    try {
      const { generateMotionPath } = require('../services/socialReframe');
      const result = generateMotionPath(crops, duration, frameRate);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.25); // 0.25 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Reframe motion-path error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /export - Batch export all formats
   */
  router.post('/export', requireCredits({ endpoint: 'reframe' }), async (req, res) => {
    const { videoPath, formats = ['portrait', 'square'], settings = {} } = req.body;

    if (!videoPath) {
      return res.status(400).json({ error: 'videoPath is required' });
    }

    try {
      const { batchExportFormats } = require('../services/socialReframe');
      const result = await batchExportFormats(videoPath, formats, settings);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage per format
      if (req.deductUsage) {
        await req.deductUsage(0.5 * formats.length);
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Reframe export error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * GET /platforms - Get available platforms and aspect ratios
   */
  router.get('/platforms', (req, res) => {
    const { getPlatformPresets } = require('../services/socialReframe');
    res.json(getPlatformPresets());
  });

  /**
   * GET /safe-zones/:platform - Get safe zones for platform
   */
  router.get('/safe-zones/:platform', (req, res) => {
    const { getSafeZones } = require('../services/socialReframe');
    const result = getSafeZones(req.params.platform);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.json(result);
  });

  return router;
}

/**
 * Create faces router (separate router for /faces prefix)
 * @param {Object} options - Route configuration options
 * @returns {express.Router}
 */
function createFacesRouter(options = {}) {
  const router = express.Router();
  const { requireCredits } = options.middleware || {};

  /**
   * POST /detect - Detect faces in video
   */
  router.post('/detect', requireCredits({ endpoint: 'reframe' }), async (req, res) => {
    const { videoPath, options: detectOptions = {} } = req.body;

    if (!videoPath) {
      return res.status(400).json({ error: 'videoPath is required' });
    }

    try {
      const { detectFaces } = require('../services/faceDetection');
      const result = await detectFaces(videoPath, detectOptions);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.5); // 0.5 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Face detect error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /track - Track faces throughout video
   */
  router.post('/track', requireCredits({ endpoint: 'reframe' }), async (req, res) => {
    const { videoPath, options: trackOptions = {} } = req.body;

    if (!videoPath) {
      return res.status(400).json({ error: 'videoPath is required' });
    }

    try {
      const { trackFaces } = require('../services/faceDetection');
      const result = await trackFaces(videoPath, trackOptions);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(1.0); // 1 credit for tracking
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Face track error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /identify-speaker - Identify primary speaker
   */
  router.post('/identify-speaker', requireCredits({ endpoint: 'reframe' }), async (req, res) => {
    const { faces, audioAnalysis = null } = req.body;

    if (!faces || !Array.isArray(faces)) {
      return res.status(400).json({ error: 'faces array is required' });
    }

    try {
      const { identifySpeaker } = require('../services/faceDetection');
      const result = identifySpeaker(faces, audioAnalysis);

      // Deduct usage for speaker identification
      if (req.deductUsage) {
        await req.deductUsage(0.1); // 0.1 credits for speaker identification
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Identify speaker error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  return router;
}

// Attach facesRouter factory to main export
createReframeRoutes.facesRouter = createFacesRouter;

module.exports = createReframeRoutes;
