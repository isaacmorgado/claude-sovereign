/**
 * Text Edit Routes
 *
 * Text-based editing endpoints
 */

const express = require('express');

/**
 * Create text edit routes
 * @param {Object} options - Route configuration options
 * @param {Object} options.middleware - Shared middleware (requireCredits)
 * @returns {express.Router}
 */
function createTextEditRoutes(options = {}) {
  const router = express.Router();
  const { requireCredits, requireFeature } = options.middleware || {};

  /**
   * POST /prepare - Create editable transcript structure
   * Requires: Pro tier or higher (text_editing feature)
   *
   * Converts transcript to editable format with unique word IDs.
   */
  router.post('/prepare', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {
    const { transcript } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'transcript is required' });
    }

    try {
      const { generateEditableTranscript } = require('../services/textBasedEditing');
      const result = generateEditableTranscript(transcript);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.25); // 0.25 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Text-edit prepare error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /apply - Apply text edits and get operations
   *
   * Compares original and edited text, returns edit operations.
   */
  router.post('/apply', requireCredits({ endpoint: 'text-edit' }), async (req, res) => {
    const { transcript, editedText } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'transcript is required' });
    }

    if (typeof editedText !== 'string') {
      return res.status(400).json({ error: 'editedText is required' });
    }

    try {
      const { applyTextEdits } = require('../services/textBasedEditing');
      const result = applyTextEdits(transcript, editedText);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.5); // 0.5 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Text-edit apply error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /search - Search transcript with timestamps
   */
  router.post('/search', requireCredits({ endpoint: 'text-edit' }), async (req, res) => {
    const { transcript, searchText } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'transcript is required' });
    }

    if (!searchText) {
      return res.status(400).json({ error: 'searchText is required' });
    }

    try {
      const { searchTranscript } = require('../services/textBasedEditing');
      const result = searchTranscript(transcript, searchText);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.1); // 0.1 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Text-edit search error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /replace - Search and replace (generates cut operations)
   */
  router.post('/replace', requireCredits({ endpoint: 'text-edit' }), async (req, res) => {
    const { transcript, searchText, replaceText = '' } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'transcript is required' });
    }

    if (!searchText) {
      return res.status(400).json({ error: 'searchText is required' });
    }

    try {
      const { searchAndReplace } = require('../services/textBasedEditing');
      const result = searchAndReplace(transcript, searchText, replaceText);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.25); // 0.25 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Text-edit replace error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /preview - Preview edits without applying
   */
  router.post('/preview', requireCredits({ endpoint: 'text-edit' }), async (req, res) => {
    const { transcript, editedText } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'transcript is required' });
    }

    if (typeof editedText !== 'string') {
      return res.status(400).json({ error: 'editedText is required' });
    }

    try {
      const { previewEdits } = require('../services/textBasedEditing');
      const result = previewEdits(transcript, editedText);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage (small amount for preview)
      if (req.deductUsage) {
        await req.deductUsage(0.1); // 0.1 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Text-edit preview error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  /**
   * POST /cut-list - Generate cut list from edit operations
   */
  router.post('/cut-list', requireCredits({ endpoint: 'text-edit' }), async (req, res) => {
    const { operations, sourceInfo = {} } = req.body;

    if (!operations || !Array.isArray(operations)) {
      return res.status(400).json({ error: 'operations array is required' });
    }

    try {
      const { generateEditCutList } = require('../services/textBasedEditing');
      const result = generateEditCutList(operations, sourceInfo);

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      // Deduct usage
      if (req.deductUsage) {
        await req.deductUsage(0.25); // 0.25 credits
      }

      res.json(result);
    } catch (err) {
      console.error('[SPLICE] Text-edit cut-list error:', err);
      res.status(500).json({ error: err.message });
    }
  });

  return router;
}

module.exports = createTextEditRoutes;
