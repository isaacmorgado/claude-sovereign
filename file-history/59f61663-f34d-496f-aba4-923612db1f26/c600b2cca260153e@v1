/**
 * Scoring Accuracy Test API Route
 * Tests the FaceIQ-compatible scoring system with mock landmark data
 *
 * GET /api/test-scoring
 */

import { NextResponse } from 'next/server';
import { LandmarkPoint } from '@/lib/landmarks';
import {
  analyzeFrontProfile,
  analyzeSideProfile,
  analyzeHarmony,
  calculateFaceIQScore,
  getMetricConfigForDemographics,
  Gender,
  Ethnicity,
} from '@/lib/faceiq-scoring';

// ============================================
// MOCK LANDMARK DATA (from landmarks-3d-2.json 2D coords)
// ============================================

const MOCK_FRONT_LANDMARKS: LandmarkPoint[] = [
  { id: 'trichion', label: 'Hairline', medicalTerm: 'Trichion', description: '', x: 509, y: 180, category: 'Head' },
  { id: 'left_pupila', label: 'Left Pupil', medicalTerm: 'Left Pupila', description: '', x: 422, y: 339, category: 'Eyes - Left' },
  { id: 'left_canthus_medialis', label: 'Left Medial Canthus', medicalTerm: '', description: '', x: 458, y: 343, category: 'Eyes - Left' },
  { id: 'left_canthus_lateralis', label: 'Left Lateral Canthus', medicalTerm: '', description: '', x: 382, y: 339, category: 'Eyes - Left' },
  { id: 'left_palpebra_superior', label: 'Left Upper Eyelid', medicalTerm: '', description: '', x: 420, y: 330, category: 'Eyes - Left' },
  { id: 'left_palpebra_inferior', label: 'Left Lower Eyelid', medicalTerm: '', description: '', x: 420, y: 348, category: 'Eyes - Left' },
  { id: 'right_pupila', label: 'Right Pupil', medicalTerm: 'Right Pupila', description: '', x: 603, y: 340, category: 'Eyes - Right' },
  { id: 'right_canthus_medialis', label: 'Right Medial Canthus', medicalTerm: '', description: '', x: 568, y: 341, category: 'Eyes - Right' },
  { id: 'right_canthus_lateralis', label: 'Right Lateral Canthus', medicalTerm: '', description: '', x: 641, y: 337, category: 'Eyes - Right' },
  { id: 'right_palpebra_superior', label: 'Right Upper Eyelid', medicalTerm: '', description: '', x: 605, y: 331, category: 'Eyes - Right' },
  { id: 'right_palpebra_inferior', label: 'Right Lower Eyelid', medicalTerm: '', description: '', x: 605, y: 349, category: 'Eyes - Right' },
  { id: 'nasal_base', label: 'Nasal Base', medicalTerm: '', description: '', x: 513, y: 360, category: 'Nose' },
  { id: 'subnasale', label: 'Subnasale', medicalTerm: '', description: '', x: 513, y: 450, category: 'Nose' },
  { id: 'left_ala_nasi', label: 'Left Nose Side', medicalTerm: '', description: '', x: 465, y: 448, category: 'Nose' },
  { id: 'right_ala_nasi', label: 'Right Nose Side', medicalTerm: '', description: '', x: 563, y: 451, category: 'Nose' },
  { id: 'labrale_superius', label: "Cupid's Bow", medicalTerm: '', description: '', x: 513, y: 490, category: 'Mouth' },
  { id: 'labrale_inferius', label: 'Lower Lip', medicalTerm: '', description: '', x: 513, y: 535, category: 'Mouth' },
  { id: 'left_cheilion', label: 'Left Mouth Corner', medicalTerm: '', description: '', x: 442, y: 531, category: 'Mouth' },
  { id: 'right_cheilion', label: 'Right Mouth Corner', medicalTerm: '', description: '', x: 584, y: 532, category: 'Mouth' },
  { id: 'left_gonion_superior', label: 'Left Upper Jaw Angle', medicalTerm: '', description: '', x: 320, y: 480, category: 'Jaw' },
  { id: 'right_gonion_superior', label: 'Right Upper Jaw Angle', medicalTerm: '', description: '', x: 706, y: 482, category: 'Jaw' },
  { id: 'left_gonion_inferior', label: 'Left Lower Jaw Angle', medicalTerm: '', description: '', x: 351, y: 553, category: 'Jaw' },
  { id: 'right_gonion_inferior', label: 'Right Lower Jaw Angle', medicalTerm: '', description: '', x: 678, y: 546, category: 'Jaw' },
  { id: 'menton', label: 'Chin Bottom', medicalTerm: '', description: '', x: 512, y: 644, category: 'Chin' },
  { id: 'left_mentum_lateralis', label: 'Left Chin', medicalTerm: '', description: '', x: 438, y: 631, category: 'Chin' },
  { id: 'right_mentum_lateralis', label: 'Right Chin', medicalTerm: '', description: '', x: 593, y: 620, category: 'Chin' },
  { id: 'left_zygion', label: 'Left Cheekbone', medicalTerm: '', description: '', x: 308, y: 355, category: 'Face Width' },
  { id: 'right_zygion', label: 'Right Cheekbone', medicalTerm: '', description: '', x: 717, y: 361, category: 'Face Width' },
  { id: 'left_temporal', label: 'Left Temple', medicalTerm: '', description: '', x: 330, y: 280, category: 'Face Width' },
  { id: 'right_temporal', label: 'Right Temple', medicalTerm: '', description: '', x: 695, y: 282, category: 'Face Width' },
];

const MOCK_SIDE_LANDMARKS: LandmarkPoint[] = [
  { id: 'tragus', label: 'Tragus', medicalTerm: '', description: '', x: 509, y: 395, category: 'Ear' },
  { id: 'intertragicNotch', label: 'Intertragic Notch', medicalTerm: '', description: '', x: 511, y: 412, category: 'Ear' },
  { id: 'porion', label: 'Porion', medicalTerm: '', description: '', x: 505, y: 380, category: 'Ear' },
  { id: 'glabella', label: 'Glabella', medicalTerm: '', description: '', x: 819, y: 288, category: 'Forehead' },
  { id: 'trichion', label: 'Hairline', medicalTerm: '', description: '', x: 780, y: 200, category: 'Cranium' },
  { id: 'nasion', label: 'Nasion', medicalTerm: '', description: '', x: 814, y: 342, category: 'Nose' },
  { id: 'pronasale', label: 'Nose Tip', medicalTerm: '', description: '', x: 870, y: 460, category: 'Nose' },
  { id: 'subnasale', label: 'Subnasale', medicalTerm: '', description: '', x: 823, y: 483, category: 'Nose' },
  { id: 'columella', label: 'Columella', medicalTerm: '', description: '', x: 845, y: 475, category: 'Nose' },
  { id: 'rhinion', label: 'Rhinion', medicalTerm: '', description: '', x: 835, y: 400, category: 'Nose' },
  { id: 'supratip', label: 'Supratip', medicalTerm: '', description: '', x: 855, y: 445, category: 'Nose' },
  { id: 'infratip', label: 'Infratip', medicalTerm: '', description: '', x: 860, y: 470, category: 'Nose' },
  { id: 'orbitale', label: 'Orbitale', medicalTerm: '', description: '', x: 780, y: 370, category: 'Eye Region' },
  { id: 'cornealApex', label: 'Corneal Apex', medicalTerm: '', description: '', x: 800, y: 350, category: 'Eye Region' },
  { id: 'labraleSuperius', label: 'Upper Lip', medicalTerm: '', description: '', x: 835, y: 510, category: 'Lips' },
  { id: 'labraleInferius', label: 'Lower Lip', medicalTerm: '', description: '', x: 830, y: 540, category: 'Lips' },
  { id: 'sublabiale', label: 'Sublabiale', medicalTerm: '', description: '', x: 784, y: 584, category: 'Lips' },
  { id: 'cheilion', label: 'Mouth Corner', medicalTerm: '', description: '', x: 750, y: 525, category: 'Lips' },
  { id: 'pogonion', label: 'Chin Point', medicalTerm: '', description: '', x: 810, y: 620, category: 'Chin' },
  { id: 'menton', label: 'Chin Bottom', medicalTerm: '', description: '', x: 747, y: 648, category: 'Chin' },
  { id: 'gonionTop', label: 'Gonion Top', medicalTerm: '', description: '', x: 524, y: 517, category: 'Jaw' },
  { id: 'gonionBottom', label: 'Gonion Bottom', medicalTerm: '', description: '', x: 577, y: 587, category: 'Jaw' },
  { id: 'cervicalPoint', label: 'Cervical Point', medicalTerm: '', description: '', x: 631, y: 646, category: 'Neck' },
  { id: 'neckPoint', label: 'Neck Point', medicalTerm: '', description: '', x: 562, y: 804, category: 'Neck' },
];

// ============================================
// TEST DEFINITIONS
// ============================================

interface TestResult {
  name: string;
  passed: boolean;
  details: Record<string, unknown>;
  error?: string;
}

interface MetricTest {
  metricId: string;
  description: string;
  testValue: number;
  gender: Gender;
  ethnicity: Ethnicity;
  expectedScoreMin: number;
}

const METRIC_TESTS: MetricTest[] = [
  { metricId: 'faceWidthToHeight', description: 'FWHR at ideal (1.9)', testValue: 1.9, gender: 'male', ethnicity: 'white', expectedScoreMin: 9.0 },
  { metricId: 'faceWidthToHeight', description: 'FWHR slightly low (1.7)', testValue: 1.7, gender: 'male', ethnicity: 'white', expectedScoreMin: 6.0 },
  { metricId: 'lateralCanthalTilt', description: 'Positive tilt (4°)', testValue: 4, gender: 'male', ethnicity: 'white', expectedScoreMin: 8.0 },
  { metricId: 'lateralCanthalTilt', description: 'Negative tilt (-2°)', testValue: -2, gender: 'male', ethnicity: 'white', expectedScoreMin: 4.0 },
  { metricId: 'eyeAspectRatio', description: 'Ideal eye aspect (0.32)', testValue: 0.32, gender: 'male', ethnicity: 'white', expectedScoreMin: 9.0 },
  { metricId: 'nasalIndex', description: 'White male ideal (70)', testValue: 70, gender: 'male', ethnicity: 'white', expectedScoreMin: 9.0 },
  { metricId: 'nasalIndex', description: 'Black male ideal (90)', testValue: 90, gender: 'male', ethnicity: 'black', expectedScoreMin: 8.0 },
  { metricId: 'jawWidthRatio', description: 'Ideal jaw width (0.75)', testValue: 0.75, gender: 'male', ethnicity: 'white', expectedScoreMin: 8.0 },
];

// ============================================
// TEST RUNNER
// ============================================

export async function GET() {
  const results: TestResult[] = [];
  let passedTests = 0;
  let failedTests = 0;

  // ========================================
  // TEST 1: Front Profile Analysis
  // ========================================
  const demographicTests: Array<{ name: string; gender: Gender; ethnicity: Ethnicity; expectedRange: [number, number] }> = [
    { name: 'Male - White', gender: 'male', ethnicity: 'white', expectedRange: [5, 9] },
    { name: 'Female - White', gender: 'female', ethnicity: 'white', expectedRange: [4, 9] },
    { name: 'Male - Black', gender: 'male', ethnicity: 'black', expectedRange: [4, 9] },
    { name: 'Male - East Asian', gender: 'male', ethnicity: 'east_asian', expectedRange: [4, 9] },
  ];

  for (const test of demographicTests) {
    try {
      const result = analyzeFrontProfile(MOCK_FRONT_LANDMARKS, test.gender, test.ethnicity);
      const passed = result.overallScore >= test.expectedRange[0] && result.overallScore <= test.expectedRange[1];

      results.push({
        name: `Front Profile: ${test.name}`,
        passed,
        details: {
          overallScore: result.overallScore,
          measurementCount: result.measurements.length,
          expectedRange: test.expectedRange,
          topStrengths: result.measurements
            .sort((a, b) => b.score - a.score)
            .slice(0, 3)
            .map(m => ({ name: m.name, score: m.score, value: m.value })),
          topFlaws: result.measurements
            .sort((a, b) => a.score - b.score)
            .slice(0, 3)
            .map(m => ({ name: m.name, score: m.score, value: m.value, deviation: m.deviation })),
        },
      });

      if (passed) passedTests++;
      else failedTests++;
    } catch (error) {
      results.push({
        name: `Front Profile: ${test.name}`,
        passed: false,
        details: {},
        error: String(error),
      });
      failedTests++;
    }
  }

  // ========================================
  // TEST 2: Side Profile Analysis
  // ========================================
  for (const test of demographicTests.slice(0, 2)) {
    try {
      const result = analyzeSideProfile(MOCK_SIDE_LANDMARKS, test.gender, test.ethnicity);
      const passed = result.measurements.length >= 3; // At least some measurements

      results.push({
        name: `Side Profile: ${test.name}`,
        passed,
        details: {
          overallScore: result.overallScore,
          measurementCount: result.measurements.length,
          measurements: result.measurements.slice(0, 5).map(m => ({
            name: m.name,
            score: m.score,
            value: m.value,
          })),
        },
      });

      if (passed) passedTests++;
      else failedTests++;
    } catch (error) {
      results.push({
        name: `Side Profile: ${test.name}`,
        passed: false,
        details: {},
        error: String(error),
      });
      failedTests++;
    }
  }

  // ========================================
  // TEST 3: Individual Metric Scoring
  // ========================================
  for (const test of METRIC_TESTS) {
    try {
      const config = getMetricConfigForDemographics(test.metricId, { gender: test.gender, ethnicity: test.ethnicity });

      if (!config) {
        results.push({
          name: `Metric: ${test.description}`,
          passed: false,
          details: { metricId: test.metricId },
          error: 'Config not found',
        });
        failedTests++;
        continue;
      }

      const score = calculateFaceIQScore(test.testValue, config);
      const passed = score >= test.expectedScoreMin;

      results.push({
        name: `Metric: ${test.description}`,
        passed,
        details: {
          metricId: test.metricId,
          testValue: test.testValue,
          score,
          expectedMin: test.expectedScoreMin,
          idealRange: [config.idealMin, config.idealMax],
          hasBezierCurve: config.customCurve?.mode === 'custom',
        },
      });

      if (passed) passedTests++;
      else failedTests++;
    } catch (error) {
      results.push({
        name: `Metric: ${test.description}`,
        passed: false,
        details: { metricId: test.metricId },
        error: String(error),
      });
      failedTests++;
    }
  }

  // ========================================
  // TEST 4: Full Harmony Analysis
  // ========================================
  try {
    const harmony = analyzeHarmony(MOCK_FRONT_LANDMARKS, MOCK_SIDE_LANDMARKS, 'male', 'white');
    const passed = harmony.overallScore > 0 && harmony.measurements.length > 10;

    results.push({
      name: 'Full Harmony Analysis',
      passed,
      details: {
        overallScore: harmony.overallScore,
        frontScore: harmony.frontScore,
        sideScore: harmony.sideScore,
        qualityTier: harmony.qualityTier,
        percentile: harmony.percentile,
        measurementCount: harmony.measurements.length,
        flawCount: harmony.flaws.length,
        strengthCount: harmony.strengths.length,
        categoryScores: harmony.categoryScores,
        topFlaws: harmony.flaws.slice(0, 3).map(f => ({
          metric: f.metricName,
          severity: f.severity,
          reason: f.reasoning,
        })),
        topStrengths: harmony.strengths.slice(0, 3).map(s => ({
          metric: s.metricName,
          tier: s.qualityTier,
          reason: s.reasoning,
        })),
      },
    });

    if (passed) passedTests++;
    else failedTests++;
  } catch (error) {
    results.push({
      name: 'Full Harmony Analysis',
      passed: false,
      details: {},
      error: String(error),
    });
    failedTests++;
  }

  // ========================================
  // TEST 5: Bezier Curve Verification
  // ========================================
  const bezierMetrics = ['faceWidthToHeight', 'lowerThirdProportion', 'eyeAspectRatio', 'totalFacialWidthToHeight', 'cheekboneHeight'];

  for (const metricId of bezierMetrics) {
    try {
      const config = getMetricConfigForDemographics(metricId, { gender: 'male', ethnicity: 'white' });

      if (!config) {
        results.push({
          name: `Bezier: ${metricId}`,
          passed: false,
          details: {},
          error: 'Config not found',
        });
        failedTests++;
        continue;
      }

      const hasBezier = config.customCurve?.mode === 'custom';
      const idealMid = (config.idealMin + config.idealMax) / 2;
      const scoreAtIdeal = calculateFaceIQScore(idealMid, config);
      const scoreAtMin = calculateFaceIQScore(config.rangeMin, config);
      const scoreAtMax = calculateFaceIQScore(config.rangeMax, config);

      // Verify curve makes sense: ideal should score highest
      const passed = scoreAtIdeal >= 9 && scoreAtMin < scoreAtIdeal && scoreAtMax < scoreAtIdeal;

      results.push({
        name: `Bezier: ${metricId}`,
        passed,
        details: {
          hasBezierCurve: hasBezier,
          idealRange: [config.idealMin, config.idealMax],
          scoreAtIdeal: { value: idealMid, score: scoreAtIdeal },
          scoreAtMin: { value: config.rangeMin, score: scoreAtMin },
          scoreAtMax: { value: config.rangeMax, score: scoreAtMax },
        },
      });

      if (passed) passedTests++;
      else failedTests++;
    } catch (error) {
      results.push({
        name: `Bezier: ${metricId}`,
        passed: false,
        details: {},
        error: String(error),
      });
      failedTests++;
    }
  }

  // ========================================
  // TEST 6: Demographic Overrides
  // ========================================
  const overrideTestMetrics = ['nasalIndex', 'jawWidthRatio', 'lateralCanthalTilt'];
  const demographics: Array<{ gender: Gender; ethnicity: Ethnicity }> = [
    { gender: 'male', ethnicity: 'white' },
    { gender: 'male', ethnicity: 'black' },
    { gender: 'female', ethnicity: 'white' },
    { gender: 'female', ethnicity: 'east_asian' },
  ];

  for (const metricId of overrideTestMetrics) {
    const ranges: Array<{ demo: string; min: number; max: number }> = [];

    for (const demo of demographics) {
      const config = getMetricConfigForDemographics(metricId, demo);
      if (config) {
        ranges.push({
          demo: `${demo.gender}/${demo.ethnicity}`,
          min: config.idealMin,
          max: config.idealMax,
        });
      }
    }

    // Check if there's variation between demographics
    const uniqueRanges = new Set(ranges.map(r => `${r.min}-${r.max}`));
    const hasVariation = uniqueRanges.size > 1;

    results.push({
      name: `Demographic Override: ${metricId}`,
      passed: hasVariation,
      details: {
        hasVariation,
        ranges,
      },
    });

    if (hasVariation) passedTests++;
    else failedTests++;
  }

  // ========================================
  // SUMMARY
  // ========================================
  const successRate = passedTests / (passedTests + failedTests) * 100;

  return NextResponse.json({
    summary: {
      passed: passedTests,
      failed: failedTests,
      total: passedTests + failedTests,
      successRate: `${successRate.toFixed(1)}%`,
    },
    results,
  });
}
