# SPLICE E2E Audit Fixes

## Process
For each feature: Implement → E2E Test → Identify Bugs → Fix → Re-test → Pass → Next Feature

---

# Phase 1: UI Critical Fixes

---

## Feature 1.1: Replace confirm() with UXP Modal

**Files:**
- `splice-plugin/js/main.js:2182`
- `splice-plugin/index.html` (add modal HTML)

**Problem:** `confirm()` is a browser dialog that doesn't exist in UXP environment. Delete preset will crash.

**Implementation:**
1. Create reusable confirmation modal in `index.html`
2. Add `showConfirmModal(title, message, onConfirm, onCancel)` function
3. Replace `confirm()` call in `deletePreset()` with modal
4. Add proper keyboard support (Escape to cancel, Enter to confirm)
5. Style consistently with existing modals

**E2E Test After Implementation:**
- Click delete on a preset → modal appears (not browser dialog)
- Click Cancel → modal closes, preset not deleted
- Click Confirm → preset deleted, modal closes
- Press Escape → modal closes, preset not deleted
- Verify no JavaScript errors in UXP console
- Test rapid open/close cycles

**Fix any bugs found, re-test until passing, then proceed to 1.2**

---

## Feature 1.2: Replace FileReader with UXP File API

**Files:**
- `splice-plugin/js/main.js:2254-2277`

**Problem:** `FileReader` API may not work in UXP. Import presets functionality will fail silently.

**Implementation:**
1. Replace `FileReader` with UXP `file.read()` method
2. Use `uxpFs.getFileForOpening()` to get file entry
3. Read file content using UXP async file API
4. Parse JSON and import presets
5. Add proper error handling for UXP file errors

**E2E Test After Implementation:**
- Click Import Presets → UXP file picker opens
- Select valid JSON → presets imported correctly
- Select invalid JSON → friendly error message
- Cancel file picker → no errors, UI stable
- Import large preset file (50+ presets) → works correctly
- Verify in actual Premiere Pro UXP environment

**Fix any bugs found, re-test until passing, then proceed to 1.3**

---

## Feature 1.3: Replace Inline onclick with addEventListener

**Files:**
- `splice-plugin/js/main.js:1607-1611` (batch list)
- Any other inline handlers

**Problem:** Inline `onclick` handlers in dynamically generated HTML may not work in UXP sandbox.

**Implementation:**
1. Remove `onclick="removeBatchItem(${i})"` from template literal
2. Add unique IDs or data attributes to buttons
3. Use event delegation on parent container
4. Attach listener once: `batchList.addEventListener('click', handleBatchClick)`
5. In handler, check `e.target` for button class/data attribute

**E2E Test After Implementation:**
- Add files to batch queue → remove buttons appear
- Click remove button → file removed from queue
- Add multiple files → each remove button works
- Rapid add/remove → no errors
- Verify no "function not found" errors in console

**Fix any bugs found, re-test until passing, then proceed to 1.4**

---

## Feature 1.4: Fix input type="file" for UXP

**Files:**
- `splice-plugin/index.html:1100`
- `splice-plugin/js/main.js` (import handler)

**Problem:** HTML `<input type="file">` doesn't work in UXP. Must use `uxpFs.getFileForOpening()`.

**Implementation:**
1. Remove hidden file input from HTML
2. Change Import button to directly call UXP file API
3. Use `uxpFs.getFileForOpening({ types: ['json'] })`
4. Read file content and process

**E2E Test After Implementation:**
- Click Import Presets → UXP native file picker opens
- Verify JSON filter works
- Select file → imports correctly
- Cancel → no errors

**Fix any bugs found, re-test until passing**

---

## Phase 1 Complete Checklist
- [ ] 1.1 confirm() replaced with UXP modal
- [ ] 1.2 FileReader replaced with UXP file API
- [ ] 1.3 Inline onclick replaced with addEventListener
- [ ] 1.4 File input replaced with UXP file API
- [ ] All features work in actual Premiere Pro UXP environment
- [ ] Ready for Phase 2

---

# Phase 2: Code Quality & Consistency

---

## Feature 2.1: Centralized URL Configuration

**Files:**
- `splice-plugin/js/config.js`
- `splice-plugin/js/main.js:1292`
- `splice-plugin/js/credits.js:10-13`
- `splice-plugin/js/settings.js:1244`

**Problem:** Three different URL fallback strategies causing inconsistent behavior.

**Implementation:**
1. Add `getBackendUrl()` function to `config.js`:
   ```javascript
   function getBackendUrl() {
     if (typeof BACKEND_URL !== 'undefined') return BACKEND_URL;
     return 'https://127.0.0.1:3847';
   }
   ```
2. Export function and use in all files
3. Remove duplicate fallback logic from each file
4. Add production URL detection based on environment

**E2E Test After Implementation:**
- With BACKEND_URL defined → uses defined URL
- Without BACKEND_URL → falls back to dev URL (not production, not localhost)
- All fetch calls use same base URL
- Test in dev and production modes

**Fix any bugs found, re-test until passing, then proceed to 2.2**

---

## Feature 2.2: Remove Duplicate Function Definitions

**Files:**
- `splice-plugin/js/main.js:1098` vs `splice-plugin/js/utils.js:12` (formatTime)
- `splice-plugin/js/main.js:1138` vs `splice-plugin/js/utils.js:36` (setStatus)
- `splice-plugin/js/slice8-silence.js:138` vs `splice-plugin/js/slice9-razor.js:255` (showRazorSection)

**Problem:** Duplicate functions cause confusion and potential inconsistent behavior.

**Implementation:**
1. Keep `formatTime()` in `utils.js` (add NaN check from main.js version)
2. Keep `setStatus()` in `utils.js` (already fixed with null check)
3. Keep `showRazorSection()` in `slice9-razor.js` only
4. Remove duplicates from main.js and slice8-silence.js
5. Ensure all files reference the canonical versions

**E2E Test After Implementation:**
- `formatTime(NaN)` returns safe value (not "NaN:NaN")
- `setStatus()` works when element missing
- `showRazorSection()` works from both silence and razor flows
- No function redefinition warnings in console

**Fix any bugs found, re-test until passing, then proceed to 2.3**

---

## Feature 2.3: Add Fetch Timeout Support

**Files:**
- `splice-plugin/js/config.js` (add timeout constant)
- `splice-plugin/js/main.js` (all fetch calls)
- `splice-plugin/js/credits.js` (fetch call)

**Problem:** No timeout on fetch calls. If server hangs, UI freezes indefinitely.

**Implementation:**
1. Add `FETCH_TIMEOUT = 30000` to config.js
2. Create `fetchWithTimeout(url, options, timeout)` helper:
   ```javascript
   async function fetchWithTimeout(url, options, timeout = FETCH_TIMEOUT) {
     const controller = new AbortController();
     const timeoutId = setTimeout(() => controller.abort(), timeout);
     try {
       const response = await fetch(url, { ...options, signal: controller.signal });
       clearTimeout(timeoutId);
       return response;
     } catch (err) {
       clearTimeout(timeoutId);
       if (err.name === 'AbortError') throw new Error('Request timed out');
       throw err;
     }
   }
   ```
3. Replace all `fetch()` calls with `fetchWithTimeout()`
4. Use shorter timeout for health checks (5s)
5. Use longer timeout for processing endpoints (60s)

**E2E Test After Implementation:**
- Normal request → completes successfully
- Slow server → times out after configured duration
- Timeout error → shows user-friendly message
- Verify AbortController properly cleans up

**Fix any bugs found, re-test until passing, then proceed to 2.4**

---

## Feature 2.4: Standardize Error Response Parsing

**Files:**
- `splice-plugin/js/credits.js:37`
- `splice-plugin/js/main.js:1337`
- All other fetch error handlers

**Problem:** Inconsistent error parsing. Some use `.catch()`, some don't. Field access varies.

**Implementation:**
1. Create standardized `parseErrorResponse(response)` helper:
   ```javascript
   async function parseErrorResponse(response) {
     try {
       const data = await response.json();
       return data.error || data.message || `Error ${response.status}`;
     } catch {
       return `Error ${response.status}: ${response.statusText}`;
     }
   }
   ```
2. Use in all fetch error handlers
3. Ensure consistent error object structure expected

**E2E Test After Implementation:**
- Server returns `{ error: "message" }` → displays message
- Server returns `{ message: "text" }` → displays text
- Server returns invalid JSON → shows status code
- Server returns empty body → shows status code

**Fix any bugs found, re-test until passing**

---

## Phase 2 Complete Checklist
- [ ] 2.1 Single getBackendUrl() function used everywhere
- [ ] 2.2 No duplicate function definitions
- [ ] 2.3 All fetch calls have timeout support
- [ ] 2.4 Standardized error response parsing
- [ ] Code is consistent and maintainable
- [ ] Ready for Phase 3

---

# Phase 3: Performance Optimizations

---

## Feature 3.1: Optimize Levenshtein Distance Algorithm

**Files:**
- `splice-backend/services/repetitionDetection.js:429-456`

**Problem:** O(n²) algorithm with new array allocation per call. Called in nested loops for large transcripts.

**Implementation:**
1. Use single-row DP (O(n) space instead of O(m×n)):
   ```javascript
   function levenshteinDistance(s1, s2) {
     if (s1 === s2) return 0;
     if (!s1.length) return s2.length;
     if (!s2.length) return s1.length;

     let prev = new Array(s2.length + 1);
     let curr = new Array(s2.length + 1);

     for (let j = 0; j <= s2.length; j++) prev[j] = j;

     for (let i = 1; i <= s1.length; i++) {
       curr[0] = i;
       for (let j = 1; j <= s2.length; j++) {
         const cost = s1[i-1] === s2[j-1] ? 0 : 1;
         curr[j] = Math.min(
           curr[j-1] + 1,
           prev[j] + 1,
           prev[j-1] + cost
         );
       }
       [prev, curr] = [curr, prev];
     }
     return prev[s2.length];
   }
   ```
2. Add early exit when distance exceeds threshold
3. Pre-allocate reusable buffers at module level

**E2E Test After Implementation:**
- Run repetition detection on 1000-word transcript
- Measure time before and after (target: 10x improvement)
- Verify detection accuracy unchanged
- Test with very long words (100+ chars)
- Memory profile shows no growth

**Fix any bugs found, re-test until passing, then proceed to 3.2**

---

## Feature 3.2: Fix Array Spread in Hot Loop

**Files:**
- `splice-backend/services/rmsSilenceDetection.js:203, 254-256`

**Problem:** `concat()` creates new array each iteration. `Math.min(...array)` can overflow call stack.

**Implementation:**
1. Replace `concat()` with `push.apply()`:
   ```javascript
   // Before
   allDBFSValues = allDBFSValues.concat(Array.from(dBFSValues));
   // After
   allDBFSValues.push.apply(allDBFSValues, Array.from(dBFSValues));
   ```
2. Replace `Math.min/max(...array)` with loop:
   ```javascript
   let minDB = Infinity, maxDB = -Infinity, sum = 0;
   for (const v of allDBFSValues) {
     if (v < minDB) minDB = v;
     if (v > maxDB) maxDB = v;
     sum += v;
   }
   const avgDB = sum / allDBFSValues.length;
   ```

**E2E Test After Implementation:**
- Process 30-minute audio file
- Verify no call stack overflow
- Measure performance improvement (target: 5-10x for large files)
- Verify min/max/avg values correct

**Fix any bugs found, re-test until passing, then proceed to 3.3**

---

## Feature 3.3: Reduce Database Round-Trips

**Files:**
- `splice-backend/services/usageTracking.js:549-587`

**Problem:** `deductUsage()` calls `getBalance()` at end, causing extra SELECT after UPDATE.

**Implementation:**
1. Use `RETURNING *` in UPDATE query:
   ```javascript
   const result = await client.query(
     `UPDATE users
      SET hours_remaining = hours_remaining - $2
      WHERE stripe_customer_id = $1
      RETURNING hours_remaining, hours_total, tier`,
     [stripeCustomerId, hoursToDeduct]
   );
   ```
2. Return updated values directly instead of calling getBalance()
3. Apply same pattern to: `confirmReservation()`, `releaseReservation()`, `resetHours()`, `updateTier()`

**E2E Test After Implementation:**
- Deduct usage → verify correct balance returned
- Verify only 1 database query per operation (check logs)
- Measure response time improvement
- Verify all returned fields correct

**Fix any bugs found, re-test until passing, then proceed to 3.4**

---

## Feature 3.4: Add Cache TTL to Transcription

**Files:**
- `splice-backend/services/transcription.js:15-19`

**Problem:** Cache entries never expire based on time. Stale entries persist for deleted files.

**Implementation:**
1. Add TTL to cache entries:
   ```javascript
   const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour

   function cacheSet(key, value) {
     while (transcriptCache.size >= MAX_CACHE_SIZE) {
       const oldestKey = transcriptCache.keys().next().value;
       transcriptCache.delete(oldestKey);
     }
     transcriptCache.set(key, {
       ...value,
       cachedAt: Date.now()
     });
   }

   function cacheGet(key) {
     const entry = transcriptCache.get(key);
     if (!entry) return null;
     if (Date.now() - entry.cachedAt > CACHE_TTL_MS) {
       transcriptCache.delete(key);
       return null;
     }
     return entry;
   }
   ```
2. Update cache access to use `cacheGet()`
3. Add periodic cleanup of expired entries

**E2E Test After Implementation:**
- Cache entry created → retrievable
- Wait 1+ hour → entry expired, new API call made
- Verify memory doesn't grow unbounded over time
- Test cache stats show correct entry count

**Fix any bugs found, re-test until passing**

---

## Phase 3 Complete Checklist
- [ ] 3.1 Levenshtein optimized (10x faster)
- [ ] 3.2 Array operations don't overflow stack
- [ ] 3.3 Database round-trips reduced by 30-50%
- [ ] 3.4 Cache entries expire after TTL
- [ ] All performance benchmarks pass
- [ ] Ready for Phase 4

---

# Phase 4: Architecture Improvements

---

## Feature 4.1: Fix Hardcoded File Paths

**Files:**
- `splice-plugin/js/config.js:9-10, 13`

**Problem:** `/tmp` paths and hardcoded "Beta" app path will break on different systems.

**Implementation:**
1. Use UXP temp directory API:
   ```javascript
   const { localFileSystem } = require('uxp').storage;
   const tempFolder = await localFileSystem.getTemporaryFolder();
   const WAV_PATH = (await tempFolder.createFile('splice_audio_export.wav')).nativePath;
   ```
2. Detect Premiere Pro version dynamically
3. Add fallback paths for different OS/versions
4. Validate paths exist before use

**E2E Test After Implementation:**
- Plugin loads on macOS → correct temp paths
- Plugin loads on Windows → correct temp paths
- Non-beta Premiere Pro → correct app path
- Invalid path → friendly error message

**Fix any bugs found, re-test until passing, then proceed to 4.2**

---

## Feature 4.2: Add Missing ARIA Labels

**Files:**
- `splice-plugin/index.html` (multiple locations)

**Problem:** Icon buttons lack ARIA labels, affecting accessibility.

**Implementation:**
1. Add `aria-label` to icon buttons:
   ```html
   <button aria-label="Help" title="Help">?</button>
   <button aria-label="Toggle protected" title="Toggle protected">*</button>
   ```
2. Add `role="dialog"` and `aria-modal="true"` to modals
3. Add `aria-live="polite"` to status message area
4. Add keyboard navigation support (Tab order)

**E2E Test After Implementation:**
- Screen reader announces button purposes
- Tab navigation follows logical order
- Modal focus trapped correctly
- Status updates announced

**Fix any bugs found, re-test until passing, then proceed to 4.3**

---

## Feature 4.3: Fix ProjectItemType Constant

**Files:**
- `splice-plugin/js/builder.js:78`

**Problem:** `pproBuilder.Constants.ProjectItemType.BIN` may be undefined in some UXP versions.

**Implementation:**
1. Add constant fallback at top of builder.js:
   ```javascript
   const ProjectItemType = pproBuilder?.Constants?.ProjectItemType || {
     CLIP: 1,
     BIN: 2,
     ROOT: 3,
     FILE: 4
   };
   ```
2. Use local constant instead of API constant
3. Match pattern already used in main.js:1222-1229

**E2E Test After Implementation:**
- Builder works when Constants undefined
- Builder works when Constants defined
- Recursive item search finds all items
- No TypeError on project item iteration

**Fix any bugs found, re-test until passing**

---

## Phase 4 Complete Checklist
- [ ] 4.1 Dynamic file paths work cross-platform
- [ ] 4.2 Accessibility labels added
- [ ] 4.3 ProjectItemType fallback works
- [ ] Plugin works on all supported systems
- [ ] Ready for Phase 5

---

# Phase 5: Final Verification

---

## Test 1: UXP Environment Verification

**Steps:**
1. Load plugin in Premiere Pro 25.6+
2. Open Settings modal → verify no browser dialogs
3. Import presets → verify UXP file picker
4. Delete preset → verify custom confirmation modal
5. All buttons respond correctly
6. No JavaScript errors in UXP console

**Pass Criteria:** All UXP-specific features work

---

## Test 2: Performance Benchmark

**Steps:**
1. Process 10-minute audio file with repetition detection
2. Measure time (target: <5 seconds for 1000 words)
3. Process 30-minute audio with RMS silence detection
4. Verify no memory issues or stack overflow
5. Run 100 consecutive requests
6. Verify no memory growth (< 50MB increase)

**Pass Criteria:** All benchmarks within targets

---

## Test 3: Cross-Platform Verification

**Steps:**
1. Test on macOS with Premiere Pro release version
2. Test on macOS with Premiere Pro Beta
3. Test on Windows (if available)
4. Verify temp paths work on each platform
5. Verify no hardcoded path failures

**Pass Criteria:** Works on all tested platforms

---

## Test 4: Full E2E Flow

**Steps:**
1. Fresh plugin install
2. Configure settings (customer ID, preferences)
3. Run GO on test video → silences detected
4. Build Sequence → new sequence created
5. Export captions → file created
6. Verify credits deducted correctly
7. Logout → verify state cleared
8. Login → verify fresh state

**Pass Criteria:** Complete workflow succeeds

---

## Final Checklist

| Test | Status |
|------|--------|
| 1. UXP Environment | ⬜ |
| 2. Performance Benchmark | ⬜ |
| 3. Cross-Platform | ⬜ |
| 4. Full E2E Flow | ⬜ |

## If Any Test Fails
1. Log failure with specific step and error
2. Trace to root cause (file:line)
3. Fix the issue
4. Re-run failed test
5. If pass, continue
6. If fail, repeat fix cycle

## Completion Criteria
All 4 tests passing = SPLICE E2E fixes complete and verified

---

# Summary of Already Fixed Issues

The following issues were already fixed during the initial E2E audit:

| Issue | File | Status |
|-------|------|--------|
| Wrong localhost fallback | `main.js:1292` | FIXED |
| Production URL fallback | `credits.js:12` | FIXED |
| Missing await on lockedAccess | `slice8-silence.js`, `slice7-apply.js` | FIXED |
| Null dereference in setStatus | `utils.js:37` | FIXED |
| Memory leak (interval not cleared) | `credits.js:189` | FIXED |
| Sync fs.existsSync blocking | `server.js` (9 locations) | FIXED |

---

*Each phase prompt is self-contained. Complete the features with E2E testing, then move to the next phase. Phase 5 is the final comprehensive validation.*
