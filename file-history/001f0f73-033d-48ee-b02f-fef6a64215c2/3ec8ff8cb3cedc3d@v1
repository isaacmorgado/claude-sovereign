/**
 * Slice 7: Apply Takes to Timeline
 *
 * Timeline manipulation functions:
 * - Label clips with take information
 * - Delete non-best takes
 *
 * These are now callable functions used by main.js.
 */

/**
 * Label clips on timeline with take information
 * @returns {number} Number of clips labeled
 */
async function labelTakesOnTimeline() {
  const takes = getCurrentTakes();

  if (!takes || takes.length === 0) {
    throw new Error('No takes to label');
  }

  const context = await getActiveSequence();
  if (!context) {
    throw new Error('No project or sequence open');
  }

  const { sequence } = context;

  // Find clips and rename them based on which take they fall into
  const videoTrackCount = await sequence.getVideoTrackCount();
  let labeledCount = 0;

  for (let i = 0; i < videoTrackCount; i++) {
    const track = await sequence.getVideoTrack(i);
    if (!track) continue;

    const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
    if (!clips) continue;

    for (let j = 0; j < clips.length; j++) {
      const clip = clips[j];
      if (!clip) continue;

      const clipStartObj = await clip.getStartTime();
      const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
      const clipStartSec = clipStart / TICKS_PER_SECOND;

      // Find which take this clip belongs to
      for (const take of takes) {
        const takeStart = take.start || take.startTime || 0;
        const takeEnd = take.end || take.endTime || 0;

        if (clipStartSec >= takeStart && clipStartSec < takeEnd) {
          // Short label: "* Take 1 - description"
          const isBest = take.isBest || take.userMarkedBest;
          const prefix = isBest ? '* ' : '';
          const takeNum = take.takeNumber || takes.indexOf(take) + 1;
          const desc = take.shortLabel || take.description || take.text || '';
          const shortDesc = desc.split(' ').slice(0, 4).join(' ');
          const label = `${prefix}Take ${takeNum} - ${shortDesc}`;

          // UXP action pattern
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;
          const labelRef = label;

          await project.lockedAccess(async () => {
            await project.executeTransaction((compoundAction) => {
              const setNameAction = clipRef.createSetNameAction(labelRef);
              compoundAction.addAction(setNameAction);
            }, 'SPLICE: Label Clip');
          });
          labeledCount++;
          break;
        }
      }
    }
  }

  return labeledCount;
}

/**
 * Apply best takes - disable non-best takes
 * @returns {number} Number of clips disabled
 */
async function applyBestTakes() {
  const takes = getCurrentTakes();

  if (!takes || takes.length === 0) {
    throw new Error('No takes to apply');
  }

  const context = await getActiveSequence();
  if (!context) {
    throw new Error('No project or sequence open');
  }

  const { sequence } = context;

  // Sort takes by start time (descending) - work from end to avoid time shifts
  const sortedTakes = [...takes].sort((a, b) => {
    const aStart = a.start || a.startTime || 0;
    const bStart = b.start || b.startTime || 0;
    return bStart - aStart;
  });

  let disabledCount = 0;

  for (const take of sortedTakes) {
    const isBest = take.isBest || take.userMarkedBest;
    if (isBest) {
      continue; // Keep best takes
    }

    const takeStart = take.start || take.startTime || 0;
    const takeEnd = take.end || take.endTime || 0;

    // Convert seconds to ticks
    const startTicks = Math.floor(takeStart * TICKS_PER_SECOND);
    const endTicks = Math.floor(takeEnd * TICKS_PER_SECOND);

    // Process both video and audio tracks
    const videoTrackCount = await sequence.getVideoTrackCount();
    const audioTrackCount = await sequence.getAudioTrackCount();

    // Process video tracks
    for (let i = 0; i < videoTrackCount; i++) {
      const track = await sequence.getVideoTrack(i);
      if (!track) continue;

      const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      if (!clips) continue;

      for (let j = clips.length - 1; j >= 0; j--) {
        const clip = clips[j];
        if (!clip) continue;

        const clipStartObj = await clip.getStartTime();
        const clipEndObj = await clip.getEndTime();
        const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
        const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

        // Check if clip is within the non-best take range
        if (clipStart >= startTicks && clipEnd <= endTicks) {
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;

          project.lockedAccess(() => {
            project.executeTransaction((compoundAction) => {
              const disableAction = clipRef.createSetDisabledAction(true);
              compoundAction.addAction(disableAction);
            }, 'SPLICE: Disable Non-Best Take');
          });
          disabledCount++;
        }
      }
    }

    // Process audio tracks
    for (let i = 0; i < audioTrackCount; i++) {
      const track = await sequence.getAudioTrack(i);
      if (!track) continue;

      const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      if (!clips) continue;

      for (let j = clips.length - 1; j >= 0; j--) {
        const clip = clips[j];
        if (!clip) continue;

        const clipStartObj = await clip.getStartTime();
        const clipEndObj = await clip.getEndTime();
        const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
        const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

        // Check if clip is within the non-best take range
        if (clipStart >= startTicks && clipEnd <= endTicks) {
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;

          project.lockedAccess(() => {
            project.executeTransaction((compoundAction) => {
              const disableAction = clipRef.createSetDisabledAction(true);
              compoundAction.addAction(disableAction);
            }, 'SPLICE: Disable Non-Best Take');
          });
          disabledCount++;
        }
      }
    }
  }

  return disabledCount;
}

// Legacy init functions - no longer needed
function initLabelTimeline() {
  // Now called directly via labelTakesOnTimeline()
}

function initApplyTakes() {
  // Now called directly via applyBestTakes()
}
