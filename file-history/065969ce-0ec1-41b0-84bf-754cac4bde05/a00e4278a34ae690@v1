# Ken Kai's Design Speak & Code Speak - Prompting Guide for Claude Code

**Source**: Ken Kai's Agency Courses (https://www.kenkais.com/exclusive)
**Course**: Design Speak & Code Speak
**Purpose**: Learn the terminology to describe designs and code to your coding agent
**Optimized For**: Claude Code AI Assistant

---

## üìö Course Overview

This guide teaches you the terminology to effectively communicate with AI coding assistants like Claude Code. Master both **Design Speak** (visual/UX terminology) and **Code Speak** (technical terminology) to get better results from your AI pair programmer.

---

## üé® Part 1: Design Speak - Visual & UX Terminology

### Layout & Structure Terms

#### **Container Types**
```
‚úÖ GOOD: "Create a flex container with justify-content center"
‚ùå AVOID: "Make things centered"

Common containers:
- Flexbox container (flex, flex-row, flex-col)
- Grid container (grid, grid-cols-3)
- Section wrapper (section, container, max-w-7xl)
- Card container (card, panel, box)
```

#### **Spacing Terms**
```
‚úÖ GOOD: "Add padding-4 and margin-bottom-6"
‚ùå AVOID: "Add some space"

Precise spacing:
- padding (p-4, px-6, py-2, pt-8, pb-4, pl-2, pr-2)
- margin (m-4, mx-auto, my-6, mt-8, mb-4)
- gap (gap-4, gap-x-6, gap-y-2)
- space-between, space-around, space-evenly
```

#### **Layout Patterns**
```
‚úÖ GOOD: "Use a 3-column grid with gap-6 on desktop, single column on mobile"
‚ùå AVOID: "Make it look good on different screens"

Common patterns:
- Sidebar layout (aside + main)
- Hero section (full-width banner)
- Card grid (grid of equal-height cards)
- Stack layout (vertical flow)
- Split layout (50/50 or 60/40)
```

### Visual Design Terms

#### **Color Terminology**
```
‚úÖ GOOD: "Use slate-800 for text, blue-600 for primary buttons, hover:blue-700"
‚ùå AVOID: "Make it blue"

Color systems:
- Primary color (main brand color)
- Secondary color (accent)
- Neutral colors (gray-100 to gray-900, slate, zinc)
- Semantic colors (red-500 danger, green-500 success, yellow-500 warning)
- Text colors (text-gray-900, text-slate-700)
- Background colors (bg-white, bg-gray-50)
```

#### **Typography Terms**
```
‚úÖ GOOD: "Use text-4xl font-bold leading-tight for the heading"
‚ùå AVOID: "Make the title big and bold"

Typography:
- Font size (text-xs, text-sm, text-base, text-lg, text-xl, text-2xl, text-4xl)
- Font weight (font-light, font-normal, font-medium, font-semibold, font-bold)
- Line height (leading-none, leading-tight, leading-normal, leading-relaxed)
- Letter spacing (tracking-tight, tracking-normal, tracking-wide)
- Text alignment (text-left, text-center, text-right, text-justify)
```

#### **Visual Effects**
```
‚úÖ GOOD: "Add shadow-lg with rounded-xl borders and a subtle gradient from blue-500 to purple-600"
‚ùå AVOID: "Make it fancy"

Effects:
- Shadows (shadow-sm, shadow, shadow-md, shadow-lg, shadow-xl)
- Rounded corners (rounded, rounded-lg, rounded-full, rounded-t-lg)
- Borders (border, border-2, border-gray-300)
- Opacity (opacity-50, opacity-75, opacity-100)
- Gradients (gradient from X to Y)
- Blur (blur-sm, backdrop-blur-md)
```

### Component Design Terms

#### **Button States**
```
‚úÖ GOOD: "Primary button with hover:scale-105 and active:scale-95 transitions"
‚ùå AVOID: "Make button interactive"

Button terminology:
- Default state (base appearance)
- Hover state (hover:bg-blue-700)
- Active state (active:scale-95)
- Focus state (focus:ring-2, focus:ring-blue-500)
- Disabled state (disabled:opacity-50, disabled:cursor-not-allowed)
- Loading state (spinner icon + disabled)
```

#### **Form Elements**
```
‚úÖ GOOD: "Text input with border-gray-300, focus:border-blue-500, and error state with border-red-500"
‚ùå AVOID: "Make a form field"

Form terminology:
- Input field (text input, email input, password input)
- Textarea (multi-line input)
- Select dropdown (combobox, dropdown menu)
- Checkbox (toggle, switch)
- Radio buttons (option selector)
- Form validation (error state, success state, warning state)
- Placeholder text
- Label (above, inline, floating)
```

### Responsive Design Terms

```
‚úÖ GOOD: "Hide on mobile (hidden md:block), show sidebar on tablet and up (lg:flex)"
‚ùå AVOID: "Make it responsive"

Breakpoints:
- sm: 640px (mobile landscape)
- md: 768px (tablet)
- lg: 1024px (desktop)
- xl: 1280px (large desktop)
- 2xl: 1536px (extra large)

Usage: hidden lg:block (hidden on mobile, visible on desktop)
```

---

## üíª Part 2: Code Speak - Technical Terminology

### Architecture & Patterns

#### **Component Structure**
```
‚úÖ GOOD: "Create a React functional component with TypeScript, accepting props interface UserCardProps"
‚ùå AVOID: "Make a component"

Terminology:
- Functional component (vs class component)
- Props interface (TypeScript type definition)
- State management (useState, useReducer)
- Side effects (useEffect, useLayoutEffect)
- Context (useContext, Provider, Consumer)
- Refs (useRef, forwardRef)
- Memoization (useMemo, useCallback, React.memo)
```

#### **State Management**
```
‚úÖ GOOD: "Use useState for local state, lift state up to parent if needed, consider Zustand for global state"
‚ùå AVOID: "Handle the data"

State terminology:
- Local state (component-level useState)
- Lifted state (moved to parent component)
- Global state (context, Redux, Zustand)
- Derived state (computed from other state)
- Server state (React Query, SWR)
- URL state (query parameters, route params)
```

#### **Data Flow Patterns**
```
‚úÖ GOOD: "Pass handleSubmit callback as prop, use controlled input with value and onChange"
‚ùå AVOID: "Connect the form"

Patterns:
- Props down, events up (one-way data flow)
- Controlled components (value + onChange)
- Uncontrolled components (ref-based)
- Callback functions (event handlers)
- Prop drilling (passing props through multiple levels)
- Composition (children, render props)
```

### API & Data Fetching

#### **HTTP Methods**
```
‚úÖ GOOD: "POST request to /api/users with JSON body, handle 201 Created and 400 Bad Request responses"
‚ùå AVOID: "Send data to server"

Methods:
- GET (fetch data, idempotent)
- POST (create resource)
- PUT (update entire resource)
- PATCH (partial update)
- DELETE (remove resource)

Status codes:
- 200 OK, 201 Created
- 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found
- 500 Internal Server Error
```

#### **Async Patterns**
```
‚úÖ GOOD: "Use async/await with try-catch, show loading spinner while fetching, handle errors with toast notification"
‚ùå AVOID: "Get data from API"

Patterns:
- async/await (modern promise handling)
- try-catch (error handling)
- Loading states (isLoading, isPending)
- Error states (error, isError)
- Success states (isSuccess, data)
- Retry logic (exponential backoff)
- Optimistic updates (update UI before API confirms)
```

### Database & Backend

#### **Query Operations**
```
‚úÖ GOOD: "SELECT user.id, user.name FROM users WHERE active = true ORDER BY created_at DESC LIMIT 10"
‚ùå AVOID: "Get users from database"

SQL terminology:
- SELECT (retrieve data)
- WHERE (filter conditions)
- JOIN (combine tables: INNER, LEFT, RIGHT, FULL)
- GROUP BY (aggregate data)
- ORDER BY (sort: ASC, DESC)
- LIMIT/OFFSET (pagination)
- INDEX (performance optimization)
```

#### **Authentication & Authorization**
```
‚úÖ GOOD: "Implement JWT authentication with refresh tokens, protect routes with middleware checking user.role"
‚ùå AVOID: "Add login"

Auth terminology:
- Authentication (who you are: login, JWT, sessions)
- Authorization (what you can do: roles, permissions)
- JWT (JSON Web Token)
- Refresh token (long-lived token for getting new access tokens)
- OAuth (third-party auth: Google, GitHub)
- Middleware (route protection, req/res interceptors)
- RBAC (Role-Based Access Control)
- Claims (user info in token)
```

### Code Quality & Testing

#### **Testing Terminology**
```
‚úÖ GOOD: "Write unit tests for the calculateTotal function, integration test for the checkout flow, and E2E test for the full user journey"
‚ùå AVOID: "Test the code"

Test types:
- Unit test (single function/component)
- Integration test (multiple components working together)
- E2E test (end-to-end user flow)
- Snapshot test (component output comparison)
- Mock (fake implementation for testing)
- Stub (predefined responses)
- Spy (track function calls)
- Coverage (percentage of code tested)
```

#### **Error Handling**
```
‚úÖ GOOD: "Wrap in try-catch, log to Sentry, show user-friendly message, include error boundary for React crashes"
‚ùå AVOID: "Handle errors"

Error handling:
- try-catch block (synchronous errors)
- .catch() (promise errors)
- Error boundary (React component errors)
- Fallback UI (what to show when error occurs)
- Error logging (Sentry, LogRocket)
- Graceful degradation (app still works with reduced functionality)
- Retry mechanism (automatic retry with backoff)
```

### Performance Optimization

```
‚úÖ GOOD: "Lazy load the Dashboard component, use React.memo for expensive renders, debounce search input, paginate API results"
‚ùå AVOID: "Make it faster"

Optimization:
- Lazy loading (code splitting, dynamic imports)
- Memoization (React.memo, useMemo, useCallback)
- Debouncing (delay function execution)
- Throttling (limit function calls per time)
- Pagination (load data in chunks)
- Virtual scrolling (only render visible items)
- Image optimization (lazy load, responsive images, WebP)
- Caching (browser cache, CDN, service workers)
```

---

## üéØ Effective Prompting Patterns for Claude Code

### Pattern 1: Specify the Stack
```
‚úÖ GOOD:
"Create a Next.js 14 App Router page component with TypeScript,
using Tailwind CSS for styling and shadcn/ui for UI components"

‚ùå AVOID:
"Make a page"
```

### Pattern 2: Define the Structure
```
‚úÖ GOOD:
"Create a UserCard component that accepts props: user (User type),
onEdit callback, and onDelete callback. Show avatar, name, email,
and action buttons."

‚ùå AVOID:
"Make a user card"
```

### Pattern 3: Specify Behavior
```
‚úÖ GOOD:
"When user clicks submit, validate email format, show loading spinner,
POST to /api/subscribe, handle success with toast notification,
handle errors by showing inline error message below input"

‚ùå AVOID:
"Make form submit work"
```

### Pattern 4: Include Edge Cases
```
‚úÖ GOOD:
"Handle loading state (show skeleton), empty state (show empty message),
error state (show retry button), and success state (show data).
Implement pagination with prev/next buttons."

‚ùå AVOID:
"Show the data"
```

### Pattern 5: Reference Existing Patterns
```
‚úÖ GOOD:
"Follow the same pattern as the existing ProductCard component,
but adapt for UserCard with different fields"

‚ùå AVOID:
"Make something similar"
```

---

## üìù Quick Reference: Common Patterns

### Creating a New Feature
```
"Create a [feature name] feature with:
- [Component name] component using [framework/library]
- Props: [list props with types]
- State: [list state variables]
- API calls: [method] to [endpoint]
- Styling: [design system/Tailwind classes]
- Error handling: [how to handle errors]
- Loading states: [what to show]
- Responsive: [mobile/tablet/desktop behavior]"
```

### Fixing a Bug
```
"Fix the [component/function name] where:
- Current behavior: [what's happening]
- Expected behavior: [what should happen]
- Error message: [if any]
- Steps to reproduce: [how to trigger bug]
- Likely cause: [your hypothesis]"
```

### Refactoring Code
```
"Refactor [component/function name] to:
- Extract [repeated logic] into [helper/hook]
- Improve performance by [specific optimization]
- Make more maintainable by [specific improvement]
- Follow [pattern/best practice]
- Keep existing functionality intact"
```

### Adding Tests
```
"Write [unit/integration/E2E] tests for [component/function]:
- Test happy path: [describe]
- Test edge cases: [list cases]
- Mock [dependencies]
- Assert [expected outcomes]
- Use [testing library/framework]"
```

---

## üöÄ Advanced Prompting Techniques

### 1. Incremental Requests
Break complex tasks into steps:
```
Step 1: "Create the basic UserProfile component structure with props interface"
Step 2: "Add form fields for name, email, and bio"
Step 3: "Implement form validation with Zod schema"
Step 4: "Add API integration with error handling"
Step 5: "Add loading and success states"
```

### 2. Provide Examples
```
"Create a notification system similar to this pattern:
[paste example code]

But adapt it to use our toast library and add:
- Auto-dismiss after 5 seconds
- Stack multiple notifications
- Different variants (success, error, warning, info)"
```

### 3. Specify Constraints
```
"Optimize the image gallery with these constraints:
- Must work on mobile (iOS Safari)
- Keep bundle size under 50KB
- Support lazy loading
- No external dependencies
- Maintain accessibility (keyboard navigation)"
```

### 4. Request Explanations
```
"Implement JWT refresh token rotation and explain:
- Why this approach is secure
- How token expiration is handled
- What happens when refresh token expires
- Include code comments for complex logic"
```

---

## ‚ú® Tips for Best Results

### DO:
- ‚úÖ Use specific technical terms
- ‚úÖ Reference exact libraries/frameworks/versions
- ‚úÖ Specify expected behavior and edge cases
- ‚úÖ Include styling details (Tailwind classes, CSS properties)
- ‚úÖ Mention accessibility requirements
- ‚úÖ Ask for TypeScript types when using TS
- ‚úÖ Request error handling explicitly
- ‚úÖ Break complex tasks into steps

### DON'T:
- ‚ùå Use vague terms like "make it nice" or "fix it"
- ‚ùå Assume Claude knows your project structure
- ‚ùå Skip mentioning important constraints
- ‚ùå Forget to specify the tech stack
- ‚ùå Leave out error and loading states
- ‚ùå Ignore accessibility
- ‚ùå Request too many changes at once

---

## üìö Glossary of Essential Terms

### Frontend
- **Component**: Reusable UI building block
- **Props**: Data passed to components
- **State**: Data that changes over time
- **Hook**: React function (useState, useEffect, etc.)
- **Render**: Display component on screen
- **Re-render**: Update display when data changes
- **Virtual DOM**: React's internal representation
- **Hydration**: Making static HTML interactive
- **SSR**: Server-Side Rendering
- **CSR**: Client-Side Rendering
- **SSG**: Static Site Generation

### Backend
- **Endpoint**: API URL path (/api/users)
- **Route**: URL pattern with handler
- **Middleware**: Code that runs between request/response
- **Controller**: Handles business logic
- **Model**: Data structure/database schema
- **Migration**: Database schema change
- **Seed**: Sample data for development
- **ORM**: Object-Relational Mapping (Prisma, TypeORM)
- **Query**: Database request
- **Transaction**: Group of database operations

### DevOps & Deployment
- **Build**: Compile/bundle code for production
- **Deploy**: Push code to production server
- **CI/CD**: Continuous Integration/Deployment
- **Environment**: dev, staging, production
- **Environment variables**: Secret config (.env)
- **Docker**: Containerization platform
- **Serverless**: Functions-as-a-Service (AWS Lambda, Vercel)

---

## üéì Course Completion Checklist

Master these prompting skills:

- [ ] Can specify layout using precise CSS/Tailwind terms
- [ ] Can describe visual design with color, typography, and effects
- [ ] Can request components with clear prop interfaces
- [ ] Can specify state management approach
- [ ] Can describe API interactions with HTTP methods
- [ ] Can request proper error and loading states
- [ ] Can specify testing requirements
- [ ] Can break complex features into incremental steps
- [ ] Can provide constraints and requirements clearly
- [ ] Can request accessibility and responsive behavior

---

**Remember**: The more specific and technical your prompts, the better Claude Code can help you build exactly what you envision!

---

*Based on Ken Kai's Design Speak & Code Speak course*
*Extracted from: https://www.kenkais.com/exclusive*
*Optimized for: Claude Code AI Assistant*
