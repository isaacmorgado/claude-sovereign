/**
 * Settings Management
 *
 * Persists user preferences to localStorage
 * v3.5: Added Persistent Token support for media folder access
 */

const uxpFs = require('uxp').storage.localFileSystem;

// =============================================================================
// CUSTOM PRESETS STORAGE (v3.5+)
// =============================================================================

const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';

/**
 * Default structure for custom presets storage
 */
const DEFAULT_CUSTOM_PRESETS = {
  version: 1,
  presets: {},
  order: []
};

/**
 * Load custom presets from localStorage
 * @returns {Object} Custom presets data structure
 */
function loadCustomPresets() {
  try {
    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      // Validate structure
      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
        // Return deep copy to avoid mutation issues
        return {
          version: parsed.version || 1,
          presets: { ...parsed.presets },
          order: [...(parsed.order || [])]
        };
      }
    }
  } catch (e) {
    console.warn('[SPLICE] Could not load custom presets:', e);
  }
  // Return fresh objects to avoid mutation of defaults
  return {
    version: 1,
    presets: {},
    order: []
  };
}

/**
 * Save custom presets to localStorage
 * @param {Object} data - Custom presets data structure
 * @returns {boolean} Success status
 */
function saveCustomPresets(data) {
  try {
    if (!data || typeof data !== 'object') {
      console.warn('[SPLICE] Invalid custom presets data');
      return false;
    }
    // Ensure required fields
    const toSave = {
      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
      presets: data.presets || {},
      order: data.order || []
    };
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    return true;
  } catch (e) {
    console.warn('[SPLICE] Could not save custom presets:', e);
    return false;
  }
}

/**
 * Generate a slugified ID from a preset name
 * @param {string} name - Preset name
 * @returns {string} Slugified ID
 */
function slugifyPresetName(name) {
  return name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50) || 'preset';
}

/**
 * Generate a unique ID for a custom preset
 * @param {string} baseName - Base name to slugify
 * @param {Object} existingPresets - Current presets object
 * @returns {string} Unique ID
 */
function generateUniquePresetId(baseName, existingPresets) {
  const baseId = slugifyPresetName(baseName);
  let id = baseId;
  let counter = 1;

  while (existingPresets[id]) {
    id = `${baseId}-${counter}`;
    counter++;
  }

  return id;
}

/**
 * Create a new custom preset
 * @param {Object} preset - Preset data
 * @param {string} preset.name - Preset name (required)
 * @param {string} [preset.description] - Preset description
 * @param {string} [preset.icon] - Icon name (default: 'settings')
 * @param {Object} [preset.settings] - Preset settings (uses current if not provided)
 * @returns {{success: boolean, id?: string, error?: string}}
 */
function createCustomPreset(preset) {
  // Validate input
  if (!preset || typeof preset !== 'object') {
    return { success: false, error: 'Invalid preset data' };
  }

  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {
    return { success: false, error: 'Preset name is required' };
  }

  const name = preset.name.trim();

  // Load current data
  const data = loadCustomPresets();

  // Generate unique ID
  const id = generateUniquePresetId(name, data.presets);

  // Get settings from preset or current settings
  const settings = preset.settings && typeof preset.settings === 'object'
    ? { ...preset.settings }
    : getCurrentPresetSettings();

  // Validate settings
  if (!settings || typeof settings !== 'object') {
    return { success: false, error: 'Invalid settings' };
  }

  // Create the preset object
  const newPreset = {
    id,
    name,
    description: preset.description || '',
    icon: preset.icon || 'settings',
    createdAt: new Date().toISOString(),
    settings
  };

  // Add to presets and order
  data.presets[id] = newPreset;
  data.order.push(id);

  // Save
  const saved = saveCustomPresets(data);
  if (!saved) {
    return { success: false, error: 'Failed to save preset' };
  }

  console.log(`[SPLICE] Created custom preset: ${name} (${id})`);
  return { success: true, id };
}

/**
 * Get current settings suitable for a preset
 * @returns {Object} Current preset-compatible settings
 */
function getCurrentPresetSettings() {
  const current = typeof getSettings === 'function' ? getSettings() : {};
  return {
    sensitivity: current.sensitivity || 50,
    threshold: current.threshold || -32,
    minSilenceLength: current.minSilenceLength || 0.5,
    paddingStart: current.paddingStart || 0.1,
    paddingEnd: current.paddingEnd || 0.1,
    autoMarkBest: current.autoMarkBest !== false,
    enableTakesDetection: current.enableTakesDetection !== false
  };
}

/**
 * Update an existing custom preset
 * @param {string} id - Preset ID to update
 * @param {Object} updates - Fields to update
 * @param {string} [updates.name] - New name
 * @param {string} [updates.description] - New description
 * @param {string} [updates.icon] - New icon
 * @param {Object} [updates.settings] - New settings (merged with existing)
 * @returns {{success: boolean, error?: string}}
 */
function updateCustomPreset(id, updates) {
  // Validate input
  if (!id || typeof id !== 'string') {
    return { success: false, error: 'Preset ID is required' };
  }

  if (!updates || typeof updates !== 'object') {
    return { success: false, error: 'Updates must be an object' };
  }

  // Load current data
  const data = loadCustomPresets();

  // Check if preset exists
  if (!data.presets[id]) {
    return { success: false, error: 'Preset not found' };
  }

  const existing = data.presets[id];

  // Apply updates (preserve fields not being updated)
  const updated = {
    ...existing,
    updatedAt: new Date().toISOString()
  };

  // Update name (with validation)
  if (updates.name !== undefined) {
    if (typeof updates.name !== 'string' || !updates.name.trim()) {
      return { success: false, error: 'Name must be a non-empty string' };
    }
    updated.name = updates.name.trim();
  }

  // Update description
  if (updates.description !== undefined) {
    updated.description = String(updates.description);
  }

  // Update icon
  if (updates.icon !== undefined) {
    updated.icon = String(updates.icon);
  }

  // Update settings (merge with existing)
  if (updates.settings !== undefined) {
    if (typeof updates.settings !== 'object') {
      return { success: false, error: 'Settings must be an object' };
    }
    updated.settings = {
      ...existing.settings,
      ...updates.settings
    };
  }

  // Save updated preset
  data.presets[id] = updated;

  const saved = saveCustomPresets(data);
  if (!saved) {
    return { success: false, error: 'Failed to save preset' };
  }

  console.log(`[SPLICE] Updated custom preset: ${updated.name} (${id})`);
  return { success: true };
}

/**
 * Get a custom preset by ID
 * @param {string} id - Preset ID
 * @returns {Object|null} Preset object or null if not found
 */
function getCustomPreset(id) {
  if (!id || typeof id !== 'string') {
    return null;
  }

  const data = loadCustomPresets();
  return data.presets[id] || null;
}

/**
 * Duplicate a custom preset
 * @param {string} id - Preset ID to duplicate
 * @returns {{success: boolean, id?: string, error?: string}}
 */
function duplicatePreset(id) {
  // Validate input
  if (!id || typeof id !== 'string') {
    return { success: false, error: 'Preset ID is required' };
  }

  // Get the original preset
  const original = getPresetById(id);
  if (!original) {
    return { success: false, error: 'Preset not found' };
  }

  // Generate new name with copy suffix
  let copyName = `${original.name} (Copy)`;

  // Check if copy name already exists and increment if needed
  const data = loadCustomPresets();
  let copyNumber = 1;
  let testId = slugifyPresetName(copyName);
  while (data.presets[testId]) {
    copyNumber++;
    copyName = `${original.name} (Copy ${copyNumber})`;
    testId = slugifyPresetName(copyName);
  }

  // Create the duplicate
  return createCustomPreset({
    name: copyName,
    description: original.description || '',
    icon: original.icon || 'settings',
    settings: original.settings ? { ...original.settings } : getCurrentPresetSettings()
  });
}

/**
 * Export all custom presets to JSON string
 * @returns {{success: boolean, data?: string, count?: number, error?: string}}
 */
function exportPresets() {
  try {
    const data = loadCustomPresets();
    const customPresets = data.order.map(id => data.presets[id]).filter(Boolean);

    if (customPresets.length === 0) {
      return { success: false, error: 'No custom presets to export' };
    }

    const exportData = {
      version: 1,
      exportedAt: new Date().toISOString(),
      presets: customPresets
    };

    return {
      success: true,
      data: JSON.stringify(exportData, null, 2),
      count: customPresets.length
    };
  } catch (e) {
    return { success: false, error: 'Failed to export presets: ' + e.message };
  }
}

/**
 * Import presets from JSON string
 * @param {string} jsonString - JSON string containing presets
 * @param {boolean} merge - If true, merge with existing; if false, skip duplicates
 * @returns {{success: boolean, imported?: number, skipped?: number, error?: string}}
 */
function importPresets(jsonString, merge = true) {
  try {
    // Parse JSON
    const imported = JSON.parse(jsonString);

    // Validate structure
    if (!imported || !imported.presets || !Array.isArray(imported.presets)) {
      return { success: false, error: 'Invalid preset file format' };
    }

    let importedCount = 0;
    let skippedCount = 0;

    for (const preset of imported.presets) {
      // Validate each preset has required fields
      if (!preset.name || typeof preset.name !== 'string') {
        skippedCount++;
        continue;
      }

      // Check if a preset with this name already exists
      const existingId = slugifyPresetName(preset.name);
      const existing = getCustomPreset(existingId);

      if (existing && !merge) {
        // Skip existing if not merging
        skippedCount++;
        continue;
      }

      // If existing and merge mode, create with unique name
      if (existing && merge) {
        let newName = `${preset.name} (Imported)`;
        let counter = 1;
        while (getCustomPreset(slugifyPresetName(newName))) {
          counter++;
          newName = `${preset.name} (Imported ${counter})`;
        }
        preset.name = newName;
      }

      // Create the preset
      const result = createCustomPreset({
        name: preset.name,
        description: preset.description || '',
        icon: preset.icon || 'settings',
        settings: preset.settings || getCurrentPresetSettings()
      });

      if (result.success) {
        importedCount++;
      } else {
        skippedCount++;
      }
    }

    if (importedCount === 0 && skippedCount > 0) {
      return { success: false, error: 'All presets already exist or were invalid', skipped: skippedCount };
    }

    return {
      success: true,
      imported: importedCount,
      skipped: skippedCount
    };
  } catch (e) {
    if (e instanceof SyntaxError) {
      return { success: false, error: 'Invalid JSON format' };
    }
    return { success: false, error: 'Failed to import presets: ' + e.message };
  }
}

/**
 * Delete a custom preset
 * @param {string} id - Preset ID to delete
 * @returns {{success: boolean, error?: string}}
 */
function deleteCustomPreset(id) {
  // Validate input
  if (!id || typeof id !== 'string') {
    return { success: false, error: 'Preset ID is required' };
  }

  // Load current data
  const data = loadCustomPresets();

  // Check if preset exists
  if (!data.presets[id]) {
    return { success: false, error: 'Preset not found' };
  }

  const presetName = data.presets[id].name;

  // Remove from presets object
  delete data.presets[id];

  // Remove from order array
  const orderIndex = data.order.indexOf(id);
  if (orderIndex !== -1) {
    data.order.splice(orderIndex, 1);
  }

  // Save
  const saved = saveCustomPresets(data);
  if (!saved) {
    return { success: false, error: 'Failed to save after deletion' };
  }

  console.log(`[SPLICE] Deleted custom preset: ${presetName} (${id})`);
  return { success: true };
}

/**
 * List of built-in preset IDs (cannot be modified or deleted)
 */
const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];

/**
 * Check if a preset is a built-in preset
 * @param {string} id - Preset ID to check
 * @returns {boolean} True if built-in, false if custom
 */
function isBuiltInPreset(id) {
  return BUILT_IN_PRESET_IDS.includes(id);
}

/**
 * Get all presets (built-in + custom merged)
 * Built-in presets appear first, then custom presets in their creation order.
 * Each preset has isBuiltIn flag added.
 *
 * @returns {Array<Object>} Array of preset objects with metadata
 */
function getAllPresets() {
  // Get built-in presets
  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {
    const preset = PRESETS[id];
    return {
      id,
      name: preset.name,
      description: preset.description,
      icon: preset.icon,
      settings: preset.settings,
      isBuiltIn: true
    };
  });

  // Get custom presets
  const customData = loadCustomPresets();
  const customPresets = customData.order.map(id => {
    const preset = customData.presets[id];
    if (!preset) return null;
    return {
      ...preset,
      isBuiltIn: false
    };
  }).filter(Boolean);

  // Merge: built-in first, then custom
  return [...builtInPresets, ...customPresets];
}

/**
 * Get all preset IDs (built-in + custom)
 * @returns {Array<string>} Array of preset IDs
 */
function getAllPresetIds() {
  const customData = loadCustomPresets();
  return [...BUILT_IN_PRESET_IDS, ...customData.order];
}

/**
 * Get a preset by ID (built-in or custom)
 * @param {string} id - Preset ID
 * @returns {Object|null} Preset object or null if not found
 */
function getPresetById(id) {
  if (!id || typeof id !== 'string') {
    return null;
  }

  // Check built-in first
  if (isBuiltInPreset(id)) {
    const preset = PRESETS[id];
    return {
      id,
      name: preset.name,
      description: preset.description,
      icon: preset.icon,
      settings: preset.settings,
      isBuiltIn: true
    };
  }

  // Check custom presets
  const custom = getCustomPreset(id);
  if (custom) {
    return {
      ...custom,
      isBuiltIn: false
    };
  }

  return null;
}

const DEFAULT_SETTINGS = {
  sensitivity: 50,
  audioSource: 'original',
  autoMarkBest: true,
  enableTakesDetection: true,
  rememberOptions: false,
  optionsExpanded: false,
  customerId: null,          // Stripe customer ID for billing
  mediaFolderToken: null,    // Persistent token for media folder access
  mediaFolderPath: null,     // Path to the media folder (for display)
  activePreset: 'custom'     // Currently active preset
};

// =============================================================================
// PRESET PROFILES
// =============================================================================

/**
 * Detection presets for different content types.
 * Each preset defines optimal settings for a specific use case.
 */
const PRESETS = {
  // Custom - user-defined settings (default)
  custom: {
    name: 'Custom',
    description: 'Your custom settings',
    icon: 'settings',
    settings: null // Uses current user settings
  },

  // Podcast - longer pauses are natural, be conservative
  podcast: {
    name: 'Podcast',
    description: 'Longer natural pauses, conversational flow',
    icon: 'mic',
    settings: {
      sensitivity: 35,           // Lower sensitivity (fewer cuts)
      threshold: -35,            // Higher threshold (only deep silence)
      minSilenceLength: 0.8,     // Longer minimum silence
      paddingStart: 0.15,        // More padding for natural transitions
      paddingEnd: 0.15,
      mergeDistance: 0.3,        // Merge nearby silences
      autoMarkBest: false,       // Don't auto-mark (manual review)
      enableTakesDetection: true
    }
  },

  // Interview - balanced, respects speaker pauses
  interview: {
    name: 'Interview',
    description: 'Balanced cuts, preserves Q&A rhythm',
    icon: 'people',
    settings: {
      sensitivity: 50,           // Medium sensitivity
      threshold: -32,            // Moderate threshold
      minSilenceLength: 0.5,     // Standard minimum silence
      paddingStart: 0.12,        // Moderate padding
      paddingEnd: 0.08,
      mergeDistance: 0.2,
      autoMarkBest: true,
      enableTakesDetection: true
    }
  },

  // Reaction video - fast pacing, quick cuts
  reaction: {
    name: 'Reaction',
    description: 'Fast-paced, tight cuts for energy',
    icon: 'bolt',
    settings: {
      sensitivity: 70,           // Higher sensitivity (more cuts)
      threshold: -28,            // Lower threshold (catches more silence)
      minSilenceLength: 0.3,     // Short minimum silence
      paddingStart: 0.05,        // Minimal padding for snappy edits
      paddingEnd: 0.03,
      mergeDistance: 0.15,
      autoMarkBest: true,
      enableTakesDetection: false // Usually single-take content
    }
  },

  // Tutorial/Educational - preserve thinking pauses
  tutorial: {
    name: 'Tutorial',
    description: 'Preserves teaching pace, minimal cuts',
    icon: 'school',
    settings: {
      sensitivity: 30,           // Low sensitivity
      threshold: -38,            // Only deep silence
      minSilenceLength: 1.0,     // Long minimum (preserve demo pauses)
      paddingStart: 0.2,         // Extra padding for clarity
      paddingEnd: 0.15,
      mergeDistance: 0.4,
      autoMarkBest: false,
      enableTakesDetection: true
    }
  },

  // Vlog/YouTube - punchy edits, engagement-focused
  vlog: {
    name: 'Vlog',
    description: 'Punchy edits for YouTube engagement',
    icon: 'videocam',
    settings: {
      sensitivity: 65,           // Higher sensitivity
      threshold: -30,            // Moderate-low threshold
      minSilenceLength: 0.35,    // Short silences
      paddingStart: 0.08,        // Quick transitions
      paddingEnd: 0.05,
      mergeDistance: 0.2,
      autoMarkBest: true,
      enableTakesDetection: true
    }
  }
};

/**
 * Get all available presets
 * @returns {Object} All preset definitions
 */
function getPresets() {
  return { ...PRESETS };
}

/**
 * Get a specific preset by name
 * @param {string} presetName - Name of the preset
 * @returns {Object|null} Preset definition or null if not found
 */
function getPreset(presetName) {
  return PRESETS[presetName] || null;
}

/**
 * Get preset names as array (for UI)
 * @returns {Array<string>} Array of preset names
 */
function getPresetNames() {
  return Object.keys(PRESETS);
}

/**
 * Apply a preset to current settings
 * @param {string} presetName - Name of the preset to apply
 * @returns {Object} The applied settings
 */
function applyPreset(presetName) {
  const preset = PRESETS[presetName];

  if (!preset) {
    console.warn(`[SPLICE] Unknown preset: ${presetName}`);
    return getSettings();
  }

  // Custom preset uses current settings
  if (presetName === 'custom' || !preset.settings) {
    saveSettings({ activePreset: 'custom' });
    return getSettings();
  }

  // Apply preset settings
  const newSettings = {
    ...preset.settings,
    activePreset: presetName
  };

  saveSettings(newSettings);
  console.log(`[SPLICE] Applied preset: ${preset.name}`);

  return getSettings();
}

/**
 * Get the currently active preset
 * @returns {string} Active preset name
 */
function getActivePreset() {
  const settings = getSettings();
  return settings.activePreset || 'custom';
}

/**
 * Check if current settings match a preset
 * @param {string} presetName - Preset to compare against
 * @returns {boolean} True if settings match the preset
 */
function settingsMatchPreset(presetName) {
  const preset = PRESETS[presetName];
  if (!preset || !preset.settings) return presetName === 'custom';

  const current = getSettings();

  // Compare relevant settings
  return Object.keys(preset.settings).every(key => {
    if (key === 'activePreset') return true;
    return current[key] === preset.settings[key];
  });
}

let currentSettings = { ...DEFAULT_SETTINGS };

/**
 * Load settings from localStorage
 */
function loadSettings() {
  try {
    const saved = localStorage.getItem('spliceSettings');
    if (saved) {
      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
    }
  } catch (e) {
    console.warn('[SPLICE] Could not load settings:', e);
    currentSettings = { ...DEFAULT_SETTINGS };
  }
  return currentSettings;
}

/**
 * Save settings to localStorage
 */
function saveSettings(settings) {
  try {
    currentSettings = { ...currentSettings, ...settings };
    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
  } catch (e) {
    console.warn('[SPLICE] Could not save settings:', e);
  }
}

/**
 * Get current settings
 */
function getSettings() {
  return { ...currentSettings };
}

/**
 * Reset settings to defaults
 */
function resetSettings() {
  currentSettings = { ...DEFAULT_SETTINGS };
  try {
    localStorage.removeItem('spliceSettings');
  } catch (e) {
    console.warn('[SPLICE] Could not clear settings:', e);
  }
}

/**
 * Initialize settings UI components
 */
function initSettingsUI() {
  const settings = loadSettings();

  // Apply saved sensitivity to slider
  const sensitivitySlider = document.getElementById('sensitivitySlider');
  if (sensitivitySlider) {
    sensitivitySlider.value = settings.sensitivity;
  }

  // Apply saved audio source
  const sourceOriginal = document.getElementById('sourceOriginal');
  const sourceIsolated = document.getElementById('sourceIsolated');
  if (sourceOriginal && sourceIsolated) {
    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';
    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';
  }

  // Apply auto-mark best setting
  const autoMarkBest = document.getElementById('autoMarkBest');
  if (autoMarkBest) {
    autoMarkBest.checked = settings.autoMarkBest;
  }

  // Apply takes detection setting
  const enableTakesDetection = document.getElementById('enableTakesDetection');
  if (enableTakesDetection) {
    enableTakesDetection.checked = settings.enableTakesDetection;
  }

  // Apply remember options setting
  const rememberOptions = document.getElementById('rememberOptions');
  if (rememberOptions) {
    rememberOptions.checked = settings.rememberOptions;
  }

  // Restore expanded state if remember is enabled
  if (settings.rememberOptions && settings.optionsExpanded) {
    toggleOptionsPanel(true);
  }
}

/**
 * Toggle options panel visibility (unified panel)
 */
function toggleOptionsPanel(forceState) {
  const toggle = document.getElementById('optionsToggle');
  const panel = document.getElementById('optionsPanel');

  if (!toggle || !panel) return;

  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');

  if (shouldExpand) {
    panel.classList.remove('collapsed');
    toggle.classList.add('expanded');
  } else {
    panel.classList.add('collapsed');
    toggle.classList.remove('expanded');
  }

  // Save state if remember is enabled
  const settings = getSettings();
  if (settings.rememberOptions) {
    saveSettings({ optionsExpanded: shouldExpand });
  }
}

/**
 * Initialize settings modal
 */
function initSettingsModal() {
  const settingsBtn = document.getElementById('settingsBtn');
  const modal = document.getElementById('settingsModal');
  const closeBtn = document.getElementById('closeSettingsBtn');
  const defaultSensitivity = document.getElementById('defaultSensitivity');
  const rememberOptions = document.getElementById('rememberOptions');

  if (settingsBtn && modal) {
    settingsBtn.addEventListener('click', () => {
      modal.classList.remove('hidden');
      // Sync modal values with current settings
      const settings = getSettings();
      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;
      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;
    });
  }

  if (closeBtn && modal) {
    closeBtn.addEventListener('click', () => {
      modal.classList.add('hidden');
    });
  }

  // Close on backdrop click
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.add('hidden');
      }
    });
  }

  // Save default sensitivity when changed
  if (defaultSensitivity) {
    defaultSensitivity.addEventListener('change', () => {
      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });
      // Also update the main slider
      const mainSlider = document.getElementById('sensitivitySlider');
      if (mainSlider) mainSlider.value = defaultSensitivity.value;
    });
  }

  // Save remember options when changed
  if (rememberOptions) {
    rememberOptions.addEventListener('change', () => {
      saveSettings({ rememberOptions: rememberOptions.checked });
    });
  }
}

/**
 * Initialize options toggle (unified panel)
 */
function initOptionsToggles() {
  const toggle = document.getElementById('optionsToggle');

  if (toggle) {
    toggle.addEventListener('click', () => toggleOptionsPanel());
  }
}

/**
 * Initialize preset selector
 */
function initPresetSelector() {
  const presetSelector = document.getElementById('presetSelector');
  const sensitivitySlider = document.getElementById('sensitivitySlider');

  if (!presetSelector) return;

  // Set initial value from settings
  const settings = getSettings();
  presetSelector.value = settings.activePreset || 'custom';

  // Handle preset change (supports both built-in and custom presets)
  presetSelector.addEventListener('change', () => {
    const presetId = presetSelector.value;

    // Get preset info (works for both built-in and custom)
    const preset = getPresetById(presetId);
    if (!preset) {
      console.warn(`[SPLICE] Preset not found: ${presetId}`);
      return;
    }

    let appliedSettings;

    if (preset.isBuiltIn) {
      // Built-in preset: use the existing applyPreset function
      appliedSettings = applyPreset(presetId);
    } else {
      // Custom preset: apply stored settings
      appliedSettings = preset.settings || {};
      saveSettings({ activePreset: presetId, ...appliedSettings });
    }

    // Update sensitivity slider to match preset
    if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {
      sensitivitySlider.value = appliedSettings.sensitivity;
    }

    // Update takes detection checkbox
    const enableTakesDetection = document.getElementById('enableTakesDetection');
    if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {
      enableTakesDetection.checked = appliedSettings.enableTakesDetection;
    }

    // Update auto-mark best checkbox
    const autoMarkBest = document.getElementById('autoMarkBest');
    if (autoMarkBest && appliedSettings.autoMarkBest !== undefined) {
      autoMarkBest.checked = appliedSettings.autoMarkBest;
    }

    if (typeof setStatus === 'function') {
      const desc = preset.description ? ` - ${preset.description}` : '';
      setStatus(`Preset: ${preset.name}${desc}`);
    }
  });

  // Switch to custom when user manually changes sensitivity
  if (sensitivitySlider) {
    sensitivitySlider.addEventListener('change', () => {
      if (presetSelector.value !== 'custom') {
        presetSelector.value = 'custom';
        saveSettings({ activePreset: 'custom' });
      }
    });
  }
}

/**
 * Initialize help button
 */
function initHelpButton() {
  const helpBtn = document.getElementById('helpBtn');
  if (helpBtn) {
    helpBtn.addEventListener('click', () => {
      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');
    });
  }
}

// =============================================================================
// PERSISTENT TOKEN MANAGEMENT (v3.5)
// =============================================================================

/**
 * Media folder entry (cached after selection)
 * @type {Object|null}
 */
let mediaFolderEntry = null;

/**
 * Prompt user to select a media folder and create a persistent token.
 * This allows silent file access without repeated permission prompts.
 *
 * @returns {Promise<{success: boolean, path?: string, error?: string}>}
 */
async function setupMediaFolder() {
  try {
    // Open folder picker dialog
    const folder = await uxpFs.getFolder();

    if (!folder) {
      return { success: false, error: 'No folder selected' };
    }

    // Create a persistent token for this folder
    const token = await uxpFs.createPersistentToken(folder);

    if (!token) {
      return { success: false, error: 'Failed to create persistent token' };
    }

    // Get the folder path for display
    const folderPath = folder.nativePath || folder.name;

    // Save to settings
    saveSettings({
      mediaFolderToken: token,
      mediaFolderPath: folderPath
    });

    // Cache the folder entry
    mediaFolderEntry = folder;

    console.log(`[SPLICE] Media folder set: ${folderPath}`);

    return {
      success: true,
      path: folderPath,
      token
    };
  } catch (err) {
    console.error('[SPLICE] Error setting up media folder:', err);
    return { success: false, error: err.message };
  }
}

/**
 * Get the media folder entry using the stored persistent token.
 * Falls back to prompting if token is invalid.
 *
 * @returns {Promise<Object|null>} The folder entry or null
 */
async function getMediaFolder() {
  // Return cached entry if available
  if (mediaFolderEntry) {
    return mediaFolderEntry;
  }

  const settings = getSettings();

  // Try to restore from persistent token
  if (settings.mediaFolderToken) {
    try {
      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);
      if (folder) {
        mediaFolderEntry = folder;
        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);
        return folder;
      }
    } catch (err) {
      console.warn('[SPLICE] Could not restore media folder from token:', err.message);
      // Clear invalid token
      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });
    }
  }

  return null;
}

/**
 * Check if a media folder is configured
 * @returns {boolean}
 */
function hasMediaFolder() {
  const settings = getSettings();
  return !!settings.mediaFolderToken;
}

/**
 * Get the configured media folder path (for display)
 * @returns {string|null}
 */
function getMediaFolderPath() {
  const settings = getSettings();
  return settings.mediaFolderPath;
}

/**
 * Clear the media folder configuration
 */
function clearMediaFolder() {
  mediaFolderEntry = null;
  saveSettings({
    mediaFolderToken: null,
    mediaFolderPath: null
  });
  console.log('[SPLICE] Media folder cleared');
}

/**
 * Read a file from the media folder
 * @param {string} filename - Name of the file to read
 * @returns {Promise<ArrayBuffer|null>} File contents or null
 */
async function readMediaFile(filename) {
  const folder = await getMediaFolder();
  if (!folder) {
    console.warn('[SPLICE] No media folder configured');
    return null;
  }

  try {
    const file = await folder.getEntry(filename);
    if (!file) {
      console.warn(`[SPLICE] File not found in media folder: ${filename}`);
      return null;
    }

    const contents = await file.read({ format: uxpFs.formats.binary });
    return contents;
  } catch (err) {
    console.error(`[SPLICE] Error reading file ${filename}:`, err);
    return null;
  }
}

// =============================================================================
// LOGIN MODAL
// =============================================================================

/**
 * Validate license key format: SPLICE-XXXX-XXXX-XXXX
 * @param {string} key - License key to validate
 * @returns {boolean} True if format is valid
 */
function isValidLicenseKeyFormat(key) {
  if (!key || typeof key !== 'string') return false;
  const normalized = key.toUpperCase().trim();
  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;
  return pattern.test(normalized);
}

/**
 * Initialize login modal handlers
 */
function initLoginModal() {
  const loginModal = document.getElementById('loginModal');
  const closeLoginBtn = document.getElementById('closeLoginBtn');
  const saveLoginBtn = document.getElementById('saveLoginBtn');
  const licenseKeyInput = document.getElementById('licenseKeyInput');
  const loginError = document.getElementById('loginError');
  const creditBadge = document.getElementById('creditBadge');

  // Show login modal when clicking credit badge (always - allows viewing/changing license)
  if (creditBadge) {
    creditBadge.addEventListener('click', () => {
      showLoginModal();
    });
  }

  // Close login modal
  if (closeLoginBtn && loginModal) {
    closeLoginBtn.addEventListener('click', () => {
      loginModal.classList.add('hidden');
    });
  }

  // Close on backdrop click
  if (loginModal) {
    loginModal.addEventListener('click', (e) => {
      if (e.target === loginModal) {
        loginModal.classList.add('hidden');
      }
    });
  }

  // Activate license key
  if (saveLoginBtn) {
    saveLoginBtn.addEventListener('click', async () => {
      const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();

      if (!licenseKey) {
        showLoginError('Please enter your license key');
        return;
      }

      if (!isValidLicenseKeyFormat(licenseKey)) {
        showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');
        return;
      }

      // Show loading state
      saveLoginBtn.disabled = true;
      saveLoginBtn.textContent = 'Activating...';

      try {
        // Call license activation API
        const baseUrl = typeof API_BASE_URL !== 'undefined' ? API_BASE_URL : 'https://127.0.0.1:3847';
        const response = await fetch(`${baseUrl}/license/activate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: licenseKey })
        });

        const result = await response.json();

        if (!result.success) {
          showLoginError(result.error || 'Activation failed');
          return;
        }

        // Save customer ID from activation response
        saveSettings({ customerId: result.customerId });

        // Hide modal
        loginModal?.classList.add('hidden');

        // Refresh credits display
        if (typeof refreshCredits === 'function') {
          await refreshCredits();
        }

        if (typeof setStatus === 'function') {
          setStatus(`License activated! ${result.tierName} tier - ${result.hoursRemaining.toFixed(1)}h remaining`);
        }
      } catch (err) {
        console.error('[SPLICE] License activation error:', err);
        showLoginError('Connection error. Check server is running.');
      } finally {
        saveLoginBtn.disabled = false;
        saveLoginBtn.textContent = 'Activate';
      }
    });
  }

  // Clear input on modal open (don't show old value for security)
  // Customer ID is stored but license key is not displayed
}

/**
 * Show login modal
 */
function showLoginModal() {
  const loginModal = document.getElementById('loginModal');
  const loginError = document.getElementById('loginError');

  if (loginError) {
    loginError.style.display = 'none';
  }

  if (loginModal) {
    loginModal.classList.remove('hidden');
  }
}

/**
 * Show login error message
 */
function showLoginError(message) {
  const loginError = document.getElementById('loginError');
  if (loginError) {
    loginError.textContent = message;
    loginError.style.display = 'block';
  }
}

/**
 * Check if user is logged in
 * @returns {boolean}
 */
function isLoggedIn() {
  const settings = getSettings();
  return !!settings.customerId;
}

/**
 * Get customer ID
 * @returns {string|null}
 */
function getCustomerId() {
  const settings = getSettings();
  return settings.customerId || null;
}

/**
 * Logout - clear customer ID
 */
function logout() {
  saveSettings({ customerId: null });
  if (typeof setStatus === 'function') {
    setStatus('Logged out');
  }
}

// Load settings on script load
loadSettings();
