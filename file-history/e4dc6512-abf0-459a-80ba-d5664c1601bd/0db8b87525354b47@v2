/**
 * FaceIQ-Style Facial Analysis Scoring System
 * Complete replication of FaceIQ Labs scoring algorithms
 *
 * Features:
 * - Exponential decay scoring with per-metric decay rates
 * - Bezier curve custom scoring for non-linear measurements
 * - 70+ facial measurements (front + side profiles)
 * - Quality tiers: Ideal, Excellent, Good
 * - 5-tier severity: Extremely Severe, Severe, Major, Moderate, Minor
 */

import { LandmarkPoint } from './landmarks';

// ============================================
// CORE TYPES
// ============================================

export interface Point {
  x: number;
  y: number;
}

export type QualityTier = 'ideal' | 'excellent' | 'good' | 'below_average';
export type SeverityLevel = 'extremely_severe' | 'severe' | 'major' | 'moderate' | 'minor' | 'optimal';
export type MeasurementUnit = 'ratio' | 'percent' | 'degrees' | 'mm' | 'none';

export interface MetricConfig {
  id: string;
  name: string;
  category: string;
  unit: MeasurementUnit;
  idealMin: number;
  idealMax: number;
  rangeMin: number;
  rangeMax: number;
  decayRate: number;
  maxScore: number;
  weight: number;
  description: string;
  profileType: 'front' | 'side';
  customCurve?: BezierCurveConfig;
}

export interface BezierCurveConfig {
  mode: 'custom' | 'exponential';
  points: CurvePoint[];
}

export interface CurvePoint {
  x: number;
  y: number;
  leftHandleX?: number;
  leftHandleY?: number;
  rightHandleX?: number;
  rightHandleY?: number;
  fixed?: boolean;
}

export interface FaceIQScoreResult {
  metricId: string;
  name: string;
  value: number;
  score: number;  // 0-10 scale
  standardizedScore: number;
  qualityTier: QualityTier;
  severity: SeverityLevel;
  idealMin: number;
  idealMax: number;
  deviation: number;
  deviationDirection: 'above' | 'below' | 'within';
  unit: MeasurementUnit;
  category: string;
  percentile?: number;
}

export interface HarmonyAnalysis {
  overallScore: number;  // 0-10 scale
  standardizedScore: number;
  qualityTier: QualityTier;
  percentile: number;
  frontScore: number;
  sideScore: number;
  categoryScores: Record<string, number>;
  measurements: FaceIQScoreResult[];
  flaws: FlawAssessment[];
  strengths: StrengthAssessment[];
}

export interface FlawAssessment {
  category: string;
  metricId: string;
  metricName: string;
  severity: SeverityLevel;
  deviation: string;
  reasoning: string;
  confidence: 'confirmed' | 'likely' | 'possible';
}

export interface StrengthAssessment {
  category: string;
  metricId: string;
  metricName: string;
  qualityTier: QualityTier;
  value: number;
  reasoning: string;
}

// ============================================
// FACEIQ MEASUREMENT CONFIGURATIONS (70+)
// ============================================

export const FACEIQ_METRICS: Record<string, MetricConfig> = {
  // ==========================================
  // FRONT PROFILE - FACIAL PROPORTIONS (32)
  // ==========================================

  faceWidthToHeight: {
    id: 'faceWidthToHeight',
    name: 'Face Width to Height Ratio',
    category: 'Midface/Face Shape',
    unit: 'ratio',
    idealMin: 1.96,
    idealMax: 2.0,
    rangeMin: 1.5,
    rangeMax: 2.5,
    decayRate: 15.0,
    maxScore: 10,
    weight: 0.04,
    description: 'Ratio of bizygomatic width to upper face height',
    profileType: 'front',
  },

  lowerThirdProportion: {
    id: 'lowerThirdProportion',
    name: 'Lower Third Proportion',
    category: 'Midface/Face Shape',
    unit: 'percent',
    idealMin: 31,
    idealMax: 33.5,
    rangeMin: 24,
    rangeMax: 40,
    decayRate: 1.86,
    maxScore: 10,
    weight: 0.03,
    description: 'Percentage of face occupied by lower third (subnasale to menton)',
    profileType: 'front',
  },

  middleThirdProportion: {
    id: 'middleThirdProportion',
    name: 'Middle Third Proportion',
    category: 'Midface/Face Shape',
    unit: 'percent',
    idealMin: 31,
    idealMax: 34,
    rangeMin: 24,
    rangeMax: 42,
    decayRate: 1.5,
    maxScore: 10,
    weight: 0.03,
    description: 'Percentage of face occupied by middle third',
    profileType: 'front',
  },

  upperThirdProportion: {
    id: 'upperThirdProportion',
    name: 'Upper Third Proportion',
    category: 'Midface/Face Shape',
    unit: 'percent',
    idealMin: 31,
    idealMax: 35,
    rangeMin: 24,
    rangeMax: 42,
    decayRate: 1.2,
    maxScore: 10,
    weight: 0.02,
    description: 'Percentage of face occupied by upper third (trichion to glabella)',
    profileType: 'front',
  },

  bitemporalWidth: {
    id: 'bitemporalWidth',
    name: 'Bitemporal Width',
    category: 'Midface/Face Shape',
    unit: 'percent',
    idealMin: 86.5,
    idealMax: 92.5,
    rangeMin: 75,
    rangeMax: 100,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.02,
    description: 'Temple width as percentage of bizygomatic width',
    profileType: 'front',
  },

  cheekboneHeight: {
    id: 'cheekboneHeight',
    name: 'Cheekbone Height',
    category: 'Midface/Face Shape',
    unit: 'percent',
    idealMin: 83,
    idealMax: 100,
    rangeMin: 60,
    rangeMax: 110,
    decayRate: 0.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Vertical position of cheekbones relative to face height',
    profileType: 'front',
  },

  totalFacialWidthToHeight: {
    id: 'totalFacialWidthToHeight',
    name: 'Total Facial Width to Height Ratio',
    category: 'Midface/Face Shape',
    unit: 'ratio',
    idealMin: 1.34,
    idealMax: 1.37,
    rangeMin: 1.0,
    rangeMax: 1.7,
    decayRate: 13.2,
    maxScore: 25,  // Special: higher max score
    weight: 0.05,
    description: 'Total face height divided by cheek width',
    profileType: 'front',
    customCurve: {
      mode: 'custom',
      points: [
        { x: 1.05, y: 0 },
        { x: 1.17, y: 1.41 },
        { x: 1.25, y: 3.86 },
        { x: 1.29, y: 6.01 },
        { x: 1.32, y: 8.88 },
        { x: 1.34, y: 10, fixed: true },
        { x: 1.37, y: 10, fixed: true },
        { x: 1.39, y: 8.88 },
        { x: 1.42, y: 6.01 },
        { x: 1.46, y: 3.86 },
        { x: 1.54, y: 1.41 },
        { x: 1.66, y: 0 },
      ],
    },
  },

  midfaceRatio: {
    id: 'midfaceRatio',
    name: 'Midface Ratio',
    category: 'Midface/Face Shape',
    unit: 'ratio',
    idealMin: 0.97,
    idealMax: 1.0,
    rangeMin: 0.7,
    rangeMax: 1.3,
    decayRate: 31.6,
    maxScore: 10,
    weight: 0.04,
    description: 'Midface width to height ratio for facial balance',
    profileType: 'front',
  },

  // JAW MEASUREMENTS
  jawSlope: {
    id: 'jawSlope',
    name: 'Jaw Slope',
    category: 'Jaw Shape',
    unit: 'degrees',
    idealMin: 140,
    idealMax: 142.5,
    rangeMin: 120,
    rangeMax: 160,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.03,
    description: 'Angle of the jawline from gonion to chin',
    profileType: 'front',
  },

  jawFrontalAngle: {
    id: 'jawFrontalAngle',
    name: 'Jaw Frontal Angle',
    category: 'Jaw Shape',
    unit: 'degrees',
    idealMin: 86.5,
    idealMax: 92.5,
    rangeMin: 70,
    rangeMax: 110,
    decayRate: 0.6,
    maxScore: 10,
    weight: 0.03,
    description: 'Angle of jaw corners from frontal view',
    profileType: 'front',
  },

  bigonialWidth: {
    id: 'bigonialWidth',
    name: 'Bigonial Width',
    category: 'Jaw Shape',
    unit: 'percent',
    idealMin: 75,
    idealMax: 82,
    rangeMin: 60,
    rangeMax: 95,
    decayRate: 0.9,
    maxScore: 10,
    weight: 0.03,
    description: 'Jaw width as percentage of bizygomatic width',
    profileType: 'front',
  },

  jawWidthRatio: {
    id: 'jawWidthRatio',
    name: 'Jaw Width to Face Width Ratio',
    category: 'Jaw Shape',
    unit: 'ratio',
    idealMin: 0.75,
    idealMax: 0.82,
    rangeMin: 0.6,
    rangeMax: 0.95,
    decayRate: 25.0,
    maxScore: 10,
    weight: 0.03,
    description: 'Bigonial width divided by bizygomatic width',
    profileType: 'front',
  },

  // EYE MEASUREMENTS
  lateralCanthalTilt: {
    id: 'lateralCanthalTilt',
    name: 'Lateral Canthal Tilt',
    category: 'Eyes',
    unit: 'degrees',
    idealMin: 4,
    idealMax: 8,
    rangeMin: -5,
    rangeMax: 15,
    decayRate: 2.5,
    maxScore: 10,
    weight: 0.04,
    description: 'Angle of eye from inner to outer canthus',
    profileType: 'front',
  },

  eyeAspectRatio: {
    id: 'eyeAspectRatio',
    name: 'Eye Aspect Ratio',
    category: 'Eyes',
    unit: 'ratio',
    idealMin: 0.28,
    idealMax: 0.32,
    rangeMin: 0.2,
    rangeMax: 0.45,
    decayRate: 40.0,
    maxScore: 10,
    weight: 0.03,
    description: 'Eye height divided by eye width',
    profileType: 'front',
  },

  eyeSeparationRatio: {
    id: 'eyeSeparationRatio',
    name: 'Eye Separation Ratio',
    category: 'Eyes',
    unit: 'ratio',
    idealMin: 0.28,
    idealMax: 0.32,
    rangeMin: 0.22,
    rangeMax: 0.38,
    decayRate: 35.0,
    maxScore: 10,
    weight: 0.03,
    description: 'Intercanthal distance divided by bizygomatic width',
    profileType: 'front',
  },

  interpupillaryRatio: {
    id: 'interpupillaryRatio',
    name: 'Interpupillary Distance Ratio',
    category: 'Eyes',
    unit: 'percent',
    idealMin: 44,
    idealMax: 48,
    rangeMin: 38,
    rangeMax: 54,
    decayRate: 1.8,
    maxScore: 10,
    weight: 0.02,
    description: 'IPD as percentage of bizygomatic width',
    profileType: 'front',
  },

  interpupillaryMouthWidthRatio: {
    id: 'interpupillaryMouthWidthRatio',
    name: 'Interpupillary-Mouth Width Ratio',
    category: 'Eyes',
    unit: 'ratio',
    idealMin: 0.8,
    idealMax: 0.9,
    rangeMin: 0.6,
    rangeMax: 1.1,
    decayRate: 12.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Mouth width divided by interpupillary distance',
    profileType: 'front',
  },

  oneEyeApartTest: {
    id: 'oneEyeApartTest',
    name: 'One Eye Apart Test',
    category: 'Eyes',
    unit: 'ratio',
    idealMin: 0.95,
    idealMax: 1.05,
    rangeMin: 0.7,
    rangeMax: 1.3,
    decayRate: 20.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Intercanthal distance should equal one eye width',
    profileType: 'front',
  },

  // EYEBROW MEASUREMENTS
  browLengthRatio: {
    id: 'browLengthRatio',
    name: 'Brow Length to Face Width Ratio',
    category: 'Upper Third',
    unit: 'percent',
    idealMin: 28,
    idealMax: 32,
    rangeMin: 20,
    rangeMax: 40,
    decayRate: 1.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Eyebrow length as percentage of face width',
    profileType: 'front',
  },

  eyebrowTilt: {
    id: 'eyebrowTilt',
    name: 'Eyebrow Tilt',
    category: 'Upper Third',
    unit: 'degrees',
    idealMin: 8,
    idealMax: 15,
    rangeMin: 0,
    rangeMax: 25,
    decayRate: 1.2,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle of eyebrow from head to tail',
    profileType: 'front',
  },

  eyebrowLowSetedness: {
    id: 'eyebrowLowSetedness',
    name: 'Eyebrow Low Setedness',
    category: 'Upper Third',
    unit: 'ratio',
    idealMin: 0.18,
    idealMax: 0.24,
    rangeMin: 0.1,
    rangeMax: 0.35,
    decayRate: 30.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Distance from brow to eye relative to eye height',
    profileType: 'front',
  },

  // NOSE MEASUREMENTS (FRONT)
  nasalIndex: {
    id: 'nasalIndex',
    name: 'Nasal Index',
    category: 'Nose',
    unit: 'percent',
    idealMin: 70,
    idealMax: 85,
    rangeMin: 55,
    rangeMax: 100,
    decayRate: 0.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Nose width divided by nose height × 100',
    profileType: 'front',
  },

  intercanthalNasalRatio: {
    id: 'intercanthalNasalRatio',
    name: 'Intercanthal-Nasal Width Ratio',
    category: 'Nose',
    unit: 'ratio',
    idealMin: 1.0,
    idealMax: 1.2,
    rangeMin: 0.7,
    rangeMax: 1.5,
    decayRate: 12.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Alar width should roughly equal intercanthal distance',
    profileType: 'front',
  },

  noseBridgeWidth: {
    id: 'noseBridgeWidth',
    name: 'Nose Bridge to Nose Width',
    category: 'Nose',
    unit: 'ratio',
    idealMin: 0.6,
    idealMax: 0.75,
    rangeMin: 0.4,
    rangeMax: 0.9,
    decayRate: 15.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Ratio of nose bridge width to alar base width',
    profileType: 'front',
  },

  noseTipPosition: {
    id: 'noseTipPosition',
    name: 'Nose Tip Position',
    category: 'Nose',
    unit: 'ratio',
    idealMin: 0.48,
    idealMax: 0.52,
    rangeMin: 0.4,
    rangeMax: 0.6,
    decayRate: 25.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Nose tip position relative to face centerline',
    profileType: 'front',
  },

  // MOUTH/LIP MEASUREMENTS
  mouthWidthToNoseRatio: {
    id: 'mouthWidthToNoseRatio',
    name: 'Mouth Width to Nose Width Ratio',
    category: 'Lips',
    unit: 'ratio',
    idealMin: 1.44,
    idealMax: 1.52,
    rangeMin: 1.2,
    rangeMax: 1.8,
    decayRate: 18.0,
    maxScore: 10,
    weight: 0.03,
    description: 'Mouth width divided by nose width',
    profileType: 'front',
  },

  lowerToUpperLipRatio: {
    id: 'lowerToUpperLipRatio',
    name: 'Lower Lip to Upper Lip Ratio',
    category: 'Lips',
    unit: 'ratio',
    idealMin: 1.4,
    idealMax: 1.8,
    rangeMin: 1.0,
    rangeMax: 2.5,
    decayRate: 8.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Lower lip height divided by upper lip height',
    profileType: 'front',
  },

  cupidsBowDepth: {
    id: 'cupidsBowDepth',
    name: "Cupid's Bow Depth",
    category: 'Lips',
    unit: 'mm',
    idealMin: 2,
    idealMax: 4,
    rangeMin: 0,
    rangeMax: 7,
    decayRate: 2.0,
    maxScore: 10,
    weight: 0.01,
    description: "Depth of the cupid's bow curve",
    profileType: 'front',
  },

  mouthCornerPosition: {
    id: 'mouthCornerPosition',
    name: 'Mouth Corner Position',
    category: 'Lips',
    unit: 'ratio',
    idealMin: -0.02,
    idealMax: 0.02,
    rangeMin: -0.1,
    rangeMax: 0.1,
    decayRate: 50.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Mouth corner vertical position relative to lip center',
    profileType: 'front',
  },

  // CHIN MEASUREMENTS (FRONT)
  chinToPhiltrumRatio: {
    id: 'chinToPhiltrumRatio',
    name: 'Chin to Philtrum Ratio',
    category: 'Chin',
    unit: 'ratio',
    idealMin: 1.8,
    idealMax: 2.2,
    rangeMin: 1.3,
    rangeMax: 2.8,
    decayRate: 10.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Chin height divided by philtrum length',
    profileType: 'front',
  },

  // OTHER FRONT MEASUREMENTS
  iaaJfaDeviation: {
    id: 'iaaJfaDeviation',
    name: 'Deviation of IAA & JFA',
    category: 'Jaw Shape',
    unit: 'degrees',
    idealMin: -3,
    idealMax: 3,
    rangeMin: -15,
    rangeMax: 15,
    decayRate: 1.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Deviation between Ipsilateral Alar Angle and Jaw Frontal Angle',
    profileType: 'front',
  },

  neckWidth: {
    id: 'neckWidth',
    name: 'Neck Width',
    category: 'Neck',
    unit: 'percent',
    idealMin: 70,
    idealMax: 85,
    rangeMin: 55,
    rangeMax: 100,
    decayRate: 0.6,
    maxScore: 10,
    weight: 0.01,
    description: 'Neck width as percentage of jaw width',
    profileType: 'front',
  },

  // ==========================================
  // SIDE PROFILE MEASUREMENTS (38)
  // ==========================================

  gonialAngle: {
    id: 'gonialAngle',
    name: 'Gonial Angle',
    category: 'Occlusion/Jaw Growth',
    unit: 'degrees',
    idealMin: 120,
    idealMax: 130,
    rangeMin: 105,
    rangeMax: 145,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.04,
    description: 'Angle at the jaw corner (gonion)',
    profileType: 'side',
  },

  nasolabialAngle: {
    id: 'nasolabialAngle',
    name: 'Nasolabial Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 90,
    idealMax: 105,
    rangeMin: 75,
    rangeMax: 120,
    decayRate: 0.6,
    maxScore: 10,
    weight: 0.03,
    description: 'Angle between columella and upper lip',
    profileType: 'side',
  },

  nasofrontalAngle: {
    id: 'nasofrontalAngle',
    name: 'Nasofrontal Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 115,
    idealMax: 135,
    rangeMin: 100,
    rangeMax: 150,
    decayRate: 0.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle at the bridge of nose (nasion)',
    profileType: 'side',
  },

  nasofacialAngle: {
    id: 'nasofacialAngle',
    name: 'Nasofacial Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 30,
    idealMax: 40,
    rangeMin: 20,
    rangeMax: 50,
    decayRate: 1.2,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle between nose and face plane',
    profileType: 'side',
  },

  nasomentaAngle: {
    id: 'nasomentaAngle',
    name: 'Nasomental Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 120,
    idealMax: 132,
    rangeMin: 105,
    rangeMax: 145,
    decayRate: 0.7,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle from nasion to nose tip to chin',
    profileType: 'side',
  },

  nasalTipAngle: {
    id: 'nasalTipAngle',
    name: 'Nasal Tip Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 85,
    idealMax: 105,
    rangeMin: 70,
    rangeMax: 120,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle of the nose tip',
    profileType: 'side',
  },

  nasalProjection: {
    id: 'nasalProjection',
    name: 'Nasal Projection',
    category: 'Nose',
    unit: 'ratio',
    idealMin: 0.55,
    idealMax: 0.6,
    rangeMin: 0.4,
    rangeMax: 0.75,
    decayRate: 20.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Nose projection relative to nasal length (Goode ratio)',
    profileType: 'side',
  },

  nasalWToHRatio: {
    id: 'nasalWToHRatio',
    name: 'Nasal W to H Ratio',
    category: 'Nose',
    unit: 'ratio',
    idealMin: 0.67,
    idealMax: 0.78,
    rangeMin: 0.5,
    rangeMax: 0.95,
    decayRate: 15.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Nose width to height ratio from side view',
    profileType: 'side',
  },

  noseTipRotationAngle: {
    id: 'noseTipRotationAngle',
    name: 'Nose Tip Rotation Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 95,
    idealMax: 110,
    rangeMin: 80,
    rangeMax: 125,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.01,
    description: 'Angle of nose tip rotation',
    profileType: 'side',
  },

  frankfortTipAngle: {
    id: 'frankfortTipAngle',
    name: 'Frankfort-Tip Angle',
    category: 'Nose',
    unit: 'degrees',
    idealMin: 28,
    idealMax: 34,
    rangeMin: 20,
    rangeMax: 42,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Angle between Frankfort plane and nose tip',
    profileType: 'side',
  },

  mentolabialAngle: {
    id: 'mentolabialAngle',
    name: 'Mentolabial Angle',
    category: 'Lips',
    unit: 'degrees',
    idealMin: 120,
    idealMax: 140,
    rangeMin: 100,
    rangeMax: 160,
    decayRate: 0.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle at the labiomental fold',
    profileType: 'side',
  },

  zAngle: {
    id: 'zAngle',
    name: 'Z Angle',
    category: 'Occlusion/Jaw Growth',
    unit: 'degrees',
    idealMin: 75,
    idealMax: 85,
    rangeMin: 60,
    rangeMax: 100,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.02,
    description: 'Merrifield Z-Angle for profile assessment',
    profileType: 'side',
  },

  submentalCervicalAngle: {
    id: 'submentalCervicalAngle',
    name: 'Submental Cervical Angle',
    category: 'Neck',
    unit: 'degrees',
    idealMin: 105,
    idealMax: 120,
    rangeMin: 90,
    rangeMax: 140,
    decayRate: 0.6,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle between chin and neck',
    profileType: 'side',
  },

  facialConvexityGlabella: {
    id: 'facialConvexityGlabella',
    name: 'Facial Convexity (Glabella)',
    category: 'Midface/Face Shape',
    unit: 'degrees',
    idealMin: 165,
    idealMax: 175,
    rangeMin: 150,
    rangeMax: 185,
    decayRate: 0.4,
    maxScore: 10,
    weight: 0.03,
    description: 'Facial convexity angle using glabella',
    profileType: 'side',
  },

  facialConvexityNasion: {
    id: 'facialConvexityNasion',
    name: 'Facial Convexity (Nasion)',
    category: 'Midface/Face Shape',
    unit: 'degrees',
    idealMin: 168,
    idealMax: 178,
    rangeMin: 155,
    rangeMax: 190,
    decayRate: 0.4,
    maxScore: 10,
    weight: 0.02,
    description: 'Facial convexity angle using nasion',
    profileType: 'side',
  },

  totalFacialConvexity: {
    id: 'totalFacialConvexity',
    name: 'Total Facial Convexity',
    category: 'Midface/Face Shape',
    unit: 'degrees',
    idealMin: 135,
    idealMax: 145,
    rangeMin: 120,
    rangeMax: 160,
    decayRate: 0.5,
    maxScore: 10,
    weight: 0.03,
    description: 'Complete facial profile convexity measurement',
    profileType: 'side',
  },

  facialDepthToHeight: {
    id: 'facialDepthToHeight',
    name: 'Facial Depth to Height Ratio',
    category: 'Midface/Face Shape',
    unit: 'ratio',
    idealMin: 0.85,
    idealMax: 0.95,
    rangeMin: 0.7,
    rangeMax: 1.1,
    decayRate: 15.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Facial depth divided by facial height',
    profileType: 'side',
  },

  anteriorFacialDepth: {
    id: 'anteriorFacialDepth',
    name: 'Anterior Facial Depth',
    category: 'Midface/Face Shape',
    unit: 'mm',
    idealMin: 85,
    idealMax: 100,
    rangeMin: 70,
    rangeMax: 115,
    decayRate: 0.3,
    maxScore: 10,
    weight: 0.01,
    description: 'Depth of the anterior face',
    profileType: 'side',
  },

  mandibularPlaneAngle: {
    id: 'mandibularPlaneAngle',
    name: 'Mandibular Plane Angle',
    category: 'Occlusion/Jaw Growth',
    unit: 'degrees',
    idealMin: 22,
    idealMax: 28,
    rangeMin: 15,
    rangeMax: 38,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.03,
    description: 'Angle of mandibular plane to Frankfort plane',
    profileType: 'side',
  },

  ramusToMandibleRatio: {
    id: 'ramusToMandibleRatio',
    name: 'Ramus to Mandible Ratio',
    category: 'Occlusion/Jaw Growth',
    unit: 'ratio',
    idealMin: 0.65,
    idealMax: 0.75,
    rangeMin: 0.5,
    rangeMax: 0.9,
    decayRate: 15.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Ramus height divided by mandible length',
    profileType: 'side',
  },

  gonionToMouthLine: {
    id: 'gonionToMouthLine',
    name: 'Gonion to Mouth Line',
    category: 'Jaw Shape',
    unit: 'mm',
    idealMin: -5,
    idealMax: 5,
    rangeMin: -20,
    rangeMax: 20,
    decayRate: 0.5,
    maxScore: 10,
    weight: 0.02,
    description: 'Distance from gonion to mouth level line',
    profileType: 'side',
  },

  // E-LINE MEASUREMENTS
  eLineUpperLip: {
    id: 'eLineUpperLip',
    name: 'Upper Lip E-Line Position',
    category: 'Lips',
    unit: 'mm',
    idealMin: -4,
    idealMax: -2,
    rangeMin: -10,
    rangeMax: 4,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Upper lip distance from E-line (Ricketts)',
    profileType: 'side',
  },

  eLineLowerLip: {
    id: 'eLineLowerLip',
    name: 'Lower Lip E-Line Position',
    category: 'Lips',
    unit: 'mm',
    idealMin: -2,
    idealMax: 0,
    rangeMin: -8,
    rangeMax: 6,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Lower lip distance from E-line (Ricketts)',
    profileType: 'side',
  },

  // S-LINE MEASUREMENTS
  sLineUpperLip: {
    id: 'sLineUpperLip',
    name: 'Upper Lip S-Line Position',
    category: 'Lips',
    unit: 'mm',
    idealMin: 0,
    idealMax: 3,
    rangeMin: -5,
    rangeMax: 8,
    decayRate: 1.2,
    maxScore: 10,
    weight: 0.01,
    description: 'Upper lip distance from S-line (Steiner)',
    profileType: 'side',
  },

  sLineLowerLip: {
    id: 'sLineLowerLip',
    name: 'Lower Lip S-Line Position',
    category: 'Lips',
    unit: 'mm',
    idealMin: 0,
    idealMax: 2,
    rangeMin: -4,
    rangeMax: 6,
    decayRate: 1.2,
    maxScore: 10,
    weight: 0.01,
    description: 'Lower lip distance from S-line (Steiner)',
    profileType: 'side',
  },

  // BURSTONE LINE
  burstoneUpperLip: {
    id: 'burstoneUpperLip',
    name: 'Upper Lip Burstone Line',
    category: 'Lips',
    unit: 'mm',
    idealMin: 2,
    idealMax: 4,
    rangeMin: -2,
    rangeMax: 8,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Upper lip to Burstone line distance',
    profileType: 'side',
  },

  burstoneLowerLip: {
    id: 'burstoneLowerLip',
    name: 'Lower Lip Burstone Line',
    category: 'Lips',
    unit: 'mm',
    idealMin: 1,
    idealMax: 3,
    rangeMin: -3,
    rangeMax: 7,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Lower lip to Burstone line distance',
    profileType: 'side',
  },

  // H LINE
  holdawayHLine: {
    id: 'holdawayHLine',
    name: 'Holdaway H Line',
    category: 'Lips',
    unit: 'mm',
    idealMin: 0,
    idealMax: 4,
    rangeMin: -5,
    rangeMax: 10,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.01,
    description: 'Holdaway H-line soft tissue assessment',
    profileType: 'side',
  },

  // CHIN MEASUREMENTS (SIDE)
  chinProjection: {
    id: 'chinProjection',
    name: 'Chin Projection',
    category: 'Chin',
    unit: 'mm',
    idealMin: -3,
    idealMax: 3,
    rangeMin: -12,
    rangeMax: 12,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.02,
    description: 'Chin projection relative to ideal position',
    profileType: 'side',
  },

  recessionRelativeToFrankfort: {
    id: 'recessionRelativeToFrankfort',
    name: 'Recession Relative to Frankfort Plane',
    category: 'Chin',
    unit: 'mm',
    idealMin: -2,
    idealMax: 2,
    rangeMin: -10,
    rangeMax: 10,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.02,
    description: 'Chin recession relative to Frankfort horizontal',
    profileType: 'side',
  },

  // FOREHEAD
  browridgeInclinationAngle: {
    id: 'browridgeInclinationAngle',
    name: 'Browridge Inclination Angle',
    category: 'Upper Third',
    unit: 'degrees',
    idealMin: 10,
    idealMax: 18,
    rangeMin: 0,
    rangeMax: 28,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle of the brow ridge from profile',
    profileType: 'side',
  },

  upperForeheadSlope: {
    id: 'upperForeheadSlope',
    name: 'Upper Forehead Slope',
    category: 'Upper Third',
    unit: 'degrees',
    idealMin: 5,
    idealMax: 12,
    rangeMin: 0,
    rangeMax: 20,
    decayRate: 1.2,
    maxScore: 10,
    weight: 0.01,
    description: 'Slope angle of the upper forehead',
    profileType: 'side',
  },

  // MIDFACE PROJECTION
  midfaceProjectionAngle: {
    id: 'midfaceProjectionAngle',
    name: 'Interior Midface Projection Angle',
    category: 'Midface/Face Shape',
    unit: 'degrees',
    idealMin: 85,
    idealMax: 95,
    rangeMin: 75,
    rangeMax: 105,
    decayRate: 0.8,
    maxScore: 10,
    weight: 0.02,
    description: 'Angle of midface projection from profile',
    profileType: 'side',
  },

  orbitalVector: {
    id: 'orbitalVector',
    name: 'Orbital Vector',
    category: 'Eyes',
    unit: 'mm',
    idealMin: 0,
    idealMax: 4,
    rangeMin: -6,
    rangeMax: 10,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.02,
    description: 'Relationship of globe to orbital rim',
    profileType: 'side',
  },

  // EAR MEASUREMENTS
  earProtrusionAngle: {
    id: 'earProtrusionAngle',
    name: 'Ear Protrusion Angle',
    category: 'Other',
    unit: 'degrees',
    idealMin: 15,
    idealMax: 25,
    rangeMin: 5,
    rangeMax: 40,
    decayRate: 1.0,
    maxScore: 10,
    weight: 0.01,
    description: 'Angle of ear protrusion from head',
    profileType: 'front',
  },

  earProtrusionRatio: {
    id: 'earProtrusionRatio',
    name: 'Ear Protrusion Ratio',
    category: 'Other',
    unit: 'percent',
    idealMin: 15,
    idealMax: 25,
    rangeMin: 8,
    rangeMax: 40,
    decayRate: 1.5,
    maxScore: 10,
    weight: 0.01,
    description: 'Ear protrusion as percentage of ear height',
    profileType: 'front',
  },
};

// ============================================
// CATEGORY DEFINITIONS
// ============================================

export const MEASUREMENT_CATEGORIES = {
  'Midface/Face Shape': { color: '#67e8f9', weight: 0.20 },
  'Occlusion/Jaw Growth': { color: '#a78bfa', weight: 0.15 },
  'Jaw Shape': { color: '#f97316', weight: 0.13 },
  'Upper Third': { color: '#84cc16', weight: 0.08 },
  'Eyes': { color: '#06b6d4', weight: 0.12 },
  'Nose': { color: '#fbbf24', weight: 0.10 },
  'Lips': { color: '#ec4899', weight: 0.10 },
  'Chin': { color: '#ef4444', weight: 0.06 },
  'Neck': { color: '#14b8a6', weight: 0.03 },
  'Other': { color: '#6b7280', weight: 0.03 },
};

// ============================================
// CORE SCORING FUNCTIONS
// ============================================

/**
 * FaceIQ Exponential Decay Scoring Algorithm
 * score = maxScore × e^(-decayRate × deviation)
 */
export function calculateFaceIQScore(
  value: number,
  config: MetricConfig
): number {
  const { idealMin, idealMax, decayRate, maxScore, customCurve } = config;

  // Use custom curve if available
  if (customCurve && customCurve.mode === 'custom') {
    return interpolateCustomCurve(value, customCurve.points, maxScore);
  }

  // Perfect score within ideal range
  if (value >= idealMin && value <= idealMax) {
    return maxScore;
  }

  // Calculate deviation from ideal range
  const deviation = value < idealMin
    ? idealMin - value
    : value - idealMax;

  // Exponential decay
  const score = maxScore * Math.exp(-decayRate * deviation);

  return Math.max(0, Math.min(maxScore, score));
}

/**
 * Interpolate custom Bezier curve for scoring
 * Uses cubic Bezier interpolation with control handles for smooth curves
 */
function interpolateCustomCurve(
  value: number,
  points: CurvePoint[],
  maxScore: number
): number {
  if (points.length === 0) return 0;

  // Sort points by x value
  const sortedPoints = [...points].sort((a, b) => a.x - b.x);

  // Clamp to range
  if (value <= sortedPoints[0].x) return sortedPoints[0].y;
  if (value >= sortedPoints[sortedPoints.length - 1].x) {
    return sortedPoints[sortedPoints.length - 1].y;
  }

  // Find bracketing points
  let lowerIndex = 0;
  for (let i = 0; i < sortedPoints.length - 1; i++) {
    if (value >= sortedPoints[i].x && value <= sortedPoints[i + 1].x) {
      lowerIndex = i;
      break;
    }
  }

  const p0 = sortedPoints[lowerIndex];
  const p3 = sortedPoints[lowerIndex + 1];

  // Check if we have Bezier control handles
  const hasHandles = p0.rightHandleX !== undefined && p3.leftHandleX !== undefined;

  if (hasHandles) {
    // Cubic Bezier interpolation with control points
    const p1x = p0.rightHandleX!;
    const p1y = p0.rightHandleY ?? p0.y;
    const p2x = p3.leftHandleX!;
    const p2y = p3.leftHandleY ?? p3.y;

    // Find t parameter for given x value using Newton-Raphson iteration
    let t = (value - p0.x) / (p3.x - p0.x); // Initial guess

    // Newton-Raphson iterations to find t where B_x(t) = value
    for (let iter = 0; iter < 10; iter++) {
      const bx = cubicBezier(p0.x, p1x, p2x, p3.x, t);
      const bxDerivative = cubicBezierDerivative(p0.x, p1x, p2x, p3.x, t);

      if (Math.abs(bxDerivative) < 1e-10) break;

      const newT = t - (bx - value) / bxDerivative;
      if (Math.abs(newT - t) < 1e-10) break;
      t = Math.max(0, Math.min(1, newT));
    }

    // Calculate y using the found t parameter
    return cubicBezier(p0.y, p1y, p2y, p3.y, t);
  } else {
    // Smooth interpolation using Catmull-Rom spline
    // This provides smoother curves than linear interpolation
    const t = (value - p0.x) / (p3.x - p0.x);

    // Get neighboring points for spline calculation
    const pMinus1 = lowerIndex > 0 ? sortedPoints[lowerIndex - 1] : p0;
    const p4 = lowerIndex + 2 < sortedPoints.length ? sortedPoints[lowerIndex + 2] : p3;

    // Catmull-Rom spline interpolation
    return catmullRomSpline(pMinus1.y, p0.y, p3.y, p4.y, t);
  }
}

/**
 * Cubic Bezier curve evaluation: B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
 */
function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number): number {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
}

/**
 * Cubic Bezier derivative: B'(t) = 3(1-t)²(P1-P0) + 6(1-t)t(P2-P1) + 3t²(P3-P2)
 */
function cubicBezierDerivative(p0: number, p1: number, p2: number, p3: number, t: number): number {
  const mt = 1 - t;
  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
}

/**
 * Catmull-Rom spline interpolation for smooth curves without explicit handles
 */
function catmullRomSpline(p0: number, p1: number, p2: number, p3: number, t: number): number {
  const t2 = t * t;
  const t3 = t2 * t;

  // Catmull-Rom coefficients with tension = 0.5
  const a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
  const b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;
  const c = -0.5 * p0 + 0.5 * p2;
  const d = p1;

  return a * t3 + b * t2 + c * t + d;
}

/**
 * Calculate standardized score (0-10 normalized)
 */
export function standardizeScore(score: number, maxScore: number): number {
  return (score / maxScore) * 10;
}

/**
 * Determine quality tier based on score
 */
export function getQualityTier(score: number, maxScore: number = 10): QualityTier {
  const normalized = (score / maxScore) * 100;

  if (normalized >= 90) return 'ideal';
  if (normalized >= 70) return 'excellent';
  if (normalized >= 50) return 'good';
  return 'below_average';
}

/**
 * Determine severity level based on score
 */
export function getSeverityLevel(score: number, maxScore: number = 10): SeverityLevel {
  const normalized = (score / maxScore) * 100;

  if (normalized >= 85) return 'optimal';
  if (normalized >= 70) return 'minor';
  if (normalized >= 50) return 'moderate';
  if (normalized >= 30) return 'major';
  if (normalized >= 15) return 'severe';
  return 'extremely_severe';
}

/**
 * Calculate deviation description
 */
export function getDeviationDescription(
  value: number,
  idealMin: number,
  idealMax: number,
  unit: MeasurementUnit
): { deviation: number; direction: 'above' | 'below' | 'within'; description: string } {
  if (value >= idealMin && value <= idealMax) {
    return { deviation: 0, direction: 'within', description: 'within ideal range' };
  }

  const unitLabel = getUnitLabel(unit);

  if (value < idealMin) {
    const dev = idealMin - value;
    return {
      deviation: dev,
      direction: 'below',
      description: `${dev.toFixed(2)}${unitLabel} below ideal`,
    };
  }

  const dev = value - idealMax;
  return {
    deviation: dev,
    direction: 'above',
    description: `${dev.toFixed(2)}${unitLabel} above ideal`,
  };
}

function getUnitLabel(unit: MeasurementUnit): string {
  switch (unit) {
    case 'ratio': return 'x';
    case 'percent': return '%';
    case 'degrees': return '°';
    case 'mm': return 'mm';
    default: return '';
  }
}

// ============================================
// MEASUREMENT CALCULATION UTILITIES
// ============================================

/**
 * Calculate distance between two points
 */
export function distance(p1: Point, p2: Point): number {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

/**
 * Calculate angle at vertex point (in degrees)
 */
export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {
  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };

  const dot = v1.x * v2.x + v1.y * v2.y;
  const cross = v1.x * v2.y - v1.y * v2.x;

  const angle = Math.atan2(cross, dot) * (180 / Math.PI);
  return Math.abs(angle);
}

/**
 * Calculate perpendicular distance from point to line (signed)
 */
export function perpendicularDistance(
  point: Point,
  lineStart: Point,
  lineEnd: Point
): number {
  const A = point.x - lineStart.x;
  const B = point.y - lineStart.y;
  const C = lineEnd.x - lineStart.x;
  const D = lineEnd.y - lineStart.y;

  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  const param = lenSq !== 0 ? dot / lenSq : -1;

  let xx: number, yy: number;

  if (param < 0) {
    xx = lineStart.x;
    yy = lineStart.y;
  } else if (param > 1) {
    xx = lineEnd.x;
    yy = lineEnd.y;
  } else {
    xx = lineStart.x + param * C;
    yy = lineStart.y + param * D;
  }

  const dx = point.x - xx;
  const dy = point.y - yy;

  const sign =
    (lineEnd.y - lineStart.y) * point.x -
      (lineEnd.x - lineStart.x) * point.y +
      lineEnd.x * lineStart.y -
      lineEnd.y * lineStart.x >=
    0
      ? 1
      : -1;

  return sign * Math.sqrt(dx * dx + dy * dy);
}

/**
 * Helper to get landmark by ID
 */
function getLandmark(landmarks: LandmarkPoint[], id: string): Point | null {
  const lm = landmarks.find((l) => l.id === id);
  return lm ? { x: lm.x, y: lm.y } : null;
}

// ============================================
// SCORE A SINGLE MEASUREMENT
// ============================================

/**
 * Calculate complete score result for a measurement
 */
export function scoreMeasurement(
  metricId: string,
  value: number
): FaceIQScoreResult | null {
  const config = FACEIQ_METRICS[metricId];
  if (!config) return null;

  const score = calculateFaceIQScore(value, config);
  const standardizedScore = standardizeScore(score, config.maxScore);
  const qualityTier = getQualityTier(score, config.maxScore);
  const severity = getSeverityLevel(score, config.maxScore);
  const { deviation, direction, description } = getDeviationDescription(
    value,
    config.idealMin,
    config.idealMax,
    config.unit
  );

  return {
    metricId,
    name: config.name,
    value,
    score,
    standardizedScore,
    qualityTier,
    severity,
    idealMin: config.idealMin,
    idealMax: config.idealMax,
    deviation,
    deviationDirection: direction,
    unit: config.unit,
    category: config.category,
  };
}

// ============================================
// FRONT PROFILE ANALYSIS
// ============================================

export interface FrontProfileResults {
  measurements: FaceIQScoreResult[];
  overallScore: number;
  standardizedScore: number;
  qualityTier: QualityTier;
  categoryScores: Record<string, number>;
}

/**
 * Calculate all front profile measurements from landmarks
 */
export function analyzeFrontProfile(
  landmarks: LandmarkPoint[],
  gender: 'male' | 'female' = 'male'
): FrontProfileResults {
  const measurements: FaceIQScoreResult[] = [];

  // Helper to add measurement if landmarks available
  const addMeasurement = (metricId: string, value: number | null) => {
    if (value !== null) {
      const result = scoreMeasurement(metricId, value);
      if (result) measurements.push(result);
    }
  };

  // Get key landmarks
  const trichion = getLandmark(landmarks, 'trichion');
  const nasalBase = getLandmark(landmarks, 'nasal_base');
  const subnasale = getLandmark(landmarks, 'subnasale');
  const menton = getLandmark(landmarks, 'menton');
  const leftZygion = getLandmark(landmarks, 'left_zygion');
  const rightZygion = getLandmark(landmarks, 'right_zygion');
  const leftGonion = getLandmark(landmarks, 'left_gonion_inferior');
  const rightGonion = getLandmark(landmarks, 'right_gonion_inferior');
  const leftPupil = getLandmark(landmarks, 'left_pupila');
  const rightPupil = getLandmark(landmarks, 'right_pupila');
  const leftCanthusM = getLandmark(landmarks, 'left_canthus_medialis');
  const leftCanthusL = getLandmark(landmarks, 'left_canthus_lateralis');
  const rightCanthusM = getLandmark(landmarks, 'right_canthus_medialis');
  const rightCanthusL = getLandmark(landmarks, 'right_canthus_lateralis');
  const leftAlaNasi = getLandmark(landmarks, 'left_ala_nasi');
  const rightAlaNasi = getLandmark(landmarks, 'right_ala_nasi');
  const leftCheilion = getLandmark(landmarks, 'left_cheilion');
  const rightCheilion = getLandmark(landmarks, 'right_cheilion');
  const labraleSuperius = getLandmark(landmarks, 'labrale_superius');
  const labraleInferius = getLandmark(landmarks, 'labrale_inferius');

  // FACIAL THIRDS
  if (trichion && nasalBase && subnasale && menton) {
    const totalHeight = distance(trichion, menton);
    if (totalHeight > 0) {
      const upperThird = (distance(trichion, nasalBase) / totalHeight) * 100;
      const middleThird = (distance(nasalBase, subnasale) / totalHeight) * 100;
      const lowerThird = (distance(subnasale, menton) / totalHeight) * 100;

      addMeasurement('upperThirdProportion', upperThird);
      addMeasurement('middleThirdProportion', middleThird);
      addMeasurement('lowerThirdProportion', lowerThird);
    }
  }

  // FACE WIDTH TO HEIGHT RATIO (FWHR)
  if (leftZygion && rightZygion && nasalBase && labraleSuperius) {
    const bizygomaticWidth = distance(leftZygion, rightZygion);
    const upperFaceHeight = distance(nasalBase, labraleSuperius);
    if (upperFaceHeight > 0) {
      addMeasurement('faceWidthToHeight', bizygomaticWidth / upperFaceHeight);
    }
  }

  // TOTAL FACIAL WIDTH TO HEIGHT
  if (leftZygion && rightZygion && trichion && menton) {
    const cheekWidth = distance(leftZygion, rightZygion);
    const totalHeight = distance(trichion, menton);
    if (cheekWidth > 0) {
      addMeasurement('totalFacialWidthToHeight', totalHeight / cheekWidth);
    }
  }

  // JAW WIDTH RATIO
  if (leftGonion && rightGonion && leftZygion && rightZygion) {
    const bigonialWidth = distance(leftGonion, rightGonion);
    const bizygomaticWidth = distance(leftZygion, rightZygion);
    if (bizygomaticWidth > 0) {
      const ratio = bigonialWidth / bizygomaticWidth;
      addMeasurement('jawWidthRatio', ratio);
      addMeasurement('bigonialWidth', ratio * 100);
    }
  }

  // CANTHAL TILT
  if (leftCanthusM && leftCanthusL) {
    const deltaY = leftCanthusM.y - leftCanthusL.y;
    const deltaX = leftCanthusL.x - leftCanthusM.x;
    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
    addMeasurement('lateralCanthalTilt', angle);
  }

  // EYE ASPECT RATIO
  if (leftCanthusM && leftCanthusL) {
    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');
    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');
    if (leftPalpSup && leftPalpInf) {
      const eyeWidth = distance(leftCanthusM, leftCanthusL);
      const eyeHeight = distance(leftPalpSup, leftPalpInf);
      if (eyeWidth > 0) {
        addMeasurement('eyeAspectRatio', eyeHeight / eyeWidth);
      }
    }
  }

  // EYE SEPARATION RATIO
  if (leftCanthusM && rightCanthusM && leftZygion && rightZygion) {
    const intercanthal = distance(leftCanthusM, rightCanthusM);
    const bizygomatic = distance(leftZygion, rightZygion);
    if (bizygomatic > 0) {
      addMeasurement('eyeSeparationRatio', intercanthal / bizygomatic);
    }
  }

  // IPD RATIO
  if (leftPupil && rightPupil && leftZygion && rightZygion) {
    const ipd = distance(leftPupil, rightPupil);
    const bizygomatic = distance(leftZygion, rightZygion);
    if (bizygomatic > 0) {
      addMeasurement('interpupillaryRatio', (ipd / bizygomatic) * 100);
    }
  }

  // ONE EYE APART TEST
  if (leftCanthusM && rightCanthusM && leftCanthusL) {
    const intercanthal = distance(leftCanthusM, rightCanthusM);
    const eyeWidth = distance(leftCanthusM, leftCanthusL);
    if (eyeWidth > 0) {
      addMeasurement('oneEyeApartTest', intercanthal / eyeWidth);
    }
  }

  // NASAL INDEX
  if (leftAlaNasi && rightAlaNasi && nasalBase && subnasale) {
    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
    const nasalHeight = distance(nasalBase, subnasale);
    if (nasalHeight > 0) {
      addMeasurement('nasalIndex', (nasalWidth / nasalHeight) * 100);
    }
  }

  // INTERCANTHAL-NASAL WIDTH RATIO
  if (leftCanthusM && rightCanthusM && leftAlaNasi && rightAlaNasi) {
    const intercanthal = distance(leftCanthusM, rightCanthusM);
    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
    if (nasalWidth > 0) {
      addMeasurement('intercanthalNasalRatio', intercanthal / nasalWidth);
    }
  }

  // MOUTH TO NOSE RATIO
  if (leftCheilion && rightCheilion && leftAlaNasi && rightAlaNasi) {
    const mouthWidth = distance(leftCheilion, rightCheilion);
    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
    if (nasalWidth > 0) {
      addMeasurement('mouthWidthToNoseRatio', mouthWidth / nasalWidth);
    }
  }

  // IPD TO MOUTH WIDTH RATIO
  if (leftPupil && rightPupil && leftCheilion && rightCheilion) {
    const ipd = distance(leftPupil, rightPupil);
    const mouthWidth = distance(leftCheilion, rightCheilion);
    if (ipd > 0) {
      addMeasurement('interpupillaryMouthWidthRatio', mouthWidth / ipd);
    }
  }

  // LIP RATIO
  if (labraleSuperius && labraleInferius && subnasale) {
    const mouthMiddle = getLandmark(landmarks, 'mouth_middle');
    if (mouthMiddle) {
      const upperLipHeight = distance(subnasale, labraleSuperius);
      const lowerLipHeight = distance(mouthMiddle, labraleInferius);
      if (upperLipHeight > 0) {
        addMeasurement('lowerToUpperLipRatio', lowerLipHeight / upperLipHeight);
      }
    }
  }

  // MIDFACE RATIO
  if (leftZygion && rightZygion && nasalBase && subnasale) {
    const midfaceWidth = distance(leftZygion, rightZygion);
    const midfaceHeight = distance(nasalBase, subnasale);
    if (midfaceHeight > 0) {
      addMeasurement('midfaceRatio', midfaceWidth / midfaceHeight / 10); // Normalized
    }
  }

  // Calculate category scores
  const categoryScores: Record<string, { total: number; count: number }> = {};
  for (const m of measurements) {
    if (!categoryScores[m.category]) {
      categoryScores[m.category] = { total: 0, count: 0 };
    }
    categoryScores[m.category].total += m.standardizedScore;
    categoryScores[m.category].count++;
  }

  const categoryAvg: Record<string, number> = {};
  for (const [cat, data] of Object.entries(categoryScores)) {
    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;
  }

  // Calculate overall score (weighted average)
  let totalWeight = 0;
  let weightedSum = 0;
  for (const m of measurements) {
    const config = FACEIQ_METRICS[m.metricId];
    if (config) {
      weightedSum += m.standardizedScore * config.weight;
      totalWeight += config.weight;
    }
  }

  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
  const standardizedScore = overallScore;

  return {
    measurements,
    overallScore,
    standardizedScore,
    qualityTier: getQualityTier(overallScore),
    categoryScores: categoryAvg,
  };
}

// ============================================
// SIDE PROFILE ANALYSIS
// ============================================

export interface SideProfileResults {
  measurements: FaceIQScoreResult[];
  overallScore: number;
  standardizedScore: number;
  qualityTier: QualityTier;
  categoryScores: Record<string, number>;
}

/**
 * Calculate all side profile measurements from landmarks
 */
export function analyzeSideProfile(
  landmarks: LandmarkPoint[],
  gender: 'male' | 'female' = 'male'
): SideProfileResults {
  const measurements: FaceIQScoreResult[] = [];

  const addMeasurement = (metricId: string, value: number | null) => {
    if (value !== null) {
      const result = scoreMeasurement(metricId, value);
      if (result) measurements.push(result);
    }
  };

  // Get key landmarks
  const glabella = getLandmark(landmarks, 'glabella');
  const nasion = getLandmark(landmarks, 'nasion');
  const rhinion = getLandmark(landmarks, 'rhinion');
  const pronasale = getLandmark(landmarks, 'pronasale');
  const columella = getLandmark(landmarks, 'columella');
  const subnasale = getLandmark(landmarks, 'subnasale');
  const labraleSuperius = getLandmark(landmarks, 'labraleSuperius');
  const labraleInferius = getLandmark(landmarks, 'labraleInferius');
  const sublabiale = getLandmark(landmarks, 'sublabiale');
  const pogonion = getLandmark(landmarks, 'pogonion');
  const menton = getLandmark(landmarks, 'menton');
  const tragus = getLandmark(landmarks, 'tragus');
  const gonionBottom = getLandmark(landmarks, 'gonionBottom');
  const cervicalPoint = getLandmark(landmarks, 'cervicalPoint');
  const orbitale = getLandmark(landmarks, 'orbitale');
  const porion = getLandmark(landmarks, 'porion');

  // GONIAL ANGLE
  if (tragus && gonionBottom && menton) {
    const angle = calculateAngle(tragus, gonionBottom, menton);
    addMeasurement('gonialAngle', angle);
  }

  // NASOLABIAL ANGLE
  if (columella && subnasale && labraleSuperius) {
    const angle = calculateAngle(columella, subnasale, labraleSuperius);
    addMeasurement('nasolabialAngle', angle);
  }

  // NASOFRONTAL ANGLE
  if (glabella && nasion && rhinion) {
    const angle = calculateAngle(glabella, nasion, rhinion);
    addMeasurement('nasofrontalAngle', angle);
  }

  // MENTOLABIAL ANGLE
  if (labraleInferius && sublabiale && pogonion) {
    const angle = calculateAngle(labraleInferius, sublabiale, pogonion);
    addMeasurement('mentolabialAngle', angle);
  }

  // E-LINE MEASUREMENTS
  if (pronasale && pogonion && labraleSuperius && labraleInferius) {
    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);
    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);
    addMeasurement('eLineUpperLip', upperLipDist);
    addMeasurement('eLineLowerLip', lowerLipDist);
  }

  // NASOMENTAL ANGLE
  if (nasion && pronasale && pogonion) {
    const angle = calculateAngle(nasion, pronasale, pogonion);
    addMeasurement('nasomentaAngle', angle);
  }

  // FACIAL CONVEXITY (GLABELLA)
  if (glabella && subnasale && pogonion) {
    const angle = calculateAngle(glabella, subnasale, pogonion);
    addMeasurement('facialConvexityGlabella', angle);
  }

  // FACIAL CONVEXITY (NASION)
  if (nasion && subnasale && pogonion) {
    const angle = calculateAngle(nasion, subnasale, pogonion);
    addMeasurement('facialConvexityNasion', angle);
  }

  // TOTAL FACIAL CONVEXITY
  if (glabella && pronasale && pogonion) {
    const angle = calculateAngle(glabella, pronasale, pogonion);
    addMeasurement('totalFacialConvexity', angle);
  }

  // SUBMENTAL CERVICAL ANGLE
  if (menton && cervicalPoint && pogonion) {
    const neckPoint = getLandmark(landmarks, 'neckPoint');
    if (neckPoint) {
      const angle = calculateAngle(pogonion, menton, neckPoint);
      addMeasurement('submentalCervicalAngle', angle);
    }
  }

  // NASAL PROJECTION (Goode ratio)
  if (pronasale && subnasale && nasion) {
    const projection = distance(pronasale, subnasale);
    const nasalLength = distance(nasion, pronasale);
    if (nasalLength > 0) {
      addMeasurement('nasalProjection', projection / nasalLength);
    }
  }

  // NASOFACIAL ANGLE
  if (nasion && pronasale && pogonion) {
    // Angle between nose dorsum and facial plane
    const nasalDorsum = { x: pronasale.x - nasion.x, y: pronasale.y - nasion.y };
    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };

    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;
    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);
    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);

    if (mag1 > 0 && mag2 > 0) {
      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
      addMeasurement('nasofacialAngle', angle);
    }
  }

  // MANDIBULAR PLANE ANGLE (using Frankfort horizontal)
  if (porion && orbitale && gonionBottom && menton) {
    // Frankfort horizontal is porion to orbitale
    // Mandibular plane is gonion to menton
    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);
    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);
    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);
    addMeasurement('mandibularPlaneAngle', angle);
  }

  // CHIN PROJECTION
  if (pogonion && subnasale) {
    // Distance from pogonion to vertical line through subnasale
    const projection = pogonion.x - subnasale.x;
    addMeasurement('chinProjection', projection);
  }

  // Calculate category scores
  const categoryScores: Record<string, { total: number; count: number }> = {};
  for (const m of measurements) {
    if (!categoryScores[m.category]) {
      categoryScores[m.category] = { total: 0, count: 0 };
    }
    categoryScores[m.category].total += m.standardizedScore;
    categoryScores[m.category].count++;
  }

  const categoryAvg: Record<string, number> = {};
  for (const [cat, data] of Object.entries(categoryScores)) {
    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;
  }

  // Calculate overall score
  let totalWeight = 0;
  let weightedSum = 0;
  for (const m of measurements) {
    const config = FACEIQ_METRICS[m.metricId];
    if (config) {
      weightedSum += m.standardizedScore * config.weight;
      totalWeight += config.weight;
    }
  }

  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;

  return {
    measurements,
    overallScore,
    standardizedScore: overallScore,
    qualityTier: getQualityTier(overallScore),
    categoryScores: categoryAvg,
  };
}

// ============================================
// COMPLETE HARMONY ANALYSIS
// ============================================

/**
 * Run complete facial harmony analysis
 */
export function analyzeHarmony(
  frontLandmarks: LandmarkPoint[],
  sideLandmarks: LandmarkPoint[],
  gender: 'male' | 'female' = 'male'
): HarmonyAnalysis {
  const frontResults = analyzeFrontProfile(frontLandmarks, gender);
  const sideResults = analyzeSideProfile(sideLandmarks, gender);

  const allMeasurements = [...frontResults.measurements, ...sideResults.measurements];

  // Combined category scores
  const allCategories: Record<string, { total: number; count: number }> = {};
  for (const m of allMeasurements) {
    if (!allCategories[m.category]) {
      allCategories[m.category] = { total: 0, count: 0 };
    }
    allCategories[m.category].total += m.standardizedScore;
    allCategories[m.category].count++;
  }

  const categoryScores: Record<string, number> = {};
  for (const [cat, data] of Object.entries(allCategories)) {
    categoryScores[cat] = data.count > 0 ? data.total / data.count : 0;
  }

  // Overall weighted score
  let totalWeight = 0;
  let weightedSum = 0;
  for (const m of allMeasurements) {
    const config = FACEIQ_METRICS[m.metricId];
    if (config) {
      weightedSum += m.standardizedScore * config.weight;
      totalWeight += config.weight;
    }
  }

  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;

  // Identify flaws (below average measurements)
  const flaws: FlawAssessment[] = allMeasurements
    .filter((m) => m.severity !== 'optimal' && m.severity !== 'minor')
    .map((m) => ({
      category: m.category,
      metricId: m.metricId,
      metricName: m.name,
      severity: m.severity,
      deviation: `${m.deviation.toFixed(2)} ${m.deviationDirection} ideal`,
      reasoning: `${m.name} is outside the ideal range`,
      confidence: m.severity === 'extremely_severe' || m.severity === 'severe'
        ? 'confirmed' as const
        : 'likely' as const,
    }))
    .sort((a, b) => {
      const severityOrder = { extremely_severe: 0, severe: 1, major: 2, moderate: 3 };
      return (severityOrder[a.severity as keyof typeof severityOrder] ?? 4) -
             (severityOrder[b.severity as keyof typeof severityOrder] ?? 4);
    });

  // Identify strengths (ideal measurements)
  const strengths: StrengthAssessment[] = allMeasurements
    .filter((m) => m.qualityTier === 'ideal' || m.qualityTier === 'excellent')
    .map((m) => ({
      category: m.category,
      metricId: m.metricId,
      metricName: m.name,
      qualityTier: m.qualityTier,
      value: m.value,
      reasoning: `${m.name} is within the ${m.qualityTier} range`,
    }));

  // Calculate percentile (based on population stats)
  const percentile = calculateHarmonyPercentile(overallScore);

  return {
    overallScore,
    standardizedScore: overallScore,
    qualityTier: getQualityTier(overallScore),
    percentile,
    frontScore: frontResults.overallScore,
    sideScore: sideResults.overallScore,
    categoryScores,
    measurements: allMeasurements,
    flaws,
    strengths,
  };
}

/**
 * Calculate percentile from harmony score
 */
function calculateHarmonyPercentile(score: number): number {
  // Based on normal distribution with mean=5, stdDev=1.5
  const mean = 5;
  const stdDev = 1.5;
  const z = (score - mean) / stdDev;
  return normalCDF(z) * 100;
}

/**
 * Standard normal CDF approximation
 */
function normalCDF(z: number): number {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;

  const sign = z < 0 ? -1 : 1;
  const absZ = Math.abs(z) / Math.sqrt(2);

  const t = 1.0 / (1.0 + p * absZ);
  const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);

  return 0.5 * (1.0 + sign * y);
}

// ============================================
// PSL RATING CONVERSION
// ============================================

export interface PSLRating {
  score: number;
  tier: string;
  percentile: number;
  description: string;
}

/**
 * Convert harmony score to PSL rating
 */
export function convertToPSL(harmonyScore: number): PSLRating {
  // Convert 0-10 harmony to 3.0-7.5 PSL range
  const psl = 3.0 + (harmonyScore / 10) * 4.5;
  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));

  let tier: string;
  let percentile: number;

  if (clampedPSL >= 7.5) {
    tier = 'Top Model';
    percentile = 99.99;
  } else if (clampedPSL >= 7.0) {
    tier = 'Chad';
    percentile = 99.87;
  } else if (clampedPSL >= 6.5) {
    tier = 'Chadlite';
    percentile = 99.0;
  } else if (clampedPSL >= 6.0) {
    tier = 'High Tier Normie+';
    percentile = 97.25;
  } else if (clampedPSL >= 5.5) {
    tier = 'High Tier Normie';
    percentile = 90.0;
  } else if (clampedPSL >= 5.0) {
    tier = 'Mid Tier Normie+';
    percentile = 84.15;
  } else if (clampedPSL >= 4.5) {
    tier = 'Mid Tier Normie';
    percentile = 65.0;
  } else if (clampedPSL >= 4.0) {
    tier = 'Low Tier Normie';
    percentile = 50.0;
  } else if (clampedPSL >= 3.5) {
    tier = 'Below Average';
    percentile = 30.0;
  } else {
    tier = 'Subpar';
    percentile = 15.0;
  }

  return {
    score: clampedPSL,
    tier,
    percentile,
    description: `${tier} (top ${(100 - percentile).toFixed(1)}%)`,
  };
}

// ============================================
// EXPORTS FOR BACKWARD COMPATIBILITY
// ============================================

export type { LandmarkPoint } from './landmarks';
