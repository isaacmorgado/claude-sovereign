import * as vscode from "vscode"
import * as path from "path"
import type {
	WorkspaceAgentConfig,
	WorkspaceAgentState,
	WorkspaceContext,
} from "@multi-agent/types"
import { WorkspaceManager } from "./WorkspaceManager"

export interface WorkspaceProviderOptions {
	workspacePath: string
	config: WorkspaceAgentConfig
}

/**
 * WorkspaceProvider provides workspace-specific context and isolation
 * for tasks running within a specific workspace folder.
 *
 * This is used to:
 * - Provide workspace-scoped paths and context
 * - Manage workspace-specific task queues
 * - Isolate context between workspaces when configured
 */
export class WorkspaceProvider implements vscode.Disposable {
	private readonly workspacePath: string
	private readonly config: WorkspaceAgentConfig
	private readonly disposables: vscode.Disposable[] = []

	// Workspace-scoped storage for context isolation
	private isolatedContext: Map<string, unknown> = new Map()

	constructor(options: WorkspaceProviderOptions) {
		this.workspacePath = options.workspacePath
		this.config = options.config
	}

	/**
	 * Get the workspace path
	 */
	getWorkspacePath(): string {
		return this.workspacePath
	}

	/**
	 * Get the workspace name (folder name)
	 */
	getWorkspaceName(): string {
		const folder = vscode.workspace.workspaceFolders?.find(
			(f) => f.uri.fsPath === this.workspacePath
		)
		return folder?.name || path.basename(this.workspacePath)
	}

	/**
	 * Get workspace context
	 */
	getContext(): WorkspaceContext {
		const folders = vscode.workspace.workspaceFolders
		const folder = folders?.find((f) => f.uri.fsPath === this.workspacePath)

		return {
			workspacePath: this.workspacePath,
			workspaceFolderIndex: folder?.index || 0,
			workspaceName: this.getWorkspaceName(),
			isMultiRoot: (folders?.length || 0) > 1,
		}
	}

	/**
	 * Get workspace configuration
	 */
	getConfig(): WorkspaceAgentConfig {
		return this.config
	}

	/**
	 * Check if context isolation is enabled
	 */
	isContextIsolated(): boolean {
		return this.config.isolatedContext
	}

	/**
	 * Get the default mode for this workspace
	 */
	getDefaultMode(): string | undefined {
		return this.config.defaultMode
	}

	/**
	 * Get the default provider profile for this workspace
	 */
	getDefaultProviderProfile(): string | undefined {
		return this.config.defaultProviderProfile
	}

	/**
	 * Store isolated context value
	 */
	setIsolatedContext<T>(key: string, value: T): void {
		if (this.config.isolatedContext) {
			this.isolatedContext.set(key, value)
		}
	}

	/**
	 * Get isolated context value
	 */
	getIsolatedContext<T>(key: string): T | undefined {
		if (this.config.isolatedContext) {
			return this.isolatedContext.get(key) as T | undefined
		}
		return undefined
	}

	/**
	 * Clear isolated context
	 */
	clearIsolatedContext(): void {
		this.isolatedContext.clear()
	}

	/**
	 * Resolve a path relative to this workspace
	 */
	resolvePath(relativePath: string): string {
		return path.join(this.workspacePath, relativePath)
	}

	/**
	 * Get a path relative to this workspace
	 */
	relativePath(absolutePath: string): string {
		return path.relative(this.workspacePath, absolutePath)
	}

	/**
	 * Check if a path is within this workspace
	 */
	containsPath(absolutePath: string): boolean {
		const relative = path.relative(this.workspacePath, absolutePath)
		return !relative.startsWith("..") && !path.isAbsolute(relative)
	}

	/**
	 * Get the .multiagent directory path for this workspace
	 */
	getMultiAgentDir(): string {
		return path.join(this.workspacePath, ".multiagent")
	}

	/**
	 * Dispose the provider
	 */
	dispose(): void {
		for (const disposable of this.disposables) {
			disposable.dispose()
		}
		this.disposables.length = 0
		this.isolatedContext.clear()
	}
}

/**
 * Factory for creating WorkspaceProviders
 */
export class WorkspaceProviderFactory {
	private readonly providers: Map<string, WorkspaceProvider> = new Map()
	private readonly workspaceManager: WorkspaceManager

	constructor(workspaceManager: WorkspaceManager) {
		this.workspaceManager = workspaceManager
	}

	/**
	 * Get or create a WorkspaceProvider for a path
	 */
	getProvider(workspacePath: string): WorkspaceProvider | undefined {
		// Return cached provider
		if (this.providers.has(workspacePath)) {
			return this.providers.get(workspacePath)
		}

		// Get config from manager
		const config = this.workspaceManager.getWorkspaceConfig(workspacePath)
		if (!config) {
			return undefined
		}

		// Create new provider
		const provider = new WorkspaceProvider({
			workspacePath,
			config,
		})

		this.providers.set(workspacePath, provider)
		return provider
	}

	/**
	 * Get provider for the currently focused workspace
	 */
	getFocusedProvider(): WorkspaceProvider | undefined {
		const focusedPath = this.workspaceManager.getFocusedWorkspacePath()
		if (!focusedPath) {
			return undefined
		}
		return this.getProvider(focusedPath)
	}

	/**
	 * Dispose all providers
	 */
	dispose(): void {
		for (const provider of this.providers.values()) {
			provider.dispose()
		}
		this.providers.clear()
	}
}
