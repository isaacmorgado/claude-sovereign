/**
 * Phase 1 E2E Tests: Song Identification (ACRCloud)
 * Tests songIdentification.js service
 */

const assert = require('assert');
const fs = require('fs');
const path = require('path');

// Test counters
let passed = 0;
let failed = 0;
const failures = [];

function test(name, fn) {
  try {
    fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    failures.push({ name, error: error.message });
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

async function asyncTest(name, fn) {
  try {
    await fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    failures.push({ name, error: error.message });
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

// ============================================
// SONG IDENTIFICATION SERVICE TESTS
// ============================================
console.log('\n=== Song Identification Service Tests ===\n');

const songIdPath = path.join(__dirname, '../services/songIdentification.js');
const songIdCode = fs.readFileSync(songIdPath, 'utf8');

test('songIdentification.js exists and is readable', () => {
  assert(fs.existsSync(songIdPath), 'songIdentification.js should exist');
  assert(songIdCode.length > 0, 'songIdentification.js should have content');
});

test('songIdentification exports validateYouTubeUrl function', () => {
  assert(songIdCode.includes('function validateYouTubeUrl'), 'Should have validateYouTubeUrl function');
  assert(songIdCode.includes('validateYouTubeUrl'), 'validateYouTubeUrl should be exported');
});

test('songIdentification exports extractAudioFingerprint function', () => {
  assert(songIdCode.includes('async function extractAudioFingerprint'), 'Should have extractAudioFingerprint function');
});

test('songIdentification exports identifySong function', () => {
  assert(songIdCode.includes('async function identifySong'), 'Should have identifySong function');
});

test('songIdentification exports identifyFromYouTube function', () => {
  assert(songIdCode.includes('async function identifyFromYouTube'), 'Should have identifyFromYouTube function');
});

test('songIdentification exports checkDependencies function', () => {
  assert(songIdCode.includes('async function checkDependencies'), 'Should have checkDependencies function');
});

test('songIdentification exports hasACRCloudCredentials function', () => {
  assert(songIdCode.includes('function hasACRCloudCredentials'), 'Should have hasACRCloudCredentials function');
});

// ============================================
// YOUTUBE URL VALIDATION TESTS
// ============================================
console.log('\n=== YouTube URL Validation Tests ===\n');

test('validates standard YouTube URL pattern', () => {
  assert(songIdCode.includes('youtube.com/watch?v='), 'Should recognize youtube.com/watch?v= pattern');
});

test('validates short YouTube URL pattern', () => {
  assert(songIdCode.includes('youtu.be/'), 'Should recognize youtu.be/ pattern');
});

test('validates embed URL pattern', () => {
  assert(songIdCode.includes('youtube.com/embed/'), 'Should recognize youtube.com/embed/ pattern');
});

test('validates video ID format (11 characters)', () => {
  assert(songIdCode.includes('[a-zA-Z0-9_-]{11}'), 'Should validate 11-character video ID');
});

test('returns validation result object', () => {
  assert(songIdCode.includes('valid:'), 'Should return valid field');
  assert(songIdCode.includes('videoId:'), 'Should return videoId field');
  assert(songIdCode.includes('error:'), 'Should return error field');
});

test('handles null/undefined URL input', () => {
  assert(songIdCode.includes("'URL is required'"), 'Should handle missing URL');
});

test('handles invalid URL format', () => {
  assert(songIdCode.includes("'Invalid YouTube URL format'"), 'Should handle invalid format');
});

// ============================================
// AUDIO EXTRACTION TESTS
// ============================================
console.log('\n=== Audio Extraction Tests ===\n');

test('uses yt-dlp for audio extraction', () => {
  assert(songIdCode.includes('yt-dlp'), 'Should use yt-dlp');
});

test('extracts audio in WAV format', () => {
  assert(songIdCode.includes("'wav'"), 'Should extract as WAV');
  assert(songIdCode.includes('--audio-format'), 'Should specify audio format');
});

test('limits extraction to prevent large files', () => {
  assert(songIdCode.includes('30'), 'Should limit download duration');
});

test('trims audio to 15 seconds for fingerprinting', () => {
  assert(songIdCode.includes('-t 15'), 'Should trim to 15 seconds');
});

test('uses FFmpeg for audio trimming', () => {
  assert(songIdCode.includes('ffmpeg'), 'Should use FFmpeg for trimming');
});

test('converts to mono for fingerprinting', () => {
  assert(songIdCode.includes('-ac 1'), 'Should convert to mono');
});

test('sets sample rate for consistency', () => {
  assert(songIdCode.includes('-ar 44100'), 'Should set 44.1kHz sample rate');
});

test('uses temp directory for extraction', () => {
  assert(songIdCode.includes('TEMP_DIR'), 'Should use TEMP_DIR');
  assert(songIdCode.includes('/tmp/splice-music'), 'Should have default temp path');
});

test('creates unique temp file names', () => {
  assert(songIdCode.includes('Date.now()'), 'Should use timestamp in filename');
  assert(songIdCode.includes('fingerprint_'), 'Should use fingerprint_ prefix');
});

test('handles yt-dlp not installed error', () => {
  assert(songIdCode.includes("'yt-dlp is not installed'"), 'Should handle missing yt-dlp');
});

test('handles unavailable video error', () => {
  assert(songIdCode.includes("'YouTube video is unavailable'"), 'Should handle unavailable video');
});

test('cleans up temp files after extraction', () => {
  assert(songIdCode.includes('cleanupTempFiles'), 'Should have cleanup function');
  assert(songIdCode.includes('fs.unlink'), 'Should delete temp files');
});

test('has extraction timeout', () => {
  assert(songIdCode.includes('timeout: 60000'), 'Should have 60s timeout for yt-dlp');
  assert(songIdCode.includes('timeout: 30000'), 'Should have 30s timeout for FFmpeg');
});

// ============================================
// ACRCLOUD INTEGRATION TESTS
// ============================================
console.log('\n=== ACRCloud Integration Tests ===\n');

test('uses ACRCloud environment variables', () => {
  assert(songIdCode.includes('ACRCLOUD_HOST'), 'Should use ACRCLOUD_HOST');
  assert(songIdCode.includes('ACRCLOUD_ACCESS_KEY'), 'Should use ACRCLOUD_ACCESS_KEY');
  assert(songIdCode.includes('ACRCLOUD_ACCESS_SECRET'), 'Should use ACRCLOUD_ACCESS_SECRET');
});

test('has default ACRCloud host', () => {
  assert(songIdCode.includes('identify-us-west-2.acrcloud.com'), 'Should have default host');
});

test('generates HMAC-SHA1 signature', () => {
  assert(songIdCode.includes('createHmac'), 'Should create HMAC');
  assert(songIdCode.includes("'sha1'"), 'Should use SHA1');
  assert(songIdCode.includes("'base64'"), 'Should encode as base64');
});

test('sends proper ACRCloud request parameters', () => {
  assert(songIdCode.includes('access_key'), 'Should send access_key');
  assert(songIdCode.includes('signature'), 'Should send signature');
  assert(songIdCode.includes('signature_version'), 'Should send signature_version');
  assert(songIdCode.includes('timestamp'), 'Should send timestamp');
  assert(songIdCode.includes('sample'), 'Should send audio sample');
  assert(songIdCode.includes('sample_bytes'), 'Should send sample_bytes');
  assert(songIdCode.includes('data_type'), 'Should send data_type');
});

test('uses FormData for multipart request', () => {
  assert(songIdCode.includes("require('form-data')"), 'Should use form-data package');
  assert(songIdCode.includes('new FormData'), 'Should create FormData');
});

test('makes HTTPS request to ACRCloud', () => {
  assert(songIdCode.includes("require('https')"), 'Should use https module');
  assert(songIdCode.includes('/v1/identify'), 'Should use identify endpoint');
});

test('has ACRCloud request timeout', () => {
  assert(songIdCode.includes('setTimeout(30000)'), 'Should have 30s timeout');
});

test('validates ACRCloud credentials before request', () => {
  assert(songIdCode.includes("'ACRCloud credentials not configured'"), 'Should validate credentials');
});

// ============================================
// RESPONSE PARSING TESTS
// ============================================
console.log('\n=== Response Parsing Tests ===\n');

test('exports parseACRCloudResponse function', () => {
  assert(songIdCode.includes('function parseACRCloudResponse'), 'Should have parseACRCloudResponse');
});

test('handles success response (code 0)', () => {
  assert(songIdCode.includes('status?.code === 0'), 'Should check for success code');
});

test('handles no match response (code 1001)', () => {
  assert(songIdCode.includes('status?.code === 1001'), 'Should check for no match code');
});

test('extracts song title', () => {
  assert(songIdCode.includes('music.title'), 'Should extract title');
});

test('extracts artist name', () => {
  assert(songIdCode.includes('music.artists'), 'Should extract artists');
});

test('extracts album name', () => {
  assert(songIdCode.includes('music.album'), 'Should extract album');
});

test('extracts genres', () => {
  assert(songIdCode.includes('music.genres'), 'Should extract genres');
});

test('extracts BPM', () => {
  assert(songIdCode.includes('function extractBPM'), 'Should have extractBPM function');
  assert(songIdCode.includes('music.bpm') || songIdCode.includes('music.tempo'), 'Should extract BPM/tempo');
});

test('extracts musical key', () => {
  assert(songIdCode.includes('function extractKey'), 'Should have extractKey function');
});

test('extracts mood', () => {
  assert(songIdCode.includes('function extractMood'), 'Should have extractMood function');
});

test('extracts confidence score', () => {
  assert(songIdCode.includes('music.score'), 'Should extract confidence score');
});

test('extracts ACRCloud ID', () => {
  assert(songIdCode.includes('music.acrid'), 'Should extract acrid');
});

test('extracts external metadata (Spotify, YouTube, Deezer)', () => {
  assert(songIdCode.includes('external_metadata'), 'Should access external_metadata');
  assert(songIdCode.includes('spotify'), 'Should extract Spotify ID');
  assert(songIdCode.includes('youtube'), 'Should extract YouTube ID');
  assert(songIdCode.includes('deezer'), 'Should extract Deezer ID');
});

test('converts Spotify key/mode to string', () => {
  assert(songIdCode.includes('function spotifyKeyToString'), 'Should have spotifyKeyToString');
  assert(songIdCode.includes("'Major'"), 'Should handle major mode');
  assert(songIdCode.includes("'Minor'"), 'Should handle minor mode');
});

test('normalizes key string', () => {
  assert(songIdCode.includes('function normalizeKey'), 'Should have normalizeKey');
});

test('infers mood from genres', () => {
  assert(songIdCode.includes("'Energetic'"), 'Should infer energetic mood');
  assert(songIdCode.includes("'Melancholic'"), 'Should infer melancholic mood');
  assert(songIdCode.includes("'Relaxed'"), 'Should infer relaxed mood');
  assert(songIdCode.includes("'Intense'"), 'Should infer intense mood');
});

// ============================================
// FULL FLOW TESTS
// ============================================
console.log('\n=== Full Identification Flow Tests ===\n');

test('identifyFromYouTube combines extraction and identification', () => {
  assert(songIdCode.includes('extractAudioFingerprint'), 'Should call extractAudioFingerprint');
  assert(songIdCode.includes('identifySong'), 'Should call identifySong');
});

test('identifyFromYouTube cleans up temp files on success', () => {
  assert(songIdCode.includes('finally'), 'Should have finally block');
  assert(songIdCode.includes('fs.unlink'), 'Should delete temp file');
});

test('identifyFromYouTube adds source metadata', () => {
  assert(songIdCode.includes('result.sourceUrl'), 'Should add sourceUrl');
  assert(songIdCode.includes('result.sourceType'), 'Should add sourceType');
});

// ============================================
// DEPENDENCY CHECK TESTS
// ============================================
console.log('\n=== Dependency Check Tests ===\n');

test('checkDependencies checks yt-dlp', () => {
  assert(songIdCode.includes("'yt-dlp --version'"), 'Should check yt-dlp version');
});

test('checkDependencies checks ffmpeg', () => {
  assert(songIdCode.includes("'ffmpeg -version'"), 'Should check ffmpeg version');
});

test('checkDependencies returns status object', () => {
  assert(songIdCode.includes('ytdlp:'), 'Should return ytdlp status');
  assert(songIdCode.includes('ffmpeg:'), 'Should return ffmpeg status');
});

// ============================================
// SECURITY TESTS
// ============================================
console.log('\n=== Security Tests ===\n');

test('uses -- to prevent URL interpretation as options', () => {
  assert(songIdCode.includes("'--'"), 'Should use -- before URL');
});

test('escapes file paths in shell commands', () => {
  assert(songIdCode.includes('"${'), 'Should quote file paths in commands');
});

test('uses execAsync with timeout', () => {
  assert(songIdCode.includes('execAsync('), 'Should use promisified exec');
  assert(songIdCode.includes('timeout:'), 'Should specify timeout');
});

test('creates temp directory with recursive option', () => {
  assert(songIdCode.includes("recursive: true"), 'Should use recursive mkdir');
});

// ============================================
// ERROR HANDLING TESTS
// ============================================
console.log('\n=== Error Handling Tests ===\n');

test('handles ACRCloud parse errors', () => {
  assert(songIdCode.includes("'Failed to parse ACRCloud response'"), 'Should handle parse errors');
});

test('handles ACRCloud request errors', () => {
  assert(songIdCode.includes("'ACRCloud request failed'"), 'Should handle request errors');
});

test('handles ACRCloud timeout', () => {
  assert(songIdCode.includes("'ACRCloud request timeout'"), 'Should handle timeout');
});

test('handles unknown ACRCloud errors', () => {
  assert(songIdCode.includes("'Unknown ACRCloud error'"), 'Should handle unknown errors');
});

test('wraps errors in friendly messages', () => {
  assert(songIdCode.includes('Audio extraction failed:'), 'Should wrap extraction errors');
});

// ============================================
// INTEGRATION WITH WORKER TESTS
// ============================================
console.log('\n=== Worker Integration Tests ===\n');

const workerPath = path.join(__dirname, '../workers/musicWorker.js');
const workerCode = fs.readFileSync(workerPath, 'utf8');

test('musicWorker can import songIdentification', () => {
  assert(workerCode.includes("require('../services/songIdentification')"), 'Worker should import songIdentification');
});

test('musicWorker calls extractAudioFingerprint', () => {
  assert(workerCode.includes('extractAudioFingerprint'), 'Worker should call extractAudioFingerprint');
});

test('musicWorker calls identifySong', () => {
  assert(workerCode.includes('identifySong'), 'Worker should call identifySong');
});

test('musicWorker stores identification result in job data', () => {
  assert(workerCode.includes('referenceSong'), 'Worker should store referenceSong');
});

// ============================================
// EXPORT STRUCTURE TESTS
// ============================================
console.log('\n=== Export Structure Tests ===\n');

test('module.exports includes all public functions', () => {
  const expectedExports = [
    'validateYouTubeUrl',
    'extractAudioFingerprint',
    'identifySong',
    'identifyFromYouTube',
    'cleanupTempFiles',
    'checkDependencies',
    'hasACRCloudCredentials',
    'parseACRCloudResponse',
    'extractBPM',
    'extractKey',
    'extractMood',
    'spotifyKeyToString',
    'normalizeKey',
    'TEMP_DIR'
  ];

  expectedExports.forEach(exp => {
    assert(songIdCode.includes(exp), `Should export ${exp}`);
  });
});

// ============================================
// SUMMARY
// ============================================
console.log('\n========================================');
console.log(`Phase 1 E2E Tests: ${passed} passed, ${failed} failed`);
console.log('========================================\n');

if (failures.length > 0) {
  console.log('Failures:');
  failures.forEach(f => {
    console.log(`  - ${f.name}: ${f.error}`);
  });
  console.log('');
}

// Exit with appropriate code
process.exit(failed > 0 ? 1 : 0);
