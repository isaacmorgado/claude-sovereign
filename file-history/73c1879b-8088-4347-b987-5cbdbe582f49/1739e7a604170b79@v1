/**
 * SPLICE Music Module
 * AI-powered music generation for video projects
 */

// ============================================
// STATE
// ============================================
const musicState = {
  jobs: [],
  selectedJob: null,
  isIdentifying: false,
  isGenerating: false,
  identifiedSong: null,
  audioPlayer: null,
  pollInterval: null
};

// ============================================
// CONSTANTS
// ============================================
const MUSIC_POLL_INTERVAL = 5000; // 5 seconds

const MOOD_OPTIONS = [
  { id: 'energetic', name: 'Energetic', description: 'Upbeat, high energy' },
  { id: 'relaxed', name: 'Relaxed', description: 'Calm, peaceful' },
  { id: 'melancholic', name: 'Melancholic', description: 'Sad, emotional' },
  { id: 'intense', name: 'Intense', description: 'Powerful, dramatic' },
  { id: 'happy', name: 'Happy', description: 'Joyful, cheerful' },
  { id: 'mysterious', name: 'Mysterious', description: 'Dark, suspenseful' },
  { id: 'romantic', name: 'Romantic', description: 'Warm, intimate' },
  { id: 'epic', name: 'Epic', description: 'Grand, orchestral' },
  { id: 'chill', name: 'Chill', description: 'Lo-fi, laid-back' },
  { id: 'neutral', name: 'Neutral', description: 'Balanced, versatile' }
];

const INSTRUMENT_OPTIONS = [
  { id: 'acoustic', name: 'Acoustic', description: 'Guitar, piano, strings' },
  { id: 'electronic', name: 'Electronic', description: 'Synths, beats' },
  { id: 'rock', name: 'Rock', description: 'Electric guitars, drums' },
  { id: 'orchestral', name: 'Orchestral', description: 'Strings, brass, woodwinds' },
  { id: 'minimal', name: 'Minimal', description: 'Piano, ambient' },
  { id: 'hiphop', name: 'Hip-Hop', description: '808s, trap drums' }
];

const DURATION_OPTIONS = [
  { value: 30, label: '30 seconds' },
  { value: 60, label: '1 minute' },
  { value: 90, label: '1.5 minutes' },
  { value: 120, label: '2 minutes' },
  { value: 180, label: '3 minutes' }
];

// ============================================
// API FUNCTIONS
// ============================================

/**
 * Identify song from YouTube URL
 * @param {string} youtubeUrl - YouTube URL
 * @returns {Promise<Object>} Identification result
 */
async function identifySong(youtubeUrl) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/identify`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ youtubeUrl })
  }, 90000); // 90 second timeout for identification

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to identify song');
  }

  return response.json();
}

/**
 * Generate music
 * @param {Object} options - Generation options
 * @returns {Promise<Object>} Job info
 */
async function generateMusicRequest(options) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(options)
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start music generation');
  }

  return response.json();
}

/**
 * Get job status
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Job status
 */
async function getJobStatus(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/status/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get job status');
  }

  return response.json();
}

/**
 * Get user's music library
 * @returns {Promise<Object[]>} Array of music items
 */
async function getMusicLibrary() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/library`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to load music library');
  }

  return response.json();
}

/**
 * Get music file with download URL
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Music info with signed URL
 */
async function getMusicFile(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get music file');
  }

  return response.json();
}

/**
 * Delete music from library
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Result
 */
async function deleteMusicFile(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
    method: 'DELETE',
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to delete music');
  }

  return response.json();
}

/**
 * Get music credits balance
 * @returns {Promise<Object>} Credits info
 */
async function getMusicCredits() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/credits`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    return { remaining: 0, total: 0 };
  }

  return response.json();
}

// ============================================
// UI FUNCTIONS
// ============================================

/**
 * Initialize music module
 */
function initMusicModule() {
  // Set up event listeners
  setupMusicEventListeners();

  // Populate dropdowns
  populateMoodDropdown();
  populateInstrumentDropdown();
  populateDurationDropdown();

  // Load library on init
  loadMusicLibrary();

  // Update credits display
  updateMusicCreditsDisplay();
}

/**
 * Set up event listeners for music UI
 */
function setupMusicEventListeners() {
  // YouTube URL input
  const urlInput = document.getElementById('musicYoutubeUrl');
  if (urlInput) {
    urlInput.addEventListener('input', debounce(handleYoutubeUrlChange, 500));
  }

  // Identify button
  const identifyBtn = document.getElementById('musicIdentifyBtn');
  if (identifyBtn) {
    identifyBtn.addEventListener('click', handleIdentifySong);
  }

  // Generate button
  const generateBtn = document.getElementById('musicGenerateBtn');
  if (generateBtn) {
    generateBtn.addEventListener('click', handleGenerateMusic);
  }

  // Clear reference button
  const clearRefBtn = document.getElementById('musicClearRefBtn');
  if (clearRefBtn) {
    clearRefBtn.addEventListener('click', handleClearReference);
  }

  // Library refresh
  const refreshBtn = document.getElementById('musicRefreshLibraryBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', loadMusicLibrary);
  }
}

/**
 * Populate mood dropdown
 */
function populateMoodDropdown() {
  const select = document.getElementById('musicMood');
  if (!select) return;

  select.innerHTML = MOOD_OPTIONS.map(mood =>
    `<option value="${mood.id}" title="${mood.description}">${mood.name}</option>`
  ).join('');
}

/**
 * Populate instrument dropdown
 */
function populateInstrumentDropdown() {
  const select = document.getElementById('musicInstruments');
  if (!select) return;

  select.innerHTML = INSTRUMENT_OPTIONS.map(inst =>
    `<option value="${inst.id}" title="${inst.description}">${inst.name}</option>`
  ).join('');
}

/**
 * Populate duration dropdown
 */
function populateDurationDropdown() {
  const select = document.getElementById('musicDuration');
  if (!select) return;

  select.innerHTML = DURATION_OPTIONS.map(dur =>
    `<option value="${dur.value}">${dur.label}</option>`
  ).join('');

  // Default to 60 seconds
  select.value = '60';
}

/**
 * Handle YouTube URL change
 */
function handleYoutubeUrlChange() {
  const urlInput = document.getElementById('musicYoutubeUrl');
  const identifyBtn = document.getElementById('musicIdentifyBtn');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  const isValidUrl = isValidYouTubeUrl(url);

  identifyBtn.disabled = !isValidUrl;

  // Clear previous identification if URL changed
  if (musicState.identifiedSong) {
    handleClearReference();
  }
}

/**
 * Validate YouTube URL
 * @param {string} url - URL to validate
 * @returns {boolean} Is valid
 */
function isValidYouTubeUrl(url) {
  if (!url) return false;
  const patterns = [
    /youtube\.com\/watch\?v=[\w-]{11}/,
    /youtu\.be\/[\w-]{11}/,
    /youtube\.com\/embed\/[\w-]{11}/
  ];
  return patterns.some(p => p.test(url));
}

/**
 * Handle identify song button click
 */
async function handleIdentifySong() {
  const urlInput = document.getElementById('musicYoutubeUrl');
  const identifyBtn = document.getElementById('musicIdentifyBtn');
  const refDisplay = document.getElementById('musicReferenceDisplay');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  if (!isValidYouTubeUrl(url)) {
    setMusicStatus('Invalid YouTube URL', 'error');
    return;
  }

  try {
    musicState.isIdentifying = true;
    identifyBtn.disabled = true;
    identifyBtn.textContent = 'Identifying...';
    setMusicStatus('Identifying song...', 'info');

    const result = await identifySong(url);

    if (result.identified) {
      musicState.identifiedSong = result;
      displayIdentifiedSong(result);
      setMusicStatus(`Identified: ${result.title} by ${result.artist}`, 'success');
    } else {
      setMusicStatus('Could not identify song. You can still generate music.', 'warning');
    }

  } catch (error) {
    console.error('Identification error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isIdentifying = false;
    identifyBtn.disabled = false;
    identifyBtn.textContent = 'Identify';
  }
}

/**
 * Display identified song info
 * @param {Object} song - Song info
 */
function displayIdentifiedSong(song) {
  const display = document.getElementById('musicReferenceDisplay');
  if (!display) return;

  const details = [];
  if (song.bpm) details.push(`${song.bpm} BPM`);
  if (song.key) details.push(song.key);
  if (song.mood) details.push(song.mood);

  display.innerHTML = `
    <div class="music-reference-card">
      <div class="music-ref-title">${escapeHtml(song.title)}</div>
      <div class="music-ref-artist">${escapeHtml(song.artist)}</div>
      <div class="music-ref-details">${details.join(' • ')}</div>
      <button id="musicClearRefBtn" class="music-clear-ref-btn" title="Clear reference">×</button>
    </div>
  `;

  display.style.display = 'block';

  // Re-attach clear button listener
  const clearBtn = document.getElementById('musicClearRefBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', handleClearReference);
  }
}

/**
 * Clear reference song
 */
function handleClearReference() {
  musicState.identifiedSong = null;

  const display = document.getElementById('musicReferenceDisplay');
  if (display) {
    display.innerHTML = '';
    display.style.display = 'none';
  }

  const urlInput = document.getElementById('musicYoutubeUrl');
  if (urlInput) {
    urlInput.value = '';
  }

  const identifyBtn = document.getElementById('musicIdentifyBtn');
  if (identifyBtn) {
    identifyBtn.disabled = true;
  }
}

/**
 * Handle generate music button click
 */
async function handleGenerateMusic() {
  const generateBtn = document.getElementById('musicGenerateBtn');
  const moodSelect = document.getElementById('musicMood');
  const instrumentSelect = document.getElementById('musicInstruments');
  const durationSelect = document.getElementById('musicDuration');
  const promptInput = document.getElementById('musicPrompt');

  if (!generateBtn) return;

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';
    setMusicStatus('Submitting generation request...', 'info');

    const options = {
      mood: moodSelect?.value || 'neutral',
      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
      duration: parseInt(durationSelect?.value) || 60,
      prompt: promptInput?.value || '',
      youtubeUrl: musicState.identifiedSong?.sourceUrl || null,
      referenceSong: musicState.identifiedSong || null
    };

    const result = await generateMusicRequest(options);

    setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');

    // Add to jobs list and start polling
    addJobToList(result.jobId, options);
    startPollingJob(result.jobId);

    // Clear form
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Generation error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate Music';
  }
}

/**
 * Add job to the jobs list
 * @param {string} jobId - Job ID
 * @param {Object} options - Job options
 */
function addJobToList(jobId, options) {
  const job = {
    jobId,
    status: 'pending',
    progress: 0,
    mood: options.mood,
    duration: options.duration,
    createdAt: new Date().toISOString()
  };

  musicState.jobs.unshift(job);
  renderJobsList();
}

/**
 * Start polling for job completion
 * @param {string} jobId - Job ID
 */
function startPollingJob(jobId) {
  // Clear any existing poll
  if (musicState.pollInterval) {
    clearInterval(musicState.pollInterval);
  }

  musicState.pollInterval = setInterval(async () => {
    try {
      const status = await getJobStatus(jobId);

      // Update job in list
      const jobIndex = musicState.jobs.findIndex(j => j.jobId === jobId);
      if (jobIndex !== -1) {
        musicState.jobs[jobIndex] = {
          ...musicState.jobs[jobIndex],
          ...status
        };
        renderJobsList();
      }

      // Check if complete or failed
      if (status.status === 'completed' || status.status === 'failed') {
        clearInterval(musicState.pollInterval);
        musicState.pollInterval = null;

        if (status.status === 'completed') {
          setMusicStatus('Music generation completed!', 'success');
          loadMusicLibrary(); // Refresh library
        } else {
          setMusicStatus(`Generation failed: ${status.failedReason || 'Unknown error'}`, 'error');
        }
      }

    } catch (error) {
      console.error('Polling error:', error);
    }
  }, MUSIC_POLL_INTERVAL);
}

/**
 * Render jobs list UI
 */
function renderJobsList() {
  const container = document.getElementById('musicJobsList');
  if (!container) return;

  if (musicState.jobs.length === 0) {
    container.innerHTML = '<div class="music-empty">No generation jobs yet</div>';
    return;
  }

  container.innerHTML = musicState.jobs.map(job => `
    <div class="music-job-item ${job.status}" data-job-id="${job.jobId}">
      <div class="music-job-status ${job.status}"></div>
      <div class="music-job-info">
        <span class="music-job-mood">${job.mood || 'Music'}</span>
        <span class="music-job-duration">${job.duration}s</span>
      </div>
      <div class="music-job-progress">
        ${job.status === 'completed' ? '✓' : job.status === 'failed' ? '✗' : `${job.progress}%`}
      </div>
    </div>
  `).join('');
}

/**
 * Load and display music library
 */
async function loadMusicLibrary() {
  const container = document.getElementById('musicLibrary');
  if (!container) return;

  try {
    container.innerHTML = '<div class="music-loading">Loading library...</div>';

    const library = await getMusicLibrary();

    if (library.length === 0) {
      container.innerHTML = '<div class="music-empty">Your music library is empty</div>';
      return;
    }

    container.innerHTML = library.map(item => `
      <div class="music-library-item" data-job-id="${item.jobId}">
        <div class="music-item-info">
          <div class="music-item-title">${escapeHtml(item.title || 'Untitled')}</div>
          <div class="music-item-meta">${item.duration}s • ${item.mood || 'Music'}</div>
        </div>
        <div class="music-item-actions">
          <button class="music-action-btn" data-action="preview" data-job-id="${item.jobId}" title="Preview">▶</button>
          <button class="music-action-btn" data-action="import" data-job-id="${item.jobId}" title="Import to Timeline">+</button>
          <button class="music-action-btn danger" data-action="delete" data-job-id="${item.jobId}" title="Delete">×</button>
        </div>
      </div>
    `).join('');

    // Add event listeners
    container.querySelectorAll('.music-action-btn').forEach(btn => {
      btn.addEventListener('click', handleLibraryAction);
    });

  } catch (error) {
    console.error('Library load error:', error);
    container.innerHTML = '<div class="music-error">Failed to load library</div>';
  }
}

/**
 * Handle library action (preview, import, delete)
 * @param {Event} event - Click event
 */
async function handleLibraryAction(event) {
  const btn = event.target;
  const action = btn.dataset.action;
  const jobId = btn.dataset.jobId;

  switch (action) {
    case 'preview':
      await previewMusic(jobId);
      break;
    case 'import':
      await importMusicToTimeline(jobId);
      break;
    case 'delete':
      await confirmDeleteMusic(jobId);
      break;
  }
}

/**
 * Preview music file
 * @param {string} jobId - Job ID
 */
async function previewMusic(jobId) {
  try {
    setMusicStatus('Loading preview...', 'info');

    const music = await getMusicFile(jobId);

    if (!music.previewUrl && !music.downloadUrl) {
      setMusicStatus('No preview available', 'warning');
      return;
    }

    // Create or update audio player
    if (!musicState.audioPlayer) {
      musicState.audioPlayer = new Audio();
      musicState.audioPlayer.addEventListener('ended', () => {
        setMusicStatus('Preview finished', 'info');
      });
    }

    musicState.audioPlayer.src = music.previewUrl || music.downloadUrl;
    musicState.audioPlayer.play();

    setMusicStatus('Playing preview...', 'success');

  } catch (error) {
    console.error('Preview error:', error);
    setMusicStatus(`Preview error: ${error.message}`, 'error');
  }
}

/**
 * Import music to Premiere Pro timeline
 * @param {string} jobId - Job ID
 */
async function importMusicToTimeline(jobId) {
  try {
    setMusicStatus('Downloading music...', 'info');

    const music = await getMusicFile(jobId);

    if (!music.downloadUrl) {
      setMusicStatus('Download URL not available', 'error');
      return;
    }

    setMusicStatus('Importing to timeline...', 'info');

    // Download file
    const response = await fetch(music.downloadUrl);
    const blob = await response.blob();

    // Get temp folder access
    const tempFolder = await getTempFolder();
    if (!tempFolder) {
      setMusicStatus('Could not access temp folder', 'error');
      return;
    }

    // Save to temp file
    const fileName = `splice_music_${jobId}.wav`;
    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
    const arrayBuffer = await blob.arrayBuffer();
    await tempFile.write(arrayBuffer);

    // Import to project
    const pproBuilder = require('premierepro').pproBuilder;
    const project = await pproBuilder.Project.getActiveProject();

    if (!project) {
      setMusicStatus('No active project', 'error');
      return;
    }

    // Import file
    const imported = await project.importFiles([tempFile.nativePath]);

    if (imported && imported.length > 0) {
      setMusicStatus('Music imported to project!', 'success');

      // Optionally insert at playhead
      const sequence = await pproBuilder.Sequence.getActiveSequence();
      if (sequence) {
        // TODO: Insert clip at playhead position
        setMusicStatus('Music imported and ready to use!', 'success');
      }
    } else {
      setMusicStatus('Import failed', 'error');
    }

  } catch (error) {
    console.error('Import error:', error);
    setMusicStatus(`Import error: ${error.message}`, 'error');
  }
}

/**
 * Confirm and delete music
 * @param {string} jobId - Job ID
 */
async function confirmDeleteMusic(jobId) {
  const confirmed = await showConfirmModal(
    'Delete Music',
    'Are you sure you want to delete this music file?'
  );

  if (!confirmed) return;

  try {
    setMusicStatus('Deleting...', 'info');
    await deleteMusicFile(jobId);
    setMusicStatus('Music deleted', 'success');
    loadMusicLibrary();
  } catch (error) {
    console.error('Delete error:', error);
    setMusicStatus(`Delete error: ${error.message}`, 'error');
  }
}

/**
 * Update music credits display
 */
async function updateMusicCreditsDisplay() {
  const badge = document.getElementById('musicCreditsBadge');
  if (!badge) return;

  try {
    const credits = await getMusicCredits();
    badge.textContent = `${credits.remaining}/${credits.total} songs`;
    badge.className = 'music-credits-badge';

    if (credits.remaining === 0) {
      badge.classList.add('empty');
    } else if (credits.remaining <= 2) {
      badge.classList.add('low');
    }
  } catch (error) {
    badge.textContent = 'Credits: --';
  }
}

/**
 * Set music status message
 * @param {string} message - Status message
 * @param {string} type - Message type (info, success, warning, error)
 */
function setMusicStatus(message, type = 'info') {
  const status = document.getElementById('musicStatus');
  if (!status) return;

  status.textContent = message;
  status.className = `music-status ${type}`;
  status.style.display = 'block';

  // Auto-hide after delay for non-error messages
  if (type !== 'error') {
    setTimeout(() => {
      status.style.display = 'none';
    }, 5000);
  }
}

/**
 * Get temp folder for file operations
 * @returns {Promise<Folder|null>}
 */
async function getTempFolder() {
  try {
    const uxpFs = require('uxp').storage.localFileSystem;
    return await uxpFs.getTemporaryFolder();
  } catch (error) {
    console.error('Temp folder error:', error);
    return null;
  }
}

/**
 * Escape HTML special characters
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

/**
 * Simple debounce function
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in ms
 * @returns {Function} Debounced function
 */
function debounce(fn, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Export for use in other modules
window.musicModule = {
  init: initMusicModule,
  identifySong,
  generateMusicRequest,
  getMusicLibrary,
  getMusicCredits,
  loadMusicLibrary,
  previewMusic,
  importMusicToTimeline,
  MOOD_OPTIONS,
  INSTRUMENT_OPTIONS,
  DURATION_OPTIONS
};
