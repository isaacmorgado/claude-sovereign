/**
 * Custom Presets E2E Tests
 *
 * Tests for Phase 1: Custom Presets Foundation
 * Each feature is tested individually then together.
 */

// Simulate localStorage for Node.js testing - using object wrapper for proper reset
const storage = { data: {} };
global.localStorage = {
  getItem: (key) => storage.data[key] || null,
  setItem: (key, value) => { storage.data[key] = value; },
  removeItem: (key) => { delete storage.data[key]; },
  clear: () => { storage.data = {}; }
};

// Helper to reset localStorage
function resetLocalStorage() {
  storage.data = {};
}

// Mock console.warn to avoid noise
const originalWarn = console.warn;
console.warn = () => {};

// =============================================================================
// COPY OF FUNCTIONS FROM settings.js (for testing without UXP)
// =============================================================================

const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';

const DEFAULT_CUSTOM_PRESETS = {
  version: 1,
  presets: {},
  order: []
};

function loadCustomPresets() {
  try {
    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
        return {
          version: parsed.version || 1,
          presets: { ...parsed.presets } || {},
          order: [...(parsed.order || [])]
        };
      }
    }
  } catch (e) {
    // Silently handle parse errors
  }
  // Return a DEEP copy of defaults to avoid mutation issues
  return {
    version: 1,
    presets: {},
    order: []
  };
}

function saveCustomPresets(data) {
  try {
    if (!data || typeof data !== 'object') {
      return false;
    }
    const toSave = {
      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
      presets: data.presets || {},
      order: data.order || []
    };
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    return true;
  } catch (e) {
    return false;
  }
}

// Slugify function
function slugifyPresetName(name) {
  return name
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50) || 'preset';
}

// Generate unique ID
function generateUniquePresetId(baseName, existingPresets) {
  const baseId = slugifyPresetName(baseName);
  let id = baseId;
  let counter = 1;

  while (existingPresets[id]) {
    id = `${baseId}-${counter}`;
    counter++;
  }

  return id;
}

// Get current preset settings (mock for testing)
function getCurrentPresetSettings() {
  return {
    sensitivity: 50,
    threshold: -32,
    minSilenceLength: 0.5,
    paddingStart: 0.1,
    paddingEnd: 0.1,
    autoMarkBest: true,
    enableTakesDetection: true
  };
}

// Create custom preset
function createCustomPreset(preset) {
  if (!preset || typeof preset !== 'object') {
    return { success: false, error: 'Invalid preset data' };
  }

  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {
    return { success: false, error: 'Preset name is required' };
  }

  const name = preset.name.trim();
  const data = loadCustomPresets();
  const id = generateUniquePresetId(name, data.presets);

  const settings = preset.settings && typeof preset.settings === 'object'
    ? { ...preset.settings }
    : getCurrentPresetSettings();

  if (!settings || typeof settings !== 'object') {
    return { success: false, error: 'Invalid settings' };
  }

  const newPreset = {
    id,
    name,
    description: preset.description || '',
    icon: preset.icon || 'settings',
    createdAt: new Date().toISOString(),
    settings
  };

  data.presets[id] = newPreset;
  data.order.push(id);

  const saved = saveCustomPresets(data);
  if (!saved) {
    return { success: false, error: 'Failed to save preset' };
  }

  return { success: true, id };
}

// Update custom preset
function updateCustomPreset(id, updates) {
  if (!id || typeof id !== 'string') {
    return { success: false, error: 'Preset ID is required' };
  }

  if (!updates || typeof updates !== 'object') {
    return { success: false, error: 'Updates must be an object' };
  }

  const data = loadCustomPresets();

  if (!data.presets[id]) {
    return { success: false, error: 'Preset not found' };
  }

  const existing = data.presets[id];

  const updated = {
    ...existing,
    updatedAt: new Date().toISOString()
  };

  if (updates.name !== undefined) {
    if (typeof updates.name !== 'string' || !updates.name.trim()) {
      return { success: false, error: 'Name must be a non-empty string' };
    }
    updated.name = updates.name.trim();
  }

  if (updates.description !== undefined) {
    updated.description = String(updates.description);
  }

  if (updates.icon !== undefined) {
    updated.icon = String(updates.icon);
  }

  if (updates.settings !== undefined) {
    if (typeof updates.settings !== 'object') {
      return { success: false, error: 'Settings must be an object' };
    }
    updated.settings = {
      ...existing.settings,
      ...updates.settings
    };
  }

  data.presets[id] = updated;

  const saved = saveCustomPresets(data);
  if (!saved) {
    return { success: false, error: 'Failed to save preset' };
  }

  return { success: true };
}

// Get custom preset by ID
function getCustomPreset(id) {
  if (!id || typeof id !== 'string') {
    return null;
  }
  const data = loadCustomPresets();
  return data.presets[id] || null;
}

// Delete custom preset
function deleteCustomPreset(id) {
  if (!id || typeof id !== 'string') {
    return { success: false, error: 'Preset ID is required' };
  }

  const data = loadCustomPresets();

  if (!data.presets[id]) {
    return { success: false, error: 'Preset not found' };
  }

  delete data.presets[id];

  const orderIndex = data.order.indexOf(id);
  if (orderIndex !== -1) {
    data.order.splice(orderIndex, 1);
  }

  const saved = saveCustomPresets(data);
  if (!saved) {
    return { success: false, error: 'Failed to save after deletion' };
  }

  return { success: true };
}

// Mock built-in presets (matching settings.js)
const PRESETS = {
  custom: { name: 'Custom', description: 'Your custom settings', icon: 'settings', settings: null },
  podcast: { name: 'Podcast', description: 'Natural pauses', icon: 'mic', settings: { sensitivity: 35 } },
  interview: { name: 'Interview', description: 'Q&A rhythm', icon: 'people', settings: { sensitivity: 50 } },
  reaction: { name: 'Reaction', description: 'Fast-paced', icon: 'bolt', settings: { sensitivity: 70 } },
  tutorial: { name: 'Tutorial', description: 'Teaching pace', icon: 'school', settings: { sensitivity: 30 } },
  vlog: { name: 'Vlog', description: 'Punchy edits', icon: 'videocam', settings: { sensitivity: 65 } }
};

const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];

// Is built-in preset
function isBuiltInPreset(id) {
  return BUILT_IN_PRESET_IDS.includes(id);
}

// Get all presets (built-in + custom)
function getAllPresets() {
  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {
    const preset = PRESETS[id];
    return {
      id,
      name: preset.name,
      description: preset.description,
      icon: preset.icon,
      settings: preset.settings,
      isBuiltIn: true
    };
  });

  const customData = loadCustomPresets();
  const customPresets = customData.order.map(id => {
    const preset = customData.presets[id];
    if (!preset) return null;
    return { ...preset, isBuiltIn: false };
  }).filter(Boolean);

  return [...builtInPresets, ...customPresets];
}

// Get all preset IDs
function getAllPresetIds() {
  const customData = loadCustomPresets();
  return [...BUILT_IN_PRESET_IDS, ...customData.order];
}

// Get preset by ID
function getPresetById(id) {
  if (!id || typeof id !== 'string') return null;

  if (isBuiltInPreset(id)) {
    const preset = PRESETS[id];
    return { id, name: preset.name, description: preset.description, icon: preset.icon, settings: preset.settings, isBuiltIn: true };
  }

  const custom = getCustomPreset(id);
  if (custom) return { ...custom, isBuiltIn: false };

  return null;
}

// =============================================================================
// TEST UTILITIES
// =============================================================================

let testsPassed = 0;
let testsFailed = 0;
const startTime = Date.now();

function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function assertEqual(actual, expected, message) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(`${message}\n  Expected: ${JSON.stringify(expected)}\n  Actual: ${JSON.stringify(actual)}`);
  }
}

async function runTest(name, testFn) {
  const testStart = Date.now();
  try {
    // Clear localStorage before each test
    storage.data = {};

    await testFn();

    const elapsed = Date.now() - testStart;
    console.log(`  âœ“ ${name} (${elapsed}ms)`);
    testsPassed++;

    // Check for performance bottleneck
    if (elapsed > 5) {
      console.log(`    âš  Performance warning: ${elapsed}ms > 5ms threshold`);
    }
  } catch (err) {
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    testsFailed++;
  }
}

// =============================================================================
// FEATURE 1.1 TESTS: localStorage Schema
// =============================================================================

async function testFeature1_1() {
  console.log('\nðŸ“¦ Feature 1.1: localStorage Schema');
  console.log('=' .repeat(50));

  // Test 1: Load returns default when empty
  await runTest('loadCustomPresets returns default when empty', async () => {
    const result = loadCustomPresets();
    assertEqual(result.version, 1, 'Version should be 1');
    assertEqual(result.presets, {}, 'Presets should be empty object');
    assertEqual(result.order, [], 'Order should be empty array');
  });

  // Test 2: Save and load round-trip
  await runTest('Save and load round-trip works', async () => {
    const testData = {
      version: 1,
      presets: {
        'test-preset': {
          id: 'test-preset',
          name: 'Test Preset',
          settings: { sensitivity: 50 }
        }
      },
      order: ['test-preset']
    };

    const saveResult = saveCustomPresets(testData);
    assert(saveResult === true, 'Save should return true');

    const loaded = loadCustomPresets();
    assertEqual(loaded.version, 1, 'Version should match');
    assertEqual(loaded.order, ['test-preset'], 'Order should match');
    assertEqual(loaded.presets['test-preset'].name, 'Test Preset', 'Preset name should match');
  });

  // Test 3: Handle corrupt data gracefully
  await runTest('Handle corrupt JSON gracefully', async () => {
    localStorage.setItem(CUSTOM_PRESETS_KEY, 'not valid json{{{');
    const result = loadCustomPresets();
    assertEqual(result.version, 1, 'Should return default version');
    assertEqual(result.presets, {}, 'Should return empty presets');
  });

  // Test 4: Handle invalid structure gracefully
  await runTest('Handle invalid structure gracefully', async () => {
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify({ foo: 'bar' }));
    const result = loadCustomPresets();
    assertEqual(result.version, 1, 'Should return default version');
    assertEqual(result.presets, {}, 'Should return empty presets');
  });

  // Test 5: Save rejects invalid data
  await runTest('Save rejects null/undefined data', async () => {
    const result1 = saveCustomPresets(null);
    assert(result1 === false, 'Should return false for null');

    const result2 = saveCustomPresets(undefined);
    assert(result2 === false, 'Should return false for undefined');

    const result3 = saveCustomPresets('string');
    assert(result3 === false, 'Should return false for string');
  });

  // Test 6: Multiple save/load cycles
  await runTest('Multiple save/load cycles work correctly', async () => {
    for (let i = 0; i < 100; i++) {
      const data = {
        version: 1,
        presets: { [`preset-${i}`]: { id: `preset-${i}`, name: `Preset ${i}` } },
        order: [`preset-${i}`]
      };
      saveCustomPresets(data);
    }

    const final = loadCustomPresets();
    assertEqual(final.order, ['preset-99'], 'Should have last preset');
  });

  // Test 7: Preserves version when saving
  await runTest('Preserves version field', async () => {
    const data = {
      version: 1,
      presets: {},
      order: []
    };
    saveCustomPresets(data);
    const loaded = loadCustomPresets();
    assertEqual(loaded.version, 1, 'Version should be preserved');
  });
}

// =============================================================================
// FEATURE 1.2 TESTS: createCustomPreset Function
// =============================================================================

async function testFeature1_2() {
  console.log('\nðŸ“¦ Feature 1.2: createCustomPreset Function');
  console.log('=' .repeat(50));

  // Test 1: Create preset with name only
  await runTest('Create preset with name only', async () => {
    const result = createCustomPreset({ name: 'My Podcast Style' });
    assert(result.success === true, 'Should succeed');
    assert(result.id === 'my-podcast-style', 'ID should be slugified');

    const data = loadCustomPresets();
    assert(data.presets['my-podcast-style'], 'Preset should exist');
    assertEqual(data.presets['my-podcast-style'].name, 'My Podcast Style', 'Name should match');
  });

  // Test 2: Create preset with all fields
  await runTest('Create preset with all fields', async () => {
    const result = createCustomPreset({
      name: 'Full Preset',
      description: 'A complete preset',
      icon: 'mic',
      settings: { sensitivity: 75, threshold: -28 }
    });

    assert(result.success === true, 'Should succeed');
    const data = loadCustomPresets();
    const preset = data.presets[result.id];
    assertEqual(preset.description, 'A complete preset', 'Description should match');
    assertEqual(preset.icon, 'mic', 'Icon should match');
    assertEqual(preset.settings.sensitivity, 75, 'Settings should match');
  });

  // Test 3: Slugify special characters
  await runTest('Slugify handles special characters', async () => {
    const result = createCustomPreset({ name: 'My (Special) Preset!!!' });
    assertEqual(result.id, 'my-special-preset', 'ID should be slugified correctly');
  });

  // Test 4: Handle duplicate names
  await runTest('Handle duplicate names with unique IDs', async () => {
    createCustomPreset({ name: 'Podcast' });
    const result2 = createCustomPreset({ name: 'Podcast' });
    const result3 = createCustomPreset({ name: 'Podcast' });

    assertEqual(result2.id, 'podcast-1', 'Second should have -1 suffix');
    assertEqual(result3.id, 'podcast-2', 'Third should have -2 suffix');

    const data = loadCustomPresets();
    assertEqual(data.order.length, 3, 'Should have 3 presets');
  });

  // Test 5: Reject empty name
  await runTest('Reject empty name', async () => {
    const result1 = createCustomPreset({ name: '' });
    assert(result1.success === false, 'Should fail for empty string');
    assertEqual(result1.error, 'Preset name is required', 'Should have correct error');

    const result2 = createCustomPreset({ name: '   ' });
    assert(result2.success === false, 'Should fail for whitespace');
  });

  // Test 6: Reject invalid input
  await runTest('Reject invalid input', async () => {
    const result1 = createCustomPreset(null);
    assert(result1.success === false, 'Should fail for null');

    const result2 = createCustomPreset('string');
    assert(result2.success === false, 'Should fail for string');

    const result3 = createCustomPreset({ name: 123 });
    assert(result3.success === false, 'Should fail for non-string name');
  });

  // Test 7: Uses default settings when not provided
  await runTest('Uses default settings when not provided', async () => {
    const result = createCustomPreset({ name: 'Default Settings Test' });
    const data = loadCustomPresets();
    const preset = data.presets[result.id];

    assertEqual(preset.settings.sensitivity, 50, 'Should have default sensitivity');
    assert(preset.settings.autoMarkBest === true, 'Should have default autoMarkBest');
  });

  // Test 8: Preset has createdAt timestamp
  await runTest('Preset has createdAt timestamp', async () => {
    const before = new Date().toISOString();
    const result = createCustomPreset({ name: 'Timestamped' });
    const after = new Date().toISOString();

    const data = loadCustomPresets();
    const preset = data.presets[result.id];

    assert(preset.createdAt >= before, 'CreatedAt should be after test start');
    assert(preset.createdAt <= after, 'CreatedAt should be before test end');
  });

  // Test 9: Order array is updated
  await runTest('Order array is updated correctly', async () => {
    createCustomPreset({ name: 'First' });
    createCustomPreset({ name: 'Second' });
    createCustomPreset({ name: 'Third' });

    const data = loadCustomPresets();
    assertEqual(data.order, ['first', 'second', 'third'], 'Order should match creation order');
  });

  // Test 10: Performance test - create many presets
  await runTest('Performance: create 100 presets < 50ms', async () => {
    const start = Date.now();
    for (let i = 0; i < 100; i++) {
      createCustomPreset({ name: `Preset ${i}` });
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 50, `Should complete in < 50ms (was ${elapsed}ms)`);

    const data = loadCustomPresets();
    assertEqual(Object.keys(data.presets).length, 100, 'Should have 100 presets');
  });
}

// =============================================================================
// FEATURE 1.3 TESTS: updateCustomPreset Function
// =============================================================================

async function testFeature1_3() {
  console.log('\nðŸ“¦ Feature 1.3: updateCustomPreset Function');
  console.log('=' .repeat(50));

  // Test 1: Update preset name
  await runTest('Update preset name', async () => {
    const create = createCustomPreset({ name: 'Original Name' });
    assert(create.success, 'Should create preset');

    const result = updateCustomPreset(create.id, { name: 'Updated Name' });
    assert(result.success, 'Should update successfully');

    const preset = getCustomPreset(create.id);
    assertEqual(preset.name, 'Updated Name', 'Name should be updated');
  });

  // Test 2: Update preserves unchanged fields
  await runTest('Update preserves unchanged fields', async () => {
    const create = createCustomPreset({
      name: 'My Preset',
      description: 'Original description',
      icon: 'mic',
      settings: { sensitivity: 75 }
    });

    updateCustomPreset(create.id, { name: 'New Name' });

    const preset = getCustomPreset(create.id);
    assertEqual(preset.description, 'Original description', 'Description preserved');
    assertEqual(preset.icon, 'mic', 'Icon preserved');
    assertEqual(preset.settings.sensitivity, 75, 'Settings preserved');
  });

  // Test 3: Update settings merges with existing
  await runTest('Update settings merges with existing', async () => {
    const create = createCustomPreset({
      name: 'Settings Test',
      settings: { sensitivity: 50, threshold: -30 }
    });

    updateCustomPreset(create.id, {
      settings: { sensitivity: 80 }
    });

    const preset = getCustomPreset(create.id);
    assertEqual(preset.settings.sensitivity, 80, 'Sensitivity should be updated');
    assertEqual(preset.settings.threshold, -30, 'Threshold should be preserved');
  });

  // Test 4: Update adds updatedAt timestamp
  await runTest('Update adds updatedAt timestamp', async () => {
    const create = createCustomPreset({ name: 'Timestamp Test' });
    const before = new Date().toISOString();

    updateCustomPreset(create.id, { description: 'Updated' });

    const after = new Date().toISOString();
    const preset = getCustomPreset(create.id);

    assert(preset.updatedAt >= before, 'UpdatedAt should be after update start');
    assert(preset.updatedAt <= after, 'UpdatedAt should be before update end');
  });

  // Test 5: Update non-existent preset fails
  await runTest('Update non-existent preset fails', async () => {
    const result = updateCustomPreset('non-existent-id', { name: 'New Name' });
    assert(result.success === false, 'Should fail');
    assertEqual(result.error, 'Preset not found', 'Should have correct error');
  });

  // Test 6: Update with invalid ID fails
  await runTest('Update with invalid ID fails', async () => {
    const result1 = updateCustomPreset(null, { name: 'Test' });
    assert(result1.success === false, 'Should fail for null');

    const result2 = updateCustomPreset('', { name: 'Test' });
    assert(result2.success === false, 'Should fail for empty string');

    const result3 = updateCustomPreset(123, { name: 'Test' });
    assert(result3.success === false, 'Should fail for number');
  });

  // Test 7: Update with invalid updates object fails
  await runTest('Update with invalid updates object fails', async () => {
    const create = createCustomPreset({ name: 'Test' });

    const result1 = updateCustomPreset(create.id, null);
    assert(result1.success === false, 'Should fail for null');

    const result2 = updateCustomPreset(create.id, 'string');
    assert(result2.success === false, 'Should fail for string');
  });

  // Test 8: Update with empty name fails
  await runTest('Update with empty name fails', async () => {
    const create = createCustomPreset({ name: 'Test' });

    const result = updateCustomPreset(create.id, { name: '' });
    assert(result.success === false, 'Should fail for empty name');
    assertEqual(result.error, 'Name must be a non-empty string', 'Should have correct error');
  });

  // Test 9: Update persists across reload
  await runTest('Update persists across reload', async () => {
    const create = createCustomPreset({ name: 'Persist Test' });
    updateCustomPreset(create.id, { name: 'New Name', description: 'New Desc' });

    // Reload from storage
    const reloaded = loadCustomPresets();
    const preset = reloaded.presets[create.id];

    assertEqual(preset.name, 'New Name', 'Name should persist');
    assertEqual(preset.description, 'New Desc', 'Description should persist');
  });

  // Test 10: Performance - update 100 presets
  await runTest('Performance: update 100 presets < 50ms', async () => {
    // Create 100 presets
    const ids = [];
    for (let i = 0; i < 100; i++) {
      const result = createCustomPreset({ name: `Preset ${i}` });
      ids.push(result.id);
    }

    const start = Date.now();
    for (const id of ids) {
      updateCustomPreset(id, { description: 'Updated' });
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 100, `Should complete in < 100ms (was ${elapsed}ms)`);
  });
}

// =============================================================================
// FEATURE 1.4 TESTS: deleteCustomPreset Function
// =============================================================================

async function testFeature1_4() {
  console.log('\nðŸ“¦ Feature 1.4: deleteCustomPreset Function');
  console.log('=' .repeat(50));

  // Test 1: Delete existing preset
  await runTest('Delete existing preset', async () => {
    const create = createCustomPreset({ name: 'To Delete' });
    assert(create.success, 'Should create preset');

    const result = deleteCustomPreset(create.id);
    assert(result.success, 'Should delete successfully');

    const preset = getCustomPreset(create.id);
    assert(preset === null, 'Preset should no longer exist');
  });

  // Test 2: Delete removes from order array
  await runTest('Delete removes from order array', async () => {
    createCustomPreset({ name: 'First' });
    const second = createCustomPreset({ name: 'Second' });
    createCustomPreset({ name: 'Third' });

    const data1 = loadCustomPresets();
    assertEqual(data1.order.length, 3, 'Should have 3 presets initially');

    deleteCustomPreset(second.id);

    const data2 = loadCustomPresets();
    assertEqual(data2.order.length, 2, 'Should have 2 presets after delete');
    assert(!data2.order.includes(second.id), 'Deleted ID should not be in order');
    assertEqual(data2.order, ['first', 'third'], 'Order should have remaining presets');
  });

  // Test 3: Delete non-existent preset fails gracefully
  await runTest('Delete non-existent preset fails gracefully', async () => {
    const result = deleteCustomPreset('non-existent-id');
    assert(result.success === false, 'Should fail');
    assertEqual(result.error, 'Preset not found', 'Should have correct error');
  });

  // Test 4: Delete with invalid ID fails
  await runTest('Delete with invalid ID fails', async () => {
    const result1 = deleteCustomPreset(null);
    assert(result1.success === false, 'Should fail for null');

    const result2 = deleteCustomPreset('');
    assert(result2.success === false, 'Should fail for empty string');

    const result3 = deleteCustomPreset(123);
    assert(result3.success === false, 'Should fail for number');
  });

  // Test 5: Delete persists across reload
  await runTest('Delete persists across reload', async () => {
    const create = createCustomPreset({ name: 'Persist Delete Test' });
    deleteCustomPreset(create.id);

    const reloaded = loadCustomPresets();
    assert(!reloaded.presets[create.id], 'Preset should not exist after reload');
    assert(!reloaded.order.includes(create.id), 'ID should not be in order after reload');
  });

  // Test 6: Can delete and recreate with same name
  await runTest('Can delete and recreate with same name', async () => {
    const create1 = createCustomPreset({ name: 'Recyclable' });
    assertEqual(create1.id, 'recyclable', 'First should have expected ID');

    deleteCustomPreset(create1.id);

    const create2 = createCustomPreset({ name: 'Recyclable' });
    assertEqual(create2.id, 'recyclable', 'Second should reuse the same ID');
  });

  // Test 7: Delete all presets
  await runTest('Delete all presets', async () => {
    const ids = [];
    for (let i = 0; i < 5; i++) {
      const result = createCustomPreset({ name: `Preset ${i}` });
      ids.push(result.id);
    }

    for (const id of ids) {
      deleteCustomPreset(id);
    }

    const data = loadCustomPresets();
    assertEqual(Object.keys(data.presets).length, 0, 'Should have no presets');
    assertEqual(data.order.length, 0, 'Should have empty order');
  });

  // Test 8: Performance - delete 100 presets
  await runTest('Performance: delete 100 presets < 50ms', async () => {
    const ids = [];
    for (let i = 0; i < 100; i++) {
      const result = createCustomPreset({ name: `Preset ${i}` });
      ids.push(result.id);
    }

    const start = Date.now();
    for (const id of ids) {
      deleteCustomPreset(id);
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 100, `Should complete in < 100ms (was ${elapsed}ms)`);

    const data = loadCustomPresets();
    assertEqual(Object.keys(data.presets).length, 0, 'Should have no presets');
  });
}

// =============================================================================
// FEATURE 1.5 TESTS: isBuiltInPreset and getAllPresets
// =============================================================================

async function testFeature1_5() {
  console.log('\nðŸ“¦ Feature 1.5: isBuiltInPreset & getAllPresets');
  console.log('=' .repeat(50));

  // Test 1: isBuiltInPreset identifies built-in presets
  await runTest('isBuiltInPreset identifies built-in presets', async () => {
    assert(isBuiltInPreset('custom') === true, 'custom should be built-in');
    assert(isBuiltInPreset('podcast') === true, 'podcast should be built-in');
    assert(isBuiltInPreset('interview') === true, 'interview should be built-in');
    assert(isBuiltInPreset('reaction') === true, 'reaction should be built-in');
    assert(isBuiltInPreset('tutorial') === true, 'tutorial should be built-in');
    assert(isBuiltInPreset('vlog') === true, 'vlog should be built-in');
  });

  // Test 2: isBuiltInPreset returns false for custom presets
  await runTest('isBuiltInPreset returns false for custom presets', async () => {
    const create = createCustomPreset({ name: 'My Custom' });
    assert(isBuiltInPreset(create.id) === false, 'Custom preset should not be built-in');
    assert(isBuiltInPreset('random-id') === false, 'Random ID should not be built-in');
  });

  // Test 3: getAllPresets returns built-in presets when no custom
  await runTest('getAllPresets returns built-in presets when no custom', async () => {
    const all = getAllPresets();
    assertEqual(all.length, 6, 'Should have 6 built-in presets');
    assertEqual(all[0].id, 'custom', 'First should be custom');
    assertEqual(all[5].id, 'vlog', 'Last should be vlog');
    assert(all.every(p => p.isBuiltIn === true), 'All should be built-in');
  });

  // Test 4: getAllPresets includes custom presets after built-in
  await runTest('getAllPresets includes custom presets after built-in', async () => {
    createCustomPreset({ name: 'First Custom' });
    createCustomPreset({ name: 'Second Custom' });

    const all = getAllPresets();
    assertEqual(all.length, 8, 'Should have 6 built-in + 2 custom');
    assertEqual(all[6].name, 'First Custom', 'Custom should come after built-in');
    assertEqual(all[7].name, 'Second Custom', 'Second custom after first');
    assert(all[6].isBuiltIn === false, 'Custom should have isBuiltIn = false');
  });

  // Test 5: getAllPresets preserves custom order
  await runTest('getAllPresets preserves custom order', async () => {
    createCustomPreset({ name: 'Alpha' });
    createCustomPreset({ name: 'Beta' });
    createCustomPreset({ name: 'Gamma' });

    const all = getAllPresets();
    const customPresets = all.filter(p => !p.isBuiltIn);
    assertEqual(customPresets.map(p => p.name), ['Alpha', 'Beta', 'Gamma'], 'Order preserved');
  });

  // Test 6: getAllPresets adds isBuiltIn flag correctly
  await runTest('getAllPresets adds isBuiltIn flag correctly', async () => {
    createCustomPreset({ name: 'Test' });

    const all = getAllPresets();
    const builtIn = all.filter(p => p.isBuiltIn);
    const custom = all.filter(p => !p.isBuiltIn);

    assertEqual(builtIn.length, 6, 'Should have 6 built-in');
    assertEqual(custom.length, 1, 'Should have 1 custom');
  });

  // Test 7: getAllPresetIds returns combined IDs
  await runTest('getAllPresetIds returns combined IDs', async () => {
    createCustomPreset({ name: 'Custom One' });

    const ids = getAllPresetIds();
    assertEqual(ids.length, 7, 'Should have 6 built-in + 1 custom');
    assert(ids.includes('podcast'), 'Should include built-in');
    assert(ids.includes('custom-one'), 'Should include custom');
  });

  // Test 8: getPresetById returns built-in preset
  await runTest('getPresetById returns built-in preset', async () => {
    const preset = getPresetById('podcast');
    assert(preset !== null, 'Should find preset');
    assertEqual(preset.name, 'Podcast', 'Name should match');
    assertEqual(preset.isBuiltIn, true, 'Should be built-in');
  });

  // Test 9: getPresetById returns custom preset
  await runTest('getPresetById returns custom preset', async () => {
    const create = createCustomPreset({ name: 'Find Me', description: 'Test' });

    const preset = getPresetById(create.id);
    assert(preset !== null, 'Should find preset');
    assertEqual(preset.name, 'Find Me', 'Name should match');
    assertEqual(preset.description, 'Test', 'Description should match');
    assertEqual(preset.isBuiltIn, false, 'Should not be built-in');
  });

  // Test 10: getPresetById returns null for non-existent
  await runTest('getPresetById returns null for non-existent', async () => {
    const preset = getPresetById('non-existent-id');
    assert(preset === null, 'Should return null');
  });

  // Test 11: Built-in presets cannot be deleted via deleteCustomPreset
  await runTest('Built-in presets cannot be deleted via deleteCustomPreset', async () => {
    const result = deleteCustomPreset('podcast');
    assert(result.success === false, 'Should fail to delete built-in');
    assertEqual(result.error, 'Preset not found', 'Should have correct error');

    // Verify it still exists
    const preset = getPresetById('podcast');
    assert(preset !== null, 'Built-in should still exist');
  });
}

// =============================================================================
// PHASE 1 INTEGRATION TESTS
// =============================================================================

async function testPhase1Integration() {
  console.log('\nðŸ“¦ Phase 1 Integration Tests');
  console.log('=' .repeat(50));

  // Test 1: Full CRUD workflow
  await runTest('Full CRUD workflow', async () => {
    // Create
    const create = createCustomPreset({
      name: 'Workflow Test',
      description: 'Testing full workflow',
      settings: { sensitivity: 60 }
    });
    assert(create.success, 'Create should succeed');
    assertEqual(create.id, 'workflow-test', 'ID should be slugified');

    // Read
    let preset = getPresetById(create.id);
    assertEqual(preset.name, 'Workflow Test', 'Read should return created preset');

    // Update
    const update = updateCustomPreset(create.id, {
      name: 'Updated Workflow',
      settings: { sensitivity: 80 }
    });
    assert(update.success, 'Update should succeed');

    preset = getPresetById(create.id);
    assertEqual(preset.name, 'Updated Workflow', 'Name should be updated');
    assertEqual(preset.settings.sensitivity, 80, 'Settings should be updated');

    // Delete
    const del = deleteCustomPreset(create.id);
    assert(del.success, 'Delete should succeed');

    preset = getPresetById(create.id);
    assert(preset === null, 'Preset should be gone after delete');
  });

  // Test 2: Mixed built-in and custom operations
  await runTest('Mixed built-in and custom operations', async () => {
    // Create some custom presets
    createCustomPreset({ name: 'Custom A' });
    createCustomPreset({ name: 'Custom B' });

    // Get all presets
    const all = getAllPresets();
    assertEqual(all.length, 8, 'Should have 6 built-in + 2 custom');

    // Verify built-in are first
    assert(all.slice(0, 6).every(p => p.isBuiltIn), 'First 6 should be built-in');
    assert(all.slice(6).every(p => !p.isBuiltIn), 'Last 2 should be custom');

    // Try to delete built-in (should fail)
    const delBuiltIn = deleteCustomPreset('vlog');
    assert(delBuiltIn.success === false, 'Cannot delete built-in');

    // Delete custom (should succeed)
    const delCustom = deleteCustomPreset('custom-a');
    assert(delCustom.success, 'Can delete custom');

    // Verify list updated
    const updated = getAllPresets();
    assertEqual(updated.length, 7, 'Should have 6 built-in + 1 custom');
  });

  // Test 3: Backward compatibility with existing settings
  await runTest('Backward compatibility with existing settings', async () => {
    // Simulate existing localStorage data (no custom presets)
    storage.data = {};

    // Load should return defaults
    const data = loadCustomPresets();
    assertEqual(data.version, 1, 'Version should be 1');
    assertEqual(Object.keys(data.presets).length, 0, 'Should have no presets');
    assertEqual(data.order.length, 0, 'Order should be empty');

    // Built-in presets should still work
    const all = getAllPresets();
    assertEqual(all.length, 6, 'Built-in presets should be available');
  });

  // Test 4: No localStorage corruption under stress
  await runTest('No localStorage corruption under stress', async () => {
    // Create, update, delete rapidly
    const ids = [];
    for (let i = 0; i < 50; i++) {
      const create = createCustomPreset({ name: `Stress ${i}` });
      ids.push(create.id);
    }

    // Update half
    for (let i = 0; i < 25; i++) {
      updateCustomPreset(ids[i], { description: `Updated ${i}` });
    }

    // Delete quarter
    for (let i = 0; i < 12; i++) {
      deleteCustomPreset(ids[i]);
    }

    // Verify data integrity
    const data = loadCustomPresets();
    assertEqual(Object.keys(data.presets).length, 38, 'Should have 50-12=38 presets');
    assertEqual(data.order.length, 38, 'Order should match preset count');

    // Each order entry should exist in presets
    for (const id of data.order) {
      assert(data.presets[id], `Preset ${id} should exist`);
    }
  });

  // Test 5: Performance - full workflow 100 times
  await runTest('Performance: full CRUD cycle 100 times < 100ms', async () => {
    const start = Date.now();

    for (let i = 0; i < 100; i++) {
      const create = createCustomPreset({ name: `Perf ${i}` });
      updateCustomPreset(create.id, { description: 'Updated' });
      deleteCustomPreset(create.id);
    }

    const elapsed = Date.now() - start;
    assert(elapsed < 200, `Should complete in < 200ms (was ${elapsed}ms)`);

    // Verify clean state
    const data = loadCustomPresets();
    assertEqual(Object.keys(data.presets).length, 0, 'Should have no presets');
  });
}

// =============================================================================
// PHASE 2 TESTS: UI Functions (simulated)
// =============================================================================

/**
 * Simulate the refreshPresetDropdown() function from main.js
 * Returns the data that would populate the dropdown
 */
function simulateRefreshDropdown() {
  const presets = getAllPresets();
  return presets.map(preset => ({
    value: preset.id,
    label: preset.name + (preset.description ? ` - ${preset.description}` : ''),
    isBuiltIn: preset.isBuiltIn
  }));
}

/**
 * Simulate the savePresetFromModal() function from main.js
 * @param {string} name - Preset name
 * @param {string} description - Preset description
 * @param {string} icon - Preset icon
 * @param {string|null} editId - If editing, the preset ID to edit
 * @returns {Object} Result with success and id/error
 */
function simulateSavePreset(name, description, icon, editId = null) {
  if (!name || !name.trim()) {
    return { success: false, error: 'Please enter a preset name' };
  }

  if (editId) {
    // Update existing preset
    return updateCustomPreset(editId, {
      name: name.trim(),
      description: description || '',
      icon: icon || 'settings'
    });
  } else {
    // Create new preset
    return createCustomPreset({
      name: name.trim(),
      description: description || '',
      icon: icon || 'settings'
    });
  }
}

/**
 * Simulate the renderPresetsList() function from main.js
 * Returns the data that would be rendered in the manage modal
 */
function simulateRenderPresetsList() {
  const presets = getAllPresets();
  return presets.map(preset => ({
    id: preset.id,
    name: preset.name,
    description: preset.description || (preset.isBuiltIn ? 'Built-in preset' : 'Custom preset'),
    icon: preset.icon,
    isBuiltIn: preset.isBuiltIn,
    hasEditButton: !preset.isBuiltIn,
    hasDeleteButton: !preset.isBuiltIn
  }));
}

async function testPhase2UI() {
  console.log('\nðŸ“¦ Phase 2: UI Functions (Simulated)');
  console.log('=' .repeat(50));

  // Test 1: Dropdown shows built-in presets initially
  await runTest('Dropdown shows 6 built-in presets initially', async () => {
    const options = simulateRefreshDropdown();
    assertEqual(options.length, 6, 'Should have 6 options');
    assert(options.every(o => o.isBuiltIn), 'All should be built-in');
    assertEqual(options[0].value, 'custom', 'First should be custom');
    assertEqual(options[5].value, 'vlog', 'Last should be vlog');
  });

  // Test 2: Dropdown includes custom presets after creation
  await runTest('Dropdown includes custom presets after creation', async () => {
    createCustomPreset({ name: 'My Test Preset', description: 'Test desc' });

    const options = simulateRefreshDropdown();
    assertEqual(options.length, 7, 'Should have 7 options');
    assertEqual(options[6].value, 'my-test-preset', 'Custom preset should be last');
    assertEqual(options[6].label, 'My Test Preset - Test desc', 'Label should include description');
    assert(!options[6].isBuiltIn, 'Custom preset should not be built-in');
  });

  // Test 3: Save preset modal - create new preset
  await runTest('Save preset modal creates new preset', async () => {
    const result = simulateSavePreset('New Modal Preset', 'Created via modal', 'mic', null);
    assert(result.success, 'Should succeed');
    assertEqual(result.id, 'new-modal-preset', 'ID should be slugified');

    const preset = getPresetById(result.id);
    assertEqual(preset.name, 'New Modal Preset', 'Name should match');
    assertEqual(preset.description, 'Created via modal', 'Description should match');
    assertEqual(preset.icon, 'mic', 'Icon should match');
  });

  // Test 4: Save preset modal - edit existing preset
  await runTest('Save preset modal edits existing preset', async () => {
    const create = createCustomPreset({ name: 'Edit Me', description: 'Original' });

    const result = simulateSavePreset('Edited Name', 'Updated description', 'star', create.id);
    assert(result.success, 'Should succeed');

    const preset = getPresetById(create.id);
    assertEqual(preset.name, 'Edited Name', 'Name should be updated');
    assertEqual(preset.description, 'Updated description', 'Description should be updated');
    assertEqual(preset.icon, 'star', 'Icon should be updated');
  });

  // Test 5: Save preset modal - reject empty name
  await runTest('Save preset modal rejects empty name', async () => {
    const result1 = simulateSavePreset('', '', 'settings', null);
    assert(!result1.success, 'Should fail for empty name');
    assertEqual(result1.error, 'Please enter a preset name', 'Should have correct error');

    const result2 = simulateSavePreset('   ', '', 'settings', null);
    assert(!result2.success, 'Should fail for whitespace name');
  });

  // Test 6: Manage presets list shows all presets
  await runTest('Manage presets list shows all presets', async () => {
    createCustomPreset({ name: 'Custom A' });
    createCustomPreset({ name: 'Custom B' });

    const items = simulateRenderPresetsList();
    const builtIn = items.filter(i => i.isBuiltIn);
    const custom = items.filter(i => !i.isBuiltIn);

    assertEqual(builtIn.length, 6, 'Should have 6 built-in');
    assert(builtIn.every(i => !i.hasEditButton), 'Built-in should not have edit button');
    assert(builtIn.every(i => !i.hasDeleteButton), 'Built-in should not have delete button');

    assert(custom.length >= 2, 'Should have at least 2 custom');
    assert(custom.every(i => i.hasEditButton), 'Custom should have edit button');
    assert(custom.every(i => i.hasDeleteButton), 'Custom should have delete button');
  });

  // Test 7: Delete from manage modal updates list
  await runTest('Delete from manage modal updates list', async () => {
    const create = createCustomPreset({ name: 'Delete From Modal' });

    let items = simulateRenderPresetsList();
    const beforeCount = items.length;

    deleteCustomPreset(create.id);

    items = simulateRenderPresetsList();
    assertEqual(items.length, beforeCount - 1, 'Should have one less item');
    assert(!items.some(i => i.id === create.id), 'Deleted preset should not appear');
  });

  // Test 8: Dropdown preserves selection after refresh
  await runTest('Dropdown preserves selection after refresh', async () => {
    const create = createCustomPreset({ name: 'Selected Preset' });

    // Simulate: user selects this preset
    let currentSelection = create.id;

    // Create another preset (would trigger refresh in UI)
    createCustomPreset({ name: 'Another Preset' });

    const options = simulateRefreshDropdown();
    const selectedExists = options.some(o => o.value === currentSelection);

    assert(selectedExists, 'Previously selected preset should still exist');
  });

  // Test 9: Preset selection applies settings correctly
  await runTest('Preset selection applies custom settings', async () => {
    const create = createCustomPreset({
      name: 'Settings Test',
      settings: { sensitivity: 75, enableTakesDetection: false }
    });

    const preset = getPresetById(create.id);
    assertEqual(preset.settings.sensitivity, 75, 'Should have custom sensitivity');
    assertEqual(preset.settings.enableTakesDetection, false, 'Should have custom takes setting');
  });

  // Test 10: Full UI workflow simulation
  await runTest('Full UI workflow: create, edit, delete', async () => {
    // 1. User clicks "+" to save current settings
    const create = simulateSavePreset('Workflow Preset', 'Initial', 'bolt', null);
    assert(create.success, 'Create should succeed');

    // 2. Dropdown is refreshed
    let options = simulateRefreshDropdown();
    assert(options.some(o => o.value === create.id), 'New preset should appear in dropdown');

    // 3. User opens manage modal and clicks edit
    let items = simulateRenderPresetsList();
    const presetItem = items.find(i => i.id === create.id);
    assert(presetItem.hasEditButton, 'Preset should have edit button');

    // 4. User edits the preset
    const edit = simulateSavePreset('Renamed Preset', 'Updated', 'heart', create.id);
    assert(edit.success, 'Edit should succeed');

    // 5. Verify changes
    const updated = getPresetById(create.id);
    assertEqual(updated.name, 'Renamed Preset', 'Name should be updated');

    // 6. User deletes the preset
    deleteCustomPreset(create.id);

    // 7. Verify deletion
    options = simulateRefreshDropdown();
    assert(!options.some(o => o.value === create.id), 'Deleted preset should not appear');
  });
}

// =============================================================================
// MAIN TEST RUNNER
// =============================================================================

async function runAllTests() {
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ§ª Custom Presets E2E Tests - Phase 1 & 2');
  console.log('='.repeat(60));

  await testFeature1_1();
  await testFeature1_2();
  await testFeature1_3();
  await testFeature1_4();
  await testFeature1_5();
  await testPhase1Integration();
  await testPhase2UI();

  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ“Š Test Summary');
  console.log('='.repeat(60));
  console.log(`  Total: ${testsPassed + testsFailed}`);
  console.log(`  Passed: ${testsPassed}`);
  console.log(`  Failed: ${testsFailed}`);
  console.log(`  Duration: ${Date.now() - startTime}ms`);

  if (testsFailed > 0) {
    console.log('\nâŒ Some tests failed!');
    process.exit(1);
  } else {
    console.log('\nâœ… All tests passed!');
    process.exit(0);
  }
}

// Restore console.warn at the end
process.on('exit', () => {
  console.warn = originalWarn;
});

runAllTests().catch(err => {
  console.error('Test runner error:', err);
  process.exit(1);
});
