"""
Side Profile Analyzer
Calculates facial geometry measurements from 2D landmarks for side profile analysis.

Based on medical/anthropometric standards:
- Farkas LG (1994) - Anthropometry of the Head and Face
- Ricketts RM (1968) - The Esthetic E-Plane
- Steiner CC (1959) - Cephalometrics for You and Me
"""

import math
from typing import Dict, Tuple, Optional, NamedTuple


class Point(NamedTuple):
    """A 2D point with x and y coordinates."""
    x: float
    y: float


class AngleResult(NamedTuple):
    """Result of an angular measurement."""
    name: str
    value: float
    unit: str = "°"


class LineDistanceResult(NamedTuple):
    """Result of a distance-to-line measurement."""
    name: str
    upper_lip_distance: float
    lower_lip_distance: float
    unit: str = "mm"


class SideProfileAnalyzer:
    """
    Analyzes side profile facial landmarks to calculate medical/aesthetic metrics.

    Expected landmark dictionary keys:
        Angular measurements require:
        - columella: Base of the nose (columella point)
        - subnasale: Point below the nose where columella meets upper lip
        - labrale_superius: Upper lip point
        - glabella: Point between the eyebrows on forehead
        - nasion: Bridge of nose (deepest point at nasal root)
        - pronasale: Tip of the nose
        - supratip: Point on nose dorsum above the tip
        - gonion: Corner/angle of the jaw
        - arion: Top of jaw near ear attachment (or use tragus)
        - menton: Bottom of chin (lowest point)
        - labrale_inferius: Lower lip point
        - supramentale: Dip between lower lip and chin (also called point B)
        - pogonion: Most anterior point of chin

        Line measurements require:
        - pronasale: Tip of nose
        - pogonion: Chin tip
        - subnasale: Base of nose (for S-line midpoint calculation)
        - columella: Columella point (for S-line midpoint calculation)
        - labrale_superius: Upper lip
        - labrale_inferius: Lower lip
    """

    def __init__(self, landmarks: Dict[str, Tuple[float, float]]):
        """
        Initialize analyzer with facial landmarks.

        Args:
            landmarks: Dictionary mapping landmark names to (x, y) coordinate tuples.
                       Example: {'nasion': (100.5, 200.3), 'pronasale': (150.2, 250.7), ...}
        """
        self.landmarks = {k: Point(v[0], v[1]) for k, v in landmarks.items()}

    # =========================================================================
    # HELPER FUNCTIONS
    # =========================================================================

    @staticmethod
    def get_angle(p1: Point, vertex: Point, p3: Point) -> float:
        """
        Calculate the angle at the vertex point formed by three points.

        Uses the dot product formula:
        cos(θ) = (v1 · v2) / (|v1| * |v2|)

        Args:
            p1: First point (one end of angle)
            vertex: The vertex point (where angle is measured)
            p3: Third point (other end of angle)

        Returns:
            Angle in degrees (0-180)
        """
        # Create vectors from vertex to each point
        v1 = Point(p1.x - vertex.x, p1.y - vertex.y)
        v2 = Point(p3.x - vertex.x, p3.y - vertex.y)

        # Calculate dot product
        dot_product = v1.x * v2.x + v1.y * v2.y

        # Calculate magnitudes
        mag1 = math.sqrt(v1.x ** 2 + v1.y ** 2)
        mag2 = math.sqrt(v2.x ** 2 + v2.y ** 2)

        # Avoid division by zero
        if mag1 < 1e-10 or mag2 < 1e-10:
            return 0.0

        # Calculate cosine of angle, clamp to [-1, 1] to handle floating point errors
        cos_angle = max(-1.0, min(1.0, dot_product / (mag1 * mag2)))

        # Convert to degrees
        angle_rad = math.acos(cos_angle)
        angle_deg = math.degrees(angle_rad)

        return angle_deg

    @staticmethod
    def get_angle_atan2(p1: Point, vertex: Point, p3: Point) -> float:
        """
        Calculate the angle at vertex using atan2 (alternative method).

        This method calculates the angle by finding the direction of each
        vector from the vertex and computing the difference.

        Args:
            p1: First point
            vertex: The vertex point
            p3: Third point

        Returns:
            Angle in degrees (0-360, but typically 0-180 for facial angles)
        """
        # Calculate angles of each vector from vertex
        angle1 = math.atan2(p1.y - vertex.y, p1.x - vertex.x)
        angle2 = math.atan2(p3.y - vertex.y, p3.x - vertex.x)

        # Calculate the difference
        angle_diff = abs(angle1 - angle2)

        # Convert to degrees
        angle_deg = math.degrees(angle_diff)

        # Normalize to 0-180 range
        if angle_deg > 180:
            angle_deg = 360 - angle_deg

        return angle_deg

    @staticmethod
    def distance_to_line(point: Point, line_start: Point, line_end: Point) -> float:
        """
        Calculate the perpendicular (signed) distance from a point to a line.

        Uses the formula:
        d = ((y2-y1)*px - (x2-x1)*py + x2*y1 - y2*x1) / sqrt((y2-y1)^2 + (x2-x1)^2)

        The sign indicates which side of the line the point is on:
        - Positive: point is to the left of the line (when facing from start to end)
        - Negative: point is to the right of the line

        For facial analysis (E-line, S-line):
        - Negative values typically mean the lip is behind the line (recessed)
        - Positive values mean the lip protrudes past the line

        Args:
            point: The point to measure from
            line_start: Start point of the reference line
            line_end: End point of the reference line

        Returns:
            Signed perpendicular distance (in same units as input coordinates)
        """
        x1, y1 = line_start.x, line_start.y
        x2, y2 = line_end.x, line_end.y
        px, py = point.x, point.y

        # Calculate the length of the line
        line_length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

        # Avoid division by zero
        if line_length < 1e-10:
            return 0.0

        # Calculate signed distance using cross product method
        # The formula gives positive values for points on the left side of the line
        distance = ((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / line_length

        return distance

    @staticmethod
    def euclidean_distance(p1: Point, p2: Point) -> float:
        """Calculate Euclidean distance between two points."""
        return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)

    @staticmethod
    def midpoint(p1: Point, p2: Point) -> Point:
        """Calculate midpoint between two points."""
        return Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)

    def _get_landmark(self, name: str) -> Optional[Point]:
        """Safely get a landmark, returning None if not found."""
        return self.landmarks.get(name)

    # =========================================================================
    # ANGULAR MEASUREMENTS
    # =========================================================================

    def nasolabial_angle(self) -> Optional[AngleResult]:
        """
        Calculate the Nasolabial Angle.

        Definition: The angle between the Columella (base of nose) and the Upper Lip,
                   measured at the Subnasale point.

        Ideal range: 90-105° (Farkas standard)
        - Males: typically 90-95°
        - Females: typically 95-105°

        Clinical significance:
        - Angle < 90°: Acute angle, may indicate nasal tip over-rotation
        - Angle > 110°: Obtuse angle, may indicate nasal tip under-rotation

        Returns:
            AngleResult with angle in degrees, or None if landmarks missing
        """
        columella = self._get_landmark('columella')
        subnasale = self._get_landmark('subnasale')
        labrale_superius = self._get_landmark('labrale_superius')

        if not all([columella, subnasale, labrale_superius]):
            return None

        angle = self.get_angle(columella, subnasale, labrale_superius)
        return AngleResult(name="Nasolabial Angle", value=angle)

    def nasofrontal_angle(self) -> Optional[AngleResult]:
        """
        Calculate the Nasofrontal Angle.

        Definition: The angle between the Forehead (Glabella), Nasion (bridge),
                   and the Nose dorsum (towards the tip).

        Ideal range: 130-140° (Powell & Humphreys standard)
        Some sources cite 115-135°

        Clinical significance:
        - This angle defines the "break" between forehead and nose
        - A well-defined nasofrontal angle contributes to aesthetic nasal profile
        - Angle too shallow: nose appears to flow directly from forehead
        - Angle too acute: over-defined nasion region

        Returns:
            AngleResult with angle in degrees, or None if landmarks missing
        """
        glabella = self._get_landmark('glabella')
        nasion = self._get_landmark('nasion')
        # Use supratip or pronasale for the nose dorsum direction
        nose_point = self._get_landmark('supratip') or self._get_landmark('pronasale')

        if not all([glabella, nasion, nose_point]):
            return None

        angle = self.get_angle(glabella, nasion, nose_point)
        return AngleResult(name="Nasofrontal Angle", value=angle)

    def gonial_angle(self) -> Optional[AngleResult]:
        """
        Calculate the Gonial Angle (Jaw Angle).

        Definition: The angle between the Arion (top of jaw/ear area),
                   Gonion (corner of jaw), and Menton (bottom of chin).

        Ideal range: 113-123° (some sources cite 120-130°)
        - Males: typically 120-125°
        - Females: typically 125-130°

        Clinical significance:
        - Low gonial angle (< 120°): Strong, square jaw appearance
        - High gonial angle (> 135°): Weaker jaw definition
        - This angle affects facial harmony and is key in orthognathic assessment

        Returns:
            AngleResult with angle in degrees, or None if landmarks missing
        """
        # Arion is at top of jaw near ear; can substitute with tragus or gonion_top
        arion = (self._get_landmark('arion') or
                 self._get_landmark('tragus') or
                 self._get_landmark('gonion_top'))
        gonion = self._get_landmark('gonion')
        menton = self._get_landmark('menton')

        if not all([arion, gonion, menton]):
            return None

        angle = self.get_angle(arion, gonion, menton)
        return AngleResult(name="Gonial Angle", value=angle)

    def mentolabial_angle(self) -> Optional[AngleResult]:
        """
        Calculate the Mentolabial Angle.

        Definition: The angle between the Lower Lip, Supramentale (labiomental fold/
                   dip above chin), and Pogonion (chin tip).

        Ideal range: 80-120° (varies by source)
        Some cite 100-130° as ideal

        Clinical significance:
        - Acute angle (< 80°): Deep labiomental fold, may indicate chin retrusion
        - Obtuse angle (> 130°): Shallow fold, may indicate chin protrusion
        - This angle is important for lower face aesthetics

        Returns:
            AngleResult with angle in degrees, or None if landmarks missing
        """
        labrale_inferius = self._get_landmark('labrale_inferius')
        supramentale = self._get_landmark('supramentale')  # Also called "point B"
        pogonion = self._get_landmark('pogonion')

        if not all([labrale_inferius, supramentale, pogonion]):
            return None

        angle = self.get_angle(labrale_inferius, supramentale, pogonion)
        return AngleResult(name="Mentolabial Angle", value=angle)

    # =========================================================================
    # LINE MEASUREMENTS
    # =========================================================================

    def ricketts_e_line(self) -> Optional[LineDistanceResult]:
        """
        Calculate lip distances to Ricketts E-Line (Esthetic Line).

        Definition: A line connecting the Tip of Nose (Pronasale) to the
                   Chin tip (Pogonion). Measures perpendicular distance of
                   upper and lower lips to this line.

        Ideal values (Ricketts standard):
        - Upper lip: -4mm (4mm behind the line)
        - Lower lip: -2mm (2mm behind the line)

        Clinical significance:
        - Positive values: Lips protrude past the E-line
        - Negative values: Lips are behind the E-line (typical for Caucasians)
        - African/Asian populations may have different norms
        - Used to assess lip prominence and profile balance

        Returns:
            LineDistanceResult with upper and lower lip distances,
            or None if landmarks missing
        """
        pronasale = self._get_landmark('pronasale')
        pogonion = self._get_landmark('pogonion')
        labrale_superius = self._get_landmark('labrale_superius')
        labrale_inferius = self._get_landmark('labrale_inferius')

        if not all([pronasale, pogonion, labrale_superius, labrale_inferius]):
            return None

        # Calculate perpendicular distances to E-line
        upper_lip_dist = self.distance_to_line(labrale_superius, pronasale, pogonion)
        lower_lip_dist = self.distance_to_line(labrale_inferius, pronasale, pogonion)

        return LineDistanceResult(
            name="Ricketts E-Line",
            upper_lip_distance=upper_lip_dist,
            lower_lip_distance=lower_lip_dist
        )

    def steiner_s_line(self) -> Optional[LineDistanceResult]:
        """
        Calculate lip distances to Steiner S-Line.

        Definition: A line connecting the Midpoint of the Nose base
                   (between Subnasale and Columella) to the Pogonion (Chin tip).
                   Measures perpendicular distance of lips to this line.

        Ideal values (Steiner standard):
        - Upper lip: Should touch or be within 0-2mm of the line
        - Lower lip: Should touch or be within 0-2mm of the line

        Clinical significance:
        - S-line is less affected by nasal tip variations than E-line
        - Provides a more stable reference for lip position assessment
        - Both lips ideally touch or nearly touch the S-line

        Returns:
            LineDistanceResult with upper and lower lip distances,
            or None if landmarks missing
        """
        subnasale = self._get_landmark('subnasale')
        columella = self._get_landmark('columella')
        pogonion = self._get_landmark('pogonion')
        labrale_superius = self._get_landmark('labrale_superius')
        labrale_inferius = self._get_landmark('labrale_inferius')

        if not all([pogonion, labrale_superius, labrale_inferius]):
            return None

        # Calculate midpoint of nose base
        if subnasale and columella:
            nose_base_midpoint = self.midpoint(subnasale, columella)
        elif subnasale:
            nose_base_midpoint = subnasale
        elif columella:
            nose_base_midpoint = columella
        else:
            return None

        # Calculate perpendicular distances to S-line
        upper_lip_dist = self.distance_to_line(labrale_superius, nose_base_midpoint, pogonion)
        lower_lip_dist = self.distance_to_line(labrale_inferius, nose_base_midpoint, pogonion)

        return LineDistanceResult(
            name="Steiner S-Line",
            upper_lip_distance=upper_lip_dist,
            lower_lip_distance=lower_lip_dist
        )

    # =========================================================================
    # COMPREHENSIVE ANALYSIS
    # =========================================================================

    def analyze_all(self) -> Dict[str, Optional[AngleResult | LineDistanceResult]]:
        """
        Run all available side profile measurements.

        Returns:
            Dictionary with all measurement results
        """
        return {
            'nasolabial_angle': self.nasolabial_angle(),
            'nasofrontal_angle': self.nasofrontal_angle(),
            'gonial_angle': self.gonial_angle(),
            'mentolabial_angle': self.mentolabial_angle(),
            'ricketts_e_line': self.ricketts_e_line(),
            'steiner_s_line': self.steiner_s_line(),
        }

    def get_summary(self) -> str:
        """
        Generate a human-readable summary of all measurements.

        Returns:
            Formatted string with all measurement results
        """
        results = self.analyze_all()
        lines = ["=" * 50, "SIDE PROFILE ANALYSIS RESULTS", "=" * 50, ""]

        lines.append("ANGULAR MEASUREMENTS:")
        lines.append("-" * 30)

        for key in ['nasolabial_angle', 'nasofrontal_angle', 'gonial_angle', 'mentolabial_angle']:
            result = results[key]
            if result:
                lines.append(f"  {result.name}: {result.value:.1f}{result.unit}")
            else:
                lines.append(f"  {key.replace('_', ' ').title()}: N/A (missing landmarks)")

        lines.append("")
        lines.append("LINE MEASUREMENTS:")
        lines.append("-" * 30)

        for key in ['ricketts_e_line', 'steiner_s_line']:
            result = results[key]
            if result:
                lines.append(f"  {result.name}:")
                lines.append(f"    Upper Lip: {result.upper_lip_distance:+.2f} {result.unit}")
                lines.append(f"    Lower Lip: {result.lower_lip_distance:+.2f} {result.unit}")
            else:
                lines.append(f"  {key.replace('_', ' ').title()}: N/A (missing landmarks)")

        lines.append("")
        lines.append("=" * 50)

        return "\n".join(lines)


# =============================================================================
# USAGE EXAMPLE
# =============================================================================

if __name__ == "__main__":
    # Example landmark data (coordinates would come from your detection model)
    # These are placeholder values - real values come from landmark detection
    example_landmarks = {
        # Nose landmarks
        'glabella': (150, 100),        # Between eyebrows
        'nasion': (155, 130),          # Bridge of nose
        'supratip': (165, 170),        # Above nose tip on dorsum
        'pronasale': (180, 190),       # Nose tip
        'columella': (170, 200),       # Columella (base of nose)
        'subnasale': (160, 205),       # Below nose

        # Lip landmarks
        'labrale_superius': (155, 220),  # Upper lip
        'labrale_inferius': (155, 240),  # Lower lip

        # Chin landmarks
        'supramentale': (150, 260),    # Labiomental fold (Point B)
        'pogonion': (155, 290),        # Chin tip
        'menton': (150, 310),          # Bottom of chin

        # Jaw landmarks
        'gonion': (100, 270),          # Jaw angle
        'arion': (90, 200),            # Top of jaw near ear
    }

    # Create analyzer
    analyzer = SideProfileAnalyzer(example_landmarks)

    # Run individual measurements
    print("Individual Measurements:")
    print("-" * 40)

    nasolabial = analyzer.nasolabial_angle()
    if nasolabial:
        print(f"Nasolabial Angle: {nasolabial.value:.1f}°")

    nasofrontal = analyzer.nasofrontal_angle()
    if nasofrontal:
        print(f"Nasofrontal Angle: {nasofrontal.value:.1f}°")

    gonial = analyzer.gonial_angle()
    if gonial:
        print(f"Gonial Angle: {gonial.value:.1f}°")

    mentolabial = analyzer.mentolabial_angle()
    if mentolabial:
        print(f"Mentolabial Angle: {mentolabial.value:.1f}°")

    e_line = analyzer.ricketts_e_line()
    if e_line:
        print(f"E-Line Upper Lip: {e_line.upper_lip_distance:+.2f} mm")
        print(f"E-Line Lower Lip: {e_line.lower_lip_distance:+.2f} mm")

    s_line = analyzer.steiner_s_line()
    if s_line:
        print(f"S-Line Upper Lip: {s_line.upper_lip_distance:+.2f} mm")
        print(f"S-Line Lower Lip: {s_line.lower_lip_distance:+.2f} mm")

    print("\n")

    # Or get full summary
    print(analyzer.get_summary())
