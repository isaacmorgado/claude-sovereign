/**
 * SPLICE Zoom Generator Service
 *
 * Generates zoom keyframe data for cut list integration.
 * Uses adjustment layers for non-destructive zoom effects.
 *
 * Features:
 * - Preset-based zoom intensity (subtle/medium/dramatic)
 * - Configurable frequency (zooms per minute)
 * - Smart placement at emphasis points (sentence starts, keywords)
 * - Easing curves for smooth animation (power-based)
 */

// Zoom intensity presets
const ZOOM_PRESETS = {
  subtle: { scale: 110, duration: 0.6, easing: 2 },
  medium: { scale: 120, duration: 0.8, easing: 3 },
  dramatic: { scale: 140, duration: 1.0, easing: 4 }
};

// Zoom frequency options (seconds between zooms)
const ZOOM_FREQUENCIES = {
  low: 60,      // ~1 per minute
  medium: 30,   // ~2 per minute
  high: 15      // ~4 per minute
};

// Placement strategies
const PLACEMENT_STRATEGIES = {
  sentence_start: 'sentence_start',
  keywords: 'keywords',
  random: 'random',
  speaker_change: 'speaker_change'
};

/**
 * Generate zoom points from transcript
 * @param {Object} transcript - Transcript with words and segments
 * @param {Object} settings - Zoom generation settings
 * @returns {Array} Array of zoom point objects
 */
function generateZoomPoints(transcript, settings = {}) {
  const {
    frequency = 'medium',
    preset = 'medium',
    placement = 'sentence_start',
    minGap = 5,           // Minimum seconds between zooms
    maxZooms = 50,        // Maximum total zooms
    excludeFirstSeconds = 3,  // Don't zoom in first N seconds
    excludeLastSeconds = 2    // Don't zoom in last N seconds
  } = settings;

  if (!transcript || (!transcript.words && !transcript.segments)) {
    console.log('[SPLICE Zoom] No transcript data, returning empty zoom points');
    return [];
  }

  const zoomPoints = [];
  const presetConfig = ZOOM_PRESETS[preset] || ZOOM_PRESETS.medium;
  const intervalSeconds = ZOOM_FREQUENCIES[frequency] || 30;

  // Get transcript duration
  const duration = transcript.duration ||
    (transcript.words?.length > 0 ? transcript.words[transcript.words.length - 1].end : 0) ||
    (transcript.segments?.length > 0 ? transcript.segments[transcript.segments.length - 1].end : 0);

  if (duration <= 0) {
    console.log('[SPLICE Zoom] No duration found, returning empty');
    return [];
  }

  // Find emphasis points based on placement strategy
  const emphasisPoints = findEmphasisPoints(transcript, placement, duration);

  // Filter and select zoom points based on frequency
  let lastZoomTime = -Infinity;

  for (const point of emphasisPoints) {
    // Skip points too close to start/end
    if (point.time < excludeFirstSeconds) continue;
    if (point.time > duration - excludeLastSeconds) continue;

    // Enforce minimum gap between zooms
    if (point.time - lastZoomTime < Math.max(minGap, intervalSeconds)) continue;

    // Create zoom point
    zoomPoints.push({
      type: 'zoom',
      startTime: parseFloat(point.time.toFixed(3)),
      duration: presetConfig.duration,
      scale: presetConfig.scale,
      easing: presetConfig.easing,
      centerPoint: point.center || { x: 0.5, y: 0.5 },
      reason: point.reason || 'emphasis'
    });

    lastZoomTime = point.time;

    // Limit total zooms
    if (zoomPoints.length >= maxZooms) break;
  }

  console.log(`[SPLICE Zoom] Generated ${zoomPoints.length} zoom points (${frequency}/${preset})`);

  return zoomPoints;
}

/**
 * Find emphasis points in transcript based on placement strategy
 * @param {Object} transcript - Transcript data
 * @param {string} placement - Placement strategy
 * @param {number} duration - Total duration
 * @returns {Array} Array of emphasis points
 */
function findEmphasisPoints(transcript, placement, duration) {
  const points = [];

  switch (placement) {
    case 'sentence_start':
      return findSentenceStarts(transcript);

    case 'keywords':
      return findKeywordPositions(transcript);

    case 'speaker_change':
      return findSpeakerChanges(transcript);

    case 'random':
    default:
      return generateRandomPoints(duration);
  }
}

/**
 * Find sentence start positions
 * @param {Object} transcript - Transcript with words
 * @returns {Array} Emphasis points at sentence starts
 */
function findSentenceStarts(transcript) {
  const points = [];
  const words = transcript.words || [];

  // Sentence ending punctuation
  const sentenceEnders = /[.!?]/;

  // First word is always a sentence start
  if (words.length > 0) {
    points.push({
      time: words[0].start || 0,
      reason: 'sentence_start',
      center: { x: 0.5, y: 0.5 }
    });
  }

  // Find words after sentence-ending punctuation
  for (let i = 0; i < words.length - 1; i++) {
    const word = words[i].word || '';

    if (sentenceEnders.test(word)) {
      const nextWord = words[i + 1];
      if (nextWord && nextWord.start !== undefined) {
        points.push({
          time: nextWord.start,
          reason: 'sentence_start',
          center: { x: 0.5, y: 0.5 }
        });
      }
    }
  }

  return points;
}

/**
 * Find keyword positions (emphasis words)
 * @param {Object} transcript - Transcript with words
 * @returns {Array} Emphasis points at keywords
 */
function findKeywordPositions(transcript) {
  const points = [];
  const words = transcript.words || [];

  // Keywords that often deserve emphasis
  const emphasisWords = new Set([
    'important', 'key', 'critical', 'essential', 'crucial',
    'amazing', 'incredible', 'awesome', 'fantastic', 'wonderful',
    'problem', 'solution', 'answer', 'question', 'reason',
    'first', 'second', 'third', 'finally', 'lastly',
    'however', 'therefore', 'because', 'although', 'moreover',
    'never', 'always', 'must', 'should', 'absolutely',
    'love', 'hate', 'best', 'worst', 'favorite'
  ]);

  for (const word of words) {
    const normalized = (word.word || '').toLowerCase().replace(/[^a-z]/g, '');

    if (emphasisWords.has(normalized) && word.start !== undefined) {
      points.push({
        time: word.start,
        reason: `keyword:${normalized}`,
        center: { x: 0.5, y: 0.5 }
      });
    }
  }

  return points;
}

/**
 * Find speaker change positions (for multicam)
 * @param {Object} transcript - Transcript with segments
 * @returns {Array} Emphasis points at speaker changes
 */
function findSpeakerChanges(transcript) {
  const points = [];
  const segments = transcript.segments || [];

  let lastSpeaker = null;

  for (const segment of segments) {
    const speaker = segment.speaker || segment.speakerId;

    if (speaker && speaker !== lastSpeaker && segment.start !== undefined) {
      points.push({
        time: segment.start,
        reason: `speaker_change:${speaker}`,
        center: { x: 0.5, y: 0.5 }
      });
      lastSpeaker = speaker;
    }
  }

  return points;
}

/**
 * Generate random zoom points
 * @param {number} duration - Total duration
 * @returns {Array} Random emphasis points
 */
function generateRandomPoints(duration) {
  const points = [];
  const numPoints = Math.floor(duration / 20); // Roughly 3 per minute

  for (let i = 0; i < numPoints; i++) {
    const time = (Math.random() * 0.8 + 0.1) * duration; // 10-90% of duration
    points.push({
      time,
      reason: 'random',
      center: { x: 0.5, y: 0.5 }
    });
  }

  // Sort by time
  points.sort((a, b) => a.time - b.time);

  return points;
}

/**
 * Calculate easing curve value
 * Uses power-based easing for smooth acceleration/deceleration
 * @param {number} t - Progress (0-1)
 * @param {number} power - Easing power (higher = more aggressive)
 * @returns {number} Eased value (0-1)
 */
function easingCurve(t, power) {
  const coefficient = Math.pow(2, power - 1);
  return (1 - Math.pow(2, -power * t)) / coefficient;
}

/**
 * Generate keyframes for a zoom animation
 * @param {Object} zoom - Zoom point configuration
 * @param {number} frameRate - Frame rate (default 30)
 * @returns {Array} Array of keyframe objects
 */
function generateZoomKeyframes(zoom, frameRate = 30) {
  const keyframes = [];
  const frameCount = Math.ceil(zoom.duration * frameRate);

  for (let i = 0; i <= frameCount; i++) {
    const t = i / frameCount;

    // Zoom in during first half, zoom out during second half
    let scale;
    if (t < 0.5) {
      // Zoom in: 100% -> peak
      const easedT = easingCurve(t * 2, zoom.easing);
      scale = 100 + (zoom.scale - 100) * easedT;
    } else {
      // Zoom out: peak -> 100%
      const easedT = easingCurve((t - 0.5) * 2, zoom.easing);
      scale = zoom.scale - (zoom.scale - 100) * easedT;
    }

    keyframes.push({
      time: parseFloat((zoom.startTime + (i / frameRate)).toFixed(4)),
      scale: [scale, scale],
      anchor: zoom.centerPoint ? [
        zoom.centerPoint.x * 1920, // Assume 1080p - will be scaled in builder
        zoom.centerPoint.y * 1080
      ] : null
    });
  }

  return keyframes;
}

/**
 * Add zoom data to a cut list
 * @param {Object} cutList - Existing cut list
 * @param {Array} zoomPoints - Zoom points to add
 * @returns {Object} Cut list with zoom data
 */
function addZoomsToCutList(cutList, zoomPoints) {
  if (!zoomPoints || zoomPoints.length === 0) {
    return cutList;
  }

  return {
    ...cutList,
    zooms: zoomPoints,
    metadata: {
      ...cutList.metadata,
      hasZooms: true,
      zoomCount: zoomPoints.length
    }
  };
}

module.exports = {
  generateZoomPoints,
  generateZoomKeyframes,
  addZoomsToCutList,
  easingCurve,
  findEmphasisPoints,
  ZOOM_PRESETS,
  ZOOM_FREQUENCIES,
  PLACEMENT_STRATEGIES
};
