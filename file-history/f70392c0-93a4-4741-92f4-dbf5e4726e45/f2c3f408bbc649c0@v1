/**
 * FaceIQ Parity - Potential Score Calculation
 *
 * Exact implementation of FaceIQ's "Your Potential" and "Your Plan" methodology.
 *
 * FaceIQ uses 4 scoring categories (reverse-engineered):
 * - Harmony: Overall facial proportions and balance
 * - Angularity: Facial leanness, jaw definition, bone structure
 * - Dimorphism: Sex-specific features (masculinity/femininity)
 * - Miscellaneous: Other features (skin, symmetry, etc.)
 *
 * Potential Calculation Formula:
 * 1. Each treatment provides category-specific improvements
 * 2. Category improvements are summed with diminishing returns
 * 3. Total improvement = weighted average of category improvements
 * 4. Potential = current score + total improvement (capped at 7.5)
 *
 * Order of Operations (FaceIQ approach):
 * 1. Softmaxxing (body composition, skincare, posture)
 * 2. Structural corrections (bimax, jaw surgery, rhinoplasty)
 * 3. Refinement procedures (fillers, botox, minor tweaks)
 */

// ============================================
// FACEIQ CATEGORY SYSTEM
// ============================================

/**
 * FaceIQ's 4 scoring categories
 */
export type FaceIQCategory = 'harmony' | 'angularity' | 'dimorphism' | 'miscellaneous';

/**
 * Category weights for overall score calculation
 * Based on FaceIQ's scoring distribution
 */
export const FACEIQ_CATEGORY_WEIGHTS: Record<FaceIQCategory, number> = {
  harmony: 0.35,      // 35% weight - most important
  angularity: 0.25,   // 25% weight
  dimorphism: 0.25,   // 25% weight
  miscellaneous: 0.15 // 15% weight
};

/**
 * Map our existing pillars to FaceIQ categories
 */
export const PILLAR_TO_FACEIQ_CATEGORY: Record<string, FaceIQCategory> = {
  // Harmony mappings
  'harmony': 'harmony',
  'profile': 'harmony',
  'symmetry': 'harmony',
  'youthfulness': 'harmony',
  'natural': 'harmony',
  'ethnicity_specific': 'harmony',

  // Angularity mappings
  'angularity': 'angularity',
  'bone_structure': 'angularity',
  'definition': 'angularity',
  'neck': 'angularity',
  'posture': 'angularity',
  'long_term': 'angularity',

  // Dimorphism mappings
  'masculinity': 'dimorphism',
  'femininity': 'dimorphism',
  'upper_third': 'dimorphism',
  'lip_area': 'dimorphism',

  // Miscellaneous mappings
  'alertness': 'miscellaneous',
  'eye_area': 'miscellaneous',
  'breathing': 'miscellaneous',
  'function': 'miscellaneous',
  'non_invasive': 'miscellaneous',
  'volume': 'miscellaneous',
  'camouflage': 'miscellaneous',
};

/**
 * Category impact configuration for each treatment category
 * Based on FaceIQ's observed behavior
 */
export const TREATMENT_CATEGORY_IMPACT_MULTIPLIERS: Record<string, Partial<Record<FaceIQCategory, number>>> = {
  // Lifestyle treatments (softmaxxing foundation)
  'lifestyle': {
    harmony: 1.0,
    angularity: 1.5,  // Body fat affects angularity most
    dimorphism: 0.8,
    miscellaneous: 0.5
  },

  // Softmaxxing treatments
  'softmaxxing': {
    harmony: 0.8,
    angularity: 1.2,
    dimorphism: 0.6,
    miscellaneous: 1.0
  },

  // Non-surgical treatments
  'non_surgical': {
    harmony: 0.6,
    angularity: 0.8,
    dimorphism: 0.5,
    miscellaneous: 0.8
  },

  // Minimally invasive treatments
  'minimally_invasive': {
    harmony: 1.0,
    angularity: 1.0,
    dimorphism: 0.8,
    miscellaneous: 0.6
  },

  // Surgical treatments
  'surgical': {
    harmony: 1.2,
    angularity: 1.3,
    dimorphism: 1.5,  // Surgery has most dimorphic impact
    miscellaneous: 0.4
  }
};

// ============================================
// TREATMENT CATEGORY IMPACTS
// ============================================

/**
 * Category impact values for common treatments
 * Format: { categoryImpact: { category: points } }
 *
 * Based on FaceIQ's observed improvement calculations:
 * - Body fat loss (25%â†’15%): +4 angularity, +1 harmony, +1 dimorphism
 * - Rhinoplasty: +1-2 harmony, +0.5 dimorphism
 * - Jaw surgery: +2-3 angularity, +1-2 dimorphism, +1 harmony
 */
export interface TreatmentCategoryImpact {
  harmony?: number;
  angularity?: number;
  dimorphism?: number;
  miscellaneous?: number;
}

/**
 * FaceIQ-style category impacts per treatment
 * Points range: 0.1 to 5.0 per category
 */
export const FACEIQ_TREATMENT_IMPACTS: Record<string, TreatmentCategoryImpact> = {
  // ============================================
  // LIFESTYLE / SOFTMAXXING
  // ============================================
  'body_recomposition': {
    angularity: 4.0,    // Major angularity impact (body fat loss)
    harmony: 1.0,
    dimorphism: 1.5,    // Leanness is dimorphic
    miscellaneous: 0.5
  },
  'mewing': {
    angularity: 1.0,
    dimorphism: 0.5,
    harmony: 0.3
  },
  'posture_correction': {
    harmony: 0.5,
    angularity: 0.8,
    dimorphism: 0.3
  },
  'skincare_routine': {
    miscellaneous: 1.5,
    harmony: 0.5
  },
  'beard_growth': {
    dimorphism: 1.5,    // Highly dimorphic for males
    angularity: 0.5,
    harmony: 0.3
  },
  'minoxidil_hair': {
    miscellaneous: 1.0,
    harmony: 0.3
  },

  // ============================================
  // NON-SURGICAL
  // ============================================
  'tretinoin': {
    miscellaneous: 1.0,
    harmony: 0.3
  },
  'dermarolling': {
    miscellaneous: 0.8
  },
  'teeth_whitening': {
    miscellaneous: 0.8,
    harmony: 0.2
  },

  // ============================================
  // MINIMALLY INVASIVE
  // ============================================
  'jaw_fillers': {
    angularity: 1.5,
    dimorphism: 1.0,
    harmony: 0.5
  },
  'chin_filler': {
    harmony: 1.2,
    angularity: 1.0,
    dimorphism: 0.8
  },
  'cheekbone_fillers': {
    harmony: 1.0,
    angularity: 0.8,
    dimorphism: 0.5
  },
  'lip_filler': {
    harmony: 0.5,
    dimorphism: 0.5,
    miscellaneous: 0.3
  },
  'masseter_botox': {
    angularity: 1.0,
    dimorphism: 0.8,    // More feminine (slimmer jaw)
    harmony: 0.3
  },
  'kybella': {
    angularity: 2.0,
    harmony: 0.8,
    dimorphism: 0.5
  },
  'pdo_thread_lift': {
    harmony: 0.8,
    angularity: 0.5,
    miscellaneous: 0.3
  },
  'tear_trough_filler': {
    miscellaneous: 0.8,
    harmony: 0.4
  },
  'brow_botox': {
    miscellaneous: 0.5,
    harmony: 0.3
  },

  // ============================================
  // SURGICAL - MAJOR IMPACT
  // ============================================
  'genioplasty': {
    harmony: 2.5,
    angularity: 2.0,
    dimorphism: 1.5
  },
  'chin_implant': {
    harmony: 2.0,
    angularity: 1.8,
    dimorphism: 1.2
  },
  'jaw_implants': {
    angularity: 3.0,
    dimorphism: 2.5,
    harmony: 1.5
  },
  'rhinoplasty': {
    harmony: 2.0,
    dimorphism: 1.0,
    miscellaneous: 0.5
  },
  'septorhinoplasty': {
    harmony: 2.5,
    dimorphism: 1.2,
    miscellaneous: 1.0   // Breathing improvement
  },
  'bimaxillary_osteotomy': {
    harmony: 3.5,
    angularity: 3.0,
    dimorphism: 2.5,
    miscellaneous: 1.0
  },
  'lefort_1': {
    harmony: 2.5,
    dimorphism: 1.5,
    angularity: 1.0
  },
  'canthoplasty': {
    dimorphism: 1.5,
    harmony: 1.0,
    miscellaneous: 0.5
  },
  'canthopexy': {
    dimorphism: 1.0,
    harmony: 0.8,
    miscellaneous: 0.3
  },
  'brow_bone_reduction': {
    dimorphism: 2.0,    // Major dimorphic impact (feminization)
    harmony: 1.0
  },
  'brow_bone_augmentation': {
    dimorphism: 2.5,    // Major dimorphic impact (masculinization)
    angularity: 1.0,
    harmony: 0.8
  },
  'cheek_implants': {
    harmony: 2.0,
    angularity: 1.5,
    dimorphism: 1.0
  },
  'midface_implants': {
    harmony: 2.5,
    angularity: 1.8,
    dimorphism: 1.2
  },
  'submental_liposuction': {
    angularity: 2.5,
    harmony: 1.2,
    dimorphism: 0.8
  },
  'neck_lift': {
    angularity: 2.0,
    harmony: 1.5,
    miscellaneous: 0.5
  },
  'submentoplasty': {
    angularity: 1.8,
    harmony: 1.0,
    dimorphism: 0.5
  },
  'blepharoplasty': {
    miscellaneous: 1.2,  // Alertness
    harmony: 0.8
  },
  'hair_transplant': {
    harmony: 1.5,
    miscellaneous: 1.0
  },
  'lip_lift': {
    harmony: 1.0,
    dimorphism: 0.8,
    miscellaneous: 0.3
  },
  'v_line_surgery': {
    angularity: 2.0,
    dimorphism: 2.0,    // Major feminization
    harmony: 1.5
  },
  'fat_grafting': {
    harmony: 1.0,
    miscellaneous: 0.8
  },
  'forehead_reduction': {
    harmony: 1.5,
    dimorphism: 1.0
  },
  'ear_pinning': {
    harmony: 0.8,
    miscellaneous: 0.5
  }
};

// ============================================
// POTENTIAL CALCULATION
// ============================================

export interface FaceIQCategoryScores {
  harmony: number;
  angularity: number;
  dimorphism: number;
  miscellaneous: number;
}

export interface FaceIQPotentialResult {
  currentScore: number;
  potentialScore: number;
  totalImprovement: number;
  categoryImprovements: FaceIQCategoryScores;
  categoryScores: {
    current: FaceIQCategoryScores;
    potential: FaceIQCategoryScores;
  };
  appliedTreatments: string[];
  diminishingFactor: number;
}

/**
 * Estimate category scores from overall PSL score
 * FaceIQ derives initial category scores from the overall score
 */
export function estimateCategoryScoresFromPSL(
  pslScore: number,
  gender: 'male' | 'female' = 'male'
): FaceIQCategoryScores {
  // Normalize PSL to 0-10 scale
  const normalizedScore = Math.max(0, Math.min(10, pslScore));

  // Slight variations based on gender
  const genderModifier = gender === 'male' ? 1.0 : 0.95;

  // Base estimates with slight variations
  return {
    harmony: normalizedScore * 0.95,
    angularity: normalizedScore * 0.90 * genderModifier,
    dimorphism: normalizedScore * 0.85 * genderModifier,
    miscellaneous: normalizedScore * 1.0
  };
}

/**
 * Get treatment category impact using FaceIQ methodology
 */
export function getTreatmentImpact(
  treatmentId: string,
  pillars: string[] = []
): TreatmentCategoryImpact {
  // First check if we have explicit FaceIQ impacts
  const explicitImpact = FACEIQ_TREATMENT_IMPACTS[treatmentId];
  if (explicitImpact) {
    return explicitImpact;
  }

  // Fall back to deriving from pillars
  const derivedImpact: TreatmentCategoryImpact = {};

  for (const pillar of pillars) {
    const category = PILLAR_TO_FACEIQ_CATEGORY[pillar];
    if (category) {
      // Add 0.5 points per matching pillar
      derivedImpact[category] = (derivedImpact[category] || 0) + 0.5;
    }
  }

  // If no pillars matched, return minimal impact
  if (Object.keys(derivedImpact).length === 0) {
    return { miscellaneous: 0.3 };
  }

  return derivedImpact;
}

/**
 * FaceIQ's order of operations phases
 */
export type FaceIQPhase = 'softmaxxing' | 'structural' | 'refinement';

/**
 * Map treatment categories to FaceIQ phases
 */
export const TREATMENT_TO_FACEIQ_PHASE: Record<string, FaceIQPhase> = {
  'lifestyle': 'softmaxxing',
  'softmaxxing': 'softmaxxing',
  'non_surgical': 'refinement',
  'minimally_invasive': 'refinement',
  'surgical': 'structural'
};

/**
 * FaceIQ phase order for optimal results
 */
export const FACEIQ_PHASE_ORDER: FaceIQPhase[] = [
  'softmaxxing',   // Foundation - body comp, skincare, posture
  'structural',    // Major surgery - bimax, rhinoplasty, implants
  'refinement'     // Fine-tuning - fillers, botox, minor procedures
];

/**
 * Phase-based diminishing returns multipliers
 * FaceIQ applies more diminishing returns to later treatments
 */
export const FACEIQ_PHASE_DIMINISHING: Record<FaceIQPhase, number> = {
  softmaxxing: 0.90,   // 10% reduction per additional softmax treatment
  structural: 0.75,    // 25% reduction per additional surgery
  refinement: 0.80     // 20% reduction per refinement procedure
};

/**
 * Calculate FaceIQ-style potential score
 *
 * Algorithm:
 * 1. Start with current category scores (derived from PSL)
 * 2. For each treatment (in phase order):
 *    a. Get category impacts
 *    b. Apply phase-specific diminishing returns
 *    c. Add to category improvement totals
 * 3. Calculate new category scores
 * 4. Weight categories to get final potential
 */
export function calculateFaceIQPotential(
  currentPSL: number,
  treatments: Array<{
    id: string;
    category: string;
    pillars?: string[];
    pslImprovement?: { min: number; max: number };
  }>,
  gender: 'male' | 'female' = 'male'
): FaceIQPotentialResult {
  // Validate and clamp current PSL
  const safePSL = Math.max(3.0, Math.min(7.5, currentPSL || 4.5));

  // Initialize current category scores
  const currentCategoryScores = estimateCategoryScoresFromPSL(safePSL, gender);

  // Track category improvements
  const categoryImprovements: FaceIQCategoryScores = {
    harmony: 0,
    angularity: 0,
    dimorphism: 0,
    miscellaneous: 0
  };

  // Group treatments by phase
  const treatmentsByPhase: Record<FaceIQPhase, typeof treatments> = {
    softmaxxing: [],
    structural: [],
    refinement: []
  };

  for (const treatment of treatments) {
    const phase = TREATMENT_TO_FACEIQ_PHASE[treatment.category] || 'refinement';
    treatmentsByPhase[phase].push(treatment);
  }

  // Track applied treatments
  const appliedTreatments: string[] = [];
  let overallDiminishingFactor = 1.0;

  // Process treatments in phase order
  for (const phase of FACEIQ_PHASE_ORDER) {
    const phaseTreatments = treatmentsByPhase[phase];
    const phaseBaseMultiplier = FACEIQ_PHASE_DIMINISHING[phase];

    phaseTreatments.forEach((treatment, index) => {
      // Get treatment's category impact
      const impact = getTreatmentImpact(treatment.id, treatment.pillars);

      // Calculate phase-specific diminishing returns
      const diminishingFactor = Math.pow(phaseBaseMultiplier, index);
      overallDiminishingFactor *= diminishingFactor;

      // Apply impacts to category improvements
      for (const [category, points] of Object.entries(impact)) {
        if (points && category in categoryImprovements) {
          const adjustedPoints = points * diminishingFactor;
          categoryImprovements[category as FaceIQCategory] += adjustedPoints;
        }
      }

      appliedTreatments.push(treatment.id);
    });
  }

  // Cap category improvements (max 4 points per category)
  const cappedImprovements: FaceIQCategoryScores = {
    harmony: Math.min(4.0, categoryImprovements.harmony),
    angularity: Math.min(4.0, categoryImprovements.angularity),
    dimorphism: Math.min(4.0, categoryImprovements.dimorphism),
    miscellaneous: Math.min(3.0, categoryImprovements.miscellaneous)
  };

  // Calculate potential category scores
  const potentialCategoryScores: FaceIQCategoryScores = {
    harmony: Math.min(10, currentCategoryScores.harmony + cappedImprovements.harmony),
    angularity: Math.min(10, currentCategoryScores.angularity + cappedImprovements.angularity),
    dimorphism: Math.min(10, currentCategoryScores.dimorphism + cappedImprovements.dimorphism),
    miscellaneous: Math.min(10, currentCategoryScores.miscellaneous + cappedImprovements.miscellaneous)
  };

  // Calculate weighted total improvement
  let totalImprovement = 0;
  for (const category of Object.keys(FACEIQ_CATEGORY_WEIGHTS) as FaceIQCategory[]) {
    const categoryImprovement = potentialCategoryScores[category] - currentCategoryScores[category];
    totalImprovement += categoryImprovement * FACEIQ_CATEGORY_WEIGHTS[category];
  }

  // Calculate potential score
  const potentialScore = Math.min(7.5, safePSL + totalImprovement);

  return {
    currentScore: safePSL,
    potentialScore: Math.round(potentialScore * 10) / 10,
    totalImprovement: Math.round(totalImprovement * 100) / 100,
    categoryImprovements: cappedImprovements,
    categoryScores: {
      current: currentCategoryScores,
      potential: potentialCategoryScores
    },
    appliedTreatments,
    diminishingFactor: overallDiminishingFactor
  };
}

// ============================================
// ORDER OF OPERATIONS
// ============================================

export interface FaceIQOrderStep {
  phase: FaceIQPhase;
  phaseLabel: string;
  treatmentId: string;
  treatmentName: string;
  categoryImpacts: TreatmentCategoryImpact;
  cumulativeImprovement: number;
  reasoning: string;
}

/**
 * Generate FaceIQ-style order of operations
 *
 * FaceIQ's approach:
 * 1. Foundation first (softmaxxing) - low risk, builds base
 * 2. Structural surgery - major changes, highest impact
 * 3. Refinement last - fine-tuning after major changes settle
 */
export function generateFaceIQOrderOfOperations(
  treatments: Array<{
    id: string;
    name: string;
    category: string;
    pillars?: string[];
    pslImprovement?: { min: number; max: number };
  }>,
  _currentPSL: number = 4.5
): FaceIQOrderStep[] {
  const steps: FaceIQOrderStep[] = [];
  let cumulativeImprovement = 0;

  // Sort treatments by phase order
  const sortedTreatments = [...treatments].sort((a, b) => {
    const phaseA = TREATMENT_TO_FACEIQ_PHASE[a.category] || 'refinement';
    const phaseB = TREATMENT_TO_FACEIQ_PHASE[b.category] || 'refinement';
    return FACEIQ_PHASE_ORDER.indexOf(phaseA) - FACEIQ_PHASE_ORDER.indexOf(phaseB);
  });

  // Phase labels for display
  const phaseLabels: Record<FaceIQPhase, string> = {
    softmaxxing: 'Foundation',
    structural: 'Structural Changes',
    refinement: 'Refinement'
  };

  // Generate reasoning for each phase
  const phaseReasoning: Record<FaceIQPhase, string> = {
    softmaxxing: 'Start with low-risk improvements to maximize baseline.',
    structural: 'Major structural changes that alter facial architecture.',
    refinement: 'Fine-tune after major changes have settled (6-12 months).'
  };

  // Process each treatment
  for (const treatment of sortedTreatments) {
    const phase = TREATMENT_TO_FACEIQ_PHASE[treatment.category] || 'refinement';
    const impact = getTreatmentImpact(treatment.id, treatment.pillars);

    // Estimate improvement from this treatment
    let treatmentImprovement = 0;
    for (const [category, points] of Object.entries(impact)) {
      if (points && category in FACEIQ_CATEGORY_WEIGHTS) {
        treatmentImprovement += points * FACEIQ_CATEGORY_WEIGHTS[category as FaceIQCategory];
      }
    }

    cumulativeImprovement += treatmentImprovement * 0.3; // Scale to PSL points

    steps.push({
      phase,
      phaseLabel: phaseLabels[phase],
      treatmentId: treatment.id,
      treatmentName: treatment.name,
      categoryImpacts: impact,
      cumulativeImprovement: Math.round(cumulativeImprovement * 100) / 100,
      reasoning: phaseReasoning[phase]
    });
  }

  return steps;
}

// ============================================
// PLAN GENERATION
// ============================================

export interface FaceIQPlanPhase {
  phase: FaceIQPhase;
  label: string;
  description: string;
  treatments: Array<{
    id: string;
    name: string;
    categoryImpacts: TreatmentCategoryImpact;
    estimatedImprovement: number;
  }>;
  totalImprovement: number;
  timeline: string;
}

export interface FaceIQPlan {
  currentScore: number;
  potentialScore: number;
  phases: FaceIQPlanPhase[];
  totalTreatments: number;
  estimatedTimeline: string;
}

/**
 * Generate a complete FaceIQ-style improvement plan
 */
export function generateFaceIQPlan(
  currentPSL: number,
  treatments: Array<{
    id: string;
    name: string;
    category: string;
    pillars?: string[];
    pslImprovement?: { min: number; max: number };
  }>,
  gender: 'male' | 'female' = 'male'
): FaceIQPlan {
  // Calculate potential
  const potential = calculateFaceIQPotential(currentPSL, treatments, gender);

  // Group treatments by phase
  const treatmentsByPhase: Record<FaceIQPhase, typeof treatments> = {
    softmaxxing: [],
    structural: [],
    refinement: []
  };

  for (const treatment of treatments) {
    const phase = TREATMENT_TO_FACEIQ_PHASE[treatment.category] || 'refinement';
    treatmentsByPhase[phase].push(treatment);
  }

  // Phase metadata
  const phaseMetadata: Record<FaceIQPhase, { label: string; description: string; timeline: string }> = {
    softmaxxing: {
      label: 'Foundation',
      description: 'Build your base with low-risk, high-impact lifestyle changes.',
      timeline: '3-6 months'
    },
    structural: {
      label: 'Structural Correction',
      description: 'Major surgical procedures that permanently alter facial structure.',
      timeline: '6-12 months recovery'
    },
    refinement: {
      label: 'Refinement',
      description: 'Fine-tune results with minimally invasive procedures.',
      timeline: '1-3 months'
    }
  };

  // Build phases
  const phases: FaceIQPlanPhase[] = [];

  for (const phase of FACEIQ_PHASE_ORDER) {
    const phaseTreatments = treatmentsByPhase[phase];
    if (phaseTreatments.length === 0) continue;

    let phaseImprovement = 0;
    const treatmentDetails = phaseTreatments.map(t => {
      const impact = getTreatmentImpact(t.id, t.pillars);

      // Calculate improvement from this treatment
      let improvement = 0;
      for (const [category, points] of Object.entries(impact)) {
        if (points && category in FACEIQ_CATEGORY_WEIGHTS) {
          improvement += points * FACEIQ_CATEGORY_WEIGHTS[category as FaceIQCategory] * 0.3;
        }
      }

      phaseImprovement += improvement;

      return {
        id: t.id,
        name: t.name,
        categoryImpacts: impact,
        estimatedImprovement: Math.round(improvement * 100) / 100
      };
    });

    phases.push({
      phase,
      label: phaseMetadata[phase].label,
      description: phaseMetadata[phase].description,
      treatments: treatmentDetails,
      totalImprovement: Math.round(phaseImprovement * 100) / 100,
      timeline: phaseMetadata[phase].timeline
    });
  }

  // Calculate total timeline
  let totalMonths = 0;
  if (treatmentsByPhase.softmaxxing.length > 0) totalMonths += 6;
  if (treatmentsByPhase.structural.length > 0) totalMonths += 12;
  if (treatmentsByPhase.refinement.length > 0) totalMonths += 3;

  const estimatedTimeline = totalMonths <= 6
    ? '3-6 months'
    : totalMonths <= 12
    ? '6-12 months'
    : '12-24 months';

  return {
    currentScore: potential.currentScore,
    potentialScore: potential.potentialScore,
    phases,
    totalTreatments: treatments.length,
    estimatedTimeline
  };
}

// ============================================
// HELPER EXPORTS
// ============================================

/**
 * Get all FaceIQ categories
 */
export function getFaceIQCategories(): FaceIQCategory[] {
  return ['harmony', 'angularity', 'dimorphism', 'miscellaneous'];
}

/**
 * Get category color for UI
 */
export function getFaceIQCategoryColor(category: FaceIQCategory): string {
  const colors: Record<FaceIQCategory, string> = {
    harmony: '#67e8f9',      // Cyan
    angularity: '#a78bfa',   // Purple
    dimorphism: '#f97316',   // Orange
    miscellaneous: '#22c55e' // Green
  };
  return colors[category];
}

/**
 * Get category description
 */
export function getFaceIQCategoryDescription(category: FaceIQCategory): string {
  const descriptions: Record<FaceIQCategory, string> = {
    harmony: 'Overall facial balance, proportions, and symmetry',
    angularity: 'Facial leanness, jaw definition, and bone structure',
    dimorphism: 'Sex-specific features (masculinity or femininity)',
    miscellaneous: 'Other features including skin quality and alertness'
  };
  return descriptions[category];
}
