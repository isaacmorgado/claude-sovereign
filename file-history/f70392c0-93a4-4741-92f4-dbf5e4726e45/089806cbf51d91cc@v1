'use client';

/**
 * LandmarkEditor Component
 *
 * Full-featured landmark adjustment UI for side profile ear landmarks.
 * Displays estimated landmarks with confidence indicators and allows
 * manual drag-to-adjust with real-time Frankfort plane angle updates.
 */

import { useState, useCallback, useRef, useEffect, useMemo } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import {
  RotateCcw,
  Check,
  AlertTriangle,
  Move,
  ZoomIn,
  ZoomOut,
  Info,
  X,
  ChevronRight,
} from 'lucide-react';
import { DraggableLandmark } from './DraggableLandmark';
import { FrankfortPlaneOverlay } from './FrankfortPlaneOverlay';
import {
  useLandmarkAdjustment,
  ESTIMATED_LANDMARKS,
  type UseLandmarkAdjustmentReturn,
} from '@/hooks/useLandmarkAdjustment';

export interface LandmarkEditorProps {
  imageUrl: string;
  landmarks: Array<{ id: string; x: number; y: number }>;
  onConfirm: (adjustedLandmarks: Array<{ id: string; x: number; y: number }>) => void;
  onSkip?: () => void;
}

// Ear landmarks info for display
const EAR_LANDMARK_INFO: Record<string, { name: string; description: string }> = {
  porion: {
    name: 'Porion',
    description: 'Highest point on the upper margin of the ear canal opening. Critical for Frankfort Horizontal Plane.',
  },
  tragus: {
    name: 'Tragus',
    description: 'Small pointed cartilage projection in front of the ear canal.',
  },
  intertragicNotch: {
    name: 'Intertragic Notch',
    description: 'Depression between the tragus and antitragus of the ear.',
  },
  orbitale: {
    name: 'Orbitale',
    description: 'Lowest point on the lower edge of the eye socket. Pairs with Porion for Frankfort plane.',
  },
};

export function LandmarkEditor({
  imageUrl,
  landmarks,
  onConfirm,
  onSkip,
}: LandmarkEditorProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [imageDimensions, setImageDimensions] = useState<{ width: number; height: number } | null>(null);
  const [containerSize, setContainerSize] = useState<{ width: number; height: number } | null>(null);
  const [zoomLevel, setZoomLevel] = useState(4); // Start at 4x for ear landmarks
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [showHelp, setShowHelp] = useState(true);

  // Use landmark adjustment hook
  const adjustment: UseLandmarkAdjustmentReturn = useLandmarkAdjustment({
    initialLandmarks: landmarks,
    onAdjustmentChange: (adjustments) => {
      console.log('[LandmarkEditor] Adjustments changed:', adjustments);
    },
  });

  // Get landmarks that need adjustment (estimated ones)
  const adjustableLandmarkIds = useMemo(() => {
    return landmarks
      .filter(lm => ESTIMATED_LANDMARKS.includes(lm.id as typeof ESTIMATED_LANDMARKS[number]))
      .map(lm => lm.id);
  }, [landmarks]);

  // Include orbitale for Frankfort plane visualization
  const relevantLandmarkIds = useMemo(() => {
    const ids = [...adjustableLandmarkIds];
    if (!ids.includes('orbitale') && landmarks.some(lm => lm.id === 'orbitale')) {
      ids.push('orbitale');
    }
    return ids;
  }, [adjustableLandmarkIds, landmarks]);

  // Load image dimensions
  useEffect(() => {
    const img = new window.Image();
    img.onload = () => {
      setImageDimensions({ width: img.naturalWidth, height: img.naturalHeight });
    };
    img.src = imageUrl;
  }, [imageUrl]);

  // Track container size
  useEffect(() => {
    if (!containerRef.current) return;

    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      setContainerSize({ width, height });
    });

    observer.observe(containerRef.current);
    return () => observer.disconnect();
  }, []);

  // Calculate image bounds within container
  const getImageBounds = useCallback(() => {
    if (!containerRef.current || !imageDimensions || !containerSize) {
      return { offsetX: 0, offsetY: 0, renderedWidth: 1, renderedHeight: 1, containerWidth: 1, containerHeight: 1 };
    }

    const containerWidth = containerSize.width;
    const containerHeight = containerSize.height;
    const imageAspect = imageDimensions.width / imageDimensions.height;
    const containerAspect = containerWidth / containerHeight;

    let renderedWidth: number;
    let renderedHeight: number;
    let offsetX = 0;
    let offsetY = 0;

    if (imageAspect > containerAspect) {
      renderedWidth = containerWidth;
      renderedHeight = containerWidth / imageAspect;
      offsetY = (containerHeight - renderedHeight) / 2;
    } else {
      renderedHeight = containerHeight;
      renderedWidth = containerHeight * imageAspect;
      offsetX = (containerWidth - renderedWidth) / 2;
    }

    return { offsetX, offsetY, renderedWidth, renderedHeight, containerWidth, containerHeight };
  }, [imageDimensions, containerSize]);

  const bounds = getImageBounds();

  // Auto-center on ear landmarks when loaded
  useEffect(() => {
    if (!containerSize || !imageDimensions) return;

    // Find porion or first ear landmark to center on
    const porion = landmarks.find(lm => lm.id === 'porion');
    if (!porion) return;

    const bounds = getImageBounds();
    const landmarkX = bounds.offsetX + porion.x * bounds.renderedWidth;
    const landmarkY = bounds.offsetY + porion.y * bounds.renderedHeight;

    setPan({
      x: bounds.containerWidth / 2 - landmarkX * zoomLevel,
      y: bounds.containerHeight / 2 - landmarkY * zoomLevel,
    });
  }, [containerSize, imageDimensions, landmarks, zoomLevel, getImageBounds]);

  // Mouse handlers for panning
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    // Don't start panning if clicking on a landmark
    if ((e.target as HTMLElement).closest('[data-landmark-id]')) return;

    e.preventDefault();
    setIsPanning(true);
    setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
  }, [pan]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (isPanning) {
      setPan({
        x: e.clientX - panStart.x,
        y: e.clientY - panStart.y,
      });
    }
  }, [isPanning, panStart]);

  const handleMouseUp = useCallback(() => {
    setIsPanning(false);
  }, []);

  // Zoom controls
  const handleZoomIn = useCallback(() => {
    setZoomLevel(prev => Math.min(prev + 2, 8));
  }, []);

  const handleZoomOut = useCallback(() => {
    setZoomLevel(prev => Math.max(prev - 2, 2));
  }, []);

  // Handle confirm
  const handleConfirm = useCallback(() => {
    const finalLandmarks = adjustment.confirmAdjustments();
    onConfirm(finalLandmarks);
  }, [adjustment, onConfirm]);

  // Dismiss help after a few seconds
  useEffect(() => {
    const timer = setTimeout(() => setShowHelp(false), 5000);
    return () => clearTimeout(timer);
  }, []);

  // Get Frankfort plane points for overlay
  const frankfortPoints = adjustment.getFrankfortPlanePoints();
  const frankfortAngle = adjustment.calculateFrankfortAngle();

  return (
    <div className="fixed inset-0 bg-black flex flex-col">
      {/* Header */}
      <div className="flex-shrink-0 px-4 py-3 border-b border-neutral-800 bg-neutral-900/80 backdrop-blur-sm">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-amber-500/20 rounded-xl flex items-center justify-center">
              <AlertTriangle className="w-5 h-5 text-amber-400" />
            </div>
            <div>
              <h1 className="text-white font-semibold">Adjust Ear Landmarks</h1>
              <p className="text-xs text-neutral-400">Drag landmarks for accurate Frankfort plane calculation</p>
            </div>
          </div>

          {/* Skip button */}
          {onSkip && (
            <button
              onClick={onSkip}
              className="px-4 py-2 text-sm text-neutral-400 hover:text-white transition-colors"
            >
              Skip for now
            </button>
          )}
        </div>
      </div>

      <div className="flex-1 flex min-h-0">
        {/* Main image area */}
        <div className="flex-1 relative" data-landmark-container>
          <div
            ref={containerRef}
            className="absolute inset-0 overflow-hidden"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            style={{ cursor: isPanning ? 'grabbing' : 'grab' }}
          >
            {/* Transformed content */}
            <div
              className="absolute inset-0"
              style={{
                transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoomLevel})`,
                transformOrigin: '0 0',
              }}
            >
              {/* Image */}
              <Image
                src={imageUrl}
                alt="Side profile"
                fill
                className="object-contain pointer-events-none select-none"
                unoptimized
                draggable={false}
              />

              {/* Frankfort Plane Overlay */}
              {frankfortPoints && (
                <FrankfortPlaneOverlay
                  orbitale={frankfortPoints.orbitale}
                  porion={frankfortPoints.porion}
                  containerBounds={bounds}
                  zoomLevel={zoomLevel}
                  isAdjusting={adjustment.activeAdjustmentId === 'porion' || adjustment.activeAdjustmentId === 'orbitale'}
                  showAngle={true}
                />
              )}

              {/* Draggable landmarks */}
              {relevantLandmarkIds.map(id => {
                const position = adjustment.getLandmarkPosition(id);
                if (!position) return null;

                const info = EAR_LANDMARK_INFO[id];
                const isEstimated = adjustment.isLandmarkEstimated(id);
                const isAdjusted = adjustment.isLandmarkAdjusted(id);
                const confidence = adjustment.getLandmarkConfidence(id);

                return (
                  <DraggableLandmark
                    key={id}
                    id={id}
                    name={info?.name || id}
                    position={position}
                    containerBounds={bounds}
                    zoomLevel={zoomLevel}
                    isActive={adjustment.activeAdjustmentId === id}
                    isEstimated={isEstimated}
                    isAdjusted={isAdjusted}
                    confidence={confidence}
                    color={id === 'orbitale' ? '#22c55e' : '#00f3ff'}
                    onDragStart={() => adjustment.setActiveAdjustment(id)}
                    onDrag={(pos) => adjustment.updateLandmarkPosition(id, pos)}
                    onDragEnd={() => adjustment.setActiveAdjustment(null)}
                    onClick={() => adjustment.setActiveAdjustment(id)}
                  />
                );
              })}
            </div>
          </div>

          {/* Help tooltip */}
          <AnimatePresence>
            {showHelp && (
              <motion.div
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                className="absolute top-4 left-4 right-4 z-20"
              >
                <div className="bg-amber-500/20 border border-amber-500/40 rounded-xl px-4 py-3 flex items-start gap-3 backdrop-blur-sm">
                  <Info className="w-5 h-5 text-amber-400 flex-shrink-0 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-sm text-amber-200 font-medium">Ear landmarks are estimated</p>
                    <p className="text-xs text-amber-200/70 mt-1">
                      Drag the orange landmarks to their correct positions for accurate Frankfort plane calculation.
                    </p>
                  </div>
                  <button
                    onClick={() => setShowHelp(false)}
                    className="text-amber-400 hover:text-amber-200 transition-colors"
                  >
                    <X className="w-4 h-4" />
                  </button>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* Zoom controls */}
          <div className="absolute bottom-20 left-4 flex flex-col gap-2 z-10">
            <button
              onClick={handleZoomIn}
              disabled={zoomLevel >= 8}
              className="w-10 h-10 rounded-lg bg-neutral-900/80 border border-neutral-700 flex items-center justify-center text-white hover:bg-neutral-800 disabled:opacity-50 disabled:cursor-not-allowed backdrop-blur-sm"
            >
              <ZoomIn className="w-5 h-5" />
            </button>
            <div className="px-2 py-1 rounded-lg bg-neutral-900/80 border border-neutral-700 text-white text-xs text-center font-mono backdrop-blur-sm">
              {zoomLevel}x
            </div>
            <button
              onClick={handleZoomOut}
              disabled={zoomLevel <= 2}
              className="w-10 h-10 rounded-lg bg-neutral-900/80 border border-neutral-700 flex items-center justify-center text-white hover:bg-neutral-800 disabled:opacity-50 disabled:cursor-not-allowed backdrop-blur-sm"
            >
              <ZoomOut className="w-5 h-5" />
            </button>
          </div>

          {/* Pan hint */}
          <div className="absolute bottom-4 left-4 px-3 py-1.5 rounded-lg bg-neutral-900/80 border border-neutral-700 flex items-center gap-2 text-neutral-400 text-xs backdrop-blur-sm">
            <Move className="w-3 h-3" />
            Drag to pan
          </div>
        </div>

        {/* Sidebar */}
        <div className="w-80 flex-shrink-0 bg-neutral-900 border-l border-neutral-800 overflow-y-auto">
          {/* Landmark list */}
          <div className="p-4">
            <h2 className="text-sm font-medium text-neutral-400 uppercase tracking-wide mb-3">
              Adjustable Landmarks
            </h2>

            <div className="space-y-3">
              {adjustableLandmarkIds.map(id => {
                const info = EAR_LANDMARK_INFO[id];
                const isAdjusted = adjustment.isLandmarkAdjusted(id);
                const isActive = adjustment.activeAdjustmentId === id;

                return (
                  <motion.div
                    key={id}
                    className={`p-3 rounded-xl border transition-all cursor-pointer ${
                      isActive
                        ? 'bg-cyan-500/10 border-cyan-500/50'
                        : isAdjusted
                          ? 'bg-green-500/10 border-green-500/30'
                          : 'bg-neutral-800/50 border-neutral-700 hover:border-neutral-600'
                    }`}
                    onClick={() => {
                      adjustment.setActiveAdjustment(isActive ? null : id);

                      // Pan to landmark
                      const pos = adjustment.getLandmarkPosition(id);
                      if (pos && containerSize) {
                        const landmarkX = bounds.offsetX + pos.x * bounds.renderedWidth;
                        const landmarkY = bounds.offsetY + pos.y * bounds.renderedHeight;
                        setPan({
                          x: bounds.containerWidth / 2 - landmarkX * zoomLevel,
                          y: bounds.containerHeight / 2 - landmarkY * zoomLevel,
                        });
                      }
                    }}
                    whileHover={{ scale: 1.01 }}
                    whileTap={{ scale: 0.99 }}
                  >
                    <div className="flex items-start gap-3">
                      <div
                        className="w-8 h-8 rounded-lg flex items-center justify-center flex-shrink-0"
                        style={{
                          backgroundColor: isAdjusted ? 'rgba(34, 197, 94, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                        }}
                      >
                        {isAdjusted ? (
                          <Check className="w-4 h-4 text-green-400" />
                        ) : (
                          <AlertTriangle className="w-4 h-4 text-amber-400" />
                        )}
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2">
                          <span className="text-white font-medium text-sm">{info?.name || id}</span>
                          {isAdjusted && (
                            <span className="text-[10px] text-green-400 bg-green-500/20 px-1.5 py-0.5 rounded">
                              Adjusted
                            </span>
                          )}
                        </div>
                        <p className="text-xs text-neutral-400 mt-1 line-clamp-2">
                          {info?.description}
                        </p>
                      </div>
                    </div>

                    {/* Reset button for adjusted landmarks */}
                    {isAdjusted && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          adjustment.resetLandmark(id);
                        }}
                        className="mt-2 w-full py-1.5 text-xs text-neutral-400 hover:text-white bg-neutral-800 rounded-lg flex items-center justify-center gap-1.5 transition-colors"
                      >
                        <RotateCcw className="w-3 h-3" />
                        Reset to estimated
                      </button>
                    )}
                  </motion.div>
                );
              })}
            </div>
          </div>

          {/* Frankfort Plane Info */}
          {frankfortAngle !== null && (
            <div className="px-4 pb-4">
              <div className="p-4 rounded-xl bg-neutral-800/50 border border-neutral-700">
                <h3 className="text-sm font-medium text-white mb-2">Frankfort Horizontal Plane</h3>
                <div className="flex items-center gap-3">
                  <div
                    className={`text-2xl font-mono font-bold ${
                      Math.abs(frankfortAngle) <= 3
                        ? 'text-green-400'
                        : Math.abs(frankfortAngle) <= 8
                          ? 'text-yellow-400'
                          : 'text-amber-400'
                    }`}
                  >
                    {frankfortAngle.toFixed(1)}Â°
                  </div>
                  <div className="flex-1">
                    <p className="text-xs text-neutral-400">
                      {Math.abs(frankfortAngle) <= 3
                        ? 'Ideal - well aligned'
                        : Math.abs(frankfortAngle) <= 8
                          ? 'Acceptable - minor deviation'
                          : 'Adjust porion for accuracy'}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Actions */}
          <div className="p-4 border-t border-neutral-800 sticky bottom-0 bg-neutral-900">
            {adjustment.hasChanges && (
              <button
                onClick={adjustment.resetAllAdjustments}
                className="w-full mb-3 py-2.5 text-sm text-neutral-400 hover:text-white bg-neutral-800 rounded-xl flex items-center justify-center gap-2 transition-colors"
              >
                <RotateCcw className="w-4 h-4" />
                Reset All Adjustments
              </button>
            )}

            <button
              onClick={handleConfirm}
              className="w-full py-3 bg-gradient-to-r from-cyan-400 to-cyan-500 text-black font-semibold rounded-xl flex items-center justify-center gap-2 hover:shadow-[0_0_20px_rgba(34,211,238,0.3)] transition-all"
            >
              {adjustment.hasChanges ? (
                <>
                  <Check className="w-5 h-5" />
                  Confirm Adjustments
                </>
              ) : (
                <>
                  Continue
                  <ChevronRight className="w-5 h-5" />
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

export default LandmarkEditor;
