'use client';

/**
 * FrankfortPlaneOverlay Component
 *
 * Displays the Frankfort Horizontal Plane line between orbitale and porion.
 * Updates in real-time as landmarks are adjusted.
 * Shows angle deviation from true horizontal.
 */

import { motion } from 'framer-motion';

export interface FrankfortPlaneOverlayProps {
  orbitale: { x: number; y: number }; // Normalized 0-1
  porion: { x: number; y: number }; // Normalized 0-1
  containerBounds: {
    offsetX: number;
    offsetY: number;
    renderedWidth: number;
    renderedHeight: number;
  };
  zoomLevel: number;
  isAdjusting?: boolean;
  showAngle?: boolean;
}

export function FrankfortPlaneOverlay({
  orbitale,
  porion,
  containerBounds,
  zoomLevel,
  isAdjusting = false,
  showAngle = true,
}: FrankfortPlaneOverlayProps) {
  // Convert normalized positions to pixel positions
  const orbitalePixel = {
    x: containerBounds.offsetX + orbitale.x * containerBounds.renderedWidth,
    y: containerBounds.offsetY + orbitale.y * containerBounds.renderedHeight,
  };

  const porionPixel = {
    x: containerBounds.offsetX + porion.x * containerBounds.renderedWidth,
    y: containerBounds.offsetY + porion.y * containerBounds.renderedHeight,
  };

  // Calculate angle from horizontal (in degrees)
  const dx = porionPixel.x - orbitalePixel.x;
  const dy = porionPixel.y - orbitalePixel.y;
  const angle = Math.atan2(dy, dx) * (180 / Math.PI);

  // Determine if angle is within acceptable range
  // Ideal Frankfort plane should be roughly horizontal (0° ± 3°)
  const isIdealAngle = Math.abs(angle) <= 3;
  const isAcceptableAngle = Math.abs(angle) <= 8;

  // Get color based on angle quality
  const getLineColor = () => {
    if (isAdjusting) return '#22d3ee'; // Cyan when adjusting
    if (isIdealAngle) return '#22c55e'; // Green for ideal
    if (isAcceptableAngle) return '#facc15'; // Yellow for acceptable
    return '#f59e0b'; // Amber for needs adjustment
  };

  const lineColor = getLineColor();

  // Extend line beyond points for visibility
  const length = Math.sqrt(dx * dx + dy * dy);
  const extendFactor = length > 0 ? 0.4 : 0;
  const unitDx = length > 0 ? dx / length : 0;
  const unitDy = length > 0 ? dy / length : 0;

  const startX = orbitalePixel.x - unitDx * containerBounds.renderedWidth * extendFactor;
  const startY = orbitalePixel.y - unitDy * containerBounds.renderedWidth * extendFactor;
  const endX = porionPixel.x + unitDx * containerBounds.renderedWidth * extendFactor;
  const endY = porionPixel.y + unitDy * containerBounds.renderedWidth * extendFactor;

  // Position for angle indicator
  const midpointX = (orbitalePixel.x + porionPixel.x) / 2;
  const midpointY = (orbitalePixel.y + porionPixel.y) / 2 - 20 / zoomLevel;

  return (
    <svg
      className="absolute inset-0 pointer-events-none overflow-visible"
      style={{ width: '100%', height: '100%' }}
    >
      {/* True horizontal reference line (dashed, subtle) */}
      <line
        x1={startX}
        y1={orbitalePixel.y}
        x2={endX}
        y2={orbitalePixel.y}
        stroke="#4b5563"
        strokeWidth={1 / zoomLevel}
        strokeDasharray={`${4 / zoomLevel} ${4 / zoomLevel}`}
        opacity={0.4}
      />

      {/* Frankfort Horizontal Plane line */}
      <motion.line
        x1={startX}
        y1={startY}
        x2={endX}
        y2={endY}
        stroke={lineColor}
        strokeWidth={isAdjusting ? 3 / zoomLevel : 2 / zoomLevel}
        strokeDasharray={isAdjusting ? 'none' : `${6 / zoomLevel} ${4 / zoomLevel}`}
        opacity={isAdjusting ? 1 : 0.8}
        initial={{ pathLength: 0 }}
        animate={{ pathLength: 1 }}
        transition={{ duration: 0.5 }}
      />

      {/* Orbitale point marker */}
      <motion.circle
        cx={orbitalePixel.x}
        cy={orbitalePixel.y}
        r={isAdjusting ? 6 / zoomLevel : 4 / zoomLevel}
        fill={lineColor}
        stroke="white"
        strokeWidth={1.5 / zoomLevel}
        animate={{ scale: isAdjusting ? [1, 1.2, 1] : 1 }}
        transition={{ duration: 0.5, repeat: isAdjusting ? Infinity : 0 }}
      />

      {/* Porion point marker */}
      <motion.circle
        cx={porionPixel.x}
        cy={porionPixel.y}
        r={isAdjusting ? 6 / zoomLevel : 4 / zoomLevel}
        fill={lineColor}
        stroke="white"
        strokeWidth={1.5 / zoomLevel}
        animate={{ scale: isAdjusting ? [1, 1.2, 1] : 1 }}
        transition={{ duration: 0.5, repeat: isAdjusting ? Infinity : 0, delay: 0.25 }}
      />

      {/* Labels */}
      <text
        x={orbitalePixel.x}
        y={orbitalePixel.y - 10 / zoomLevel}
        fill="white"
        fontSize={10 / zoomLevel}
        textAnchor="middle"
        fontWeight="bold"
        style={{ textShadow: '0 0 3px rgba(0,0,0,0.8)' }}
      >
        Or
      </text>
      <text
        x={porionPixel.x}
        y={porionPixel.y - 10 / zoomLevel}
        fill="white"
        fontSize={10 / zoomLevel}
        textAnchor="middle"
        fontWeight="bold"
        style={{ textShadow: '0 0 3px rgba(0,0,0,0.8)' }}
      >
        Po
      </text>

      {/* Angle indicator */}
      {showAngle && (
        <motion.g
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3 }}
        >
          {/* Background pill */}
          <rect
            x={midpointX - 45 / zoomLevel}
            y={midpointY - 12 / zoomLevel}
            width={90 / zoomLevel}
            height={24 / zoomLevel}
            rx={12 / zoomLevel}
            fill="rgba(0, 0, 0, 0.85)"
            stroke={lineColor}
            strokeWidth={1 / zoomLevel}
          />

          {/* Angle text */}
          <text
            x={midpointX}
            y={midpointY + 4 / zoomLevel}
            fill={lineColor}
            fontSize={12 / zoomLevel}
            textAnchor="middle"
            fontWeight="bold"
            fontFamily="monospace"
          >
            FH: {angle.toFixed(1)}°
          </text>
        </motion.g>
      )}

      {/* Angle arc visualization */}
      {Math.abs(angle) > 1 && (
        <path
          d={`M ${orbitalePixel.x + 20 / zoomLevel} ${orbitalePixel.y}
              A ${20 / zoomLevel} ${20 / zoomLevel} 0 0 ${angle > 0 ? 1 : 0}
              ${orbitalePixel.x + (20 / zoomLevel) * Math.cos(angle * Math.PI / 180)}
              ${orbitalePixel.y + (20 / zoomLevel) * Math.sin(angle * Math.PI / 180)}`}
          fill="none"
          stroke={lineColor}
          strokeWidth={1.5 / zoomLevel}
          opacity={0.6}
        />
      )}
    </svg>
  );
}

export default FrankfortPlaneOverlay;
