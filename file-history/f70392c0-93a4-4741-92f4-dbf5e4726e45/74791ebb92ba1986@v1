'use client';

import { useMemo } from 'react';
import { motion } from 'framer-motion';
import { Scale, Triangle, Users, Sparkles, TrendingUp, AlertCircle } from 'lucide-react';
import type { Ratio } from '@/types/results';
import type { FaceIQCategory } from '@/lib/faceiq-parity/potential';
import {
  calculateCategoryScores,
  getCategoryLabel,
  getCategoryImprovementSuggestions,
} from '@/lib/faceiq-parity/categoryScores';
import {
  FACEIQ_CATEGORY_WEIGHTS,
  getFaceIQCategoryColor,
  getFaceIQCategoryDescription,
} from '@/lib/faceiq-parity/potential';

interface CategoryBreakdownProps {
  ratios: Ratio[];
  gender?: 'male' | 'female';
  showSuggestions?: boolean;
  compact?: boolean;
}

const CATEGORY_ICONS: Record<FaceIQCategory, React.ReactNode> = {
  harmony: <Scale size={16} />,
  angularity: <Triangle size={16} />,
  dimorphism: <Users size={16} />,
  miscellaneous: <Sparkles size={16} />,
};

export function CategoryBreakdown({
  ratios,
  gender = 'male',
  showSuggestions = false,
  compact = false,
}: CategoryBreakdownProps) {
  const categoryResult = useMemo(
    () => calculateCategoryScores(ratios),
    [ratios]
  );

  const suggestions = useMemo(
    () => showSuggestions
      ? getCategoryImprovementSuggestions(categoryResult.scores, gender)
      : [],
    [categoryResult.scores, gender, showSuggestions]
  );

  const categories: FaceIQCategory[] = ['harmony', 'angularity', 'dimorphism', 'miscellaneous'];

  return (
    <div className={`rounded-2xl bg-neutral-900/60 backdrop-blur-xl border border-white/10 ${compact ? 'p-4' : 'p-6'}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-bold uppercase tracking-wider text-white/80">
          Category Breakdown
        </h3>
        <div className="flex items-center gap-2 px-3 py-1 rounded-full bg-cyan-500/10 border border-cyan-500/20">
          <span className="text-xs font-medium text-cyan-400">
            {categoryResult.overallScore.toFixed(1)}/10
          </span>
        </div>
      </div>

      {/* Category Bars */}
      <div className="space-y-3">
        {categories.map((category, index) => {
          const score = categoryResult.scores[category];
          const weight = FACEIQ_CATEGORY_WEIGHTS[category];
          const color = getFaceIQCategoryColor(category);
          const isWeakest = category === categoryResult.weakestCategory && score < 6;
          const isStrongest = category === categoryResult.strongestCategory && score >= 7;

          return (
            <motion.div
              key={category}
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: index * 0.1 }}
            >
              {/* Label Row */}
              <div className="flex items-center justify-between mb-1.5">
                <div className="flex items-center gap-2">
                  <span style={{ color }} className="opacity-80">
                    {CATEGORY_ICONS[category]}
                  </span>
                  <span className="text-sm font-medium text-white/90">
                    {getCategoryLabel(category)}
                  </span>
                  <span className="text-[10px] text-white/40">
                    {Math.round(weight * 100)}%
                  </span>
                  {isWeakest && (
                    <span className="flex items-center gap-1 text-[10px] text-amber-400">
                      <AlertCircle size={10} />
                      Focus
                    </span>
                  )}
                  {isStrongest && (
                    <span className="flex items-center gap-1 text-[10px] text-emerald-400">
                      <TrendingUp size={10} />
                      Strong
                    </span>
                  )}
                </div>
                <span
                  className="text-sm font-bold tabular-nums"
                  style={{ color }}
                >
                  {score.toFixed(1)}
                </span>
              </div>

              {/* Progress Bar */}
              <div className="relative h-2 rounded-full bg-white/5 overflow-hidden">
                <motion.div
                  className="absolute inset-y-0 left-0 rounded-full"
                  style={{ backgroundColor: color }}
                  initial={{ width: 0 }}
                  animate={{ width: `${(score / 10) * 100}%` }}
                  transition={{ duration: 0.8, delay: index * 0.1, ease: 'easeOut' }}
                />
                {/* Ideal zone indicator */}
                <div
                  className="absolute inset-y-0 bg-white/10"
                  style={{ left: '70%', width: '30%' }}
                />
              </div>

              {/* Description (non-compact mode) */}
              {!compact && (
                <p className="mt-1 text-[10px] text-white/40">
                  {getFaceIQCategoryDescription(category)}
                </p>
              )}
            </motion.div>
          );
        })}
      </div>

      {/* Suggestions (if enabled) */}
      {showSuggestions && suggestions.length > 0 && (
        <div className="mt-4 pt-4 border-t border-white/5">
          <h4 className="text-xs font-semibold uppercase tracking-wider text-white/60 mb-2">
            Priority Improvements
          </h4>
          <div className="space-y-2">
            {suggestions.slice(0, 2).map((suggestion) => (
              <div
                key={suggestion.category}
                className="flex items-start gap-2 p-2 rounded-lg bg-white/5"
              >
                <span
                  className="mt-0.5"
                  style={{ color: getFaceIQCategoryColor(suggestion.category) }}
                >
                  {CATEGORY_ICONS[suggestion.category]}
                </span>
                <div>
                  <span className="text-xs font-medium text-white/80">
                    {getCategoryLabel(suggestion.category)}:
                  </span>
                  <p className="text-[11px] text-white/50">
                    {suggestion.suggestion}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

/**
 * Compact inline version for headers/cards
 */
export function CategoryScoreChips({ ratios }: { ratios: Ratio[] }) {
  const categoryResult = useMemo(
    () => calculateCategoryScores(ratios),
    [ratios]
  );

  const categories: FaceIQCategory[] = ['harmony', 'angularity', 'dimorphism', 'miscellaneous'];

  return (
    <div className="flex flex-wrap gap-2">
      {categories.map((category) => {
        const score = categoryResult.scores[category];
        const color = getFaceIQCategoryColor(category);

        return (
          <div
            key={category}
            className="flex items-center gap-1.5 px-2 py-1 rounded-lg bg-white/5 border border-white/10"
          >
            <span style={{ color }} className="opacity-70">
              {CATEGORY_ICONS[category]}
            </span>
            <span className="text-xs text-white/60">
              {getCategoryLabel(category).slice(0, 3)}
            </span>
            <span
              className="text-xs font-bold tabular-nums"
              style={{ color }}
            >
              {score.toFixed(1)}
            </span>
          </div>
        );
      })}
    </div>
  );
}

/**
 * Mini radar-style visualization
 */
export function CategoryRadar({ ratios }: { ratios: Ratio[] }) {
  const categoryResult = useMemo(
    () => calculateCategoryScores(ratios),
    [ratios]
  );

  const categories: FaceIQCategory[] = ['harmony', 'angularity', 'dimorphism', 'miscellaneous'];
  const size = 120;
  const center = size / 2;
  const maxRadius = (size / 2) - 20;

  // Calculate points for the radar polygon
  const points = categories.map((category, i) => {
    const score = categoryResult.scores[category];
    const angle = (i / categories.length) * Math.PI * 2 - Math.PI / 2;
    const radius = (score / 10) * maxRadius;
    return {
      x: center + Math.cos(angle) * radius,
      y: center + Math.sin(angle) * radius,
      category,
      score,
      color: getFaceIQCategoryColor(category),
    };
  });

  const polygonPoints = points.map(p => `${p.x},${p.y}`).join(' ');

  return (
    <div className="flex flex-col items-center">
      <svg width={size} height={size} className="overflow-visible">
        {/* Background rings */}
        {[0.25, 0.5, 0.75, 1].map((scale) => (
          <circle
            key={scale}
            cx={center}
            cy={center}
            r={maxRadius * scale}
            fill="none"
            stroke="rgba(255,255,255,0.1)"
            strokeWidth="1"
          />
        ))}

        {/* Axis lines */}
        {categories.map((_, i) => {
          const angle = (i / categories.length) * Math.PI * 2 - Math.PI / 2;
          return (
            <line
              key={i}
              x1={center}
              y1={center}
              x2={center + Math.cos(angle) * maxRadius}
              y2={center + Math.sin(angle) * maxRadius}
              stroke="rgba(255,255,255,0.1)"
              strokeWidth="1"
            />
          );
        })}

        {/* Score polygon */}
        <motion.polygon
          points={polygonPoints}
          fill="rgba(6, 182, 212, 0.2)"
          stroke="rgb(6, 182, 212)"
          strokeWidth="2"
          initial={{ opacity: 0, scale: 0.5 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5 }}
        />

        {/* Data points */}
        {points.map((point, i) => (
          <motion.circle
            key={i}
            cx={point.x}
            cy={point.y}
            r="4"
            fill={point.color}
            initial={{ opacity: 0, scale: 0 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ delay: i * 0.1 }}
          />
        ))}

        {/* Labels */}
        {categories.map((category, i) => {
          const angle = (i / categories.length) * Math.PI * 2 - Math.PI / 2;
          const labelRadius = maxRadius + 15;
          const x = center + Math.cos(angle) * labelRadius;
          const y = center + Math.sin(angle) * labelRadius;

          return (
            <text
              key={category}
              x={x}
              y={y}
              textAnchor="middle"
              dominantBaseline="middle"
              className="text-[9px] fill-white/60 font-medium"
            >
              {getCategoryLabel(category).slice(0, 3).toUpperCase()}
            </text>
          );
        })}
      </svg>

      {/* Score label */}
      <div className="mt-2 text-center">
        <span className="text-lg font-black text-cyan-400">
          {categoryResult.overallScore.toFixed(1)}
        </span>
        <span className="text-xs text-white/40 ml-1">/10</span>
      </div>
    </div>
  );
}
