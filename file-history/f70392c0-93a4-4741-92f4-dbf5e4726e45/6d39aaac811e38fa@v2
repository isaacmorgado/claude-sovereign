'use client';

/**
 * DraggableLandmark Component
 *
 * A draggable landmark point for manual adjustment of estimated ear landmarks.
 * Supports both mouse and touch interactions with precision controls.
 */

import { useCallback, useRef, useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { AlertTriangle, Check, GripVertical } from 'lucide-react';

export interface DraggableLandmarkProps {
  id: string;
  name: string;
  position: { x: number; y: number }; // Normalized 0-1
  containerBounds: {
    offsetX: number;
    offsetY: number;
    renderedWidth: number;
    renderedHeight: number;
  };
  zoomLevel: number;
  isActive: boolean;
  isEstimated: boolean;
  isAdjusted: boolean;
  confidence: 'high' | 'medium' | 'low';
  color?: string;
  onDragStart?: () => void;
  onDrag: (position: { x: number; y: number }) => void;
  onDragEnd?: () => void;
  onClick?: () => void;
}

export function DraggableLandmark({
  id,
  name,
  position,
  containerBounds,
  zoomLevel,
  isActive,
  isEstimated,
  isAdjusted,
  confidence,
  color = '#00f3ff',
  onDragStart,
  onDrag,
  onDragEnd,
  onClick,
}: DraggableLandmarkProps) {
  const elementRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);

  // Convert normalized position to pixel position
  const pixelPosition = {
    left: containerBounds.offsetX + position.x * containerBounds.renderedWidth,
    top: containerBounds.offsetY + position.y * containerBounds.renderedHeight,
  };

  // Get confidence-based styling
  const getConfidenceStyles = () => {
    switch (confidence) {
      case 'low':
        return {
          borderColor: '#f59e0b', // Amber
          glowColor: 'rgba(245, 158, 11, 0.5)',
          icon: AlertTriangle,
        };
      case 'medium':
        return {
          borderColor: '#facc15', // Yellow
          glowColor: 'rgba(250, 204, 21, 0.5)',
          icon: null,
        };
      case 'high':
      default:
        return {
          borderColor: isAdjusted ? '#22c55e' : color,
          glowColor: isAdjusted ? 'rgba(34, 197, 94, 0.5)' : `${color}80`,
          icon: isAdjusted ? Check : null,
        };
    }
  };

  const styles = getConfidenceStyles();

  // Handle mouse down - start dragging
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    if (!elementRef.current) return;

    setIsDragging(true);
    onDragStart?.();
  }, [onDragStart]);

  // Handle touch start - start dragging
  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    e.preventDefault();
    e.stopPropagation();

    if (!elementRef.current || e.touches.length !== 1) return;

    setIsDragging(true);
    onDragStart?.();
  }, [onDragStart]);

  // Handle mouse move while dragging
  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e: MouseEvent) => {
      // Calculate new normalized position
      const containerElement = elementRef.current?.closest('[data-landmark-container]');
      if (!containerElement) return;

      const containerRect = containerElement.getBoundingClientRect();
      const mouseX = e.clientX - containerRect.left;
      const mouseY = e.clientY - containerRect.top;

      // Account for zoom transform
      const adjustedX = mouseX / zoomLevel;
      const adjustedY = mouseY / zoomLevel;

      // Convert to normalized position
      const normalizedX = (adjustedX - containerBounds.offsetX) / containerBounds.renderedWidth;
      const normalizedY = (adjustedY - containerBounds.offsetY) / containerBounds.renderedHeight;

      // Clamp to valid range
      const clampedX = Math.max(0, Math.min(1, normalizedX));
      const clampedY = Math.max(0, Math.min(1, normalizedY));

      onDrag({ x: clampedX, y: clampedY });
    };

    const handleMouseUp = () => {
      setIsDragging(false);
      onDragEnd?.();
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, containerBounds, zoomLevel, onDrag, onDragEnd]);

  // Handle touch move while dragging
  useEffect(() => {
    if (!isDragging) return;

    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length !== 1) return;

      const touch = e.touches[0];
      const containerElement = elementRef.current?.closest('[data-landmark-container]');
      if (!containerElement) return;

      const containerRect = containerElement.getBoundingClientRect();
      const touchX = touch.clientX - containerRect.left;
      const touchY = touch.clientY - containerRect.top;

      // Account for zoom transform
      const adjustedX = touchX / zoomLevel;
      const adjustedY = touchY / zoomLevel;

      // Convert to normalized position
      const normalizedX = (adjustedX - containerBounds.offsetX) / containerBounds.renderedWidth;
      const normalizedY = (adjustedY - containerBounds.offsetY) / containerBounds.renderedHeight;

      // Clamp to valid range
      const clampedX = Math.max(0, Math.min(1, normalizedX));
      const clampedY = Math.max(0, Math.min(1, normalizedY));

      onDrag({ x: clampedX, y: clampedY });
    };

    const handleTouchEnd = () => {
      setIsDragging(false);
      onDragEnd?.();
    };

    window.addEventListener('touchmove', handleTouchMove, { passive: false });
    window.addEventListener('touchend', handleTouchEnd);

    return () => {
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', handleTouchEnd);
    };
  }, [isDragging, containerBounds, zoomLevel, onDrag, onDragEnd]);

  const IconComponent = styles.icon;

  return (
    <motion.div
      ref={elementRef}
      data-landmark-id={id}
      className="absolute cursor-grab active:cursor-grabbing"
      style={{
        left: pixelPosition.left,
        top: pixelPosition.top,
        transform: `translate(-50%, -50%) scale(${1 / zoomLevel})`,
        transformOrigin: 'center center',
        zIndex: isActive ? 100 : isDragging ? 99 : 10,
      }}
      initial={{ scale: 0 }}
      animate={{
        scale: isActive ? 1.3 : 1,
        opacity: 1,
      }}
      transition={{ type: 'spring', stiffness: 400, damping: 25 }}
      onMouseDown={handleMouseDown}
      onTouchStart={handleTouchStart}
      onClick={(e) => {
        e.stopPropagation();
        onClick?.();
      }}
    >
      {/* Outer glow ring for active state */}
      {isActive && (
        <motion.div
          className="absolute rounded-full"
          style={{
            width: 48,
            height: 48,
            left: -24,
            top: -24,
            background: `radial-gradient(circle, ${styles.glowColor} 0%, transparent 70%)`,
          }}
          animate={{ scale: [1, 1.2, 1], opacity: [0.5, 0.8, 0.5] }}
          transition={{ duration: 1.5, repeat: Infinity }}
        />
      )}

      {/* Confidence indicator ring */}
      {isEstimated && !isActive && (
        <motion.div
          className="absolute rounded-full border-2 border-dashed"
          style={{
            width: 24,
            height: 24,
            left: -12,
            top: -12,
            borderColor: styles.borderColor,
          }}
          animate={{ rotate: 360 }}
          transition={{ duration: 8, repeat: Infinity, ease: 'linear' }}
        />
      )}

      {/* Main landmark dot */}
      <div
        className="relative rounded-full flex items-center justify-center"
        style={{
          width: isActive ? 20 : 14,
          height: isActive ? 20 : 14,
          backgroundColor: isAdjusted ? '#22c55e' : isEstimated ? '#f59e0b' : color,
          border: `2px solid ${styles.borderColor}`,
          boxShadow: `0 0 8px ${styles.glowColor}, 0 0 16px ${styles.glowColor}`,
        }}
      >
        {/* Icon for status */}
        {IconComponent && (
          <IconComponent
            className="text-white"
            style={{ width: isActive ? 10 : 8, height: isActive ? 10 : 8 }}
          />
        )}

        {/* Drag indicator for active landmarks */}
        {isActive && !IconComponent && (
          <GripVertical className="text-white" style={{ width: 10, height: 10 }} />
        )}
      </div>

      {/* Label tooltip */}
      {isActive && (
        <motion.div
          className="absolute left-1/2 -top-10 -translate-x-1/2 whitespace-nowrap"
          initial={{ opacity: 0, y: 5 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="px-2.5 py-1.5 rounded-lg bg-black/90 border border-white/20 backdrop-blur-sm">
            <p className="text-xs font-medium text-white">{name}</p>
            {isEstimated && !isAdjusted && (
              <p className="text-[10px] text-amber-400 mt-0.5">Estimated - Drag to adjust</p>
            )}
            {isAdjusted && (
              <p className="text-[10px] text-green-400 mt-0.5">Manually adjusted</p>
            )}
          </div>
        </motion.div>
      )}
    </motion.div>
  );
}

export default DraggableLandmark;
