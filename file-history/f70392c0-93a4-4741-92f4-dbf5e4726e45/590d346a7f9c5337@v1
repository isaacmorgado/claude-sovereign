/**
 * useLandmarkAdjustment Hook
 *
 * Manages manual adjustment of estimated landmarks (porion, tragus, intertragicNotch).
 * These ear landmarks are geometrically estimated by InsightFace with ~10-15px error,
 * affecting Frankfort plane accuracy. This hook enables FaceIQ-style manual adjustment.
 */

import { useState, useCallback, useMemo } from 'react';

export interface AdjustableLandmark {
  id: string;
  name: string;
  originalPosition: { x: number; y: number };
  adjustedPosition: { x: number; y: number };
  isEstimated: boolean;
  confidence: 'high' | 'medium' | 'low';
}

export interface LandmarkAdjustmentState {
  adjustments: Record<string, { x: number; y: number }>;
  activeAdjustmentId: string | null;
  hasChanges: boolean;
}

// Landmarks that are geometrically estimated and need manual adjustment capability
export const ESTIMATED_LANDMARKS = ['porion', 'tragus', 'intertragicNotch'] as const;

// Confidence levels for each landmark type
export const LANDMARK_CONFIDENCE: Record<string, 'high' | 'medium' | 'low'> = {
  // Ear landmarks - estimated geometrically (~10-15px error)
  porion: 'low',
  tragus: 'low',
  intertragicNotch: 'low',
  // These are detected but may need fine-tuning
  orbitale: 'medium',
  // Most landmarks are well-detected
  default: 'high',
};

export interface UseLandmarkAdjustmentOptions {
  initialLandmarks: Array<{ id: string; x: number; y: number }>;
  onAdjustmentChange?: (adjustments: Record<string, { x: number; y: number }>) => void;
}

export interface UseLandmarkAdjustmentReturn {
  // State
  adjustedLandmarks: Array<{ id: string; x: number; y: number }>;
  adjustments: Record<string, { x: number; y: number }>;
  activeAdjustmentId: string | null;
  hasChanges: boolean;

  // Actions
  setActiveAdjustment: (id: string | null) => void;
  updateLandmarkPosition: (id: string, position: { x: number; y: number }) => void;
  resetLandmark: (id: string) => void;
  resetAllAdjustments: () => void;
  confirmAdjustments: () => Array<{ id: string; x: number; y: number }>;

  // Helpers
  getLandmarkPosition: (id: string) => { x: number; y: number } | null;
  isLandmarkAdjusted: (id: string) => boolean;
  isLandmarkEstimated: (id: string) => boolean;
  getLandmarkConfidence: (id: string) => 'high' | 'medium' | 'low';

  // Frankfort Plane helpers
  calculateFrankfortAngle: () => number | null;
  getFrankfortPlanePoints: () => { orbitale: { x: number; y: number }; porion: { x: number; y: number } } | null;
}

export function useLandmarkAdjustment({
  initialLandmarks,
  onAdjustmentChange,
}: UseLandmarkAdjustmentOptions): UseLandmarkAdjustmentReturn {
  // Store original positions for reset functionality
  const originalPositions = useMemo(() => {
    const positions: Record<string, { x: number; y: number }> = {};
    initialLandmarks.forEach(lm => {
      positions[lm.id] = { x: lm.x, y: lm.y };
    });
    return positions;
  }, [initialLandmarks]);

  // Current adjustments (delta from original or absolute position)
  const [adjustments, setAdjustments] = useState<Record<string, { x: number; y: number }>>({});

  // Currently active landmark being adjusted
  const [activeAdjustmentId, setActiveAdjustment] = useState<string | null>(null);

  // Check if any changes have been made
  const hasChanges = useMemo(() => Object.keys(adjustments).length > 0, [adjustments]);

  // Get merged landmarks with adjustments applied
  const adjustedLandmarks = useMemo(() => {
    return initialLandmarks.map(lm => {
      if (adjustments[lm.id]) {
        return { ...lm, ...adjustments[lm.id] };
      }
      return lm;
    });
  }, [initialLandmarks, adjustments]);

  // Update a landmark's position
  const updateLandmarkPosition = useCallback((id: string, position: { x: number; y: number }) => {
    setAdjustments(prev => {
      const next = { ...prev, [id]: position };
      onAdjustmentChange?.(next);
      return next;
    });
  }, [onAdjustmentChange]);

  // Reset a single landmark to original position
  const resetLandmark = useCallback((id: string) => {
    setAdjustments(prev => {
      const next = { ...prev };
      delete next[id];
      onAdjustmentChange?.(next);
      return next;
    });
  }, [onAdjustmentChange]);

  // Reset all adjustments
  const resetAllAdjustments = useCallback(() => {
    setAdjustments({});
    setActiveAdjustment(null);
    onAdjustmentChange?.({});
  }, [onAdjustmentChange]);

  // Confirm and return final positions
  const confirmAdjustments = useCallback(() => {
    return adjustedLandmarks;
  }, [adjustedLandmarks]);

  // Get position for a specific landmark (adjusted if available)
  const getLandmarkPosition = useCallback((id: string) => {
    const adjusted = adjustments[id];
    if (adjusted) return adjusted;
    return originalPositions[id] || null;
  }, [adjustments, originalPositions]);

  // Check if landmark has been manually adjusted
  const isLandmarkAdjusted = useCallback((id: string) => {
    return id in adjustments;
  }, [adjustments]);

  // Check if landmark is estimated (not directly detected)
  const isLandmarkEstimated = useCallback((id: string) => {
    return ESTIMATED_LANDMARKS.includes(id as typeof ESTIMATED_LANDMARKS[number]);
  }, []);

  // Get confidence level for a landmark
  const getLandmarkConfidence = useCallback((id: string) => {
    return LANDMARK_CONFIDENCE[id] || LANDMARK_CONFIDENCE.default;
  }, []);

  // Calculate Frankfort Horizontal Plane angle from orbitale and porion
  const calculateFrankfortAngle = useCallback(() => {
    const orbitale = getLandmarkPosition('orbitale');
    const porion = getLandmarkPosition('porion');

    if (!orbitale || !porion) return null;

    const dx = porion.x - orbitale.x;
    const dy = porion.y - orbitale.y;
    const angle = Math.atan2(dy, dx) * (180 / Math.PI);

    return angle;
  }, [getLandmarkPosition]);

  // Get Frankfort plane points for visualization
  const getFrankfortPlanePoints = useCallback(() => {
    const orbitale = getLandmarkPosition('orbitale');
    const porion = getLandmarkPosition('porion');

    if (!orbitale || !porion) return null;

    return { orbitale, porion };
  }, [getLandmarkPosition]);

  return {
    adjustedLandmarks,
    adjustments,
    activeAdjustmentId,
    hasChanges,
    setActiveAdjustment,
    updateLandmarkPosition,
    resetLandmark,
    resetAllAdjustments,
    confirmAdjustments,
    getLandmarkPosition,
    isLandmarkAdjusted,
    isLandmarkEstimated,
    getLandmarkConfidence,
    calculateFrankfortAngle,
    getFrankfortPlanePoints,
  };
}
