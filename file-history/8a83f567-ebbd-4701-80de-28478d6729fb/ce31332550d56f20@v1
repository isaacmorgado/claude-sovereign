/**
 * FaceIQ Complete Data Capture Script
 *
 * USAGE:
 * 1. Open https://beta.faceiqlabs.com
 * 2. Open DevTools (Cmd+Option+I)
 * 3. Paste this entire script in Console
 * 4. Use the site normally
 * 5. Run: FaceIQCapture.export()
 */

(function() {
  'use strict';

  // Global capture object
  window.FaceIQCapture = {
    version: '1.0',
    startTime: new Date().toISOString(),

    // Captured data
    data: {
      mediapipe: {
        frontFace: [],
        sideFace: []
      },
      api: {
        requests: [],
        responses: []
      },
      landmarks: {
        detected: [],
        adjusted: []
      },
      calculations: [],
      uiState: [],
      errors: []
    },

    // Status check
    status: function() {
      console.log('%c=== FaceIQ Capture Status ===', 'color: #00ff00; font-weight: bold');
      console.log('MediaPipe Front Face detections:', this.data.mediapipe.frontFace.length);
      console.log('MediaPipe Side Face detections:', this.data.mediapipe.sideFace.length);
      console.log('API Requests captured:', this.data.api.requests.length);
      console.log('Landmark adjustments:', this.data.landmarks.adjusted.length);
      console.log('Calculations captured:', this.data.calculations.length);
      console.log('Errors:', this.data.errors.length);
      return this.data;
    },

    // Export all data
    export: function() {
      const exportData = {
        ...this.data,
        exportedAt: new Date().toISOString(),
        captureStarted: this.startTime
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `faceiq-capture-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      console.log('%c✓ Data exported!', 'color: #00ff00; font-weight: bold');
      return exportData;
    },

    // Scrape visible calculations from the page
    scrapeCalculations: function() {
      const calculations = {};

      // Look for common measurement containers
      const selectors = [
        '[class*="measurement"]',
        '[class*="score"]',
        '[class*="ratio"]',
        '[class*="result"]',
        '[class*="analysis"]',
        '[class*="metric"]'
      ];

      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(el => {
          const text = el.innerText.trim();
          if (text && text.length < 200) {
            calculations[selector] = calculations[selector] || [];
            calculations[selector].push({
              text: text,
              html: el.outerHTML.substring(0, 500)
            });
          }
        });
      });

      // Also get any visible numbers that look like measurements
      const allText = document.body.innerText;
      const measurementPatterns = [
        /FWHR[:\s]+(\d+\.?\d*)/gi,
        /Golden Ratio[:\s]+(\d+\.?\d*)/gi,
        /Symmetry[:\s]+(\d+\.?\d*%?)/gi,
        /Facial Thirds[:\s]+([\d.]+)/gi,
        /Canthal Tilt[:\s]+([-\d.]+°?)/gi,
        /Nasolabial Angle[:\s]+(\d+\.?\d*°?)/gi,
        /Gonial Angle[:\s]+(\d+\.?\d*°?)/gi
      ];

      measurementPatterns.forEach(pattern => {
        const matches = allText.match(pattern);
        if (matches) {
          calculations.extracted = calculations.extracted || [];
          calculations.extracted.push(...matches);
        }
      });

      this.data.calculations.push({
        timestamp: new Date().toISOString(),
        url: window.location.href,
        data: calculations
      });

      console.log('%c✓ Calculations scraped', 'color: #00ff00');
      return calculations;
    }
  };

  // ============================================
  // 1. INTERCEPT FETCH API (for API calls)
  // ============================================
  const originalFetch = window.fetch;
  window.fetch = async function(...args) {
    const url = args[0]?.url || args[0];
    const options = args[1] || {};

    // Log the request
    if (url && url.includes && url.includes('faceiqlabs.com/api')) {
      const requestData = {
        timestamp: new Date().toISOString(),
        url: url,
        method: options.method || 'GET',
        body: options.body ? tryParse(options.body) : null
      };
      FaceIQCapture.data.api.requests.push(requestData);
      console.log('%c→ API Request:', 'color: #ffaa00', requestData.method, url);
    }

    // Make the actual request
    const response = await originalFetch.apply(this, args);

    // Capture the response
    if (url && url.includes && url.includes('faceiqlabs.com/api')) {
      try {
        const clonedResponse = response.clone();
        const responseBody = await clonedResponse.json();

        FaceIQCapture.data.api.responses.push({
          timestamp: new Date().toISOString(),
          url: url,
          status: response.status,
          body: responseBody
        });

        console.log('%c← API Response:', 'color: #00aaff', response.status, url);

        // Special handling for landmark data
        if (responseBody.data && responseBody.data.landmarks) {
          console.log('%c  ✓ Contains landmarks!', 'color: #00ff00',
            responseBody.data.landmarks.length, 'points');
        }
      } catch (e) {
        // Response might not be JSON
      }
    }

    return response;
  };

  // ============================================
  // 2. INTERCEPT MEDIAPIPE (for front face)
  // ============================================
  function interceptMediaPipe() {
    // Wait for MediaPipe to load
    const checkInterval = setInterval(() => {
      // Try to find the FaceLandmarker in the global scope or modules
      if (window.FaceLandmarker) {
        clearInterval(checkInterval);
        hookFaceLandmarker(window.FaceLandmarker);
      }

      // Also try to intercept via prototype if available
      try {
        const proto = Object.getPrototypeOf(document.createElement('canvas').getContext('2d'));
        // Additional hooks can go here
      } catch (e) {}
    }, 500);

    // Also intercept any canvas drawing (landmarks are drawn on canvas)
    const originalDrawImage = CanvasRenderingContext2D.prototype.drawImage;
    CanvasRenderingContext2D.prototype.drawImage = function(...args) {
      // Track when images are drawn (face photos)
      if (args[0] instanceof HTMLImageElement || args[0] instanceof HTMLVideoElement) {
        // Could capture the image here if needed
      }
      return originalDrawImage.apply(this, args);
    };

    // Intercept arc drawing (landmark points are circles)
    const originalArc = CanvasRenderingContext2D.prototype.arc;
    let arcPoints = [];
    let lastArcTime = 0;

    CanvasRenderingContext2D.prototype.arc = function(x, y, radius, startAngle, endAngle) {
      const now = Date.now();

      // If drawing many small circles in quick succession, it's likely landmarks
      if (radius < 10 && radius > 1) {
        if (now - lastArcTime < 100) {
          arcPoints.push({ x, y, radius });
        } else {
          // New batch of points
          if (arcPoints.length > 50) {
            // This was probably a landmark drawing
            FaceIQCapture.data.landmarks.detected.push({
              timestamp: new Date().toISOString(),
              pointCount: arcPoints.length,
              points: [...arcPoints]
            });
            console.log('%c✓ Detected landmark drawing:', 'color: #00ff00', arcPoints.length, 'points');
          }
          arcPoints = [{ x, y, radius }];
        }
        lastArcTime = now;
      }

      return originalArc.apply(this, arguments);
    };
  }

  function hookFaceLandmarker(FaceLandmarkerClass) {
    const originalDetect = FaceLandmarkerClass.prototype.detect;
    if (originalDetect) {
      FaceLandmarkerClass.prototype.detect = function(...args) {
        const result = originalDetect.apply(this, args);

        if (result && result.faceLandmarks && result.faceLandmarks.length > 0) {
          const landmarks = result.faceLandmarks[0];
          FaceIQCapture.data.mediapipe.frontFace.push({
            timestamp: new Date().toISOString(),
            landmarkCount: landmarks.length,
            landmarks: landmarks.map((p, i) => ({
              index: i,
              x: p.x,
              y: p.y,
              z: p.z
            })),
            blendshapes: result.faceBlendshapes?.[0] || null
          });

          console.log('%c✓ MediaPipe detection captured!', 'color: #00ff00',
            landmarks.length, 'landmarks');
        }

        return result;
      };
      console.log('%c✓ MediaPipe FaceLandmarker hooked', 'color: #00ff00');
    }
  }

  // ============================================
  // 3. INTERCEPT MOUSE EVENTS (for adjustments)
  // ============================================
  function interceptMouseEvents() {
    let isDragging = false;
    let dragStart = null;
    let dragPoints = [];

    document.addEventListener('mousedown', (e) => {
      // Check if clicking on a landmark point (usually a small circle/dot)
      const target = e.target;
      if (target.tagName === 'circle' ||
          target.classList.contains('landmark') ||
          target.dataset.landmark) {
        isDragging = true;
        dragStart = { x: e.clientX, y: e.clientY, target: target.outerHTML };
      }
    }, true);

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        dragPoints.push({ x: e.clientX, y: e.clientY });
      }
    }, true);

    document.addEventListener('mouseup', (e) => {
      if (isDragging && dragPoints.length > 0) {
        FaceIQCapture.data.landmarks.adjusted.push({
          timestamp: new Date().toISOString(),
          start: dragStart,
          end: { x: e.clientX, y: e.clientY },
          pointsMoved: dragPoints.length,
          path: dragPoints
        });
        console.log('%c✓ Landmark adjustment captured', 'color: #ffaa00');
      }
      isDragging = false;
      dragStart = null;
      dragPoints = [];
    }, true);
  }

  // ============================================
  // 4. REACT STATE CAPTURE
  // ============================================
  function captureReactState() {
    // Try to find React fiber
    const root = document.getElementById('__next');
    if (root && root._reactRootContainer) {
      try {
        const fiber = root._reactRootContainer._internalRoot?.current;
        FaceIQCapture.data.uiState.push({
          timestamp: new Date().toISOString(),
          note: 'React fiber accessible',
          fiber: 'Available - use React DevTools for detailed inspection'
        });
      } catch (e) {
        FaceIQCapture.data.errors.push({
          timestamp: new Date().toISOString(),
          error: 'Could not access React fiber',
          message: e.message
        });
      }
    }
  }

  // ============================================
  // UTILITY FUNCTIONS
  // ============================================
  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return str;
    }
  }

  // ============================================
  // INITIALIZE
  // ============================================
  console.log('%c╔═══════════════════════════════════════╗', 'color: #00ff00');
  console.log('%c║   FaceIQ Capture Script v1.0          ║', 'color: #00ff00');
  console.log('%c║   Ready to capture all data!          ║', 'color: #00ff00');
  console.log('%c╠═══════════════════════════════════════╣', 'color: #00ff00');
  console.log('%c║ Commands:                             ║', 'color: #00ff00');
  console.log('%c║   FaceIQCapture.status()   - Check    ║', 'color: #00ff00');
  console.log('%c║   FaceIQCapture.export()   - Download ║', 'color: #00ff00');
  console.log('%c║   FaceIQCapture.scrapeCalculations()  ║', 'color: #00ff00');
  console.log('%c╚═══════════════════════════════════════╝', 'color: #00ff00');

  interceptMediaPipe();
  interceptMouseEvents();
  captureReactState();

  // Periodically try to scrape calculations
  setInterval(() => {
    if (window.location.href.includes('analysis') ||
        window.location.href.includes('result') ||
        document.body.innerText.includes('FWHR') ||
        document.body.innerText.includes('Golden Ratio')) {
      FaceIQCapture.scrapeCalculations();
    }
  }, 5000);

  console.log('%c✓ All interceptors active', 'color: #00ff00');
  console.log('%c→ Now use the site normally. Data will be captured automatically.', 'color: #ffaa00');

})();
