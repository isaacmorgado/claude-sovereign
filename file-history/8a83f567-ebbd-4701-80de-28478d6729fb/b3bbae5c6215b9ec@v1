#!/usr/bin/env python3
"""Extract calculation-related code from FaceIQ minified JavaScript"""

import re
import os

JS_PATH = os.path.expanduser("~/Desktop/FACEIQHAR/dashboard-front/_next/static/chunks/053ca3e7db98a078-q82d43b8cac.js")
OUTPUT_PATH = os.path.expanduser("~/Desktop/reverse-engineer/extracted-calculations.txt")

print(f"Reading: {JS_PATH}")
with open(JS_PATH, 'r') as f:
    js_content = f.read()

print(f"File size: {len(js_content):,} characters")

# Patterns to search for
patterns = {
    "Math operations": r'Math\.(sqrt|atan2|pow|abs|cos|sin|tan|PI|floor|ceil|round)\([^)]+\)',
    "Distance calculations": r'\b(distance|dist)\s*[=:]\s*[^;,]+',
    "Angle calculations": r'\b(angle|tilt|rotation)\s*[=:]\s*[^;,]+',
    "Ratio calculations": r'\b(ratio|fwhr|golden)\s*[=:]\s*[^;,]+',
    "Score functions": r'\b(score|Score|getScore|calculateScore)[^(]*\([^)]*\)',
    "Landmark references": r'landmarks?\[\d+\]',
    "Width/Height": r'\b(width|height)\s*[=:]\s*[^;,]+(?:landmark|point)',
    "Coordinate access": r'\.[xy]\b',
    "Function definitions with calc/score/measure": r'function\s+\w*(calc|score|measure|ratio|angle|distance)\w*\s*\([^)]*\)',
    "Arrow functions with math": r'\([^)]*\)\s*=>\s*\{[^}]*Math\.',
    "Object with idealMin/idealMax": r'\{[^}]*ideal(?:Min|Max)[^}]*\}',
    "Facial features": r'(Trichion|Glabella|Nasion|Pronasale|Subnasale|Pogonion|Menton|Gonion|canthal|nasolabial|gonial)',
}

results = {}
for name, pattern in patterns.items():
    matches = re.findall(pattern, js_content, re.IGNORECASE)
    if matches:
        # Deduplicate and limit
        unique_matches = list(set(matches))[:50]
        results[name] = unique_matches
        print(f"\n{name}: {len(matches)} matches (showing {len(unique_matches)} unique)")
        for m in unique_matches[:10]:
            if isinstance(m, str) and len(m) < 200:
                print(f"  - {m[:100]}")

# Look for longer calculation blocks
print("\n\n=== Searching for calculation blocks ===")

# Find function blocks containing calculation keywords
calc_block_pattern = r'function\s*\w*\s*\([^)]*\)\s*\{[^}]{50,500}(?:Math\.|score|ratio|angle|distance)[^}]{0,500}\}'
calc_blocks = re.findall(calc_block_pattern, js_content, re.IGNORECASE)
print(f"\nFound {len(calc_blocks)} potential calculation function blocks")

# Find objects with measurement configurations
config_pattern = r'\{[^{}]{20,500}(?:idealMin|idealMax|scoreWeight|harmonyScore)[^{}]{0,500}\}'
configs = re.findall(config_pattern, js_content, re.IGNORECASE)
print(f"Found {len(configs)} potential configuration objects")

# Save all findings
with open(OUTPUT_PATH, 'w') as f:
    f.write("# FaceIQ Calculation Code Extraction\n\n")

    for name, matches in results.items():
        f.write(f"\n## {name}\n")
        for m in matches:
            if isinstance(m, str):
                f.write(f"- {m}\n")

    f.write("\n\n## Calculation Function Blocks\n")
    for i, block in enumerate(calc_blocks[:20]):
        f.write(f"\n### Block {i+1}\n```javascript\n{block}\n```\n")

    f.write("\n\n## Configuration Objects\n")
    for i, config in enumerate(configs[:20]):
        f.write(f"\n### Config {i+1}\n```javascript\n{config}\n```\n")

print(f"\nResults saved to: {OUTPUT_PATH}")

# Also search for specific known patterns from the summary
print("\n\n=== Searching for known FaceIQ patterns ===")

known_patterns = [
    r'getScoreColorRGB',
    r'harmonyAnalysis',
    r'facialThirds',
    r'symmetryScore',
    r'goldenRatio',
    r'faceLandmarks',
    r'sideLandmarks',
    r'cephalometric',
]

for pattern in known_patterns:
    matches = re.findall(f'.{{0,50}}{pattern}.{{0,50}}', js_content, re.IGNORECASE)
    if matches:
        print(f"\n{pattern}: {len(matches)} occurrences")
        for m in matches[:3]:
            print(f"  ...{m}...")
