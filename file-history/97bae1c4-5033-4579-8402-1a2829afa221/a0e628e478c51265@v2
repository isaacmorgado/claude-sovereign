#!/usr/bin/env python3
"""
AI Face Generator Automation Script
Generates diverse faces using Somake AI dropdown interface
"""

import asyncio
import json
from pathlib import Path
from playwright.async_api import async_playwright
import time

# Configuration
OUTPUT_DIR = Path("/Users/imorgado/Desktop/face_generation/generated_faces")
SOMAKE_URL = "https://www.somake.ai/tools/face-generator"

# Somake AI available ethnicities (from their dropdown)
# American, Japanese, European, Korean, Latino, Custom
# We'll map our ethnicities to their options + use Custom for others

FACES_TO_GENERATE = [
    # Using their preset ethnicities
    {"ethnicity": "European", "gender": "Male", "filename": "male_white_front.webp", "custom_ethnicity": None},
    {"ethnicity": "European", "gender": "Female", "filename": "female_white_front.webp", "custom_ethnicity": None},
    {"ethnicity": "Japanese", "gender": "Male", "filename": "male_east_asian_front.webp", "custom_ethnicity": None},
    {"ethnicity": "Japanese", "gender": "Female", "filename": "female_east_asian_front.webp", "custom_ethnicity": None},
    {"ethnicity": "Korean", "gender": "Male", "filename": "male_korean_front.webp", "custom_ethnicity": None},
    {"ethnicity": "Korean", "gender": "Female", "filename": "female_korean_front.webp", "custom_ethnicity": None},
    {"ethnicity": "Latino", "gender": "Male", "filename": "male_hispanic_front.webp", "custom_ethnicity": None},
    {"ethnicity": "Latino", "gender": "Female", "filename": "female_hispanic_front.webp", "custom_ethnicity": None},

    # Using Custom ethnicity for others
    {"ethnicity": "Custom", "gender": "Male", "filename": "male_black_front.webp", "custom_ethnicity": "Black African"},
    {"ethnicity": "Custom", "gender": "Female", "filename": "female_black_front.webp", "custom_ethnicity": "Black African"},
    {"ethnicity": "Custom", "gender": "Male", "filename": "male_south_asian_front.webp", "custom_ethnicity": "South Asian Indian"},
    {"ethnicity": "Custom", "gender": "Female", "filename": "female_south_asian_front.webp", "custom_ethnicity": "South Asian Indian"},
    {"ethnicity": "Custom", "gender": "Male", "filename": "male_middle_eastern_front.webp", "custom_ethnicity": "Middle Eastern Arab"},
    {"ethnicity": "Custom", "gender": "Female", "filename": "female_middle_eastern_front.webp", "custom_ethnicity": "Middle Eastern Arab"},
    {"ethnicity": "Custom", "gender": "Male", "filename": "male_pacific_islander_front.webp", "custom_ethnicity": "Pacific Islander Polynesian"},
    {"ethnicity": "Custom", "gender": "Female", "filename": "female_pacific_islander_front.webp", "custom_ethnicity": "Pacific Islander Polynesian"},
    {"ethnicity": "Custom", "gender": "Male", "filename": "male_native_american_front.webp", "custom_ethnicity": "Native American Indigenous"},
    {"ethnicity": "Custom", "gender": "Female", "filename": "female_native_american_front.webp", "custom_ethnicity": "Native American Indigenous"},
]

async def select_dropdown(page, label_text: str, value: str):
    """Select a value from a dropdown by finding its label"""
    try:
        # Try to find dropdown by label
        dropdown = await page.locator(f'select:near(:text("{label_text}"))').first
        if dropdown:
            await dropdown.select_option(label=value)
            return True
    except:
        pass

    # Try clicking dropdown and selecting option
    try:
        dropdown_btn = await page.locator(f'button:near(:text("{label_text}"))').first
        if dropdown_btn:
            await dropdown_btn.click()
            await asyncio.sleep(0.5)
            option = await page.locator(f'text="{value}"').first
            if option:
                await option.click()
                return True
    except:
        pass

    return False


async def generate_face(page, face_config: dict, output_dir: Path):
    """Generate a single face using dropdown selections"""
    print(f"\n{'='*60}")
    print(f"Generating: {face_config['filename']}")
    print(f"Gender: {face_config['gender']}, Ethnicity: {face_config['ethnicity']}")
    if face_config['custom_ethnicity']:
        print(f"Custom: {face_config['custom_ethnicity']}")

    try:
        # Refresh page for clean state
        await page.goto(SOMAKE_URL, wait_until="networkidle")
        await asyncio.sleep(3)

        # Select Gender
        gender_selectors = [
            f'button:has-text("{face_config["gender"]}")',
            f'[data-value="{face_config["gender"].lower()}"]',
            f'label:has-text("{face_config["gender"]}")',
        ]
        for selector in gender_selectors:
            try:
                elem = page.locator(selector).first
                if await elem.is_visible():
                    await elem.click()
                    print(f"  ✓ Selected gender: {face_config['gender']}")
                    break
            except:
                continue
        await asyncio.sleep(0.5)

        # Select Ethnicity
        ethnicity_selectors = [
            f'button:has-text("{face_config["ethnicity"]}")',
            f'[data-value="{face_config["ethnicity"].lower()}"]',
            f'label:has-text("{face_config["ethnicity"]}")',
        ]
        for selector in ethnicity_selectors:
            try:
                elem = page.locator(selector).first
                if await elem.is_visible():
                    await elem.click()
                    print(f"  ✓ Selected ethnicity: {face_config['ethnicity']}")
                    break
            except:
                continue
        await asyncio.sleep(0.5)

        # If custom ethnicity, try to enter it
        if face_config['custom_ethnicity']:
            try:
                custom_input = page.locator('input[placeholder*="ethnicity"], input[placeholder*="custom"], textarea').first
                if await custom_input.is_visible():
                    await custom_input.fill(face_config['custom_ethnicity'])
                    print(f"  ✓ Entered custom ethnicity: {face_config['custom_ethnicity']}")
            except:
                print(f"  ! Could not enter custom ethnicity")

        # Select white background
        bg_selectors = [
            'button:has-text("High-Key White")',
            'button:has-text("White")',
            '[data-value="white"]',
        ]
        for selector in bg_selectors:
            try:
                elem = page.locator(selector).first
                if await elem.is_visible():
                    await elem.click()
                    print(f"  ✓ Selected white background")
                    break
            except:
                continue
        await asyncio.sleep(0.5)

        # Take screenshot before generating (for debugging)
        await page.screenshot(path=output_dir / f"debug_before_{face_config['filename']}.png")

        # Click Generate button
        generate_selectors = [
            'button:has-text("Generate")',
            'button[type="submit"]',
            '.generate-button',
            '#generate-btn',
        ]

        for selector in generate_selectors:
            try:
                btn = page.locator(selector).first
                if await btn.is_visible():
                    await btn.click()
                    print(f"  ✓ Clicked Generate")
                    break
            except:
                continue

        # Wait for generation (can take 10-30 seconds)
        print(f"  ⏳ Waiting for image generation...")
        await asyncio.sleep(20)

        # Look for generated image
        await page.screenshot(path=output_dir / f"debug_after_{face_config['filename']}.png")

        # Try to find and download the generated image
        image_selectors = [
            '#results-panel img',
            '.generated-image img',
            '.result-image img',
            'img[src*="generated"]',
            'img[src*="output"]',
            'img[src*="faces"]',
        ]

        for selector in image_selectors:
            try:
                images = await page.locator(selector).all()
                for img in images:
                    if await img.is_visible():
                        src = await img.get_attribute('src')
                        if src and ('blob:' in src or 'http' in src or 'data:' in src):
                            # Screenshot the image element
                            save_path = output_dir / face_config['filename'].replace('.webp', '.png')
                            await img.screenshot(path=save_path)
                            print(f"  ✓ Saved image to {save_path}")
                            return True
            except:
                continue

        # Try clicking download button
        download_selectors = [
            'button:has-text("Download")',
            'a:has-text("Download")',
            '[download]',
            'button:has-text("Save")',
        ]

        for selector in download_selectors:
            try:
                btn = page.locator(selector).first
                if await btn.is_visible():
                    async with page.expect_download(timeout=15000) as download_info:
                        await btn.click()
                    download = await download_info.value
                    save_path = output_dir / face_config['filename']
                    await download.save_as(save_path)
                    print(f"  ✓ Downloaded to {save_path}")
                    return True
            except:
                continue

        print(f"  ✗ Could not find/download generated image")
        return False

    except Exception as e:
        print(f"  ✗ Error: {e}")
        await page.screenshot(path=output_dir / f"error_{face_config['filename']}.png")
        return False


async def main():
    """Main function to generate all faces"""
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    results = {'success': [], 'failed': []}

    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=False,  # Show browser so you can see what's happening
            slow_mo=300
        )

        context = await browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            accept_downloads=True
        )

        page = await context.new_page()

        # Process first few faces as a test
        test_faces = FACES_TO_GENERATE[:4]  # Start with 4 to test

        for i, face in enumerate(test_faces):
            print(f"\n[{i+1}/{len(test_faces)}] Processing...")

            success = await generate_face(page, face, OUTPUT_DIR)

            if success:
                results['success'].append(face['filename'])
            else:
                results['failed'].append(face['filename'])

            await asyncio.sleep(2)

        # Keep browser open for inspection
        print("\n" + "="*60)
        print("TEST BATCH COMPLETE")
        print(f"Success: {len(results['success'])}")
        print(f"Failed: {len(results['failed'])}")
        print("="*60)
        print("\nBrowser will stay open for 30 seconds for inspection...")
        await asyncio.sleep(30)

        await browser.close()

    with open(OUTPUT_DIR / 'results.json', 'w') as f:
        json.dump(results, f, indent=2)

    print(f"\nResults saved to: {OUTPUT_DIR}")


if __name__ == "__main__":
    asyncio.run(main())
