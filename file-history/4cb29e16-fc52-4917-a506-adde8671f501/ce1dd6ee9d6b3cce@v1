import { googleOAuthManager } from "./oauth"

/**
 * Gemini subscription tiers
 */
export type GeminiSubscriptionTier = "free" | "pro" | "max" | "unknown"

/**
 * Subscription status with details
 */
export interface GeminiSubscriptionStatus {
	tier: GeminiSubscriptionTier
	isActive: boolean
	expiresAt?: string
	email?: string
	cachedAt: number
}

// Cache TTL in milliseconds (5 minutes)
const SUBSCRIPTION_CACHE_TTL = 5 * 60 * 1000

// Cached subscription status
let cachedSubscription: GeminiSubscriptionStatus | null = null

/**
 * Check Gemini subscription status
 * Uses OAuth token to query Google's subscription APIs
 */
export async function checkGeminiSubscription(): Promise<GeminiSubscriptionStatus> {
	// Return cached result if still valid
	if (cachedSubscription && Date.now() - cachedSubscription.cachedAt < SUBSCRIPTION_CACHE_TTL) {
		return cachedSubscription
	}

	const accessToken = await googleOAuthManager.getAccessToken()

	if (!accessToken) {
		return {
			tier: "unknown",
			isActive: false,
			cachedAt: Date.now(),
		}
	}

	try {
		// Query Google's subscription status endpoint
		// Note: This endpoint may need to be adjusted based on actual Google API
		// Currently using a placeholder endpoint structure
		const response = await fetch("https://generativelanguage.googleapis.com/v1/subscriptions", {
			headers: {
				Authorization: `Bearer ${accessToken}`,
			},
			signal: AbortSignal.timeout(10000),
		})

		if (!response.ok) {
			// If 401/403, the user might not have a subscription
			if (response.status === 401 || response.status === 403) {
				cachedSubscription = {
					tier: "free",
					isActive: true,
					email: await googleOAuthManager.getEmail() || undefined,
					cachedAt: Date.now(),
				}
				return cachedSubscription
			}

			// For other errors, return unknown
			console.warn("[google-subscription] Failed to check subscription:", response.status)
			return {
				tier: "unknown",
				isActive: false,
				cachedAt: Date.now(),
			}
		}

		const data = await response.json()

		// Parse subscription data
		// Note: Actual structure depends on Google's API response format
		const tier = parseSubscriptionTier(data)
		const email = await googleOAuthManager.getEmail()

		cachedSubscription = {
			tier,
			isActive: tier !== "free" && tier !== "unknown",
			expiresAt: data.expiresAt,
			email: email || undefined,
			cachedAt: Date.now(),
		}

		return cachedSubscription
	} catch (error) {
		console.error("[google-subscription] Error checking subscription:", error)
		return {
			tier: "unknown",
			isActive: false,
			cachedAt: Date.now(),
		}
	}
}

/**
 * Parse subscription tier from API response
 */
function parseSubscriptionTier(data: unknown): GeminiSubscriptionTier {
	if (!data || typeof data !== "object") {
		return "free"
	}

	const subscription = data as { tier?: string; plan?: string; type?: string }

	// Try different field names that Google might use
	const tierValue = subscription.tier || subscription.plan || subscription.type || ""

	switch (tierValue.toLowerCase()) {
		case "max":
		case "gemini_max":
		case "advanced":
		case "ultra":
			return "max"
		case "pro":
		case "gemini_pro":
		case "premium":
			return "pro"
		case "free":
		case "basic":
		case "":
			return "free"
		default:
			return "unknown"
	}
}

/**
 * Check if user has Gemini Max subscription
 */
export async function isGeminiMaxSubscriber(): Promise<boolean> {
	const status = await checkGeminiSubscription()
	return status.tier === "max"
}

/**
 * Check if user has Gemini Pro subscription or higher
 */
export async function isGeminiProOrHigher(): Promise<boolean> {
	const status = await checkGeminiSubscription()
	return status.tier === "pro" || status.tier === "max"
}

/**
 * Check if user has any paid Gemini subscription
 */
export async function hasGeminiSubscription(): Promise<boolean> {
	const status = await checkGeminiSubscription()
	return status.isActive
}

/**
 * Get current cached subscription status (if available)
 */
export function getCachedSubscription(): GeminiSubscriptionStatus | null {
	return cachedSubscription
}

/**
 * Clear subscription cache
 */
export function clearSubscriptionCache(): void {
	cachedSubscription = null
}

/**
 * Get subscription tier display name
 */
export function getSubscriptionTierDisplayName(tier: GeminiSubscriptionTier): string {
	switch (tier) {
		case "max":
			return "Gemini Max"
		case "pro":
			return "Gemini Pro"
		case "free":
			return "Free"
		default:
			return "Unknown"
	}
}

/**
 * Get features available for a subscription tier
 */
export function getSubscriptionFeatures(tier: GeminiSubscriptionTier): {
	hasAdvancedModels: boolean
	hasHigherRateLimits: boolean
	hasPriorityAccess: boolean
	hasLongerContext: boolean
} {
	switch (tier) {
		case "max":
			return {
				hasAdvancedModels: true,
				hasHigherRateLimits: true,
				hasPriorityAccess: true,
				hasLongerContext: true,
			}
		case "pro":
			return {
				hasAdvancedModels: true,
				hasHigherRateLimits: true,
				hasPriorityAccess: false,
				hasLongerContext: false,
			}
		case "free":
		default:
			return {
				hasAdvancedModels: false,
				hasHigherRateLimits: false,
				hasPriorityAccess: false,
				hasLongerContext: false,
			}
	}
}
