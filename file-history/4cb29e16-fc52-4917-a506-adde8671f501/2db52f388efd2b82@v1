import * as crypto from "crypto"
import * as http from "http"
import { URL } from "url"
import type { ExtensionContext } from "vscode"
import { z } from "zod"

// OAuth Configuration for Google
export const GOOGLE_OAUTH_CONFIG = {
	authorizationEndpoint: "https://accounts.google.com/o/oauth2/v2/auth",
	tokenEndpoint: "https://oauth2.googleapis.com/token",
	userInfoEndpoint: "https://www.googleapis.com/oauth2/v3/userinfo",
	// Client ID for desktop apps - should be registered in Google Cloud Console
	// Using placeholder - replace with actual registered client ID
	clientId: process.env.GOOGLE_OAUTH_CLIENT_ID || "YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com",
	clientSecret: process.env.GOOGLE_OAUTH_CLIENT_SECRET || "",
	redirectUri: "http://localhost:54546/callback",
	scopes: [
		"openid",
		"email",
		"profile",
		"https://www.googleapis.com/auth/cloud-platform", // For Gemini API access
	].join(" "),
	callbackPort: 54546,
} as const

// Token storage key
const GOOGLE_CREDENTIALS_KEY = "google-oauth-credentials"

// Credentials schema
const googleCredentialsSchema = z.object({
	type: z.literal("google"),
	access_token: z.string().min(1),
	refresh_token: z.string().optional(),
	expires_at: z.string(), // RFC3339 datetime
	email: z.string().optional(),
	name: z.string().optional(),
	picture: z.string().optional(),
	id_token: z.string().optional(),
})

export type GoogleCredentials = z.infer<typeof googleCredentialsSchema>

// Token response schema from Google
const tokenResponseSchema = z.object({
	access_token: z.string(),
	refresh_token: z.string().optional(),
	expires_in: z.number(),
	token_type: z.string(),
	scope: z.string().optional(),
	id_token: z.string().optional(),
})

// User info response schema
const userInfoResponseSchema = z.object({
	sub: z.string(),
	email: z.string().optional(),
	email_verified: z.boolean().optional(),
	name: z.string().optional(),
	given_name: z.string().optional(),
	family_name: z.string().optional(),
	picture: z.string().optional(),
})

/**
 * Generates a cryptographically random PKCE code verifier
 * Must be 43-128 characters long using unreserved characters
 */
export function generateCodeVerifier(): string {
	const buffer = crypto.randomBytes(32)
	return buffer.toString("base64url")
}

/**
 * Generates the PKCE code challenge from the verifier using S256 method
 */
export function generateCodeChallenge(verifier: string): string {
	const hash = crypto.createHash("sha256").update(verifier).digest()
	return hash.toString("base64url")
}

/**
 * Generates a random state parameter for CSRF protection
 */
export function generateState(): string {
	return crypto.randomBytes(16).toString("hex")
}

/**
 * Builds the authorization URL for Google OAuth flow
 */
export function buildAuthorizationUrl(codeChallenge: string, state: string): string {
	const params = new URLSearchParams({
		client_id: GOOGLE_OAUTH_CONFIG.clientId,
		redirect_uri: GOOGLE_OAUTH_CONFIG.redirectUri,
		scope: GOOGLE_OAUTH_CONFIG.scopes,
		code_challenge: codeChallenge,
		code_challenge_method: "S256",
		response_type: "code",
		state,
		access_type: "offline", // Request refresh token
		prompt: "consent", // Force consent to get refresh token
	})

	return `${GOOGLE_OAUTH_CONFIG.authorizationEndpoint}?${params.toString()}`
}

/**
 * Exchanges the authorization code for tokens
 */
export async function exchangeCodeForTokens(
	code: string,
	codeVerifier: string,
): Promise<GoogleCredentials> {
	const body = new URLSearchParams({
		code,
		client_id: GOOGLE_OAUTH_CONFIG.clientId,
		client_secret: GOOGLE_OAUTH_CONFIG.clientSecret,
		redirect_uri: GOOGLE_OAUTH_CONFIG.redirectUri,
		grant_type: "authorization_code",
		code_verifier: codeVerifier,
	})

	const response = await fetch(GOOGLE_OAUTH_CONFIG.tokenEndpoint, {
		method: "POST",
		headers: {
			"Content-Type": "application/x-www-form-urlencoded",
		},
		body: body.toString(),
		signal: AbortSignal.timeout(30000),
	})

	if (!response.ok) {
		const errorText = await response.text()
		throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${errorText}`)
	}

	const data = await response.json()
	const tokenResponse = tokenResponseSchema.parse(data)

	// Calculate expiry time
	const expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000)

	// Fetch user info
	const userInfo = await fetchUserInfo(tokenResponse.access_token)

	return {
		type: "google",
		access_token: tokenResponse.access_token,
		refresh_token: tokenResponse.refresh_token,
		expires_at: expiresAt.toISOString(),
		email: userInfo?.email,
		name: userInfo?.name,
		picture: userInfo?.picture,
		id_token: tokenResponse.id_token,
	}
}

/**
 * Fetches user info from Google
 */
async function fetchUserInfo(
	accessToken: string,
): Promise<{ email?: string; name?: string; picture?: string } | null> {
	try {
		const response = await fetch(GOOGLE_OAUTH_CONFIG.userInfoEndpoint, {
			headers: {
				Authorization: `Bearer ${accessToken}`,
			},
			signal: AbortSignal.timeout(10000),
		})

		if (!response.ok) {
			console.warn("[google-oauth] Failed to fetch user info:", response.status)
			return null
		}

		const data = await response.json()
		const userInfo = userInfoResponseSchema.parse(data)

		return {
			email: userInfo.email,
			name: userInfo.name,
			picture: userInfo.picture,
		}
	} catch (error) {
		console.warn("[google-oauth] Error fetching user info:", error)
		return null
	}
}

/**
 * Refreshes the access token using the refresh token
 */
export async function refreshAccessToken(refreshToken: string): Promise<GoogleCredentials> {
	const body = new URLSearchParams({
		grant_type: "refresh_token",
		client_id: GOOGLE_OAUTH_CONFIG.clientId,
		client_secret: GOOGLE_OAUTH_CONFIG.clientSecret,
		refresh_token: refreshToken,
	})

	const response = await fetch(GOOGLE_OAUTH_CONFIG.tokenEndpoint, {
		method: "POST",
		headers: {
			"Content-Type": "application/x-www-form-urlencoded",
		},
		body: body.toString(),
		signal: AbortSignal.timeout(30000),
	})

	if (!response.ok) {
		const errorText = await response.text()
		throw new Error(`Token refresh failed: ${response.status} ${response.statusText} - ${errorText}`)
	}

	const data = await response.json()
	const tokenResponse = tokenResponseSchema.parse(data)

	// Calculate expiry time
	const expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000)

	// Fetch updated user info
	const userInfo = await fetchUserInfo(tokenResponse.access_token)

	return {
		type: "google",
		access_token: tokenResponse.access_token,
		// Google may not return a new refresh token on refresh
		refresh_token: tokenResponse.refresh_token || refreshToken,
		expires_at: expiresAt.toISOString(),
		email: userInfo?.email,
		name: userInfo?.name,
		picture: userInfo?.picture,
		id_token: tokenResponse.id_token,
	}
}

/**
 * Checks if the credentials are expired (with 5 minute buffer)
 */
export function isTokenExpired(credentials: GoogleCredentials): boolean {
	const expiryTime = new Date(credentials.expires_at).getTime()
	const bufferMs = 5 * 60 * 1000 // 5 minutes buffer
	return Date.now() >= expiryTime - bufferMs
}

/**
 * GoogleOAuthManager - Handles OAuth flow and token management for Google
 */
export class GoogleOAuthManager {
	private context: ExtensionContext | null = null
	private credentials: GoogleCredentials | null = null
	private pendingAuth: {
		codeVerifier: string
		state: string
		server?: http.Server
	} | null = null

	/**
	 * Initialize the OAuth manager with VS Code extension context
	 */
	initialize(context: ExtensionContext): void {
		this.context = context
	}

	/**
	 * Load credentials from storage
	 */
	async loadCredentials(): Promise<GoogleCredentials | null> {
		if (!this.context) {
			return null
		}

		try {
			const credentialsJson = await this.context.secrets.get(GOOGLE_CREDENTIALS_KEY)
			if (!credentialsJson) {
				return null
			}

			const parsed = JSON.parse(credentialsJson)
			this.credentials = googleCredentialsSchema.parse(parsed)
			return this.credentials
		} catch (error) {
			console.error("[google-oauth] Failed to load credentials:", error)
			return null
		}
	}

	/**
	 * Save credentials to storage
	 */
	async saveCredentials(credentials: GoogleCredentials): Promise<void> {
		if (!this.context) {
			throw new Error("OAuth manager not initialized")
		}

		await this.context.secrets.store(GOOGLE_CREDENTIALS_KEY, JSON.stringify(credentials))
		this.credentials = credentials
	}

	/**
	 * Clear credentials from storage
	 */
	async clearCredentials(): Promise<void> {
		if (!this.context) {
			return
		}

		await this.context.secrets.delete(GOOGLE_CREDENTIALS_KEY)
		this.credentials = null
	}

	/**
	 * Get a valid access token, refreshing if necessary
	 */
	async getAccessToken(): Promise<string | null> {
		// Try to load credentials if not already loaded
		if (!this.credentials) {
			await this.loadCredentials()
		}

		if (!this.credentials) {
			return null
		}

		// Check if token is expired and refresh if needed
		if (isTokenExpired(this.credentials)) {
			if (!this.credentials.refresh_token) {
				console.warn("[google-oauth] Token expired and no refresh token available")
				await this.clearCredentials()
				return null
			}

			try {
				const newCredentials = await refreshAccessToken(this.credentials.refresh_token)
				await this.saveCredentials(newCredentials)
			} catch (error) {
				console.error("[google-oauth] Failed to refresh token:", error)
				// Clear invalid credentials
				await this.clearCredentials()
				return null
			}
		}

		return this.credentials.access_token
	}

	/**
	 * Get the user's email from credentials
	 */
	async getEmail(): Promise<string | null> {
		if (!this.credentials) {
			await this.loadCredentials()
		}
		return this.credentials?.email || null
	}

	/**
	 * Get the user's name from credentials
	 */
	async getName(): Promise<string | null> {
		if (!this.credentials) {
			await this.loadCredentials()
		}
		return this.credentials?.name || null
	}

	/**
	 * Check if the user is authenticated
	 */
	async isAuthenticated(): Promise<boolean> {
		const token = await this.getAccessToken()
		return token !== null
	}

	/**
	 * Start the OAuth authorization flow
	 * Returns the authorization URL to open in browser
	 */
	startAuthorizationFlow(): string {
		// Cancel any existing authorization flow before starting a new one
		this.cancelAuthorizationFlow()

		const codeVerifier = generateCodeVerifier()
		const codeChallenge = generateCodeChallenge(codeVerifier)
		const state = generateState()

		this.pendingAuth = {
			codeVerifier,
			state,
		}

		return buildAuthorizationUrl(codeChallenge, state)
	}

	/**
	 * Start a local server to receive the OAuth callback
	 * Returns a promise that resolves when authentication is complete
	 */
	async waitForCallback(): Promise<GoogleCredentials> {
		if (!this.pendingAuth) {
			throw new Error("No pending authorization flow")
		}

		// Close any existing server before starting a new one
		if (this.pendingAuth.server) {
			try {
				this.pendingAuth.server.close()
			} catch {
				// Ignore errors when closing
			}
			this.pendingAuth.server = undefined
		}

		return new Promise((resolve, reject) => {
			const server = http.createServer(async (req, res) => {
				try {
					const url = new URL(req.url || "", `http://localhost:${GOOGLE_OAUTH_CONFIG.callbackPort}`)

					if (url.pathname !== "/callback") {
						res.writeHead(404)
						res.end("Not Found")
						return
					}

					const code = url.searchParams.get("code")
					const state = url.searchParams.get("state")
					const error = url.searchParams.get("error")

					if (error) {
						res.writeHead(400)
						res.end(`Authentication failed: ${error}`)
						reject(new Error(`OAuth error: ${error}`))
						server.close()
						return
					}

					if (!code || !state) {
						res.writeHead(400)
						res.end("Missing code or state parameter")
						reject(new Error("Missing code or state parameter"))
						server.close()
						return
					}

					if (state !== this.pendingAuth?.state) {
						res.writeHead(400)
						res.end("State mismatch - possible CSRF attack")
						reject(new Error("State mismatch"))
						server.close()
						return
					}

					try {
						const credentials = await exchangeCodeForTokens(code, this.pendingAuth.codeVerifier)

						await this.saveCredentials(credentials)

						res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" })
						res.end(`<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Authentication Successful</title>
</head>
<body style="font-family: system-ui; text-align: center; padding: 50px;">
<h1>&#10003; Google Authentication Successful</h1>
<p>You can close this window and return to VS Code.</p>
<script>window.close();</script>
</body>
</html>`)

						this.pendingAuth = null
						server.close()
						resolve(credentials)
					} catch (exchangeError) {
						res.writeHead(500)
						res.end(`Token exchange failed: ${exchangeError}`)
						reject(exchangeError)
						server.close()
					}
				} catch (err) {
					res.writeHead(500)
					res.end("Internal server error")
					reject(err)
					server.close()
				}
			})

			server.on("error", (err: NodeJS.ErrnoException) => {
				this.pendingAuth = null
				if (err.code === "EADDRINUSE") {
					reject(
						new Error(
							`Port ${GOOGLE_OAUTH_CONFIG.callbackPort} is already in use. ` +
								`Please close any other applications using this port and try again.`,
						),
					)
				} else {
					reject(err)
				}
			})

			// Set a timeout for the callback
			const timeout = setTimeout(
				() => {
					server.close()
					reject(new Error("Authentication timed out"))
				},
				5 * 60 * 1000,
			) // 5 minutes

			server.listen(GOOGLE_OAUTH_CONFIG.callbackPort, () => {
				if (this.pendingAuth) {
					this.pendingAuth.server = server
				}
			})

			// Clear timeout when server closes
			server.on("close", () => {
				clearTimeout(timeout)
			})
		})
	}

	/**
	 * Cancel any pending authorization flow
	 */
	cancelAuthorizationFlow(): void {
		if (this.pendingAuth?.server) {
			this.pendingAuth.server.close()
		}
		this.pendingAuth = null
	}

	/**
	 * Get the current credentials (for display purposes)
	 */
	getCredentials(): GoogleCredentials | null {
		return this.credentials
	}
}

// Singleton instance
export const googleOAuthManager = new GoogleOAuthManager()
