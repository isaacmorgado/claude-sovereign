/**
 * SPLICE Backend Server
 *
 * Main entry point for the SPLICE backend API.
 * Orchestrates the audio analysis pipeline.
 *
 * Slices:
 * - Slice 4: Transcription (services/transcription.js)
 * - Slice 5: Take Detection (services/takeDetection.js)
 *
 * Architecture: Modular routes (see routes/ directory)
 */


require('dotenv').config();

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const cookieParser = require('cookie-parser');
const fs = require('fs');
const https = require('https');
const http = require('http');
const path = require('path');
const crypto = require('crypto');

// MEDIUM-005: Request ID Tracing Middleware
const { requestIdMiddleware } = require('./middleware/requestId');

// HIGH-008: Sentry Error Monitoring Integration
let Sentry = null;
if (process.env.SENTRY_DSN) {
  try {
    Sentry = require('@sentry/node');
    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');
  } catch (_err) {
    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');
  }
}

// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;

// Import services
const usageTracking = require('./services/usageTracking');
const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');
const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');
const referralService = require('./services/referralService');
const licenseService = require('./services/licenseService');
const emailService = require('./services/emailService');
const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');
const { getSupportedFormats } = require('./services/captionExporter');

// Import route modules
const healthRoutes = require('./routes/health');
const analyzeRoutes = require('./routes/analyze');
const silencesRoutes = require('./routes/silences');
const detectionRoutes = require('./routes/detection');
const exportRoutes = require('./routes/export');
const multitrackRoutes = require('./routes/multitrack');
const cutListRoutes = require('./routes/cutList');
const zoomRoutes = require('./routes/zoom');
const chaptersRoutes = require('./routes/chapters');
const youtubeRoutes = require('./routes/youtube');
const captionsRoutes = require('./routes/captions');
const textEditRoutes = require('./routes/textEdit');
const reframeRoutes = require('./routes/reframe');
const batchRoutes = require('./routes/batch');
const authRoutes = require('./routes/auth');
const billingRoutes = require('./routes/billing');
const referralRoutes = require('./routes/referral');
const licenseRoutes = require('./routes/license');
const musicRoutes = require('./routes/music');
const zoomProRoutes = require('./routes/zoomPro');
const workflowRoutes = require('./routes/workflows');

// Music generation worker (BullMQ background processor)
const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');
let musicWorkerInstance = null; // Track worker for graceful shutdown

// HIGH-011: API Versioning - v1 routes
const v1Routes = require('./routes/v1');

// Stripe for webhooks
const Stripe = require('stripe');

// MEDIUM-008: Pin Stripe API version for stability
// This prevents breaking changes when Stripe releases new API versions
// Should match version in services/stripeUsageReporting.js
const STRIPE_API_VERSION = '2024-12-18.acacia';

// =============================================================================
// SECURITY: Environment Variable Validation
// Validate all required environment variables at startup
// Fail fast with clear error messages if critical secrets are missing
// =============================================================================

/**
 * Validate required environment variables
 * @returns {Object} { valid: boolean, errors: string[] }
 */
function validateEnvironmentVariables() {
  const errors = [];
  
  // CRITICAL: Core infrastructure secrets
  if (!process.env.STRIPE_SECRET_KEY) {
    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');
  }
  
  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {
    errors.push('JWT_SECRET must be set to a secure random value (not default)');
  } else if (process.env.JWT_SECRET.length < 32) {
    // HIGH-001: Enforce minimum 32 character length for cryptographic security
    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');
  }
  
  if (!process.env.DATABASE_URL) {
    errors.push('DATABASE_URL is required (PostgreSQL connection string)');
  }
  
  if (!process.env.OPENAI_API_KEY) {
    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');
  }
  
  // CRITICAL: Redis required for job queue and rate limiting in production
  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)
  // In development, will fall back to in-memory storage
  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {
    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');
  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {
    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');
  }
  
  // CRITICAL: Webhook secret required in production
  if (!process.env.STRIPE_WEBHOOK_SECRET) {
    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');
  }
  
  // CONDITIONAL: Email provider validation
  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';
  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {
    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');
  }
  
  // RECOMMENDED: R2 Storage (warn if missing, don't block)
  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {
    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

// Run validation in production
if (isProduction) {
  const validation = validateEnvironmentVariables();
  
  if (!validation.valid) {
    console.error('[SPLICE] ========================================');
    console.error('[SPLICE] CRITICAL: Missing required environment variables');
    console.error('[SPLICE] ========================================');
    validation.errors.forEach(error => {
      console.error(`[SPLICE]   ❌ ${error}`);
    });
    console.error('[SPLICE] ========================================');
    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');
    console.error('[SPLICE] See .env.example for complete documentation.');
    process.exit(1);
  }
  
  console.log('[SPLICE] ✅ Environment validation passed');
}

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: STRIPE_API_VERSION
});

// =============================================================================
// PERF-FIX: Static Response Cache
// Cache static endpoint responses at startup to avoid repeated computation
// =============================================================================

// Generate ETag from content
function generateETag(content) {
  return `"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}"`;
}

// Static response cache - populated at startup
const STATIC_RESPONSE_CACHE = {
  profanityLanguages: null,
  profanityBleeps: null,
  exportFormats: null
};

// Initialize cache at startup (called after server starts)
function initializeStaticCache() {
  // Cache profanity languages
  const languages = getSupportedLanguages();
  STATIC_RESPONSE_CACHE.profanityLanguages = {
    body: { success: true, languages },
    etag: generateETag({ languages })
  };

  // Cache profanity bleeps
  const sounds = getAvailableBleepSounds();
  STATIC_RESPONSE_CACHE.profanityBleeps = {
    body: { success: true, sounds },
    etag: generateETag({ sounds })
  };

  // Cache export formats
  const formats = getSupportedFormats();
  STATIC_RESPONSE_CACHE.exportFormats = {
    body: { success: true, formats },
    etag: generateETag({ formats })
  };

  console.log('[SPLICE] Static response cache initialized');
}

// Helper to send cached response with ETag
function sendCachedResponse(req, res, cacheKey) {
  const cached = STATIC_RESPONSE_CACHE[cacheKey];
  if (!cached) {
    return res.status(500).json({ error: 'Cache not initialized' });
  }

  // Check If-None-Match header for conditional GET
  const clientETag = req.headers['if-none-match'];
  if (clientETag === cached.etag) {
    return res.status(304).end(); // Not Modified
  }

  // Send cached response with ETag and cache headers
  res.set('ETag', cached.etag);
  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
  res.json(cached.body);
}

// =============================================================================
// Server Configuration
// =============================================================================

const app = express();
const PORT = process.env.PORT || 3847;

// HIGH-008: Initialize Sentry after app creation
if (Sentry && process.env.SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV || 'development',
    release: process.env.npm_package_version || '6.0.3',
    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev
    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production
    integrations: [
      // Automatically instrument HTTP requests
      Sentry.httpIntegration({ tracing: true }),
      // Automatically instrument Express
      Sentry.expressIntegration({ app }),
    ],
    // Filter out sensitive data
    beforeSend(event) {
      // Remove sensitive headers
      if (event.request && event.request.headers) {
        delete event.request.headers.authorization;
        delete event.request.headers['x-stripe-customer-id'];
        delete event.request.headers['stripe-signature'];
      }
      return event;
    },
  });
  
  // Add Sentry request handler as first middleware
  app.use(Sentry.Handlers.requestHandler());
  app.use(Sentry.Handlers.tracingHandler());
  
  console.log('[SPLICE] ✅ Sentry error monitoring initialized');
}

// MEDIUM-005: Request ID Tracing Middleware
// Add early in chain to ensure all requests have correlation IDs for logging
app.use(requestIdMiddleware);

// HTTPS certificates (generated by mkcert) - only for local development
let httpsOptions = null;
if (!isProduction) {
  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
  const certPath = path.join(__dirname, 'localhost+1.pem');
  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
    httpsOptions = {
      key: fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath)
    };
  }
}

// =============================================================================
// Security Configuration
// =============================================================================

// CORS whitelist - restrict origins in production
const CORS_WHITELIST = [
  'http://localhost:3000',
  'http://localhost:3847',
  'https://localhost:3847',
  'http://127.0.0.1:3000',
  'http://127.0.0.1:3847',
  'https://127.0.0.1:3847',
  'https://splice.app',
  'https://www.splice.app',
  'https://splice.video',
  'https://www.splice.video',
  'https://spliceclips.com',
  'https://www.spliceclips.com',
  'https://splice-api-production.up.railway.app',
  'https://splice-website.vercel.app',
  'https://splice-dusky.vercel.app',
  // Adobe CEP/UXP panels run from file:// or bolt://
  'file://',
  'bolt://'
];

const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)
    if (!origin) {
      return callback(null, true);
    }
    // Check if origin is in whitelist
    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {
      return callback(null, true);
    }
    // In development, allow all origins with warning
    if (!isProduction) {
      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);
      return callback(null, true);
    }
    // In production, reject non-whitelisted origins
    console.error(`[CORS] Blocked request from: ${origin}`);
    return callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']
};

app.use(cors(corsOptions));

// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers
// This ensures rate limiting and logging use the correct client IP
if (isProduction) {
  app.set('trust proxy', 1);
}

// IP-based rate limiting (100 requests/minute per IP)
app.use(ipRateLimit);

// Security headers via helmet
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
  noSniff: true,
  xssFilter: true,
  hidePoweredBy: true
}));

// PERF-003: Response compression (gzip/deflate) - reduces payload size by 40-60%
app.use(compression({
  // Only compress responses > 1KB
  threshold: 1024,
  // Compression level (0-9), 6 is a good balance between speed and compression
  level: 6,
  // Skip compression if client sends x-no-compression header
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    // Use compression's default filter (compresses text-based responses)
    return compression.filter(req, res);
  }
}));

// Helper to determine tier from price ID with logging
// Supports both monthly and annual pricing
function getTierFromPriceId(priceId) {
  // Monthly prices
  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';

  // Annual prices (same tier, just different billing period)
  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';
  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';
  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';

  // Log unknown price ID for debugging
  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
  return 'starter';
}

// =============================================================================
// Stripe Webhook (must be before express.json())
// =============================================================================

app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;

  try {
    if (webhookSecret) {
      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
    } else if (isProduction) {
      // SECURITY: Reject unsigned webhooks in production
      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
    } else {
      // For local development testing only
      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
      event = JSON.parse(bodyString);
      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
    }
  } catch (err) {
    console.error('[SPLICE] Webhook signature verification failed:', err.message);
    return res.status(400).json({ error: 'Webhook signature verification failed' });
  }

  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);

  // Idempotency check - skip if already processed
  if (await usageTracking.isEventProcessed(event.id)) {
    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
    return res.json({ received: true, skipped: true });
  }

  try {
    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated': {
        const subscription = event.data.object;
        const customerId = subscription.customer;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in subscription event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Get tier from price ID
        const priceId = subscription.items?.data?.[0]?.price?.id;
        const tier = getTierFromPriceId(priceId);

        // Update user tier and reset hours
        await usageTracking.updateTier(customerId, tier);
        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);

        // Initialize music credits for new subscriptions
        if (event.type === 'customer.subscription.created') {
          await usageTracking.resetMusicCredits(customerId, tier);
          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);
        }

        // Update trial end date if present
        if (subscription.trial_end) {
          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);
        }

        // Generate license key for new subscriptions with retry and delivery
        if (event.type === 'customer.subscription.created') {
          let licenseResult = null;
          let retryCount = 0;
          const maxRetries = 3;

          // Retry mechanism for license key generation
          while (retryCount < maxRetries) {
            licenseResult = await licenseService.generateLicenseKey(customerId);
            if (licenseResult.success) {
              break;
            }
            retryCount++;
            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
            // Wait before retry (exponential backoff)
            if (retryCount < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            }
          }

          if (licenseResult && licenseResult.success) {
            // SECURITY: Mask license key in logs
            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);

            // Store license key in Stripe subscription metadata as backup
            try {
              await stripe.subscriptions.update(subscription.id, {
                metadata: {
                  license_key: licenseResult.key,
                  license_generated_at: new Date().toISOString()
                }
              });
              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
            } catch (stripeErr) {
              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);
            }

            // Get customer email and send license key
            try {
              const customer = await stripe.customers.retrieve(customerId);
              if (customer.email) {
                // SECURITY: Mask sensitive data in logs
                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);

                // Send license key email
                try {
                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);
                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);
                } catch (sendErr) {
                  // Log but don't fail - license is stored in Stripe metadata as backup
                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);
                }

                // Store email in database for reference
                await usageTracking.updateTier(customerId, tier, customer.email);
              } else {
                console.warn(`[SPLICE] No email found for customer ${customerId}`);
              }
            } catch (emailErr) {
              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
            }
          } else {
            // CRITICAL: License generation failed - return 500 to trigger Stripe retry
            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;
            console.error(`[SPLICE] ${errorMsg}`);
            return res.status(500).json({ error: errorMsg });
          }
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        const customerId = subscription.customer;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Downgrade to cancelled (0 hours)
        await usageTracking.updateTier(customerId, 'cancelled');
        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
        break;
      }

      case 'invoice.payment_succeeded': {
        const invoice = event.data.object;
        const customerId = invoice.customer;
        const subscriptionId = invoice.subscription;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in invoice event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Reset hours on successful payment (new billing period)
        let tier = 'starter';
        if (subscriptionId) {
          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
          const priceId = subscription.items?.data?.[0]?.price?.id;
          tier = getTierFromPriceId(priceId);

          await usageTracking.resetHours(customerId, tier);
          await usageTracking.resetMusicCredits(customerId, tier);
          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);
        }

        // Check for affiliate coupon and record commission
        const discount = invoice.discount;
        if (discount && discount.coupon) {
          const couponId = discount.coupon.id;
          // Check if this is an affiliate code (like JIMMYN)
          if (referralService.AFFILIATE_CODES[couponId]) {
            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars
            await referralService.recordAffiliateCommission(
              couponId,
              customerId,
              amountPaid,
              tier
            );
            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);
          }
        }
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object;
        const customerId = invoice.customer;
        const attemptCount = invoice.attempt_count || 1;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in payment_failed event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);

        // Stripe will retry automatically per retry settings
        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted
        // Send warning email on final attempt
        if (attemptCount >= 3) {
          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);
          // Send warning email to customer about impending cancellation
          try {
            const customer = await stripe.customers.retrieve(customerId);
            if (customer.email) {
              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);
              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);
            }
          } catch (emailErr) {
            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);
          }
        }
        break;
      }

      case 'customer.deleted': {
        const customer = event.data.object;
        const customerId = customer.id;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in customer.deleted event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Clean up user data - downgrade to cancelled
        await usageTracking.updateTier(customerId, 'cancelled');
        console.log(`[SPLICE] Customer deleted: ${customerId}`);
        break;
      }

      default:
        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
    }

    // Record event as processed (idempotency)
    await usageTracking.recordWebhookEvent(event.id, event.type);

    res.json({ received: true });
  } catch (err) {
    console.error('[SPLICE] Webhook handler error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Parse JSON body for all other routes
// SECURITY: Limit JSON body size to prevent DoS attacks
app.use(express.json({ limit: '10mb' }));

// Parse cookies for CSRF token validation
app.use(cookieParser());

// =============================================================================
// Route Configuration Options
// =============================================================================

const routeOptions = {
  middleware: {
    requireCredits,
    requireFeature,
    authenticateToken
  },
  services: {
    usageTracking,
    referralService,
    licenseService,
    emailService,
    stripe
  },
  authHelpers: {
    generateToken,
    generateRefreshToken,
    verifyToken,
    maskSensitiveData,
    blacklistToken
  },
  staticCache: STATIC_RESPONSE_CACHE,
  sendCachedResponse
};

// =============================================================================
// Mount Routes
// =============================================================================

// Health check and system endpoints (no prefix)
app.use('/', healthRoutes(routeOptions));

// Core analysis endpoints
app.use('/', analyzeRoutes(routeOptions));
app.use('/', silencesRoutes(routeOptions));
app.use('/', detectionRoutes(routeOptions));

// Export endpoints
app.use('/export', exportRoutes(routeOptions));

// Multitrack/Multicam endpoints
app.use('/multitrack', multitrackRoutes(routeOptions));

// Cut list generation
app.use('/cut-list', cutListRoutes(routeOptions));

// Legacy XML processing endpoint (backwards compatibility)
const { processXMLFile } = require('./services/xmlProcessor');
app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {
  const {
    xmlPath,
    silences,
    removeGaps = true,
    outputPath = null
  } = req.body;

  if (!xmlPath) {
    return res.status(400).json({ error: 'xmlPath is required' });
  }

  if (!silences || !Array.isArray(silences)) {
    return res.status(400).json({ error: 'silences array is required' });
  }

  if (!fs.existsSync(xmlPath)) {
    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
  }

  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);

  try {
    const result = await processXMLFile(xmlPath, silences, {
      outputPath,
      removeGaps
    });

    res.json({
      success: true,
      inputPath: xmlPath,
      outputPath: result.outputPath,
      stats: result.stats
    });
  } catch (err) {
    console.error('[SPLICE] XML processing error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Auto zoom endpoints
app.use('/zoom', zoomRoutes(routeOptions));

// Chapter detection endpoints
app.use('/chapters', chaptersRoutes(routeOptions));

// YouTube content generation
app.use('/youtube', youtubeRoutes(routeOptions));

// Animated captions endpoints
app.use('/captions', captionsRoutes(routeOptions));

// Text-based editing endpoints
app.use('/text-edit', textEditRoutes(routeOptions));

// Social reframe endpoints
app.use('/reframe', reframeRoutes(routeOptions));
app.use('/faces', reframeRoutes.facesRouter(routeOptions));

// Batch processing endpoints
app.use('/batch', batchRoutes(routeOptions));

// Authentication endpoints
app.use('/auth', authRoutes(routeOptions));

// Billing and credits endpoints
app.use('/', billingRoutes(routeOptions));

// Referral system endpoints
app.use('/referral', referralRoutes(routeOptions));

// License key endpoints
app.use('/license', licenseRoutes(routeOptions));

// AI Music generation endpoints
app.use('/music', musicRoutes(routeOptions));

// Auto Zoom with Face Detection endpoints
app.use('/zoom-pro', zoomProRoutes(routeOptions));

// Workflow Automation endpoints
app.use('/workflows', workflowRoutes(routeOptions));

// =============================================================================
// HIGH-011: API Versioning
// Mount versioned routes under /api/v1 prefix
// Maintain backwards compatibility with deprecation warnings
// =============================================================================

// Mount v1 API routes
app.use('/api/v1', v1Routes(routeOptions));

// Deprecation warning middleware for unversioned API calls
// This helps clients migrate to versioned endpoints
app.use('/api', (req, res, next) => {
  // Skip if already using versioned endpoint
  if (req.path.startsWith('/v1')) {
    return next();
  }
  
  // Add deprecation warning header
  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');
  res.set('X-API-Version', 'unversioned');
  res.set('Deprecation', 'true');
  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now
  
  next();
});

// HIGH-008: Add Sentry error handler (must be after all routes)
if (Sentry) {
  app.use(Sentry.Handlers.errorHandler({
    shouldHandleError(error) {
      // Capture all 4xx and 5xx errors
      if (error.status >= 400) {
        return true;
      }
      return true;
    },
  }));
}

// =============================================================================
// Start Server
// =============================================================================

// Track active server for graceful shutdown
let server = null;

// Initialize database and start server
async function startServer() {
  try {
    await usageTracking.initDatabase();
    await referralService.initReferralTables();
    await licenseService.initLicenseTables();
    console.log('[SPLICE] Database initialized');

    // PERF-FIX: Initialize static response cache at startup
    initializeStaticCache();

    // Start music generation worker (BullMQ background processor)
    // Only starts if Redis is configured and Replicate API key is available
    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {
      if (process.env.REPLICATE_API_TOKEN) {
        try {
          musicWorkerInstance = createMusicWorker();
          console.log('[SPLICE] ✅ Music generation worker started');
        } catch (workerErr) {
          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);
          // Don't fail server startup - music generation will be unavailable
        }
      } else {
        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');
      }
    } else {
      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');
    }

    if (isProduction || !httpsOptions) {
      // Production: Railway provides TLS termination, use HTTP
      server = http.createServer(app).listen(PORT, () => {
        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
      });
    } else {
      // Development: Use HTTPS with local certificates
      server = https.createServer(httpsOptions, app).listen(PORT, () => {
        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
      });
    }
  } catch (err) {
    console.error('[SPLICE] Failed to start server:', err);
    process.exit(1);
  }
}

// =============================================================================
// Graceful Shutdown
// =============================================================================

async function gracefulShutdown(signal) {
  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);

  // Stop accepting new connections
  if (server) {
    server.close(() => {
      console.log('[SPLICE] HTTP server closed');
    });
  }

  // Shutdown music worker (allows in-progress jobs to complete)
  try {
    if (musicWorkerInstance) {
      await shutdownWorker(musicWorkerInstance);
      console.log('[SPLICE] Music worker shut down');
    }
  } catch (err) {
    console.error('[SPLICE] Error shutting down music worker:', err.message);
  }

  // Close database pool
  try {
    await usageTracking.closePool();
    console.log('[SPLICE] Database pool closed');
  } catch (err) {
    console.error('[SPLICE] Error closing database pool:', err.message);
  }

  // Give ongoing requests time to complete (max 10 seconds)
  setTimeout(() => {
    console.log('[SPLICE] Graceful shutdown complete');
    process.exit(0);
  }, 10000);
}

// Handle termination signals
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('[SPLICE] Uncaught exception:', err);
  gracefulShutdown('uncaughtException');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);
});

startServer();
