/**
 * CaptionStylingSystem - Main caption styling system with 15 color pickers
 * Manages all caption styling options including gradients and animations
 */
class CaptionStylingSystem {
  constructor() {
    this.pickers = {};
    this.currentStyle = {
      font: {
        fillType: 'solid', // 'solid' or 'gradient'
        color: '#FFFFFF',
        gradient: {
          color1: '#FF0000',
          color2: '#0000FF',
          angle: 0
        },
        size: 50,
        family: 'Arial'
      },
      outline: {
        enabled: true,
        color: '#000000',
        width: 2
      },
      box: {
        enabled: false,
        fillType: 'solid',
        color: '#000000AA',
        gradient: {
          color1: '#FF0000',
          color2: '#FFFF00',
          angle: 90
        },
        padding: 10,
        borderRadius: 5
      },
      shadow: {
        enabled: false,
        color: '#00000080',
        blur: 5,
        offsetX: 0,
        offsetY: 2
      },
      animation: {
        type: 'none', // 'none', 'wiggle', 'highlight', 'glow', 'underline', 'box', 'reveal'
        colors: {
          highlight: '#FFFF00',
          glow: '#FF0000',
          highlightStroke: '#000000',
          underline: '#00FF00',
          box: '#0000FFAA',
          revealOutline: '#FFFFFF'
        },
        settings: {}
      },
      chapter: {
        fontColor: '#FFFFFF',
        fontSize: 40
      }
    };

    this.previewCanvas = null;
    this.onStyleChange = null;
  }

  /**
   * Initialize all 15 color pickers
   */
  initializeAllPickers() {
    // 1. Font Color (Solid)
    this.pickers.fontColor = new ColorPicker({
      default: this.currentStyle.font.color,
      onSave: (color) => {
        this.currentStyle.font.color = color;
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.fontColor.create('font-color-picker');

    // 2-3. Font Gradient Colors
    this.pickers.fontGradient1 = new ColorPicker({
      default: this.currentStyle.font.gradient.color1,
      onSave: (color) => {
        this.currentStyle.font.gradient.color1 = color;
        this.recalculateGradient('font');
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.fontGradient1.create('font-gradient1-picker');

    this.pickers.fontGradient2 = new ColorPicker({
      default: this.currentStyle.font.gradient.color2,
      onSave: (color) => {
        this.currentStyle.font.gradient.color2 = color;
        this.recalculateGradient('font');
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.fontGradient2.create('font-gradient2-picker');

    // 4. Outline Color
    this.pickers.outlineColor = new ColorPicker({
      default: this.currentStyle.outline.color,
      onSave: (color) => {
        this.currentStyle.outline.color = color;
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.outlineColor.create('outline-color-picker');

    // 5. Box Color (Solid)
    this.pickers.boxColor = new ColorPicker({
      default: this.currentStyle.box.color,
      showOpacity: true,
      onSave: (color) => {
        this.currentStyle.box.color = color;
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.boxColor.create('box-color-picker');

    // 6-7. Box Gradient Colors
    this.pickers.boxGradient1 = new ColorPicker({
      default: this.currentStyle.box.gradient.color1,
      onSave: (color) => {
        this.currentStyle.box.gradient.color1 = color;
        this.recalculateGradient('box');
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.boxGradient1.create('box-gradient1-picker');

    this.pickers.boxGradient2 = new ColorPicker({
      default: this.currentStyle.box.gradient.color2,
      onSave: (color) => {
        this.currentStyle.box.gradient.color2 = color;
        this.recalculateGradient('box');
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.boxGradient2.create('box-gradient2-picker');

    // 8. Shadow Color
    this.pickers.shadowColor = new ColorPicker({
      default: this.currentStyle.shadow.color,
      showOpacity: true,
      onSave: (color) => {
        this.currentStyle.shadow.color = color;
        this.updatePreview();
        this.triggerChange();
      }
    });
    this.pickers.shadowColor.create('shadow-color-picker');

    // 9. Animation: Highlight Color
    this.pickers.animHighlight = new ColorPicker({
      default: this.currentStyle.animation.colors.highlight,
      onSave: (color) => {
        this.currentStyle.animation.colors.highlight = color;
        this.triggerChange();
      }
    });
    this.pickers.animHighlight.create('anim-highlight-picker');

    // 10. Animation: Glow Color
    this.pickers.animGlow = new ColorPicker({
      default: this.currentStyle.animation.colors.glow,
      onSave: (color) => {
        this.currentStyle.animation.colors.glow = color;
        this.triggerChange();
      }
    });
    this.pickers.animGlow.create('anim-glow-picker');

    // 11. Animation: Highlight Stroke Color
    this.pickers.animHighlightStroke = new ColorPicker({
      default: this.currentStyle.animation.colors.highlightStroke,
      onSave: (color) => {
        this.currentStyle.animation.colors.highlightStroke = color;
        this.triggerChange();
      }
    });
    this.pickers.animHighlightStroke.create('anim-highlight-stroke-picker');

    // 12. Animation: Underline Color
    this.pickers.animUnderline = new ColorPicker({
      default: this.currentStyle.animation.colors.underline,
      onSave: (color) => {
        this.currentStyle.animation.colors.underline = color;
        this.triggerChange();
      }
    });
    this.pickers.animUnderline.create('anim-underline-picker');

    // 13. Animation: Box Color
    this.pickers.animBox = new ColorPicker({
      default: this.currentStyle.animation.colors.box,
      showOpacity: true,
      onSave: (color) => {
        this.currentStyle.animation.colors.box = color;
        this.triggerChange();
      }
    });
    this.pickers.animBox.create('anim-box-picker');

    // 14. Animation: Reveal Outline Color
    this.pickers.animRevealOutline = new ColorPicker({
      default: this.currentStyle.animation.colors.revealOutline,
      onSave: (color) => {
        this.currentStyle.animation.colors.revealOutline = color;
        this.triggerChange();
      }
    });
    this.pickers.animRevealOutline.create('anim-reveal-outline-picker');

    // 15. Chapter Font Color
    this.pickers.chapterFont = new ColorPicker({
      default: this.currentStyle.chapter.fontColor,
      onSave: (color) => {
        this.currentStyle.chapter.fontColor = color;
        this.triggerChange();
      }
    });
    this.pickers.chapterFont.create('chapter-font-picker');

    console.log('Initialized 15 color pickers');
  }

  /**
   * Recalculate gradient when colors or angle change
   * @param {string} target - 'font' or 'box'
   */
  recalculateGradient(target) {
    const gradient = this.currentStyle[target].gradient;
    const css = GradientCalculator.toCss(
      gradient.color1,
      gradient.color2,
      gradient.angle
    );

    // Store calculated gradient
    gradient.css = css;
    gradient.coords = GradientCalculator.calculateGradientCoordinates(gradient.angle);

    console.log(`Recalculated ${target} gradient:`, css);
  }

  /**
   * Update preview canvas
   */
  updatePreview() {
    if (!this.previewCanvas) return;

    const ctx = this.previewCanvas.getContext('2d');
    const width = this.previewCanvas.width;
    const height = this.previewCanvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    const centerX = width / 2;
    const centerY = height / 2;
    const previewText = 'Sample Text';

    // Save context
    ctx.save();

    // Draw box background (if enabled)
    if (this.currentStyle.box.enabled) {
      const textWidth = this.estimateTextWidth(previewText);
      const textHeight = this.currentStyle.font.size;
      const padding = this.currentStyle.box.padding;

      if (this.currentStyle.box.fillType === 'gradient') {
        const gradient = ctx.createLinearGradient(
          centerX - textWidth / 2,
          centerY - textHeight / 2,
          centerX + textWidth / 2,
          centerY + textHeight / 2
        );
        gradient.addColorStop(0, this.currentStyle.box.gradient.color1);
        gradient.addColorStop(1, this.currentStyle.box.gradient.color2);
        ctx.fillStyle = gradient;
      } else {
        ctx.fillStyle = this.currentStyle.box.color;
      }

      const boxX = centerX - textWidth / 2 - padding;
      const boxY = centerY - textHeight / 2 - padding;
      const boxWidth = textWidth + padding * 2;
      const boxHeight = textHeight + padding * 2;

      this.roundRect(ctx, boxX, boxY, boxWidth, boxHeight, this.currentStyle.box.borderRadius);
      ctx.fill();
    }

    // Draw shadow (if enabled)
    if (this.currentStyle.shadow.enabled) {
      ctx.shadowColor = this.currentStyle.shadow.color;
      ctx.shadowBlur = this.currentStyle.shadow.blur;
      ctx.shadowOffsetX = this.currentStyle.shadow.offsetX;
      ctx.shadowOffsetY = this.currentStyle.shadow.offsetY;
    }

    // Set font
    ctx.font = `${this.currentStyle.font.size}px ${this.currentStyle.font.family}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Draw outline (if enabled)
    if (this.currentStyle.outline.enabled) {
      ctx.strokeStyle = this.currentStyle.outline.color;
      ctx.lineWidth = this.currentStyle.outline.width;
      ctx.strokeText(previewText, centerX, centerY);
    }

    // Draw text fill
    if (this.currentStyle.font.fillType === 'gradient') {
      const textWidth = ctx.measureText(previewText).width;
      const gradient = ctx.createLinearGradient(
        centerX - textWidth / 2,
        centerY,
        centerX + textWidth / 2,
        centerY
      );
      gradient.addColorStop(0, this.currentStyle.font.gradient.color1);
      gradient.addColorStop(1, this.currentStyle.font.gradient.color2);
      ctx.fillStyle = gradient;
    } else {
      ctx.fillStyle = this.currentStyle.font.color;
    }

    ctx.fillText(previewText, centerX, centerY);

    // Restore context
    ctx.restore();
  }

  /**
   * Estimate text width
   * @param {string} text - Text to measure
   * @returns {number} Estimated width
   */
  estimateTextWidth(text) {
    return text.length * this.currentStyle.font.size * 0.6;
  }

  /**
   * Draw rounded rectangle
   * @param {CanvasRenderingContext2D} ctx - Canvas context
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width
   * @param {number} height - Height
   * @param {number} radius - Corner radius
   */
  roundRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  }

  /**
   * Set preview canvas
   * @param {HTMLCanvasElement} canvas - Canvas element
   */
  setPreviewCanvas(canvas) {
    this.previewCanvas = canvas;
    this.updatePreview();
  }

  /**
   * Get current style
   * @returns {Object} Current style object
   */
  getStyle() {
    return JSON.parse(JSON.stringify(this.currentStyle));
  }

  /**
   * Set style
   * @param {Object} style - Style object
   */
  setStyle(style) {
    this.currentStyle = {
      ...this.currentStyle,
      ...style
    };

    // Update all pickers
    this.pickers.fontColor?.setColor(this.currentStyle.font.color);
    this.pickers.fontGradient1?.setColor(this.currentStyle.font.gradient.color1);
    this.pickers.fontGradient2?.setColor(this.currentStyle.font.gradient.color2);
    this.pickers.outlineColor?.setColor(this.currentStyle.outline.color);
    this.pickers.boxColor?.setColor(this.currentStyle.box.color);
    this.pickers.boxGradient1?.setColor(this.currentStyle.box.gradient.color1);
    this.pickers.boxGradient2?.setColor(this.currentStyle.box.gradient.color2);
    this.pickers.shadowColor?.setColor(this.currentStyle.shadow.color);
    this.pickers.chapterFont?.setColor(this.currentStyle.chapter.fontColor);

    this.updatePreview();
  }

  /**
   * Trigger style change callback
   */
  triggerChange() {
    if (this.onStyleChange) {
      this.onStyleChange(this.getStyle());
    }
  }

  /**
   * Create animation based on current settings
   * @param {Object} word - Word object
   * @returns {BaseAnimation} Animation instance
   */
  createAnimation(word) {
    const animType = this.currentStyle.animation.type;

    switch (animType) {
      case 'wiggle':
        return new WiggleAnimation(word, this.currentStyle.animation.settings);

      case 'highlight':
        return new HighlightAnimation(word, {
          color: this.currentStyle.animation.colors.highlight,
          ...this.currentStyle.animation.settings
        });

      case 'glow':
        return new GlowAnimation(word, {
          color: this.currentStyle.animation.colors.glow,
          ...this.currentStyle.animation.settings
        });

      case 'underline':
        return new UnderlineAnimation(word, {
          color: this.currentStyle.animation.colors.underline,
          ...this.currentStyle.animation.settings
        });

      case 'box':
        return new BoxAnimation(word, {
          color: this.currentStyle.animation.colors.box,
          ...this.currentStyle.animation.settings
        });

      case 'reveal':
        return new RevealAnimation(word, {
          outlineColor: this.currentStyle.animation.colors.revealOutline,
          ...this.currentStyle.animation.settings
        });

      default:
        return null;
    }
  }

  /**
   * Export style as preset
   * @param {string} name - Preset name
   * @returns {Object} Preset object
   */
  exportPreset(name) {
    return {
      name,
      style: this.getStyle(),
      createdAt: new Date().toISOString()
    };
  }

  /**
   * Import preset
   * @param {Object} preset - Preset object
   */
  importPreset(preset) {
    if (preset.style) {
      this.setStyle(preset.style);
      console.log(`Imported preset: ${preset.name}`);
    }
  }

  /**
   * Destroy the styling system
   */
  destroy() {
    Object.values(this.pickers).forEach(picker => {
      if (picker) picker.destroy();
    });
    this.pickers = {};
    this.previewCanvas = null;
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CaptionStylingSystem;
}
