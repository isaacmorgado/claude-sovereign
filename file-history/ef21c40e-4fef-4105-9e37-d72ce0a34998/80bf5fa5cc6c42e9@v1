/**
 * RevealAnimation - Progressive reveal with clipping mask
 * Text is revealed progressively in a direction (left-to-right, etc.)
 */
class RevealAnimation extends BaseAnimation {
  constructor(word, settings = {}) {
    super(word, {
      direction: 'left-to-right', // 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
      duration: 0.3,              // Duration in seconds
      outlineColor: '#FFFFFF',    // Outline color for reveal edge
      outlineWidth: 2,            // Outline width
      ...settings
    });
  }

  /**
   * Generate reveal animation keyframes
   * @returns {Array} Array of keyframes
   */
  generate() {
    const { direction, duration, outlineColor, outlineWidth, fps } = this.settings;

    const frameCount = Math.ceil(duration * fps);
    this.keyframes = [];

    for (let frame = 0; frame <= frameCount; frame++) {
      const t = frame / frameCount;
      const eased = this.ease(t, 'ease-out');

      let clipPath;
      let revealProgress = eased;

      switch (direction) {
        case 'left-to-right':
          clipPath = `inset(0 ${100 - eased * 100}% 0 0)`;
          break;
        case 'right-to-left':
          clipPath = `inset(0 0 0 ${100 - eased * 100}%)`;
          break;
        case 'top-to-bottom':
          clipPath = `inset(0 0 ${100 - eased * 100}% 0)`;
          break;
        case 'bottom-to-top':
          clipPath = `inset(${100 - eased * 100}% 0 0 0)`;
          break;
        default:
          clipPath = `inset(0 ${100 - eased * 100}% 0 0)`;
      }

      this.keyframes.push({
        time: this.word.start + t * duration,
        clipPath,
        reveal: eased,
        direction,
        outlineColor,
        outlineWidth
      });
    }

    return this.keyframes;
  }

  /**
   * Apply reveal animation to Premiere Pro caption clip
   * @param {Object} clip - Premiere Pro text clip
   */
  async applyToPremiere(clip) {
    try {
      // Create mask for reveal effect
      // This requires mask/matte creation in Premiere

      console.log(`Reveal animation (${this.settings.direction}):`);
      console.log(`- ${this.keyframes.length} keyframes`);
      console.log(`- Duration: ${this.settings.duration}s`);
      console.log(`Note: Requires mask/matte layer in Premiere Pro`);

      return {
        success: true,
        keyframeCount: this.keyframes.length,
        note: 'Requires mask layer creation for clipping effect'
      };

    } catch (error) {
      console.error('Failed to apply reveal animation:', error);
      throw error;
    }
  }

  /**
   * Preview animation on canvas
   * @param {HTMLCanvasElement} canvas - Canvas element
   * @param {string} text - Text to animate
   * @param {Object} style - Text style
   */
  animateOnCanvas(canvas, text, style = {}) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    let currentFrame = 0;

    const animate = () => {
      if (currentFrame >= this.keyframes.length) {
        currentFrame = 0; // Loop
      }

      const keyframe = this.keyframes[currentFrame];

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save context
      ctx.save();

      // Measure text
      ctx.font = `${style.fontSize || 50}px ${style.fontFamily || 'Arial'}`;
      const metrics = ctx.measureText(text);
      const textWidth = metrics.width;
      const textHeight = style.fontSize || 50;

      // Calculate clip region based on direction and reveal progress
      const textX = centerX - textWidth / 2;
      const textY = centerY - textHeight / 2;

      let clipX, clipY, clipWidth, clipHeight;

      switch (keyframe.direction) {
        case 'left-to-right':
          clipX = textX;
          clipY = textY;
          clipWidth = textWidth * keyframe.reveal;
          clipHeight = textHeight;
          break;
        case 'right-to-left':
          clipX = textX + textWidth * (1 - keyframe.reveal);
          clipY = textY;
          clipWidth = textWidth * keyframe.reveal;
          clipHeight = textHeight;
          break;
        case 'top-to-bottom':
          clipX = textX;
          clipY = textY;
          clipWidth = textWidth;
          clipHeight = textHeight * keyframe.reveal;
          break;
        case 'bottom-to-top':
          clipX = textX;
          clipY = textY + textHeight * (1 - keyframe.reveal);
          clipWidth = textWidth;
          clipHeight = textHeight * keyframe.reveal;
          break;
        default:
          clipX = textX;
          clipY = textY;
          clipWidth = textWidth * keyframe.reveal;
          clipHeight = textHeight;
      }

      // Create clipping region
      ctx.beginPath();
      ctx.rect(clipX, clipY, clipWidth, clipHeight);
      ctx.clip();

      // Draw text (clipped)
      ctx.fillStyle = style.color || '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (style.strokeWidth) {
        ctx.strokeStyle = style.strokeColor || '#000000';
        ctx.lineWidth = style.strokeWidth;
        ctx.strokeText(text, centerX, centerY);
      }

      ctx.fillText(text, centerX, centerY);

      // Restore context (remove clip)
      ctx.restore();

      // Draw reveal edge outline (optional)
      if (keyframe.outlineWidth > 0 && keyframe.reveal < 1) {
        ctx.strokeStyle = keyframe.outlineColor;
        ctx.lineWidth = keyframe.outlineWidth;

        switch (keyframe.direction) {
          case 'left-to-right':
            ctx.beginPath();
            ctx.moveTo(clipX + clipWidth, clipY);
            ctx.lineTo(clipX + clipWidth, clipY + clipHeight);
            ctx.stroke();
            break;
          case 'right-to-left':
            ctx.beginPath();
            ctx.moveTo(clipX, clipY);
            ctx.lineTo(clipX, clipY + clipHeight);
            ctx.stroke();
            break;
          case 'top-to-bottom':
            ctx.beginPath();
            ctx.moveTo(clipX, clipY + clipHeight);
            ctx.lineTo(clipX + clipWidth, clipY + clipHeight);
            ctx.stroke();
            break;
          case 'bottom-to-top':
            ctx.beginPath();
            ctx.moveTo(clipX, clipY);
            ctx.lineTo(clipX + clipWidth, clipY);
            ctx.stroke();
            break;
        }
      }

      currentFrame++;
      requestAnimationFrame(animate);
    };

    animate();
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = RevealAnimation;
}
