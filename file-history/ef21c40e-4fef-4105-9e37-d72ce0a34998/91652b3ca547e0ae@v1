/**
 * WiggleAnimation - Shake effect using Fourier series
 * Uses 10 sine wave harmonics for natural-looking wiggle
 */
class WiggleAnimation extends BaseAnimation {
  constructor(word, settings = {}) {
    super(word, {
      intensity: 1.0,      // Wiggle intensity (0-2)
      frequency: 12,       // Frequency in Hz
      duration: 0.3,       // Duration in seconds
      ...settings
    });
  }

  /**
   * Generate wiggle keyframes using Fourier series
   * @returns {Array} Array of keyframes
   */
  generate() {
    const {
      intensity,
      frequency,
      duration,
      fps
    } = this.settings;

    // Fourier coefficients (10 harmonics for natural movement)
    // Each harmonic contributes to the overall wiggle pattern
    const coefficients = [0.5, 0.3, 0.15, 0.08, 0.05, 0.03, 0.02, 0.01, 0.01, 0.01];

    const amplitude = 5 * intensity; // Base amplitude in pixels
    const frameCount = Math.ceil(duration * fps);

    this.keyframes = [];

    for (let frame = 0; frame <= frameCount; frame++) {
      const t = frame / fps; // Time in seconds
      let x = 0, y = 0;

      // Sum all harmonics (Fourier series)
      for (let i = 0; i < coefficients.length; i++) {
        const coef = coefficients[i];
        const freq = frequency * (i + 1); // Each harmonic is a multiple of base frequency

        // Use sine for x-axis, cosine for y-axis to create circular-like motion
        x += coef * Math.sin(2 * Math.PI * freq * t) * amplitude;
        y += coef * Math.cos(2 * Math.PI * freq * t) * amplitude;
      }

      this.keyframes.push({
        time: this.word.start + t,
        position: { x, y },
        rotation: x * 0.1 // Slight rotation based on x displacement
      });
    }

    return this.keyframes;
  }

  /**
   * Apply wiggle animation to Premiere Pro caption clip
   * @param {Object} clip - Premiere Pro text clip
   */
  async applyToPremiere(clip) {
    try {
      // Get motion component for position and rotation
      const motionComponent = clip.components[0]; // Motion graphics component

      // Store original position
      const originalX = motionComponent.properties.Position.getValue()[0];
      const originalY = motionComponent.properties.Position.getValue()[1];

      // Apply keyframes
      for (const keyframe of this.keyframes) {
        const timeInTicks = keyframe.time * 254016000000; // Convert to Premiere ticks

        // Add position keyframe
        motionComponent.properties.Position.addKey(timeInTicks);
        motionComponent.properties.Position.setValueAtKey(
          timeInTicks,
          [originalX + keyframe.position.x, originalY + keyframe.position.y]
        );

        // Add rotation keyframe
        motionComponent.properties.Rotation.addKey(timeInTicks);
        motionComponent.properties.Rotation.setValueAtKey(timeInTicks, keyframe.rotation);
      }

      console.log(`Applied wiggle animation with ${this.keyframes.length} keyframes`);
      return { success: true, keyframeCount: this.keyframes.length };

    } catch (error) {
      console.error('Failed to apply wiggle animation:', error);
      throw error;
    }
  }

  /**
   * Preview animation as canvas animation
   * @param {HTMLCanvasElement} canvas - Canvas element
   * @param {string} text - Text to animate
   * @param {Object} style - Text style
   */
  animateOnCanvas(canvas, text, style = {}) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    let currentFrame = 0;

    const animate = () => {
      if (currentFrame >= this.keyframes.length) {
        currentFrame = 0; // Loop
      }

      const keyframe = this.keyframes[currentFrame];

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save context
      ctx.save();

      // Apply transformations
      ctx.translate(centerX + keyframe.position.x, centerY + keyframe.position.y);
      ctx.rotate((keyframe.rotation * Math.PI) / 180);

      // Draw text
      ctx.font = `${style.fontSize || 50}px ${style.fontFamily || 'Arial'}`;
      ctx.fillStyle = style.color || '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (style.strokeWidth) {
        ctx.strokeStyle = style.strokeColor || '#000000';
        ctx.lineWidth = style.strokeWidth;
        ctx.strokeText(text, 0, 0);
      }

      ctx.fillText(text, 0, 0);

      // Restore context
      ctx.restore();

      currentFrame++;
      requestAnimationFrame(animate);
    };

    animate();
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = WiggleAnimation;
}
