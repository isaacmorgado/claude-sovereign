/**
 * SPLICE Zoom Routes (Production-Ready)
 *
 * Face detection and zoom keyframe generation endpoints
 * Based on FireCut's implementation approach
 */

const express = require('express');
const faceDetection = require('../services/faceDetectionPro');
const { body, validationResult } = require('express-validator');

/**
 * Create zoom routes
 * @param {Object} options - Route configuration options
 * @param {Object} options.middleware - Shared middleware (authenticateToken)
 * @returns {express.Router}
 */
function createZoomRoutes(options = {}) {
  const router = express.Router();
  const { authenticateToken } = options.middleware || {};

  // Apply authentication to all routes
  if (authenticateToken) {
    router.use(authenticateToken);
  }

// ============================================================================
// FACE DETECTION ENDPOINTS
// ============================================================================

/**
 * POST /zoom/detect-faces
 *
 * Detect faces at multiple timestamps in video
 *
 * Body:
 * - videoPath: string (required) - Path to video file
 * - times: number[] (required) - Array of timestamps in seconds
 *
 * Response:
 * - success: boolean
 * - detections: Array of { time, face, success }
 *   - face: { x, y, confidence, box, model } or null
 * - summary: { total, detected, failed, detectionRate }
 */
router.post('/detect-faces',
  authenticateToken,
  [
    body('videoPath')
      .isString()
      .notEmpty()
      .withMessage('videoPath is required'),
    body('times')
      .isArray({ min: 1 })
      .withMessage('times must be a non-empty array'),
    body('times.*')
      .isNumeric()
      .withMessage('All times must be numbers')
  ],
  async (req, res) => {
    try {
      // Validate request
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          errors: errors.array()
        });
      }

      const { videoPath, times } = req.body;

      // Validate video format
      const validExtensions = ['.mp4', '.mov', '.avi', '.mkv', '.webm'];
      const hasValidExt = validExtensions.some(ext => videoPath.toLowerCase().endsWith(ext));

      if (!hasValidExt) {
        return res.status(400).json({
          success: false,
          error: `Invalid video format. Supported: ${validExtensions.join(', ')}`
        });
      }

      console.log(`[Zoom] Detecting faces in ${videoPath} at ${times.length} timestamps`);

      // Perform batch face detection
      const detections = await faceDetection.detectFacesInVideo(videoPath, times);

      // Calculate summary statistics
      const successCount = detections.filter(d => d.success).length;
      const failedCount = times.length - successCount;
      const detectionRate = ((successCount / times.length) * 100).toFixed(1);

      res.json({
        success: true,
        detections: detections,
        summary: {
          total: times.length,
          detected: successCount,
          failed: failedCount,
          detectionRate: `${detectionRate}%`
        }
      });

    } catch (error) {
      console.error('[Zoom] Face detection error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
);

/**
 * POST /zoom/detect-face-at-time
 *
 * Detect face at a single timestamp with retry fallback
 *
 * Body:
 * - videoPath: string (required)
 * - time: number (required) - Timestamp in seconds
 * - offsets: number[] (optional) - Retry offsets (default: [0, 1, -1])
 *
 * Response:
 * - success: boolean
 * - face: { x, y, confidence, box, model, detectedAt } or null
 * - detected: boolean
 */
router.post('/detect-face-at-time',
  authenticateToken,
  [
    body('videoPath')
      .isString()
      .notEmpty()
      .withMessage('videoPath is required'),
    body('time')
      .isNumeric()
      .withMessage('time must be a number'),
    body('offsets')
      .optional()
      .isArray()
      .withMessage('offsets must be an array')
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          errors: errors.array()
        });
      }

      const { videoPath, time, offsets } = req.body;

      console.log(`[Zoom] Detecting face at ${time}s in ${videoPath}`);

      const face = await faceDetection.detectFaceAtTime(videoPath, time, offsets);

      if (face) {
        res.json({
          success: true,
          face: face,
          detected: true,
          message: `Face detected using ${face.model} (confidence: ${(face.confidence * 100).toFixed(1)}%)`
        });
      } else {
        res.json({
          success: true,
          face: null,
          detected: false,
          message: 'No face detected at specified time (tried all fallback offsets)'
        });
      }

    } catch (error) {
      console.error('[Zoom] Face detection error:', error);
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
);

/**
 * GET /zoom/models-status
 *
 * Check if face detection models are loaded
 *
 * Response:
 * - success: boolean
 * - loaded: boolean
 * - models: string[]
 */
router.get('/models-status',
  authenticateToken,
  async (req, res) => {
    try {
      res.json({
        success: true,
        loaded: faceDetection.modelsLoaded,
        models: faceDetection.modelsLoaded
          ? ['SSD MobileNet v1', 'MTCNN']
          : [],
        info: faceDetection.modelsLoaded
          ? 'Face detection models loaded and ready'
          : 'Models not loaded. Run: npm run install-face-models'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
);

/**
 * POST /zoom/cleanup
 *
 * Manually trigger cleanup of temporary frame files
 * (Normally runs automatically every 30 minutes)
 *
 * Response:
 * - success: boolean
 * - message: string
 */
router.post('/cleanup',
  authenticateToken,
  async (req, res) => {
    try {
      await faceDetection.cleanup();

      res.json({
        success: true,
        message: 'Cleanup completed successfully'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
);

module.exports = router;
