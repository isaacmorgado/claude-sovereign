/**
 * GlowAnimation - Multi-layer text shadow with pulsing intensity
 * Creates a glowing effect using multiple shadow layers
 */
class GlowAnimation extends BaseAnimation {
  constructor(word, settings = {}) {
    super(word, {
      color: '#FF0000',     // Glow color
      layers: 5,            // Number of shadow layers
      maxBlur: 20,          // Maximum blur radius
      duration: 0.5,        // Duration in seconds
      ...settings
    });
  }

  /**
   * Generate glow animation keyframes
   * @returns {Array} Array of keyframes
   */
  generate() {
    const { color, layers, maxBlur, duration, fps } = this.settings;

    const frameCount = Math.ceil(duration * fps);
    this.keyframes = [];

    for (let frame = 0; frame <= frameCount; frame++) {
      const t = frame / frameCount;
      const intensity = Math.sin(t * Math.PI); // 0 → 1 → 0 (pulse)
      const blur = maxBlur * intensity;

      const shadows = [];
      for (let layer = 1; layer <= layers; layer++) {
        shadows.push({
          x: 0,
          y: 0,
          blur: blur * layer / layers,
          color: color,
          spread: 0
        });
      }

      this.keyframes.push({
        time: this.word.start + t * duration,
        shadows,
        intensity
      });
    }

    return this.keyframes;
  }

  /**
   * Apply glow animation to Premiere Pro caption clip
   * @param {Object} clip - Premiere Pro text clip
   */
  async applyToPremiere(clip) {
    try {
      // Premiere Pro supports drop shadow (single layer)
      // For multi-layer glow, would need Essential Graphics template
      // Applying basic shadow animation

      const textComponent = clip.components[1]; // Text component

      for (const keyframe of this.keyframes) {
        const timeInTicks = keyframe.time * 254016000000;

        // Get primary shadow (first layer)
        const primaryShadow = keyframe.shadows[0];

        // Note: This is a simplified implementation
        // Full multi-layer shadow requires Essential Graphics API
        if (textComponent.properties.Shadow) {
          textComponent.properties.Shadow.addKey(timeInTicks);
          textComponent.properties.ShadowBlur.addKey(timeInTicks);
          textComponent.properties.ShadowBlur.setValueAtKey(timeInTicks, primaryShadow.blur);
        }
      }

      console.log(`Applied glow animation with ${this.keyframes.length} keyframes`);
      return { success: true, keyframeCount: this.keyframes.length };

    } catch (error) {
      console.error('Failed to apply glow animation:', error);
      throw error;
    }
  }

  /**
   * Preview animation on canvas
   * @param {HTMLCanvasElement} canvas - Canvas element
   * @param {string} text - Text to animate
   * @param {Object} style - Text style
   */
  animateOnCanvas(canvas, text, style = {}) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    let currentFrame = 0;

    const animate = () => {
      if (currentFrame >= this.keyframes.length) {
        currentFrame = 0; // Loop
      }

      const keyframe = this.keyframes[currentFrame];

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save context
      ctx.save();

      // Set text properties
      ctx.font = `${style.fontSize || 50}px ${style.fontFamily || 'Arial'}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw multiple shadow layers
      for (const shadow of keyframe.shadows) {
        ctx.shadowColor = shadow.color;
        ctx.shadowBlur = shadow.blur;
        ctx.shadowOffsetX = shadow.x;
        ctx.shadowOffsetY = shadow.y;

        ctx.fillStyle = style.color || '#FFFFFF';
        ctx.fillText(text, centerX, centerY);
      }

      // Reset shadow
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;

      // Draw text on top (solid)
      ctx.fillStyle = style.color || '#FFFFFF';
      if (style.strokeWidth) {
        ctx.strokeStyle = style.strokeColor || '#000000';
        ctx.lineWidth = style.strokeWidth;
        ctx.strokeText(text, centerX, centerY);
      }
      ctx.fillText(text, centerX, centerY);

      // Restore context
      ctx.restore();

      currentFrame++;
      requestAnimationFrame(animate);
    };

    animate();
  }

  /**
   * Generate CSS text-shadow string
   * @param {Array} shadows - Array of shadow objects
   * @returns {string} CSS text-shadow value
   */
  static shadowsToCSS(shadows) {
    return shadows.map(shadow =>
      `${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.color}`
    ).join(', ');
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = GlowAnimation;
}
