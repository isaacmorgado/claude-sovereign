/**
 * UnderlineAnimation - Underline expands from center outward
 * Creates an animated underline that grows horizontally
 */
class UnderlineAnimation extends BaseAnimation {
  constructor(word, settings = {}) {
    super(word, {
      color: '#00FF00',     // Underline color
      thickness: 3,         // Underline thickness in pixels
      duration: 0.15,       // Duration in seconds
      offset: 5,            // Distance below text in pixels
      ...settings
    });
  }

  /**
   * Generate underline animation keyframes
   * @returns {Array} Array of keyframes
   */
  generate() {
    const { color, thickness, duration, offset } = this.settings;

    // Estimate word width (will be more accurate with actual font metrics)
    const wordWidth = this.measureTextWidth(this.word.text, 50);

    this.keyframes = [
      {
        time: this.word.start + 0.0,
        width: 0,
        left: wordWidth / 2,
        thickness,
        color,
        offset
      },
      {
        time: this.word.start + duration,
        width: wordWidth,
        left: 0,
        thickness,
        color,
        offset
      }
    ];

    return this.keyframes;
  }

  /**
   * Apply underline animation to Premiere Pro caption clip
   * @param {Object} clip - Premiere Pro text clip
   */
  async applyToPremiere(clip) {
    try {
      // Create underline as a shape layer
      // This requires Essential Graphics API or programmatic shape creation

      console.log(`Underline animation would create animated shape layer`);
      console.log(`From: ${this.keyframes[0].left}, ${this.keyframes[0].width}px`);
      console.log(`To: ${this.keyframes[1].left}, ${this.keyframes[1].width}px`);

      return {
        success: true,
        keyframeCount: this.keyframes.length,
        note: 'Requires Essential Graphics template or shape layer creation'
      };

    } catch (error) {
      console.error('Failed to apply underline animation:', error);
      throw error;
    }
  }

  /**
   * Preview animation on canvas
   * @param {HTMLCanvasElement} canvas - Canvas element
   * @param {string} text - Text to animate
   * @param {Object} style - Text style
   */
  animateOnCanvas(canvas, text, style = {}) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    let startTime = Date.now();

    const animate = () => {
      const elapsed = (Date.now() - startTime) / 1000;

      // Find current keyframe (interpolate)
      let currentKeyframe = this.keyframes[0];
      if (elapsed >= 0 && elapsed < this.keyframes[1].time - this.keyframes[0].time) {
        const t = elapsed / (this.keyframes[1].time - this.keyframes[0].time);
        const eased = this.ease(t, 'ease-out');

        currentKeyframe = {
          width: this.keyframes[0].width + (this.keyframes[1].width - this.keyframes[0].width) * eased,
          left: this.keyframes[0].left + (this.keyframes[1].left - this.keyframes[0].left) * eased,
          thickness: this.keyframes[0].thickness,
          color: this.keyframes[0].color,
          offset: this.keyframes[0].offset
        };
      } else if (elapsed >= this.keyframes[1].time - this.keyframes[0].time) {
        currentKeyframe = this.keyframes[1];
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw text
      ctx.font = `${style.fontSize || 50}px ${style.fontFamily || 'Arial'}`;
      ctx.fillStyle = style.color || '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (style.strokeWidth) {
        ctx.strokeStyle = style.strokeColor || '#000000';
        ctx.lineWidth = style.strokeWidth;
        ctx.strokeText(text, centerX, centerY);
      }

      ctx.fillText(text, centerX, centerY);

      // Draw underline
      const textWidth = ctx.measureText(text).width;
      const underlineY = centerY + (style.fontSize || 50) / 2 + currentKeyframe.offset;
      const underlineX = centerX - textWidth / 2 + currentKeyframe.left;

      ctx.fillStyle = currentKeyframe.color;
      ctx.fillRect(
        underlineX,
        underlineY,
        currentKeyframe.width,
        currentKeyframe.thickness
      );

      // Loop animation
      if (elapsed > this.keyframes[1].time - this.keyframes[0].time + 0.5) {
        startTime = Date.now();
      }

      requestAnimationFrame(animate);
    };

    animate();
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = UnderlineAnimation;
}
