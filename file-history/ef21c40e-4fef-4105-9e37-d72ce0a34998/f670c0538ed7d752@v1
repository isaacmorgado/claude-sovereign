/**
 * GradientCalculator - Utility for gradient angle calculations
 * Converts angles to CSS, SVG, and Premiere Pro XML formats
 */
class GradientCalculator {
  /**
   * Calculate gradient coordinates from angle
   * @param {number} angle - Gradient angle in degrees (0-360)
   * @returns {Object} - Start/end coordinates as percentages
   */
  static calculateGradientCoordinates(angle) {
    // Normalize angle to 0-360
    angle = ((angle % 360) + 360) % 360;

    // Convert to radians
    const radians = (angle * Math.PI) / 180;

    // Calculate start point (opposite direction)
    const x1 = 50 + Math.cos(radians + Math.PI) * 50;
    const y1 = 50 + Math.sin(radians + Math.PI) * 50;

    // Calculate end point
    const x2 = 50 + Math.cos(radians) * 50;
    const y2 = 50 + Math.sin(radians) * 50;

    return {
      x1: Math.round(x1 * 100) / 100,
      y1: Math.round(y1 * 100) / 100,
      x2: Math.round(x2 * 100) / 100,
      y2: Math.round(y2 * 100) / 100
    };
  }

  /**
   * Generate CSS linear gradient
   * @param {string} color1 - Start color (hex)
   * @param {string} color2 - End color (hex)
   * @param {number} angle - Gradient angle in degrees
   * @returns {string} CSS gradient string
   */
  static toCss(color1, color2, angle) {
    return `linear-gradient(${angle}deg, ${color1}, ${color2})`;
  }

  /**
   * Generate SVG gradient for preview
   * @param {string} color1 - Start color (hex)
   * @param {string} color2 - End color (hex)
   * @param {number} angle - Gradient angle in degrees
   * @param {string} id - Gradient ID
   * @returns {string} SVG linearGradient element
   */
  static toSvg(color1, color2, angle, id = 'grad') {
    const coords = this.calculateGradientCoordinates(angle);
    return `
      <linearGradient id="${id}" x1="${coords.x1}%" y1="${coords.y1}%" x2="${coords.x2}%" y2="${coords.y2}%">
        <stop offset="0%" style="stop-color:${color1}" />
        <stop offset="100%" style="stop-color:${color2}" />
      </linearGradient>
    `;
  }

  /**
   * Generate Premiere Pro graphic layer gradient
   * @param {string} color1 - Start color (hex)
   * @param {string} color2 - End color (hex)
   * @param {number} angle - Gradient angle in degrees
   * @returns {Object} Premiere Pro gradient object
   */
  static toPremiereXml(color1, color2, angle) {
    const coords = this.calculateGradientCoordinates(angle);
    return {
      fillType: 'gradient',
      gradientType: 'linear',
      startPoint: { x: coords.x1, y: coords.y1 },
      endPoint: { x: coords.x2, y: coords.y2 },
      colorStops: [
        { offset: 0, color: this.hexToRgb(color1) },
        { offset: 1, color: this.hexToRgb(color2) }
      ]
    };
  }

  /**
   * Convert hex color to RGB
   * @param {string} hex - Hex color (#RRGGBB or #RRGGBBAA)
   * @returns {Object} RGB(A) object
   */
  static hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
    if (!result) return null;

    return {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16),
      a: result[4] ? parseInt(result[4], 16) / 255 : 1
    };
  }

  /**
   * Convert RGB to hex
   * @param {number} r - Red (0-255)
   * @param {number} g - Green (0-255)
   * @param {number} b - Blue (0-255)
   * @param {number} a - Alpha (0-1)
   * @returns {string} Hex color
   */
  static rgbToHex(r, g, b, a = 1) {
    const toHex = (n) => {
      const hex = Math.round(n).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };

    let hex = '#' + toHex(r) + toHex(g) + toHex(b);

    if (a < 1) {
      hex += toHex(a * 255);
    }

    return hex;
  }

  /**
   * Interpolate between two colors
   * @param {string} color1 - Start color (hex)
   * @param {string} color2 - End color (hex)
   * @param {number} t - Interpolation factor (0-1)
   * @returns {string} Interpolated hex color
   */
  static interpolateColor(color1, color2, t) {
    const rgb1 = this.hexToRgb(color1);
    const rgb2 = this.hexToRgb(color2);

    if (!rgb1 || !rgb2) return color1;

    const r = rgb1.r + (rgb2.r - rgb1.r) * t;
    const g = rgb1.g + (rgb2.g - rgb1.g) * t;
    const b = rgb1.b + (rgb2.b - rgb1.b) * t;
    const a = rgb1.a + (rgb2.a - rgb1.a) * t;

    return this.rgbToHex(r, g, b, a);
  }

  /**
   * Generate gradient preview as data URL
   * @param {string} color1 - Start color
   * @param {string} color2 - End color
   * @param {number} angle - Gradient angle
   * @param {number} width - Preview width
   * @param {number} height - Preview height
   * @returns {string} Data URL
   */
  static generatePreviewDataUrl(color1, color2, angle, width = 100, height = 30) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    // Create gradient
    const radians = (angle * Math.PI) / 180;
    const x1 = width / 2 + Math.cos(radians + Math.PI) * width / 2;
    const y1 = height / 2 + Math.sin(radians + Math.PI) * height / 2;
    const x2 = width / 2 + Math.cos(radians) * width / 2;
    const y2 = height / 2 + Math.sin(radians) * height / 2;

    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    return canvas.toDataURL();
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = GradientCalculator;
}
