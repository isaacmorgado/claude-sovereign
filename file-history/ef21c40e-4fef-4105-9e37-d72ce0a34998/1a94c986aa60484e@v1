/**
 * BaseAnimation - Base class for all caption animations
 * All animation types inherit from this class
 */
class BaseAnimation {
  /**
   * @param {Object} word - Word object with text, start, end, duration
   * @param {Object} settings - Animation settings
   */
  constructor(word, settings = {}) {
    this.word = word; // { text, start, end, duration }
    this.settings = {
      fps: 30,
      ...settings
    };
    this.keyframes = [];
  }

  /**
   * Generate keyframes for the animation
   * Must be implemented by subclasses
   * @returns {Array} Array of keyframe objects
   */
  generate() {
    throw new Error('generate() must be implemented by subclass');
  }

  /**
   * Easing function
   * @param {number} t - Progress (0 to 1)
   * @param {string} type - Easing type
   * @returns {number} Eased value
   */
  ease(t, type = 'ease-in-out') {
    // Clamp t to [0, 1]
    t = Math.max(0, Math.min(1, t));

    switch (type) {
      case 'linear':
        return t;

      case 'ease-in':
        return t * t;

      case 'ease-out':
        return t * (2 - t);

      case 'ease-in-out':
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

      case 'cubic':
        return t < 0.5
          ? 4 * t * t * t
          : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;

      case 'elastic':
        if (t === 0 || t === 1) return t;
        return Math.sin(-13 * (Math.PI / 2) * (t + 1)) * Math.pow(2, -10 * t) + 1;

      case 'bounce':
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        } else if (t < 2 / 2.75) {
          t -= 1.5 / 2.75;
          return 7.5625 * t * t + 0.75;
        } else if (t < 2.5 / 2.75) {
          t -= 2.25 / 2.75;
          return 7.5625 * t * t + 0.9375;
        } else {
          t -= 2.625 / 2.75;
          return 7.5625 * t * t + 0.984375;
        }

      default:
        return t;
    }
  }

  /**
   * Asymmetric easing (separate in/out curves)
   * @param {number} t - Progress (0 to 1)
   * @param {number} power - Easing power (2 = smooth, 3 = snappy)
   * @returns {number} Eased value
   */
  asymmetricEase(t, power = 2) {
    if (t < 0.5) {
      // Ease-in (first half): slow start
      return Math.pow(t * 2, power) / 2;
    } else {
      // Ease-out (second half): slow end
      return 1 - Math.pow((1 - t) * 2, power) / 2;
    }
  }

  /**
   * Measure text width (approximate)
   * @param {string} text - Text to measure
   * @param {number} fontSize - Font size in pixels
   * @returns {number} Estimated width in pixels
   */
  measureTextWidth(text, fontSize = 50) {
    // Average character width is approximately 0.6 * fontSize
    // This is a rough estimate - actual measurement would require canvas
    const avgCharWidth = fontSize * 0.6;
    return text.length * avgCharWidth;
  }

  /**
   * Apply animation to Premiere Pro clip
   * Must be implemented by subclasses
   * @param {Object} clip - Premiere Pro clip object
   */
  async applyToPremiere(clip) {
    throw new Error('applyToPremiere() must be implemented by subclass');
  }

  /**
   * Get animation duration
   * @returns {number} Duration in seconds
   */
  getDuration() {
    if (this.keyframes.length === 0) return 0;
    return this.keyframes[this.keyframes.length - 1].time - this.keyframes[0].time;
  }

  /**
   * Export animation as JSON
   * @returns {Object} Animation data
   */
  toJSON() {
    return {
      type: this.constructor.name,
      word: this.word,
      settings: this.settings,
      keyframes: this.keyframes,
      duration: this.getDuration()
    };
  }

  /**
   * Create animation from JSON
   * @param {Object} data - Animation data
   * @returns {BaseAnimation} Animation instance
   */
  static fromJSON(data) {
    // This would need to be implemented to deserialize animations
    // For now, return null
    return null;
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = BaseAnimation;
}
