/**
 * HighlightAnimation - Background color flash with scale pulse
 * Word gets highlighted with a background color and scales slightly
 */
class HighlightAnimation extends BaseAnimation {
  constructor(word, settings = {}) {
    super(word, {
      color: '#FFFF00',     // Highlight color
      duration: 0.5,        // Total duration
      holdTime: 0.3,        // How long to hold the highlight
      scaleFactor: 1.1,     // Scale multiplier (1.1 = 110%)
      ...settings
    });
  }

  /**
   * Generate highlight animation keyframes
   * @returns {Array} Array of keyframes
   */
  generate() {
    const { color, duration, holdTime, scaleFactor } = this.settings;

    // Define keyframes at specific time points
    this.keyframes = [
      {
        time: this.word.start + 0.0,
        bgColor: 'transparent',
        bgOpacity: 0,
        scale: 1.0
      },
      {
        time: this.word.start + 0.1,
        bgColor: color,
        bgOpacity: 1,
        scale: scaleFactor
      },
      {
        time: this.word.start + holdTime,
        bgColor: color,
        bgOpacity: 1,
        scale: scaleFactor
      },
      {
        time: this.word.start + duration,
        bgColor: 'transparent',
        bgOpacity: 0,
        scale: 1.0
      }
    ];

    return this.keyframes;
  }

  /**
   * Apply highlight animation to Premiere Pro caption clip
   * @param {Object} clip - Premiere Pro text clip
   */
  async applyToPremiere(clip) {
    try {
      const motionComponent = clip.components[0];

      // Create background rectangle (would need Essential Graphics API)
      // For now, apply scale animation

      for (const keyframe of this.keyframes) {
        const timeInTicks = keyframe.time * 254016000000;

        // Add scale keyframe
        motionComponent.properties.Scale.addKey(timeInTicks);
        motionComponent.properties.Scale.setValueAtKey(
          timeInTicks,
          [keyframe.scale * 100, keyframe.scale * 100]
        );

        // Note: Background color would require Essential Graphics template
        // or creating a shape layer programmatically
      }

      console.log(`Applied highlight animation with ${this.keyframes.length} keyframes`);
      return { success: true, keyframeCount: this.keyframes.length };

    } catch (error) {
      console.error('Failed to apply highlight animation:', error);
      throw error;
    }
  }

  /**
   * Preview animation on canvas
   * @param {HTMLCanvasElement} canvas - Canvas element
   * @param {string} text - Text to animate
   * @param {Object} style - Text style
   */
  animateOnCanvas(canvas, text, style = {}) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    let currentKeyframeIndex = 0;
    let startTime = Date.now();

    const animate = () => {
      const elapsed = (Date.now() - startTime) / 1000; // Seconds

      // Find current keyframe
      let currentKeyframe = this.keyframes[0];
      for (let i = 0; i < this.keyframes.length - 1; i++) {
        if (elapsed >= this.keyframes[i].time && elapsed < this.keyframes[i + 1].time) {
          // Interpolate between keyframes
          const t = (elapsed - this.keyframes[i].time) / (this.keyframes[i + 1].time - this.keyframes[i].time);
          currentKeyframe = {
            bgColor: this.keyframes[i].bgColor,
            bgOpacity: this.keyframes[i].bgOpacity + (this.keyframes[i + 1].bgOpacity - this.keyframes[i].bgOpacity) * t,
            scale: this.keyframes[i].scale + (this.keyframes[i + 1].scale - this.keyframes[i].scale) * t
          };
          break;
        }
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save context
      ctx.save();

      // Measure text
      ctx.font = `${style.fontSize || 50}px ${style.fontFamily || 'Arial'}`;
      const textWidth = ctx.measureText(text).width;
      const textHeight = style.fontSize || 50;

      // Apply scale
      ctx.translate(centerX, centerY);
      ctx.scale(currentKeyframe.scale, currentKeyframe.scale);
      ctx.translate(-centerX, -centerY);

      // Draw background
      if (currentKeyframe.bgOpacity > 0) {
        ctx.fillStyle = currentKeyframe.bgColor;
        ctx.globalAlpha = currentKeyframe.bgOpacity;
        const padding = 10;
        ctx.fillRect(
          centerX - textWidth / 2 - padding,
          centerY - textHeight / 2 - padding,
          textWidth + padding * 2,
          textHeight + padding * 2
        );
        ctx.globalAlpha = 1;
      }

      // Draw text
      ctx.fillStyle = style.color || '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (style.strokeWidth) {
        ctx.strokeStyle = style.strokeColor || '#000000';
        ctx.lineWidth = style.strokeWidth;
        ctx.strokeText(text, centerX, centerY);
      }

      ctx.fillText(text, centerX, centerY);

      // Restore context
      ctx.restore();

      // Loop animation
      if (elapsed > this.keyframes[this.keyframes.length - 1].time) {
        startTime = Date.now();
      }

      requestAnimationFrame(animate);
    };

    animate();
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = HighlightAnimation;
}
