/**
 * BoxAnimation - Background box fades in with scale
 * Box appears behind text with scale and opacity animation
 */
class BoxAnimation extends BaseAnimation {
  constructor(word, settings = {}) {
    super(word, {
      color: '#000000AA',   // Box color (with alpha)
      padding: 10,          // Padding around text
      duration: 0.2,        // Duration in seconds
      borderRadius: 5,      // Corner radius
      ...settings
    });
  }

  /**
   * Generate box animation keyframes
   * @returns {Array} Array of keyframes
   */
  generate() {
    const { color, padding, duration, borderRadius } = this.settings;

    this.keyframes = [
      {
        time: this.word.start + 0.0,
        scale: 0.8,
        opacity: 0,
        color,
        padding,
        borderRadius
      },
      {
        time: this.word.start + duration,
        scale: 1.0,
        opacity: 1,
        color,
        padding,
        borderRadius
      }
    ];

    return this.keyframes;
  }

  /**
   * Apply box animation to Premiere Pro caption clip
   * @param {Object} clip - Premiere Pro text clip
   */
  async applyToPremiere(clip) {
    try {
      // Create box as a shape layer behind text
      // This requires Essential Graphics API

      console.log(`Box animation would create shape layer with:`);
      console.log(`- Color: ${this.keyframes[1].color}`);
      console.log(`- Padding: ${this.keyframes[1].padding}px`);
      console.log(`- Scale: ${this.keyframes[0].scale} → ${this.keyframes[1].scale}`);
      console.log(`- Opacity: ${this.keyframes[0].opacity} → ${this.keyframes[1].opacity}`);

      return {
        success: true,
        keyframeCount: this.keyframes.length,
        note: 'Requires Essential Graphics template for box background'
      };

    } catch (error) {
      console.error('Failed to apply box animation:', error);
      throw error;
    }
  }

  /**
   * Preview animation on canvas
   * @param {HTMLCanvasElement} canvas - Canvas element
   * @param {string} text - Text to animate
   * @param {Object} style - Text style
   */
  animateOnCanvas(canvas, text, style = {}) {
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    let startTime = Date.now();

    const animate = () => {
      const elapsed = (Date.now() - startTime) / 1000;

      // Find current keyframe (interpolate)
      let currentKeyframe = this.keyframes[0];
      if (elapsed >= 0 && elapsed < this.keyframes[1].time - this.keyframes[0].time) {
        const t = elapsed / (this.keyframes[1].time - this.keyframes[0].time);
        const eased = this.ease(t, 'ease-out');

        currentKeyframe = {
          scale: this.keyframes[0].scale + (this.keyframes[1].scale - this.keyframes[0].scale) * eased,
          opacity: this.keyframes[0].opacity + (this.keyframes[1].opacity - this.keyframes[0].opacity) * eased,
          color: this.keyframes[0].color,
          padding: this.keyframes[0].padding,
          borderRadius: this.keyframes[0].borderRadius
        };
      } else if (elapsed >= this.keyframes[1].time - this.keyframes[0].time) {
        currentKeyframe = this.keyframes[1];
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Save context
      ctx.save();

      // Measure text
      ctx.font = `${style.fontSize || 50}px ${style.fontFamily || 'Arial'}`;
      const metrics = ctx.measureText(text);
      const textWidth = metrics.width;
      const textHeight = style.fontSize || 50;

      // Apply scale from center
      ctx.translate(centerX, centerY);
      ctx.scale(currentKeyframe.scale, currentKeyframe.scale);
      ctx.translate(-centerX, -centerY);

      // Draw box
      ctx.globalAlpha = currentKeyframe.opacity;
      ctx.fillStyle = currentKeyframe.color;

      const boxX = centerX - textWidth / 2 - currentKeyframe.padding;
      const boxY = centerY - textHeight / 2 - currentKeyframe.padding;
      const boxWidth = textWidth + currentKeyframe.padding * 2;
      const boxHeight = textHeight + currentKeyframe.padding * 2;

      // Draw rounded rectangle
      this.roundRect(
        ctx,
        boxX,
        boxY,
        boxWidth,
        boxHeight,
        currentKeyframe.borderRadius
      );
      ctx.fill();

      ctx.globalAlpha = 1;

      // Draw text
      ctx.fillStyle = style.color || '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (style.strokeWidth) {
        ctx.strokeStyle = style.strokeColor || '#000000';
        ctx.lineWidth = style.strokeWidth;
        ctx.strokeText(text, centerX, centerY);
      }

      ctx.fillText(text, centerX, centerY);

      // Restore context
      ctx.restore();

      // Loop animation
      if (elapsed > this.keyframes[1].time - this.keyframes[0].time + 0.5) {
        startTime = Date.now();
      }

      requestAnimationFrame(animate);
    };

    animate();
  }

  /**
   * Draw rounded rectangle
   * @param {CanvasRenderingContext2D} ctx - Canvas context
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width
   * @param {number} height - Height
   * @param {number} radius - Corner radius
   */
  roundRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = BoxAnimation;
}
