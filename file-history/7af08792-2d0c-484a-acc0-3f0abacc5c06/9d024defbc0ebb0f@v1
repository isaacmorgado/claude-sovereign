/**
 * SPLICE Backend Server
 *
 * Main entry point for the SPLICE backend API.
 * Orchestrates the audio analysis pipeline.
 *
 * Slices:
 * - Slice 4: Transcription (services/transcription.js)
 * - Slice 5: Take Detection (services/takeDetection.js)
 *
 * Architecture: Modular routes (see routes/ directory)
 */


require('dotenv').config();

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const fs = require('fs');
const https = require('https');
const http = require('http');
const path = require('path');
const crypto = require('crypto');

// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;

// Import services
const usageTracking = require('./services/usageTracking');
const { requireCredits, ipRateLimit } = require('./middleware/rateLimiter');
const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData } = require('./middleware/auth');
const referralService = require('./services/referralService');
const licenseService = require('./services/licenseService');
const emailService = require('./services/emailService');
const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');
const { getSupportedFormats } = require('./services/captionExporter');

// Import route modules
const healthRoutes = require('./routes/health');
const analyzeRoutes = require('./routes/analyze');
const silencesRoutes = require('./routes/silences');
const detectionRoutes = require('./routes/detection');
const exportRoutes = require('./routes/export');
const multitrackRoutes = require('./routes/multitrack');
const cutListRoutes = require('./routes/cutList');
const zoomRoutes = require('./routes/zoom');
const chaptersRoutes = require('./routes/chapters');
const youtubeRoutes = require('./routes/youtube');
const captionsRoutes = require('./routes/captions');
const textEditRoutes = require('./routes/textEdit');
const reframeRoutes = require('./routes/reframe');
const batchRoutes = require('./routes/batch');
const authRoutes = require('./routes/auth');
const billingRoutes = require('./routes/billing');
const referralRoutes = require('./routes/referral');
const licenseRoutes = require('./routes/license');
const musicRoutes = require('./routes/music');

// Stripe for webhooks
const Stripe = require('stripe');

// Validate STRIPE_SECRET_KEY in production - exit if missing
if (isProduction && !process.env.STRIPE_SECRET_KEY) {
  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');
  process.exit(1);
}

// Validate JWT_SECRET in production - exit if using default
if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {
  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');
  process.exit(1);
}

// Validate DATABASE_URL in production
if (isProduction && !process.env.DATABASE_URL) {
  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');
  process.exit(1);
}

// Validate OPENAI_API_KEY in production
if (isProduction && !process.env.OPENAI_API_KEY) {
  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');
  process.exit(1);
}

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// =============================================================================
// PERF-FIX: Static Response Cache
// Cache static endpoint responses at startup to avoid repeated computation
// =============================================================================

// Generate ETag from content
function generateETag(content) {
  return `"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}"`;
}

// Static response cache - populated at startup
const STATIC_RESPONSE_CACHE = {
  profanityLanguages: null,
  profanityBleeps: null,
  exportFormats: null
};

// Initialize cache at startup (called after server starts)
function initializeStaticCache() {
  // Cache profanity languages
  const languages = getSupportedLanguages();
  STATIC_RESPONSE_CACHE.profanityLanguages = {
    body: { success: true, languages },
    etag: generateETag({ languages })
  };

  // Cache profanity bleeps
  const sounds = getAvailableBleepSounds();
  STATIC_RESPONSE_CACHE.profanityBleeps = {
    body: { success: true, sounds },
    etag: generateETag({ sounds })
  };

  // Cache export formats
  const formats = getSupportedFormats();
  STATIC_RESPONSE_CACHE.exportFormats = {
    body: { success: true, formats },
    etag: generateETag({ formats })
  };

  console.log('[SPLICE] Static response cache initialized');
}

// Helper to send cached response with ETag
function sendCachedResponse(req, res, cacheKey) {
  const cached = STATIC_RESPONSE_CACHE[cacheKey];
  if (!cached) {
    return res.status(500).json({ error: 'Cache not initialized' });
  }

  // Check If-None-Match header for conditional GET
  const clientETag = req.headers['if-none-match'];
  if (clientETag === cached.etag) {
    return res.status(304).end(); // Not Modified
  }

  // Send cached response with ETag and cache headers
  res.set('ETag', cached.etag);
  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
  res.json(cached.body);
}

// =============================================================================
// Server Configuration
// =============================================================================

const app = express();
const PORT = process.env.PORT || 3847;

// HTTPS certificates (generated by mkcert) - only for local development
let httpsOptions = null;
if (!isProduction) {
  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
  const certPath = path.join(__dirname, 'localhost+1.pem');
  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
    httpsOptions = {
      key: fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath)
    };
  }
}

// =============================================================================
// Security Configuration
// =============================================================================

// CORS whitelist - restrict origins in production
const CORS_WHITELIST = [
  'http://localhost:3000',
  'http://localhost:3847',
  'https://localhost:3847',
  'http://127.0.0.1:3000',
  'http://127.0.0.1:3847',
  'https://127.0.0.1:3847',
  'https://splice.app',
  'https://www.splice.app',
  'https://splice-api-production.up.railway.app',
  'https://splice-website.vercel.app',
  // Adobe CEP/UXP panels run from file:// or bolt://
  'file://',
  'bolt://'
];

const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)
    if (!origin) {
      return callback(null, true);
    }
    // Check if origin is in whitelist
    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {
      return callback(null, true);
    }
    // In development, allow all origins with warning
    if (!isProduction) {
      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);
      return callback(null, true);
    }
    // In production, reject non-whitelisted origins
    console.error(`[CORS] Blocked request from: ${origin}`);
    return callback(new Error('Not allowed by CORS'));
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature']
};

app.use(cors(corsOptions));

// IP-based rate limiting (100 requests/minute per IP)
app.use(ipRateLimit);

// Security headers via helmet
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
  noSniff: true,
  xssFilter: true,
  hidePoweredBy: true
}));

// Helper to determine tier from price ID with logging
// Supports both monthly and annual pricing
function getTierFromPriceId(priceId) {
  // Monthly prices
  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';

  // Annual prices (same tier, just different billing period)
  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';
  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';
  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';

  // Log unknown price ID for debugging
  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
  return 'starter';
}

// =============================================================================
// Stripe Webhook (must be before express.json())
// =============================================================================

app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;

  try {
    if (webhookSecret) {
      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
    } else if (isProduction) {
      // SECURITY: Reject unsigned webhooks in production
      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
    } else {
      // For local development testing only
      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
      event = JSON.parse(bodyString);
      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
    }
  } catch (err) {
    console.error('[SPLICE] Webhook signature verification failed:', err.message);
    return res.status(400).json({ error: 'Webhook signature verification failed' });
  }

  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);

  // Idempotency check - skip if already processed
  if (await usageTracking.isEventProcessed(event.id)) {
    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
    return res.json({ received: true, skipped: true });
  }

  try {
    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated': {
        const subscription = event.data.object;
        const customerId = subscription.customer;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in subscription event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Get tier from price ID
        const priceId = subscription.items?.data?.[0]?.price?.id;
        const tier = getTierFromPriceId(priceId);

        // Update user tier and reset hours
        await usageTracking.updateTier(customerId, tier);
        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);

        // Generate license key for new subscriptions with retry and delivery
        if (event.type === 'customer.subscription.created') {
          let licenseResult = null;
          let retryCount = 0;
          const maxRetries = 3;

          // Retry mechanism for license key generation
          while (retryCount < maxRetries) {
            licenseResult = await licenseService.generateLicenseKey(customerId);
            if (licenseResult.success) {
              break;
            }
            retryCount++;
            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
            // Wait before retry (exponential backoff)
            if (retryCount < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            }
          }

          if (licenseResult && licenseResult.success) {
            // SECURITY: Mask license key in logs
            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);

            // Store license key in Stripe subscription metadata as backup
            try {
              await stripe.subscriptions.update(subscription.id, {
                metadata: {
                  license_key: licenseResult.key,
                  license_generated_at: new Date().toISOString()
                }
              });
              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
            } catch (stripeErr) {
              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);
            }

            // Get customer email and send license key
            try {
              const customer = await stripe.customers.retrieve(customerId);
              if (customer.email) {
                // SECURITY: Mask sensitive data in logs
                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);
                // TODO: Integrate with email service (SendGrid, SES, etc.)
                // await sendLicenseKeyEmail(customer.email, licenseResult.key, tier);

                // Store email in database for reference
                await usageTracking.updateTier(customerId, tier, customer.email);
              } else {
                console.warn(`[SPLICE] No email found for customer ${customerId}`);
              }
            } catch (emailErr) {
              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
            }
          } else {
            // CRITICAL: License generation failed - return 500 to trigger Stripe retry
            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;
            console.error(`[SPLICE] ${errorMsg}`);
            return res.status(500).json({ error: errorMsg });
          }
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        const customerId = subscription.customer;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Downgrade to cancelled (0 hours)
        await usageTracking.updateTier(customerId, 'cancelled');
        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
        break;
      }

      case 'invoice.payment_succeeded': {
        const invoice = event.data.object;
        const customerId = invoice.customer;
        const subscriptionId = invoice.subscription;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in invoice event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Reset hours on successful payment (new billing period)
        let tier = 'starter';
        if (subscriptionId) {
          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
          const priceId = subscription.items?.data?.[0]?.price?.id;
          tier = getTierFromPriceId(priceId);

          await usageTracking.resetHours(customerId, tier);
          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);
        }

        // Check for affiliate coupon and record commission
        const discount = invoice.discount;
        if (discount && discount.coupon) {
          const couponId = discount.coupon.id;
          // Check if this is an affiliate code (like JIMMYN)
          if (referralService.AFFILIATE_CODES[couponId]) {
            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars
            await referralService.recordAffiliateCommission(
              couponId,
              customerId,
              amountPaid,
              tier
            );
            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);
          }
        }
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object;
        const customerId = invoice.customer;
        const attemptCount = invoice.attempt_count || 1;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in payment_failed event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);

        // Stripe will retry automatically per retry settings
        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted
        // For now, just log and potentially notify user
        if (attemptCount >= 3) {
          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);
          // TODO: Send warning email to customer about impending cancellation
        }
        break;
      }

      case 'customer.deleted': {
        const customer = event.data.object;
        const customerId = customer.id;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in customer.deleted event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Clean up user data - downgrade to cancelled
        await usageTracking.updateTier(customerId, 'cancelled');
        console.log(`[SPLICE] Customer deleted: ${customerId}`);
        break;
      }

      default:
        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
    }

    // Record event as processed (idempotency)
    await usageTracking.recordWebhookEvent(event.id, event.type);

    res.json({ received: true });
  } catch (err) {
    console.error('[SPLICE] Webhook handler error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Parse JSON body for all other routes
// SECURITY: Limit JSON body size to prevent DoS attacks
app.use(express.json({ limit: '10mb' }));

// =============================================================================
// Route Configuration Options
// =============================================================================

const routeOptions = {
  middleware: {
    requireCredits,
    authenticateToken
  },
  services: {
    usageTracking,
    referralService,
    licenseService,
    stripe
  },
  authHelpers: {
    generateToken,
    generateRefreshToken,
    verifyToken,
    maskSensitiveData
  },
  staticCache: STATIC_RESPONSE_CACHE,
  sendCachedResponse
};

// =============================================================================
// Mount Routes
// =============================================================================

// Health check and system endpoints (no prefix)
app.use('/', healthRoutes(routeOptions));

// Core analysis endpoints
app.use('/', analyzeRoutes(routeOptions));
app.use('/', silencesRoutes(routeOptions));
app.use('/', detectionRoutes(routeOptions));

// Export endpoints
app.use('/export', exportRoutes(routeOptions));

// Multitrack/Multicam endpoints
app.use('/multitrack', multitrackRoutes(routeOptions));

// Cut list generation
app.use('/cut-list', cutListRoutes(routeOptions));

// Legacy XML processing endpoint (backwards compatibility)
const { processXMLFile } = require('./services/xmlProcessor');
app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {
  const {
    xmlPath,
    silences,
    removeGaps = true,
    outputPath = null
  } = req.body;

  if (!xmlPath) {
    return res.status(400).json({ error: 'xmlPath is required' });
  }

  if (!silences || !Array.isArray(silences)) {
    return res.status(400).json({ error: 'silences array is required' });
  }

  if (!fs.existsSync(xmlPath)) {
    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
  }

  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);

  try {
    const result = await processXMLFile(xmlPath, silences, {
      outputPath,
      removeGaps
    });

    res.json({
      success: true,
      inputPath: xmlPath,
      outputPath: result.outputPath,
      stats: result.stats
    });
  } catch (err) {
    console.error('[SPLICE] XML processing error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Auto zoom endpoints
app.use('/zoom', zoomRoutes(routeOptions));

// Chapter detection endpoints
app.use('/chapters', chaptersRoutes(routeOptions));

// YouTube content generation
app.use('/youtube', youtubeRoutes(routeOptions));

// Animated captions endpoints
app.use('/captions', captionsRoutes(routeOptions));

// Text-based editing endpoints
app.use('/text-edit', textEditRoutes(routeOptions));

// Social reframe endpoints
app.use('/reframe', reframeRoutes(routeOptions));
app.use('/faces', reframeRoutes.facesRouter(routeOptions));

// Batch processing endpoints
app.use('/batch', batchRoutes(routeOptions));

// Authentication endpoints
app.use('/auth', authRoutes(routeOptions));

// Billing and credits endpoints
app.use('/', billingRoutes(routeOptions));

// Referral system endpoints
app.use('/referral', referralRoutes(routeOptions));

// License key endpoints
app.use('/license', licenseRoutes(routeOptions));

// AI Music generation endpoints
app.use('/music', musicRoutes(routeOptions));

// =============================================================================
// Start Server
// =============================================================================

// Track active server for graceful shutdown
let server = null;

// Initialize database and start server
async function startServer() {
  try {
    await usageTracking.initDatabase();
    await referralService.initReferralTables();
    await licenseService.initLicenseTables();
    console.log('[SPLICE] Database initialized');

    // PERF-FIX: Initialize static response cache at startup
    initializeStaticCache();

    if (isProduction || !httpsOptions) {
      // Production: Railway provides TLS termination, use HTTP
      server = http.createServer(app).listen(PORT, () => {
        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
      });
    } else {
      // Development: Use HTTPS with local certificates
      server = https.createServer(httpsOptions, app).listen(PORT, () => {
        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
      });
    }
  } catch (err) {
    console.error('[SPLICE] Failed to start server:', err);
    process.exit(1);
  }
}

// =============================================================================
// Graceful Shutdown
// =============================================================================

async function gracefulShutdown(signal) {
  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);

  // Stop accepting new connections
  if (server) {
    server.close(() => {
      console.log('[SPLICE] HTTP server closed');
    });
  }

  // Close database pool
  try {
    await usageTracking.closePool();
    console.log('[SPLICE] Database pool closed');
  } catch (err) {
    console.error('[SPLICE] Error closing database pool:', err.message);
  }

  // Give ongoing requests time to complete (max 10 seconds)
  setTimeout(() => {
    console.log('[SPLICE] Graceful shutdown complete');
    process.exit(0);
  }, 10000);
}

// Handle termination signals
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('[SPLICE] Uncaught exception:', err);
  gracefulShutdown('uncaughtException');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);
});

startServer();
