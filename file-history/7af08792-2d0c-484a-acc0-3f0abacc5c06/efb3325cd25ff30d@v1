/**
 * SPLICE CEP Panel - Multitrack UI Module
 * Multi-speaker analysis, auto-balance, and timeline building
 * v4.0.0 - CEP Migration
 */

// ============================================================================
// STATE
// ============================================================================
let speakerConfig = [];
let analysisResults = null;
let isMultitrackOperationInProgress = false;

// Speaker colors for visual distinction
const SPEAKER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];

// ============================================================================
// DOM ELEMENT CACHE
// ============================================================================
const multitrackUI = {};

function cacheMultitrackElements() {
    multitrackUI.section = document.getElementById('multitrackSection');
    multitrackUI.toggle = document.getElementById('multitrackToggle');
    multitrackUI.panel = document.getElementById('multitrackPanel');
    multitrackUI.speakerList = document.getElementById('speakerList');
    multitrackUI.addSpeakerBtn = document.getElementById('addSpeakerBtn');
    multitrackUI.wideShotTrack = document.getElementById('wideShotTrack');

    // Parameters
    multitrackUI.minShotDuration = document.getElementById('minShotDuration');
    multitrackUI.minShotDurationValue = document.getElementById('minShotDurationValue');
    multitrackUI.wideShotPercent = document.getElementById('wideShotPercent');
    multitrackUI.wideShotPercentValue = document.getElementById('wideShotPercentValue');
    multitrackUI.switchingFrequency = document.getElementById('switchingFrequency');
    multitrackUI.switchingFrequencyValue = document.getElementById('switchingFrequencyValue');
    multitrackUI.enableWideShotDetection = document.getElementById('enableWideShotDetection');

    // Actions
    multitrackUI.analyzeBtn = document.getElementById('analyzeMultitrackBtn');
    multitrackUI.autoBalanceBtn = document.getElementById('autoBalanceBtn');
    multitrackUI.applyBtn = document.getElementById('applyMultitrackBtn');

    // Preview
    multitrackUI.preview = document.getElementById('multitrackPreview');
    multitrackUI.distributionChart = document.getElementById('distributionChart');
    multitrackUI.speakerStats = document.getElementById('speakerStats');
    multitrackUI.decisionCount = document.getElementById('decisionCount');
    multitrackUI.decisionList = document.getElementById('decisionList');
}

// ============================================================================
// INITIALIZATION
// ============================================================================
function initMultitrackUI() {
    cacheMultitrackElements();

    if (!multitrackUI.section) {
        console.warn('[SPLICE Multitrack] Multitrack section not found in DOM');
        return;
    }

    // Toggle section expand/collapse
    if (multitrackUI.toggle) {
        multitrackUI.toggle.addEventListener('click', toggleMultitrackSection);
    }

    // Add speaker button
    if (multitrackUI.addSpeakerBtn) {
        multitrackUI.addSpeakerBtn.addEventListener('click', addSpeaker);
    }

    // Speaker list event delegation (remove buttons, name changes)
    if (multitrackUI.speakerList) {
        multitrackUI.speakerList.addEventListener('click', handleSpeakerListClick);
        multitrackUI.speakerList.addEventListener('change', handleSpeakerListChange);
    }

    // Parameter sliders
    setupParameterListeners();

    // Action buttons
    if (multitrackUI.analyzeBtn) {
        multitrackUI.analyzeBtn.addEventListener('click', analyzeMultitrack);
    }
    if (multitrackUI.autoBalanceBtn) {
        multitrackUI.autoBalanceBtn.addEventListener('click', autoBalanceMultitrack);
    }
    if (multitrackUI.applyBtn) {
        multitrackUI.applyBtn.addEventListener('click', applyMultitrackCuts);
    }

    // Decision list event delegation (seek buttons)
    if (multitrackUI.decisionList) {
        multitrackUI.decisionList.addEventListener('click', handleDecisionListClick);
    }

    // Initialize speaker config from DOM
    initSpeakerConfigFromDOM();

    console.log('[SPLICE Multitrack] UI initialized');
}

// ============================================================================
// SECTION TOGGLE
// ============================================================================
function toggleMultitrackSection() {
    if (!multitrackUI.panel || !multitrackUI.toggle) return;

    const isNowCollapsed = multitrackUI.panel.classList.toggle('collapsed');
    const icon = multitrackUI.toggle.querySelector('.toggle-icon');

    if (icon) {
        icon.textContent = isNowCollapsed ? '+' : '-';
    }
}

// ============================================================================
// SPEAKER CONFIGURATION
// ============================================================================
function initSpeakerConfigFromDOM() {
    speakerConfig = [];
    const items = multitrackUI.speakerList?.querySelectorAll('.speaker-item') || [];

    items.forEach((item, index) => {
        const nameInput = item.querySelector('.speaker-name');
        const trackSelect = item.querySelector('.speaker-track');

        speakerConfig.push({
            index,
            name: nameInput?.value || `Speaker ${index + 1}`,
            videoTrack: parseInt(trackSelect?.value || index)
        });
    });
}

function addSpeaker() {
    if (speakerConfig.length >= 4) {
        setStatus('Maximum 4 speakers supported');
        return;
    }

    const newIndex = speakerConfig.length;
    const defaultName = `Speaker ${newIndex + 1}`;

    speakerConfig.push({
        index: newIndex,
        name: defaultName,
        videoTrack: newIndex
    });

    // Add DOM element
    // SECURITY: Escape dynamic content to prevent XSS
    const speakerItem = document.createElement('div');
    speakerItem.className = `speaker-item speaker-${newIndex}`;
    speakerItem.dataset.speakerIndex = newIndex;
    speakerItem.innerHTML = `
        <input type="text" class="speaker-name" value="${escapeHtml(defaultName)}" placeholder="Name" aria-label="Speaker ${newIndex + 1} name">
        <select class="speaker-track" aria-label="Speaker ${newIndex + 1} video track">
            <option value="0" ${newIndex === 0 ? 'selected' : ''}>V1</option>
            <option value="1" ${newIndex === 1 ? 'selected' : ''}>V2</option>
            <option value="2" ${newIndex === 2 ? 'selected' : ''}>V3</option>
            <option value="3" ${newIndex === 3 ? 'selected' : ''}>V4</option>
        </select>
        <button class="speaker-remove-btn" title="Remove speaker" aria-label="Remove speaker ${newIndex + 1}">x</button>
    `;

    multitrackUI.speakerList.appendChild(speakerItem);

    // Update remove button visibility
    updateRemoveButtonVisibility();
}

function removeSpeaker(index) {
    if (speakerConfig.length <= 2) {
        setStatus('Minimum 2 speakers required');
        return;
    }

    speakerConfig.splice(index, 1);

    // Remove from DOM
    const item = multitrackUI.speakerList.querySelector(`[data-speaker-index="${index}"]`);
    if (item) {
        item.remove();
    }

    // Re-index remaining speakers
    reindexSpeakers();

    // Update remove button visibility
    updateRemoveButtonVisibility();
}

function reindexSpeakers() {
    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
    items.forEach((item, i) => {
        item.dataset.speakerIndex = i;
        item.className = `speaker-item speaker-${i}`;

        // Update speakerConfig
        if (speakerConfig[i]) {
            speakerConfig[i].index = i;
        }
    });
}

function updateRemoveButtonVisibility() {
    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
    const canRemove = items.length > 2;

    items.forEach(item => {
        const btn = item.querySelector('.speaker-remove-btn');
        if (btn) {
            btn.style.display = canRemove ? 'block' : 'none';
        }
    });
}

function handleSpeakerListClick(e) {
    const removeBtn = e.target.closest('.speaker-remove-btn');
    if (removeBtn) {
        const item = removeBtn.closest('.speaker-item');
        const index = parseInt(item?.dataset.speakerIndex || 0);
        removeSpeaker(index);
    }
}

function handleSpeakerListChange(e) {
    const item = e.target.closest('.speaker-item');
    if (!item) return;

    const index = parseInt(item.dataset.speakerIndex || 0);

    if (e.target.classList.contains('speaker-name')) {
        speakerConfig[index].name = e.target.value;
    } else if (e.target.classList.contains('speaker-track')) {
        speakerConfig[index].videoTrack = parseInt(e.target.value);
    }
}

// ============================================================================
// PARAMETER LISTENERS
// ============================================================================
function setupParameterListeners() {
    // Min shot duration slider
    if (multitrackUI.minShotDuration && multitrackUI.minShotDurationValue) {
        multitrackUI.minShotDuration.addEventListener('input', () => {
            multitrackUI.minShotDurationValue.textContent =
                parseFloat(multitrackUI.minShotDuration.value).toFixed(1) + 's';
        });
    }

    // Wide shot percentage slider
    if (multitrackUI.wideShotPercent && multitrackUI.wideShotPercentValue) {
        multitrackUI.wideShotPercent.addEventListener('input', () => {
            multitrackUI.wideShotPercentValue.textContent =
                multitrackUI.wideShotPercent.value + '%';
        });
    }

    // Switching frequency slider
    if (multitrackUI.switchingFrequency && multitrackUI.switchingFrequencyValue) {
        multitrackUI.switchingFrequency.addEventListener('input', () => {
            multitrackUI.switchingFrequencyValue.textContent =
                multitrackUI.switchingFrequency.value;
        });
    }
}

// ============================================================================
// GET SETTINGS
// ============================================================================
function getMultitrackSettings() {
    return {
        minShotDuration: parseFloat(multitrackUI.minShotDuration?.value || 2),
        wideShotPercentage: parseInt(multitrackUI.wideShotPercent?.value || 20),
        switchingFrequency: parseInt(multitrackUI.switchingFrequency?.value || 50),
        wideShotEnabled: multitrackUI.enableWideShotDetection?.checked ?? true,
        wideShotTracks: multitrackUI.wideShotTrack?.value !== '-1'
            ? [parseInt(multitrackUI.wideShotTrack.value)]
            : [],
        speakerNames: speakerConfig.map(s => s.name),
        videoTrackMapping: speakerConfig.reduce((acc, s) => {
            acc[s.index] = s.videoTrack;
            return acc;
        }, {})
    };
}

// ============================================================================
// GET AUDIO PATH (CEP VERSION)
// ============================================================================
async function getAudioPath() {
    try {
        // Try to get audio path from active sequence
        const seqInfo = await jsx.call('getActiveSequence');
        if (seqInfo && seqInfo.audioPath) {
            return seqInfo.audioPath;
        }

        // Fallback: export sequence audio for analysis
        const exportResult = await jsx.call('exportSequenceAudioForAnalysis');
        if (exportResult && exportResult.path) {
            return exportResult.path;
        }

        // Last resort: get first clip audio path
        const clipPath = await jsx.call('getFirstClipAudioPath');
        if (clipPath) {
            return clipPath;
        }

        throw new Error('Could not determine audio path');
    } catch (e) {
        console.error('[SPLICE Multitrack] Failed to get audio path:', e);
        throw e;
    }
}

// ============================================================================
// ANALYZE MULTITRACK
// ============================================================================
async function analyzeMultitrack() {
    if (isMultitrackOperationInProgress) return;

    // Check online status
    if (typeof isOnline === 'function' && !isOnline()) {
        setStatus('Offline - Check your connection');
        return;
    }

    isMultitrackOperationInProgress = true;
    if (multitrackUI.analyzeBtn) {
        multitrackUI.analyzeBtn.disabled = true;
        multitrackUI.analyzeBtn.textContent = 'Analyzing...';
    }

    try {
        setStatus('Exporting audio tracks...');

        // Get audio path
        const audioPath = await getAudioPath();
        if (!audioPath) {
            throw new Error('Audio export path not initialized');
        }

        // For now, we use the main audio path
        // In a full implementation, we'd export separate tracks per speaker
        const audioPaths = [audioPath];

        // Add additional tracks if multi-track sequence
        if (speakerConfig.length > 1) {
            for (let i = 1; i < speakerConfig.length; i++) {
                audioPaths.push(audioPath);
            }
        }

        setStatus('Analyzing speakers...');

        const settings = getMultitrackSettings();
        const apiUrl = getBackendUrl();

        const response = await fetchWithTimeout(`${apiUrl}/multitrack`, {
            method: 'POST',
            headers: getAuthHeaders(),
            body: JSON.stringify({
                audioPaths,
                speakerNames: settings.speakerNames,
                videoTrackMapping: settings.videoTrackMapping,
                wideShotEnabled: settings.wideShotEnabled,
                wideShotPercentage: settings.wideShotPercentage,
                wideShotTracks: settings.wideShotTracks,
                minShotDuration: settings.minShotDuration,
                switchingFrequency: settings.switchingFrequency
            })
        }, 120000);

        if (!response.ok) {
            const errorMsg = await parseErrorResponse(response);
            throw new Error(errorMsg);
        }

        const data = await response.json();
        analysisResults = data;

        // Display results
        displayMultitrackResults(data);

        // Enable apply button
        if (multitrackUI.applyBtn) {
            multitrackUI.applyBtn.disabled = false;
        }

        setStatus(`Analysis complete - ${data.decisions?.length || 0} switching decisions`);

    } catch (err) {
        console.error('[SPLICE Multitrack] Analysis error:', err);
        setStatus('Analysis failed: ' + err.message, true);
    } finally {
        isMultitrackOperationInProgress = false;
        if (multitrackUI.analyzeBtn) {
            multitrackUI.analyzeBtn.disabled = false;
            multitrackUI.analyzeBtn.textContent = 'Analyze';
        }
    }
}

// ============================================================================
// AUTO-BALANCE
// ============================================================================
async function autoBalanceMultitrack() {
    if (isMultitrackOperationInProgress) return;

    // Check online status
    if (typeof isOnline === 'function' && !isOnline()) {
        setStatus('Offline - Check your connection');
        return;
    }

    isMultitrackOperationInProgress = true;
    if (multitrackUI.autoBalanceBtn) {
        multitrackUI.autoBalanceBtn.disabled = true;
        multitrackUI.autoBalanceBtn.textContent = 'Balancing...';
    }

    try {
        setStatus('Auto-balancing speaker screentime...');

        const audioPath = await getAudioPath();
        const audioPaths = [audioPath];

        // Duplicate for multiple speakers
        for (let i = 1; i < speakerConfig.length; i++) {
            audioPaths.push(audioPath);
        }

        const settings = getMultitrackSettings();
        const apiUrl = getBackendUrl();

        const response = await fetchWithTimeout(`${apiUrl}/multitrack/auto-balance`, {
            method: 'POST',
            headers: getAuthHeaders(),
            body: JSON.stringify({
                audioPaths,
                speakerNames: settings.speakerNames,
                videoTrackMapping: settings.videoTrackMapping,
                wideShotEnabled: settings.wideShotEnabled,
                wideShotPercentage: settings.wideShotPercentage,
                wideShotTracks: settings.wideShotTracks,
                minShotDuration: settings.minShotDuration,
                switchingFrequency: settings.switchingFrequency
            })
        }, 120000);

        if (!response.ok) {
            const errorMsg = await parseErrorResponse(response);
            throw new Error(errorMsg);
        }

        const data = await response.json();
        analysisResults = data;

        // Display results
        displayMultitrackResults(data);

        // Enable apply button
        if (multitrackUI.applyBtn) {
            multitrackUI.applyBtn.disabled = false;
        }

        const errorInfo = data.finalError ? ` (${data.finalError.toFixed(1)}% deviation)` : '';
        setStatus(`Auto-balance complete${errorInfo}`);

    } catch (err) {
        console.error('[SPLICE Multitrack] Auto-balance error:', err);
        setStatus('Auto-balance failed: ' + err.message, true);
    } finally {
        isMultitrackOperationInProgress = false;
        if (multitrackUI.autoBalanceBtn) {
            multitrackUI.autoBalanceBtn.disabled = false;
            multitrackUI.autoBalanceBtn.textContent = 'Auto-Balance';
        }
    }
}

// ============================================================================
// DISPLAY RESULTS
// ============================================================================
function displayMultitrackResults(results) {
    if (!results) return;

    // Show preview section
    if (multitrackUI.preview) {
        multitrackUI.preview.classList.remove('hidden');
    }

    // Render distribution chart
    renderDistributionChart(results.metadata);

    // Render speaker stats
    renderSpeakerStats(results.metadata);

    // Render decision list
    renderDecisionList(results.decisions || []);
}

function renderDistributionChart(metadata) {
    if (!multitrackUI.distributionChart || !metadata) return;

    const speakerPercentages = metadata.speakerPercentages || {};
    const wideShotPct = metadata.wideShotPercentage || 0;

    const fragment = document.createDocumentFragment();

    // Add speaker bars
    let speakerIndex = 0;
    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
        if (pct > 0) {
            const bar = document.createElement('div');
            bar.className = `distribution-bar speaker-${speakerIndex % 4}`;
            bar.style.width = `${pct}%`;
            bar.textContent = pct >= 10 ? `${speaker}: ${pct.toFixed(0)}%` : '';
            bar.title = `${speaker}: ${pct.toFixed(1)}%`;
            fragment.appendChild(bar);
        }
        speakerIndex++;
    }

    // Add wide shot bar
    if (wideShotPct > 0) {
        const bar = document.createElement('div');
        bar.className = 'distribution-bar wide-shot';
        bar.style.width = `${wideShotPct}%`;
        bar.textContent = wideShotPct >= 8 ? `Wide: ${wideShotPct.toFixed(0)}%` : '';
        bar.title = `Wide Shot: ${wideShotPct.toFixed(1)}%`;
        fragment.appendChild(bar);
    }

    multitrackUI.distributionChart.innerHTML = '';
    multitrackUI.distributionChart.appendChild(fragment);
}

function renderSpeakerStats(metadata) {
    if (!multitrackUI.speakerStats || !metadata) return;

    const speakerPercentages = metadata.speakerPercentages || {};
    const wideShotPct = metadata.wideShotPercentage || 0;

    const fragment = document.createDocumentFragment();

    // Add speaker stats
    // SECURITY: Escape speaker names to prevent XSS
    let speakerIndex = 0;
    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
        const stat = document.createElement('div');
        stat.className = 'speaker-stat';
        stat.innerHTML = `
            <span class="speaker-stat-dot speaker-${speakerIndex % 4}"></span>
            <span>${escapeHtml(speaker)}: ${escapeHtml(pct.toFixed(1))}%</span>
        `;
        fragment.appendChild(stat);
        speakerIndex++;
    }

    // Add wide shot stat
    if (wideShotPct > 0) {
        const stat = document.createElement('div');
        stat.className = 'speaker-stat';
        stat.innerHTML = `
            <span class="speaker-stat-dot wide-shot"></span>
            <span>Wide: ${escapeHtml(wideShotPct.toFixed(1))}%</span>
        `;
        fragment.appendChild(stat);
    }

    // Add avg shot duration
    if (metadata.averageShotDuration) {
        const stat = document.createElement('div');
        stat.className = 'speaker-stat';
        stat.innerHTML = `<span style="color: #888;">Avg: ${escapeHtml(metadata.averageShotDuration.toFixed(1))}s</span>`;
        fragment.appendChild(stat);
    }

    multitrackUI.speakerStats.innerHTML = '';
    multitrackUI.speakerStats.appendChild(fragment);
}

function renderDecisionList(decisions) {
    if (!multitrackUI.decisionList) return;

    // Update count
    if (multitrackUI.decisionCount) {
        multitrackUI.decisionCount.textContent = decisions.length;
    }

    const fragment = document.createDocumentFragment();

    // Limit to first 50 for performance
    const displayDecisions = decisions.slice(0, 50);

    displayDecisions.forEach((decision, i) => {
        const item = document.createElement('div');
        item.className = 'decision-item';

        const speakerClass = decision.isWideShot ? 'wide-shot' : '';
        const startTime = formatTime(decision.startTime);
        const endTime = formatTime(decision.endTime);

        // SECURITY: Escape dynamic content to prevent XSS
        item.innerHTML = `
            <span class="decision-time">${escapeHtml(startTime)}-${escapeHtml(endTime)}</span>
            <span class="decision-speaker ${speakerClass}">${escapeHtml(decision.speakerName)}</span>
            <span class="decision-reason">${escapeHtml(decision.reason || '')}</span>
            <button class="decision-seek" data-time="${escapeHtml(decision.startTime)}" title="Seek to ${escapeHtml(startTime)}" aria-label="Seek to ${escapeHtml(startTime)}">&gt;</button>
        `;

        fragment.appendChild(item);
    });

    if (decisions.length > 50) {
        const more = document.createElement('div');
        more.className = 'decision-item';
        more.style.justifyContent = 'center';
        more.style.color = '#888';
        more.textContent = `+ ${decisions.length - 50} more decisions`;
        fragment.appendChild(more);
    }

    multitrackUI.decisionList.innerHTML = '';
    multitrackUI.decisionList.appendChild(fragment);
}

function handleDecisionListClick(e) {
    const seekBtn = e.target.closest('.decision-seek');
    if (seekBtn) {
        e.stopPropagation();
        const time = parseFloat(seekBtn.dataset.time);
        if (!isNaN(time)) {
            seekToTime(time);
        }
    }
}

// ============================================================================
// SEEK TO TIME (CEP VERSION)
// ============================================================================
async function seekToTime(seconds) {
    try {
        await jsx.call('seekToTime', seconds);
    } catch (e) {
        console.warn('[SPLICE Multitrack] Failed to seek:', e);
    }
}

// ============================================================================
// APPLY MULTITRACK CUTS
// ============================================================================
async function applyMultitrackCuts() {
    if (!analysisResults || !analysisResults.decisions) {
        setStatus('No analysis data. Run analysis first.');
        return;
    }

    if (isMultitrackOperationInProgress) return;

    isMultitrackOperationInProgress = true;
    if (multitrackUI.applyBtn) {
        multitrackUI.applyBtn.disabled = true;
        multitrackUI.applyBtn.textContent = 'Applying...';
    }

    try {
        setStatus('Building multitrack sequence...');

        // Check if builder is available
        if (!window.spliceBuilder) {
            throw new Error('Builder not initialized');
        }

        // Get active sequence info
        const seqInfo = await jsx.call('getActiveSequence');
        if (!seqInfo) {
            throw new Error('No active sequence');
        }

        // Create cut list from decisions
        const cutList = {
            version: '3.5',
            source: {
                name: seqInfo.name,
                path: seqInfo.treePath || seqInfo.name
            },
            segments: analysisResults.decisions.map(d => ({
                type: d.isWideShot ? 'wide_shot' : (d.speakerIndex >= 0 ? 'speaker' : 'speech'),
                sourceName: seqInfo.name,
                sourcePath: seqInfo.treePath || seqInfo.name,
                inPoint: d.startTime,
                outPoint: d.endTime,
                speaker: d.speakerName,
                videoTrack: d.videoTrack,
                colorHint: d.isWideShot ? 'yellow' :
                           (d.speakerIndex === 0 ? 'mango' :
                            d.speakerIndex === 1 ? 'caribbean' :
                            d.speakerIndex === 2 ? 'lavender' : 'cerulean')
            })),
            metadata: {
                isMultitrack: true,
                speakerCount: speakerConfig.length,
                decisionCount: analysisResults.decisions.length,
                ...analysisResults.metadata
            }
        };

        // Build sequence
        const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, {
            suffix: '_MULTITRACK'
        });

        if (result.success) {
            // Hide preview
            if (multitrackUI.preview) {
                multitrackUI.preview.classList.add('hidden');
            }

            setStatus(`Multitrack sequence created: ${result.stats?.clipsInserted || 0} clips`);

            // Clear results
            analysisResults = null;
        } else {
            throw new Error(result.error || 'Failed to build sequence');
        }

    } catch (err) {
        console.error('[SPLICE Multitrack] Apply error:', err);
        setStatus('Apply failed: ' + err.message, true);
    } finally {
        isMultitrackOperationInProgress = false;
        if (multitrackUI.applyBtn) {
            multitrackUI.applyBtn.disabled = true;
            multitrackUI.applyBtn.textContent = 'Apply';
        }
    }
}

// ============================================================================
// EXPORTS
// ============================================================================
// Expose for initialization from main.js
if (typeof window !== 'undefined') {
    window.initMultitrackUI = initMultitrackUI;
    window.spliceMultitrack = {
        init: initMultitrackUI,
        analyze: analyzeMultitrack,
        autoBalance: autoBalanceMultitrack,
        apply: applyMultitrackCuts,
        getSettings: getMultitrackSettings,
        getResults: () => analysisResults
    };
}
