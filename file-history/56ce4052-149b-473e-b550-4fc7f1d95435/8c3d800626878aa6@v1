/**
 * SPLICE CEP Panel - Main Entry Point
 * v4.0.0 - CEP Migration
 */

// ============================================================================
// CACHED DOM ELEMENTS
// ============================================================================
const ui = {};

function cacheUIElements() {
    ui.status = document.getElementById('status');
    ui.goBtn = document.getElementById('goBtn');
    ui.optionsToggle = document.getElementById('optionsToggle');
    ui.optionsPanel = document.getElementById('optionsPanel');

    // Sliders and options
    ui.sensitivitySlider = document.getElementById('sensitivitySlider');
    ui.sensitivityValue = document.getElementById('sensitivityValue');
    ui.sourceOriginal = document.getElementById('sourceOriginal');
    ui.sourceIsolated = document.getElementById('sourceIsolated');

    // Feature toggles
    ui.enableTakesDetection = document.getElementById('enableTakesDetection');
    ui.enableJCut = document.getElementById('enableJCut');
    ui.jcutSettings = document.getElementById('jcutSettings');
    ui.jcutLeadIn = document.getElementById('jcutLeadIn');
    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');
    ui.jcutLeadOut = document.getElementById('jcutLeadOut');
    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');

    // Zoom settings
    ui.enableZoom = document.getElementById('enableZoom');
    ui.zoomSettings = document.getElementById('zoomSettings');
    ui.zoomFrequency = document.getElementById('zoomFrequency');
    ui.zoomPreset = document.getElementById('zoomPreset');
    ui.zoomPlacement = document.getElementById('zoomPlacement');

    // Chapter settings
    ui.enableChapters = document.getElementById('enableChapters');
    ui.chapterSettings = document.getElementById('chapterSettings');
    ui.maxChapters = document.getElementById('maxChapters');
    ui.minChapterLength = document.getElementById('minChapterLength');

    // Profanity settings
    ui.enableProfanity = document.getElementById('enableProfanity');
    ui.profanitySettings = document.getElementById('profanitySettings');

    // Filler word settings
    ui.enableFillerDetection = document.getElementById('enableFillerDetection');
    ui.fillerSettings = document.getElementById('fillerSettings');

    // Progress
    ui.progressContainer = document.getElementById('progressContainer');
    ui.progressBar = document.getElementById('progressBar');
    ui.progressText = document.getElementById('progressText');
    ui.resultsEmpty = document.getElementById('resultsEmpty');

    // Preview
    ui.combinedPreview = document.getElementById('combinedPreview');
    ui.previewList = document.getElementById('previewList');
    ui.silenceCount = document.getElementById('silenceCount');
    ui.takeCount = document.getElementById('takeCount');
    ui.selectedCount = document.getElementById('selectedCount');
    ui.selectAllSilences = document.getElementById('selectAllSilences');
    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');

    // Results
    ui.zoomResults = document.getElementById('zoomResults');
    ui.zoomList = document.getElementById('zoomList');
    ui.chapterResults = document.getElementById('chapterResults');
    ui.chapterList = document.getElementById('chapterList');
    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');
    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');

    // Modals
    ui.settingsBtn = document.getElementById('settingsBtn');
    ui.settingsModal = document.getElementById('settingsModal');
    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
    ui.loginModal = document.getElementById('loginModal');
    ui.closeLoginBtn = document.getElementById('closeLoginBtn');
    ui.licenseKeyInput = document.getElementById('licenseKeyInput');
    ui.saveLoginBtn = document.getElementById('saveLoginBtn');

    // Credit badge
    ui.creditBadge = document.getElementById('creditBadge');

    // Preset selector
    ui.presetSelector = document.getElementById('presetSelector');
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================
let previewSilences = [];
let previewTakes = [];
let currentChapters = [];
let currentZooms = [];
let selectedSilenceIndices = new Set();
let isOperationInProgress = false;
let lastDetectionResult = null;
let currentAudioPath = null;
let currentSequenceInfo = null;
let currentTranscript = null;

// Global state for captions/reframe modules
window.spliceState = {
    lastTranscript: null,
    currentVideoPath: null,
    activeSequence: null,
    audioPath: null
};

// Also expose transcript globally for music module
window.currentTranscript = null;

// ============================================================================
// INITIALIZATION
// ============================================================================
document.addEventListener('DOMContentLoaded', async () => {
    // Premium Loading Experience
    setTimeout(() => {
        const loader = document.getElementById('loading-overlay');
        if (loader) loader.classList.add('hidden');
    }, 800); // Small delay for smooth perception
    console.log('[SPLICE] Initializing CEP panel...');

    // Cache DOM elements
    cacheUIElements();

    // Load settings
    loadSettingsToUI();

    // Initialize UI handlers
    initOptionsToggle();
    initTextEditorToggle();
    initSocialReframeToggle();
    initMusicToggle();
    initSliders();
    initFeatureToggles();
    initPresetSelector();
    initGoButton();
    initPreviewHandlers();
    initModals();
    initCredits();
    initHelpButton();

    // Initialize offline detection
    if (typeof initOfflineDetection === 'function') {
        initOfflineDetection();
    }

    // Initialize multitrack UI
    if (typeof initMultitrackUI === 'function') {
        initMultitrackUI();
    }

    // Initialize animated captions UI
    if (typeof initAnimatedCaptions === 'function') {
        initAnimatedCaptions();
    }

    // Initialize text editor UI
    if (typeof initTextEditor === 'function') {
        initTextEditor();
    }

    // Initialize text editor section toggle
    initTextEditorToggle();

    // Initialize social reframe UI
    if (typeof initSocialReframe === 'function') {
        initSocialReframe();
    }

    // Initialize social reframe section toggle
    initSocialReframeToggle();

    // Initialize music UI
    if (typeof initMusicModule === 'function') {
        initMusicModule();
    }

    // Initialize music section toggle
    initMusicToggle();

    // Check JSX connection
    await checkJSXConnection();

    setStatus('Ready');
    console.log('[SPLICE] CEP panel initialized');
});

// ============================================================================
// JSX CONNECTION CHECK
// ============================================================================
async function checkJSXConnection() {
    try {
        const result = await jsx.call('getVersion');
        console.log('[SPLICE] JSX connection OK, version:', result);
        return true;
    } catch (e) {
        console.warn('[SPLICE] JSX connection failed:', e.message);
        setStatus('Premiere Pro connection failed', true);
        return false;
    }
}

async function checkSequenceOpen() {
    try {
        const result = await jsx.call('checkSequenceOpen');
        return result === true || result === 'true';
    } catch {
        return false;
    }
}

// ============================================================================
// OPTIONS TOGGLE
// ============================================================================
function initOptionsToggle() {
    if (ui.optionsToggle && ui.optionsPanel) {
        ui.optionsToggle.addEventListener('click', () => {
            // Check current state BEFORE toggling
            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');
            ui.optionsPanel.classList.toggle('collapsed');
            // If it was collapsed, it's now expanded (show 'expanded' class)
            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);
            saveSettings({ expandedOptions: wasCollapsed });
        });

        // Restore state
        const settings = getSettings();
        if (!settings.expandedOptions) {
            ui.optionsPanel.classList.add('collapsed');
            ui.optionsToggle.classList.remove('expanded');
        } else {
            ui.optionsToggle.classList.add('expanded');
            ui.optionsPanel.classList.remove('collapsed');
        }
    }
}

// ============================================================================
// TEXT EDITOR TOGGLE
// ============================================================================
function initTextEditorToggle() {
    const toggle = document.getElementById('textEditorToggle');
    const panel = document.getElementById('text-editor-panel');

    if (toggle && panel) {
        toggle.addEventListener('click', () => {
            // Check state BEFORE toggling
            const wasCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            const icon = toggle.querySelector('.toggle-icon');
            if (icon) {
                // If it was collapsed, it's now expanded (show -)
                icon.textContent = wasCollapsed ? '-' : '+';
            }
        });
    }
}

// ============================================================================
// SOCIAL REFRAME TOGGLE
// ============================================================================
function initSocialReframeToggle() {
    const toggle = document.getElementById('socialReframeToggle');
    const panel = document.getElementById('social-reframe-panel');

    if (toggle && panel) {
        toggle.addEventListener('click', () => {
            // Check state BEFORE toggling
            const wasCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            const icon = toggle.querySelector('.toggle-icon');
            if (icon) {
                // If it was collapsed, it's now expanded (show -)
                icon.textContent = wasCollapsed ? '-' : '+';
            }
        });
    }
}

// ============================================================================
// MUSIC TOGGLE
// ============================================================================
function initMusicToggle() {
    const toggle = document.getElementById('musicToggle');
    const panel = document.getElementById('music-panel');

    if (toggle && panel) {
        toggle.addEventListener('click', () => {
            // Check state BEFORE toggling
            const wasCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            const icon = toggle.querySelector('.toggle-icon');
            if (icon) {
                // If it was collapsed, it's now expanded (show -)
                icon.textContent = wasCollapsed ? '-' : '+';
            }
        });
    }
}

// ============================================================================
// SLIDERS
// ============================================================================
function initSliders() {
    // Sensitivity slider
    if (ui.sensitivitySlider && ui.sensitivityValue) {
        ui.sensitivitySlider.addEventListener('input', () => {
            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;
            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });
        });
    }

    // J-Cut sliders
    if (ui.jcutLeadIn && ui.jcutLeadInValue) {
        ui.jcutLeadIn.addEventListener('input', () => {
            const val = (ui.jcutLeadIn.value / 100).toFixed(2);
            ui.jcutLeadInValue.textContent = val + 's';
            saveSettings({ jcutLeadIn: parseFloat(val) });
        });
    }

    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {
        ui.jcutLeadOut.addEventListener('input', () => {
            const val = (ui.jcutLeadOut.value / 100).toFixed(2);
            ui.jcutLeadOutValue.textContent = val + 's';
            saveSettings({ jcutLeadOut: parseFloat(val) });
        });
    }
}

// ============================================================================
// FEATURE TOGGLES
// ============================================================================
function initFeatureToggles() {
    // J-Cut toggle
    if (ui.enableJCut && ui.jcutSettings) {
        ui.enableJCut.addEventListener('change', () => {
            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);
            saveSettings({ enableJCut: ui.enableJCut.checked });
        });
    }

    // Zoom toggle
    if (ui.enableZoom && ui.zoomSettings) {
        ui.enableZoom.addEventListener('change', () => {
            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);
            saveSettings({ enableZoom: ui.enableZoom.checked });
        });
    }

    // Chapters toggle
    if (ui.enableChapters && ui.chapterSettings) {
        ui.enableChapters.addEventListener('change', () => {
            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);
            saveSettings({ enableChapters: ui.enableChapters.checked });
        });
    }

    // Takes detection toggle
    if (ui.enableTakesDetection) {
        ui.enableTakesDetection.addEventListener('change', () => {
            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });
        });
    }

    // Profanity detection toggle
    if (ui.enableProfanity && ui.profanitySettings) {
        ui.enableProfanity.addEventListener('change', () => {
            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);
            saveSettings({ enableProfanity: ui.enableProfanity.checked });
        });
    }

    // Filler word detection toggle
    if (ui.enableFillerDetection && ui.fillerSettings) {
        ui.enableFillerDetection.addEventListener('change', () => {
            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);
            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });
        });
    }
}

// ============================================================================
// PRESET SELECTOR
// ============================================================================
// PRESETS is defined in config.js

function initPresetSelector() {
    if (!ui.presetSelector) return;

    ui.presetSelector.addEventListener('change', () => {
        const presetId = ui.presetSelector.value;
        applyPreset(presetId);
    });

    // Load current preset
    const settings = getSettings();
    if (settings.activePreset) {
        ui.presetSelector.value = settings.activePreset;
    }
}

function applyPreset(presetId) {
    const preset = PRESETS[presetId];
    if (!preset) return;

    // Custom preset - keep current settings
    if (presetId === 'custom' || !preset.settings) {
        saveSettings({ activePreset: 'custom' });
        setStatus('Using custom settings');
        return;
    }

    const settings = preset.settings;

    // Apply to UI
    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {
        ui.sensitivitySlider.value = settings.sensitivity;
        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;
    }

    if (ui.enableJCut) {
        ui.enableJCut.checked = settings.enableJCut || false;
        if (ui.jcutSettings) {
            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);
        }
    }

    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {
        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);
        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';
    }

    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {
        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);
        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';
    }

    // Save merged settings
    saveSettings({
        activePreset: presetId,
        sensitivity: settings.sensitivity,
        threshold: settings.threshold,
        minSilenceLength: settings.minSilenceLength,
        paddingStart: settings.paddingStart,
        paddingEnd: settings.paddingEnd,
        enableTakesDetection: settings.enableTakesDetection,
        enableJCut: settings.enableJCut || false,
        jcutLeadIn: settings.jCutLeadIn || 0.3,
        jcutLeadOut: settings.jCutLeadOut || 0.2
    });

    setStatus(`Applied ${preset.name} preset`);
}

// ============================================================================
// LOAD SETTINGS TO UI
// ============================================================================
function loadSettingsToUI() {
    const settings = getSettings();

    if (ui.sensitivitySlider) {
        ui.sensitivitySlider.value = settings.sensitivity;
        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;
    }

    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;
    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;
    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;
    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;

    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);
    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);
    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);

    if (ui.jcutLeadIn) {
        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);
        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';
    }
    if (ui.jcutLeadOut) {
        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);
        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';
    }

    if (ui.presetSelector && settings.activePreset) {
        ui.presetSelector.value = settings.activePreset;
    }
}

// ============================================================================
// GO BUTTON - MAIN WORKFLOW
// ============================================================================
function initGoButton() {
    if (!ui.goBtn) return;

    ui.goBtn.addEventListener('click', async () => {
        if (isOperationInProgress) return;
        await runDetection();
    });
}

async function runDetection() {
    if (isOperationInProgress) return;

    // Check sequence
    const hasSequence = await checkSequenceOpen();
    if (!hasSequence) {
        setStatus('Please open a sequence first', true);
        return;
    }

    // Check online
    if (!isOnline()) {
        setStatus('Offline - Check your connection', true);
        return;
    }

    isOperationInProgress = true;
    ui.goBtn.disabled = true;
    showProgress('Detecting silences...');

    try {
        const settings = getSettings();

        // Get sequence info
        const seqInfo = await jsx.call('getActiveSequence');
        console.log('[SPLICE] Sequence info:', seqInfo);

        // Store sequence info for later use
        currentSequenceInfo = seqInfo;
        window.spliceState.activeSequence = seqInfo;
        if (seqInfo && seqInfo.videoPath) {
            window.spliceState.currentVideoPath = seqInfo.videoPath;
        }

        // Export audio via JSX for silence detection
        updateProgress(10, 'Exporting audio...');

        let audioFilePath = null;
        try {
            // Get sequence info for audio export
            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');
            if (exportResult && exportResult.success && exportResult.outputPath) {
                audioFilePath = exportResult.outputPath;
                console.log('[SPLICE] Audio exported to:', audioFilePath);
            } else if (exportResult && exportResult.error) {
                throw new Error(exportResult.error);
            }
        } catch (exportError) {
            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);
            // Try to get audio from first clip in timeline
            try {
                const clipInfo = await jsx.call('getFirstClipAudioPath');
                if (clipInfo && clipInfo.path) {
                    audioFilePath = clipInfo.path;
                    console.log('[SPLICE] Using clip audio path:', audioFilePath);
                }
            } catch (clipError) {
                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);
            }
        }

        if (!audioFilePath) {
            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');
        }

        // Store audio path globally for other modules
        currentAudioPath = audioFilePath;
        window.spliceState.audioPath = audioFilePath;

        // Call backend for silence detection with audio file path
        updateProgress(30, 'Detecting silences...');
        const silenceResponse = await fetchWithTimeout(
            `${getBackendUrl()}/silences-rms`,
            {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    wavPath: audioFilePath,
                    sensitivity: settings.sensitivity,
                    minSilenceLength: settings.minSilenceLength || 0.5
                })
            }
        );

        if (!silenceResponse.ok) {
            throw new Error(await parseErrorResponse(silenceResponse));
        }

        const silenceData = await silenceResponse.json();
        previewSilences = silenceData.silences || [];

        // Detect takes if enabled
        if (settings.enableTakesDetection) {
            updateProgress(60, 'Detecting takes...');
            const analyzeResponse = await fetchWithTimeout(
                `${getBackendUrl()}/analyze`,
                {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        wavPath: audioFilePath,
                        detectTakes: true
                    })
                }
            );

            if (analyzeResponse.ok) {
                const analyzeData = await analyzeResponse.json();
                previewTakes = analyzeData.takes || [];

                // Store transcript for captions/music modules
                if (analyzeData.transcript) {
                    currentTranscript = analyzeData.transcript;
                    window.currentTranscript = analyzeData.transcript;
                    window.spliceState.lastTranscript = analyzeData.transcript;
                }
            }
        }

        // Detect chapters if enabled
        if (settings.enableChapters) {
            updateProgress(80, 'Detecting chapters...');
            try {
                const chapterResponse = await fetchWithTimeout(
                    `${getBackendUrl()}/chapters`,
                    {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            wavPath: audioFilePath,
                            transcript: currentTranscript,
                            maxChapters: settings.maxChapters || 10,
                            minChapterLength: settings.minChapterLength || 60
                        })
                    }
                );

                if (chapterResponse.ok) {
                    const chapterData = await chapterResponse.json();
                    currentChapters = chapterData.chapters || [];
                }
            } catch (e) {
                console.warn('[SPLICE] Chapter detection failed:', e);
            }
        }

        // Detect zoom points if enabled
        if (settings.enableZoom) {
            updateProgress(90, 'Detecting zoom points...');
            try {
                const zoomResponse = await fetchWithTimeout(
                    `${getBackendUrl()}/zoom`,
                    {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            wavPath: audioFilePath,
                            transcript: currentTranscript,
                            frequency: settings.zoomFrequency || 'medium',
                            preset: settings.zoomPreset || 'medium',
                            placement: settings.zoomPlacement || 'sentence_start'
                        })
                    }
                );

                if (zoomResponse.ok) {
                    const zoomData = await zoomResponse.json();
                    currentZooms = zoomData.zoomPoints || [];
                }
            } catch (e) {
                console.warn('[SPLICE] Zoom detection failed:', e);
            }
        }

        // Store results
        lastDetectionResult = {
            silences: previewSilences,
            takes: previewTakes,
            chapters: currentChapters,
            zooms: currentZooms
        };

        // Show preview
        hideProgress();
        showCombinedPreview();
        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);

    } catch (error) {
        console.error('[SPLICE] Detection error:', error);
        setStatus('Detection failed: ' + error.message, true);
        hideProgress();
    } finally {
        isOperationInProgress = false;
        ui.goBtn.disabled = false;
    }
}

// ============================================================================
// PROGRESS UI
// ============================================================================
function showProgress(message) {
    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');
    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');
    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');
    updateProgress(0, message);
}

function updateProgress(percent, message) {
    if (ui.progressBar) ui.progressBar.style.width = percent + '%';
    if (ui.progressText) ui.progressText.textContent = message || '';
}

function hideProgress() {
    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');
}

// ============================================================================
// COMBINED PREVIEW
// ============================================================================
function showCombinedPreview() {
    if (!ui.combinedPreview) return;

    ui.combinedPreview.classList.remove('hidden');
    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');

    // Update counts
    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;
    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;

    // Select all by default
    selectedSilenceIndices.clear();
    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
    updateSelectedCount();

    // Render preview list
    renderPreviewList();

    // Show chapter results if available
    if (currentChapters.length > 0 && ui.chapterResults) {
        ui.chapterResults.classList.remove('hidden');
        renderChapterList();
    }

    // Show zoom results if available
    if (currentZooms.length > 0 && ui.zoomResults) {
        ui.zoomResults.classList.remove('hidden');
    }
}

function renderPreviewList() {
    if (!ui.previewList) return;

    const html = [];

    // Render silences
    previewSilences.forEach((silence, i) => {
        const isSelected = selectedSilenceIndices.has(i);
        const duration = silence.end - silence.start;
        html.push(`
            <div class="preview-item ${isSelected ? '' : 'excluded'}" data-index="${i}" data-type="silence">
                <input type="checkbox" class="preview-item-check" ${isSelected ? 'checked' : ''}>
                <div class="preview-item-info">
                    <div class="preview-item-time">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>
                    <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
                </div>
            </div>
        `);
    });

    // Render takes
    previewTakes.forEach((take, i) => {
        // SECURITY: Escape take label to prevent XSS
        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));
        html.push(`
            <div class="preview-item take-item" data-index="${i}" data-type="take">
                <div class="preview-item-icon">ðŸŽ¬</div>
                <div class="preview-item-info">
                    <div class="preview-item-time">${formatTime(take.start)} - ${formatTime(take.end)}</div>
                    <div class="preview-item-label">${safeLabel}</div>
                </div>
            </div>
        `);
    });

    ui.previewList.innerHTML = html.join('');

    // Add click handlers
    ui.previewList.querySelectorAll('.preview-item').forEach(item => {
        item.addEventListener('click', (e) => {
            const index = parseInt(item.dataset.index);
            const type = item.dataset.type;

            if (e.target.classList.contains('preview-item-check')) {
                // Checkbox clicked
                toggleSilenceSelection(index);
            } else {
                // Item clicked - seek to time
                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];
                seekToTime(data.start);
            }
        });
    });
}

function toggleSilenceSelection(index) {
    if (selectedSilenceIndices.has(index)) {
        selectedSilenceIndices.delete(index);
    } else {
        selectedSilenceIndices.add(index);
    }
    updateSelectedCount();
    renderPreviewList();
}

function updateSelectedCount() {
    if (ui.selectedCount) {
        ui.selectedCount.textContent = selectedSilenceIndices.size;
    }
    if (ui.selectAllSilences) {
        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;
    }
}

async function seekToTime(seconds) {
    try {
        // Check if there's an active sequence before seeking
        if (!app?.project?.activeSequence) {
            console.warn('[SPLICE] No active sequence to seek in');
            return;
        }
        // Use JSX to set playhead position
        // Note: setPlayerPosition expects ticks as a string without quotes around the number value
        const ticks = Math.round(seconds * 254016000000);
        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);
    } catch (e) {
        console.warn('[SPLICE] Seek failed:', e);
    }
}

// ============================================================================
// CHAPTER LIST
// ============================================================================
function renderChapterList() {
    if (!ui.chapterList) return;

    const html = currentChapters.map((chapter, i) => {
        // SECURITY: Escape chapter title to prevent XSS
        const safeTitle = escapeHtml(chapter.title);
        return `
            <div class="chapter-item" data-index="${i}">
                <div class="chapter-time">${formatTime(chapter.startTime)}</div>
                <div class="chapter-title">${safeTitle}</div>
            </div>
        `;
    }).join('');

    ui.chapterList.innerHTML = html;

    // Add click handlers
    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {
        item.addEventListener('click', () => {
            const index = parseInt(item.dataset.index);
            seekToTime(currentChapters[index].startTime);
        });
    });
}

// ============================================================================
// PREVIEW HANDLERS
// ============================================================================
function initPreviewHandlers() {
    // Select all checkbox
    if (ui.selectAllSilences) {
        ui.selectAllSilences.addEventListener('change', () => {
            if (ui.selectAllSilences.checked) {
                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
            } else {
                selectedSilenceIndices.clear();
            }
            updateSelectedCount();
            renderPreviewList();
        });
    }

    // Apply button
    if (ui.applyPreviewBtn) {
        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);
    }

    // Cancel button
    if (ui.cancelPreviewBtn) {
        ui.cancelPreviewBtn.addEventListener('click', hidePreview);
    }

    // Build sequence button
    if (ui.buildSequenceBtn) {
        ui.buildSequenceBtn.addEventListener('click', buildSequence);
    }

    // Copy YouTube timestamps
    if (ui.copyYouTubeBtn) {
        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);
    }

    // Add chapter markers
    if (ui.addChapterMarkersBtn) {
        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);
    }

    // Apply zoom markers
    const applyZoomsBtn = document.getElementById('applyZoomsBtn');
    if (applyZoomsBtn) {
        applyZoomsBtn.addEventListener('click', applyZoomMarkers);
    }
}

async function applyPreviewAndMarkers() {
    if (isOperationInProgress) return;

    isOperationInProgress = true;
    setStatus('Adding markers...');

    try {
        // Add silence markers
        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));
        for (const silence of selectedSilences) {
            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);
        }

        // Add take markers
        for (const take of previewTakes) {
            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);
        }

        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);
    } catch (error) {
        setStatus('Failed to add markers: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

function hidePreview() {
    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');
    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');
    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');
    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');
    previewSilences = [];
    previewTakes = [];
    selectedSilenceIndices.clear();
}

async function buildSequence() {
    if (isOperationInProgress) return;

    isOperationInProgress = true;
    setStatus('Building sequence...');

    try {
        const settings = getSettings();

        // Ensure we have sequence info
        if (!currentSequenceInfo) {
            currentSequenceInfo = await jsx.call('getActiveSequence');
        }

        // Create cut list from selected silences
        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));

        // Calculate total duration from sequence info or last silence
        let duration = 0;
        if (currentSequenceInfo && currentSequenceInfo.duration) {
            duration = currentSequenceInfo.duration;
        } else if (previewSilences.length > 0) {
            const lastSilence = previewSilences[previewSilences.length - 1];
            duration = lastSilence.end + 10; // Add buffer
        }

        // Call backend to generate cut list
        const cutListResponse = await fetchWithTimeout(
            `${getBackendUrl()}/cut-list`,
            {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',
                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',
                    duration: duration,
                    silences: selectedSilences,
                    takes: previewTakes,
                    enableTakes: settings.enableTakesDetection,
                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,
                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0
                })
            }
        );

        if (!cutListResponse.ok) {
            throw new Error(await parseErrorResponse(cutListResponse));
        }

        const cutList = await cutListResponse.json();

        // Build sequence via JSX
        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));

        if (result && result.success) {
            setStatus(`Built sequence: ${result.sequenceName}`);
            hidePreview();
        } else {
            throw new Error(result?.error || 'Build failed');
        }
    } catch (error) {
        setStatus('Build failed: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

function copyYouTubeTimestamps() {
    if (currentChapters.length === 0) return;

    const timestamps = currentChapters.map(ch =>
        `${formatTime(ch.startTime)} ${ch.title}`
    ).join('\n');

    navigator.clipboard.writeText(timestamps).then(() => {
        setStatus('Copied YouTube timestamps');
    }).catch(() => {
        setStatus('Failed to copy', true);
    });
}

async function addChapterMarkers() {
    if (isOperationInProgress || currentChapters.length === 0) return;

    isOperationInProgress = true;
    setStatus('Adding chapter markers...');

    try {
        for (const chapter of currentChapters) {
            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);
        }
        setStatus(`Added ${currentChapters.length} chapter markers`);
    } catch (error) {
        setStatus('Failed to add markers: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

/**
 * Apply zoom point markers to the timeline
 */
async function applyZoomMarkers() {
    if (isOperationInProgress || currentZooms.length === 0) return;

    isOperationInProgress = true;
    setStatus('Adding zoom markers...');

    try {
        for (const zoom of currentZooms) {
            // Create a marker for each zoom point with zoom intensity info
            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;
            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);
        }
        setStatus(`Added ${currentZooms.length} zoom markers`);
    } catch (error) {
        setStatus('Failed to add zoom markers: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

// ============================================================================
// MODALS
// ============================================================================
function initModals() {
    // Settings modal
    if (ui.settingsBtn && ui.settingsModal) {
        ui.settingsBtn.addEventListener('click', () => {
            ui.settingsModal.classList.remove('hidden');
            // Sync remember options checkbox with current settings
            const rememberOptions = document.getElementById('rememberOptions');
            if (rememberOptions) {
                rememberOptions.checked = getSettings().rememberOptions;
            }
        });
    }

    if (ui.closeSettingsBtn && ui.settingsModal) {
        ui.closeSettingsBtn.addEventListener('click', () => {
            ui.settingsModal.classList.add('hidden');
        });
    }

    // Remember options checkbox
    const rememberOptions = document.getElementById('rememberOptions');
    if (rememberOptions) {
        rememberOptions.addEventListener('change', () => {
            saveSettings({ rememberOptions: rememberOptions.checked });
            if (rememberOptions.checked) {
                setStatus('Options will be remembered');
            } else {
                setStatus('Options will reset to defaults');
            }
        });
    }

    // Login modal
    if (ui.creditBadge) {
        ui.creditBadge.addEventListener('click', () => {
            const settings = getSettings();
            if (!settings.customerId) {
                showLoginModal();
            }
        });
    }

    if (ui.closeLoginBtn && ui.loginModal) {
        ui.closeLoginBtn.addEventListener('click', () => {
            ui.loginModal.classList.add('hidden');
        });
    }

    if (ui.saveLoginBtn) {
        ui.saveLoginBtn.addEventListener('click', activateLicense);
    }

    // License lookup button
    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');
    if (lookupLicenseBtn) {
        lookupLicenseBtn.addEventListener('click', lookupLicense);
    }

    // Close modals on backdrop click
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.add('hidden');
            }
        });
    });
}

function showLoginModal() {
    if (ui.loginModal) ui.loginModal.classList.remove('hidden');
}

async function activateLicense() {
    if (!ui.licenseKeyInput) return;

    const licenseKey = ui.licenseKeyInput.value.trim();
    if (!licenseKey) {
        setStatus('Please enter a license key', true);
        return;
    }

    try {
        const response = await fetchWithTimeout(
            `${getBackendUrl()}/license/activate`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ key: licenseKey })
            }
        );

        if (!response.ok) {
            throw new Error(await parseErrorResponse(response));
        }

        const data = await response.json();
        saveSettings({
            customerId: data.customerId,
            licenseKey: licenseKey
        });

        if (ui.loginModal) ui.loginModal.classList.add('hidden');
        setStatus('License activated');
        updateCredits();
    } catch (error) {
        setStatus('Activation failed: ' + error.message, true);
    }
}

/**
 * Look up license key by email address
 */
async function lookupLicense() {
    const lookupEmailInput = document.getElementById('lookupEmailInput');
    const licenseKeyInput = document.getElementById('licenseKeyInput');

    if (!lookupEmailInput) return;

    const email = lookupEmailInput.value.trim().toLowerCase();
    if (!email) {
        setStatus('Please enter your email address', true);
        return;
    }

    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        setStatus('Please enter a valid email address', true);
        return;
    }

    const lookupBtn = document.getElementById('lookupLicenseBtn');
    if (lookupBtn) {
        lookupBtn.disabled = true;
        lookupBtn.textContent = 'Looking up...';
    }

    try {
        const response = await fetchWithTimeout(
            `${getBackendUrl()}/license/lookup`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email })
            },
            30000
        );

        const result = await response.json();

        // Note: For security, the backend does NOT return the license key directly.
        // It sends the key via email to prevent enumeration attacks.
        if (result.success) {
            setStatus(result.message || 'If a license exists, it has been sent to your email.');
        } else {
            setStatus(result.error || 'Lookup failed. Please try again.', true);
        }
    } catch (error) {
        setStatus('Lookup failed: ' + error.message, true);
    } finally {
        if (lookupBtn) {
            lookupBtn.disabled = false;
            lookupBtn.textContent = 'Lookup';
        }
    }
}

// ============================================================================
// CREDITS
// ============================================================================
function initCredits() {
    updateCredits();
}

async function updateCredits() {
    if (!ui.creditBadge) return;

    const settings = getSettings();
    if (!settings.customerId) {
        ui.creditBadge.className = 'credit-badge login';
        ui.creditBadge.textContent = 'Login';
        ui.creditBadge.style.display = 'flex';
        return;
    }

    try {
        const response = await fetchWithTimeout(
            `${getBackendUrl()}/credits`,
            {
                method: 'GET',
                headers: getAuthHeaders()
            }
        );

        if (response.ok) {
            const data = await response.json();
            // Backend returns hoursRemaining (not remainingMinutes)
            const hours = (data.hoursRemaining || 0).toFixed(1);
            ui.creditBadge.textContent = `${hours}h`;
            // Low warning when less than 1 hour remaining
            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';
            ui.creditBadge.style.display = 'flex';
        } else {
            ui.creditBadge.className = 'credit-badge error';
            ui.creditBadge.textContent = 'Error';
            ui.creditBadge.style.display = 'flex';
        }
    } catch {
        ui.creditBadge.className = 'credit-badge error';
        ui.creditBadge.textContent = 'Offline';
        ui.creditBadge.style.display = 'flex';
    }
}

// ============================================================================
// HELP BUTTON
// ============================================================================
function initHelpButton() {
    const helpBtn = document.getElementById('helpBtn');
    if (helpBtn) {
        helpBtn.addEventListener('click', () => {
            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');
        });
    }
}

// Export for debugging
window.spliceDebug = {
    getState: () => ({
        silences: previewSilences,
        takes: previewTakes,
        chapters: currentChapters,
        zooms: currentZooms,
        selected: Array.from(selectedSilenceIndices)
    }),
    jsx,
    runDetection
};
