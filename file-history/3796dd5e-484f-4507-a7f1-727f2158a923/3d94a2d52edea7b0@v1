#!/bin/bash
# Debug Orchestrator - Intelligent debugging with regression detection and self-healing
# Solves the problem: "fixing one thing breaks another"

set -eo pipefail

CLAUDE_DIR="${HOME}/.claude"
DEBUG_DIR="${CLAUDE_DIR}/.debug"
BUG_FIX_MEMORY="${DEBUG_DIR}/bug-fixes.jsonl"
REGRESSION_LOG="${DEBUG_DIR}/regressions.jsonl"
TEST_SNAPSHOTS="${DEBUG_DIR}/test-snapshots"
LOG_FILE="${CLAUDE_DIR}/debug-orchestrator.log"

# GitHub MCP integration
GITHUB_MCP_AVAILABLE=false
CHROME_MCP_AVAILABLE=false

mkdir -p "$DEBUG_DIR" "$TEST_SNAPSHOTS"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# =============================================================================
# BUG FIX MEMORY BANK
# =============================================================================

record_bug_fix() {
    local bug_description="$1"
    local bug_type="$2"
    local fix_description="$3"
    local files_changed="$4"
    local success="$5"
    local tests_passed="${6:-unknown}"

    local record
    record=$(jq -n \
        --arg desc "$bug_description" \
        --arg type "$bug_type" \
        --arg fix "$fix_description" \
        --arg files "$files_changed" \
        --arg success "$success" \
        --arg tests "$tests_passed" \
        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        '{
            timestamp: $ts,
            bug_description: $desc,
            bug_type: $type,
            fix_description: $fix,
            files_changed: $files,
            success: ($success == "true"),
            tests_passed: $tests,
            embedding_keywords: ($desc + " " + $fix | split(" ") | map(select(length > 3)))
        }')

    echo "$record" >> "$BUG_FIX_MEMORY"
    log "Recorded bug fix: $bug_description -> $success"
    echo "$record"
}

search_similar_bugs() {
    local search_query="$1"
    local limit="${2:-5}"

    if [[ ! -f "$BUG_FIX_MEMORY" ]]; then
        echo '{"similar_fixes":[],"count":0}'
        return
    fi

    # Simple keyword matching (could be enhanced with embeddings)
    local keywords
    keywords=$(echo "$search_query" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '\n' | grep -v '^$' || true)

    log "Searching for similar bugs: $search_query"

    # Search through bug fix memory
    local results
    results=$(tail -n 100 "$BUG_FIX_MEMORY" | jq -s \
        --arg query "$(echo "$keywords" | tr '\n' ' ')" \
        --argjson limit "$limit" \
        'map(select(.success == true)) |
         map(. + {relevance_score: 0}) |
         .[:$limit]')

    jq -n \
        --argjson results "$results" \
        --argjson count "$(echo "$results" | jq 'length')" \
        '{similar_fixes: $results, count: $count}'
}

# =============================================================================
# REGRESSION DETECTION
# =============================================================================

create_test_snapshot() {
    local snapshot_id="$1"
    local test_command="$2"
    local description="$3"

    log "Creating test snapshot: $snapshot_id"

    # Run tests and capture output
    local test_output
    local test_exit_code=0
    test_output=$(eval "$test_command" 2>&1 || test_exit_code=$?)

    # Save snapshot
    local snapshot_file="${TEST_SNAPSHOTS}/${snapshot_id}.json"
    jq -n \
        --arg id "$snapshot_id" \
        --arg desc "$description" \
        --arg cmd "$test_command" \
        --arg output "$test_output" \
        --argjson exit_code "$test_exit_code" \
        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        '{
            snapshot_id: $id,
            description: $desc,
            test_command: $cmd,
            output: $output,
            exit_code: $exit_code,
            timestamp: $ts,
            tests_passed: ($exit_code == 0)
        }' > "$snapshot_file"

    log "Snapshot created: $snapshot_id (exit code: $test_exit_code)"
    echo "$snapshot_file"
}

detect_regression() {
    local before_snapshot="$1"
    local after_snapshot="$2"

    if [[ ! -f "$before_snapshot" || ! -f "$after_snapshot" ]]; then
        echo '{"regression_detected":false,"error":"Snapshots not found"}'
        return 1
    fi

    local before_passed
    local after_passed
    before_passed=$(jq -r '.tests_passed' "$before_snapshot")
    after_passed=$(jq -r '.tests_passed' "$after_snapshot")

    local regression_detected="false"
    local regression_type="none"
    local details=""

    if [[ "$before_passed" == "true" && "$after_passed" == "false" ]]; then
        regression_detected="true"
        regression_type="test_failure"
        details="Tests passed before fix, but fail after fix"
        log "REGRESSION DETECTED: Tests failing after fix"

        # Record regression
        jq -n \
            --arg type "$regression_type" \
            --arg details "$details" \
            --arg before_id "$(jq -r '.snapshot_id' "$before_snapshot")" \
            --arg after_id "$(jq -r '.snapshot_id' "$after_snapshot")" \
            --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{
                timestamp: $ts,
                regression_type: $type,
                details: $details,
                before_snapshot: $before_id,
                after_snapshot: $after_id
            }' >> "$REGRESSION_LOG"
    fi

    jq -n \
        --argjson regression "$regression_detected" \
        --arg type "$regression_type" \
        --arg details "$details" \
        '{regression_detected: $regression, regression_type: $type, details: $details}'
}

# =============================================================================
# SELF-HEALING FIX ORCHESTRATION
# =============================================================================

smart_debug() {
    local bug_description="$1"
    local bug_type="${2:-general}"
    local test_command="${3:-echo 'No tests configured'}"
    local context="${4:-}"

    log "Starting smart debug: $bug_description"

    # Step 1: Create BEFORE snapshot
    local before_snapshot_id="before_$(date +%s)"
    local before_snapshot
    before_snapshot=$(create_test_snapshot "$before_snapshot_id" "$test_command" "Before fix: $bug_description")

    # Step 2: Search for similar bug fixes in memory
    log "Searching bug fix memory for similar bugs..."
    local similar_fixes
    similar_fixes=$(search_similar_bugs "$bug_description" 5)
    local similar_count
    similar_count=$(echo "$similar_fixes" | jq -r '.count')

    if [[ "$similar_count" -gt 0 ]]; then
        log "Found $similar_count similar bug fixes in memory"
    fi

    # Step 3: Search GitHub for similar issues (if GitHub MCP available)
    local github_solutions=""
    if command -v gh &> /dev/null; then
        log "Searching GitHub for similar issues..."
        # Use gh CLI to search (fallback if GitHub MCP not available)
        github_solutions=$(gh search issues "$bug_description" --limit 3 --json title,url 2>/dev/null || echo '[]')
    fi

    # Step 4: Generate intelligent fix prompt
    local fix_prompt
    fix_prompt=$(jq -n \
        --arg bug "$bug_description" \
        --arg type "$bug_type" \
        --arg context "$context" \
        --argjson similar "$similar_fixes" \
        --arg github "$github_solutions" \
        '{
            task: "Fix bug with regression awareness",
            bug_description: $bug,
            bug_type: $type,
            context: $context,
            similar_fixes_from_memory: $similar,
            github_solutions: $github,
            instructions: [
                "1. Review similar fixes from memory to avoid repeating failed approaches",
                "2. Consider GitHub solutions if available",
                "3. Make the fix incrementally",
                "4. Think about potential side effects on other components",
                "5. Run tests after fix to detect regressions"
            ]
        }')

    log "Fix prompt generated with context from memory and GitHub"

    # Return orchestration data for Claude to use
    jq -n \
        --arg bug "$bug_description" \
        --arg before_snapshot_id "$before_snapshot_id" \
        --argjson similar "$similar_fixes" \
        --arg github "$github_solutions" \
        --argjson fix_prompt "$fix_prompt" \
        '{
            bug: $bug,
            before_snapshot: $before_snapshot_id,
            similar_fixes_count: ($similar.count),
            similar_fixes: $similar,
            github_solutions: $github,
            fix_prompt: $fix_prompt,
            next_steps: [
                "1. Review similar fixes and GitHub solutions",
                "2. Apply fix incrementally",
                "3. Run: debug-orchestrator.sh verify-fix <snapshot_id> <test_command>",
                "4. If regression detected, will auto-recommend revert"
            ]
        }'
}

verify_fix() {
    local before_snapshot_id="$1"
    local test_command="$2"
    local fix_description="${3:-Fix applied}"

    log "Verifying fix against snapshot: $before_snapshot_id"

    # Create AFTER snapshot
    local after_snapshot_id="after_$(date +%s)"
    local after_snapshot
    after_snapshot=$(create_test_snapshot "$after_snapshot_id" "$test_command" "After fix")

    local before_snapshot_file="${TEST_SNAPSHOTS}/${before_snapshot_id}.json"

    # Detect regression
    local regression_result
    regression_result=$(detect_regression "$before_snapshot_file" "$after_snapshot")

    local regression_detected
    regression_detected=$(echo "$regression_result" | jq -r '.regression_detected')

    if [[ "$regression_detected" == "true" ]]; then
        log "REGRESSION DETECTED: Fix broke something else!"

        # Return recommendation to revert
        jq -n \
            --arg status "regression_detected" \
            --arg message "Fix introduced a regression - tests passing before, failing after" \
            --argjson regression "$regression_result" \
            '{
                status: $status,
                message: $message,
                regression: $regression,
                recommendation: "REVERT THE FIX",
                actions: [
                    "1. Git revert the changes",
                    "2. Analyze test failures",
                    "3. Try alternative approach using similar_fixes from memory"
                ]
            }'
    else
        log "No regression detected - fix looks good!"

        # Record successful fix to memory
        record_bug_fix "Bug fix verified" "general" "$fix_description" "unknown" "true" "passed"

        jq -n \
            --arg status "success" \
            --arg message "Fix verified - no regressions detected" \
            '{
                status: $status,
                message: $message,
                tests_passed: true,
                recorded_to_memory: true
            }'
    fi
}

# =============================================================================
# UI TESTING WITH CLAUDE IN CHROME
# =============================================================================

ui_test_workflow() {
    local test_scenario="$1"
    local url="$2"
    local expected_outcome="$3"

    log "Starting UI test workflow: $test_scenario"

    # Generate test instructions for Claude in Chrome
    jq -n \
        --arg scenario "$test_scenario" \
        --arg url "$url" \
        --arg expected "$expected_outcome" \
        '{
            ui_test: {
                scenario: $scenario,
                url: $url,
                expected_outcome: $expected,
                instructions: [
                    "1. Use Claude in Chrome MCP to open browser",
                    "2. Navigate to URL",
                    "3. Perform test actions (click, type, etc.)",
                    "4. Take screenshots at each step",
                    "5. Verify expected outcome",
                    "6. Report pass/fail with evidence"
                ],
                tools_needed: [
                    "mcp__claude-in-chrome__tabs_create_mcp",
                    "mcp__claude-in-chrome__navigate",
                    "mcp__claude-in-chrome__computer (for clicks/typing)",
                    "mcp__claude-in-chrome__read_page (verify state)",
                    "mcp__claude-in-chrome__computer (screenshot action)"
                ]
            },
            note: "Claude in Chrome MCP is already installed and available for browser automation"
        }'
}

# =============================================================================
# COMMAND INTERFACE
# =============================================================================

case "${1:-help}" in
    smart-debug)
        smart_debug "${2:-bug description}" "${3:-general}" "${4:-echo 'No tests'}" "${5:-}"
        ;;
    verify-fix)
        verify_fix "${2:-before_snapshot}" "${3:-echo 'No tests'}" "${4:-Fix applied}"
        ;;
    record-fix)
        record_bug_fix "${2:-bug}" "${3:-general}" "${4:-fix}" "${5:-files}" "${6:-true}" "${7:-passed}"
        ;;
    search-similar)
        search_similar_bugs "${2:-search query}" "${3:-5}"
        ;;
    snapshot)
        create_test_snapshot "${2:-snapshot_$(date +%s)}" "${3:-echo 'No tests'}" "${4:-Test snapshot}"
        ;;
    detect-regression)
        detect_regression "${2:-before_snapshot_file}" "${3:-after_snapshot_file}"
        ;;
    ui-test)
        ui_test_workflow "${2:-test scenario}" "${3:-http://localhost:3000}" "${4:-expected outcome}"
        ;;
    memory-stats)
        if [[ -f "$BUG_FIX_MEMORY" ]]; then
            jq -s '{
                total_fixes: length,
                successful_fixes: (map(select(.success == true)) | length),
                recent_fixes: (.[-10:] | map({bug: .bug_description, success: .success, timestamp: .timestamp}))
            }' "$BUG_FIX_MEMORY"
        else
            echo '{"total_fixes":0,"successful_fixes":0,"recent_fixes":[]}'
        fi
        ;;
    help|*)
        cat << 'EOF'
Debug Orchestrator - Intelligent Debugging System

Solves the problem: "Fixing one thing breaks another"

USAGE:
  debug-orchestrator.sh <command> [args]

COMMANDS:
  smart-debug <bug_desc> [bug_type] [test_command] [context]
    - Intelligent debugging with memory and regression awareness
    - Searches similar bugs in memory
    - Searches GitHub for solutions
    - Creates before snapshot for regression detection

  verify-fix <before_snapshot_id> <test_command> [fix_desc]
    - Verifies fix didn't introduce regression
    - Compares before/after test results
    - Auto-recommends revert if regression detected
    - Records successful fixes to memory

  record-fix <bug> <type> <fix> <files> <success> [tests]
    - Manually record a bug fix to memory
    - Builds knowledge base of successful fixes

  search-similar <query> [limit]
    - Search bug fix memory for similar bugs
    - Returns relevant fixes with descriptions

  snapshot <id> <test_command> [description]
    - Create test snapshot for comparison
    - Captures test output and exit code

  ui-test <scenario> <url> <expected_outcome>
    - Generate UI test workflow using Claude in Chrome
    - Automated browser testing

  memory-stats
    - View bug fix memory statistics
    - See recent successful fixes

WORKFLOW EXAMPLE:
  # 1. Start debugging with memory awareness
  debug-orchestrator.sh smart-debug "Login button not working" ui "npm test"

  # 2. Apply fix based on suggestions from similar bugs
  # (make your code changes)

  # 3. Verify fix with regression detection
  debug-orchestrator.sh verify-fix before_1234567 "npm test" "Fixed login handler"

  # If regression detected, will recommend revert
  # If clean, records to memory for future reference

UI TESTING EXAMPLE:
  # Generate UI test workflow
  debug-orchestrator.sh ui-test "User login flow" "http://localhost:3000/login" "Dashboard page loads"

  # Use with Claude in Chrome MCP for automated testing
  # Takes screenshots, verifies state, reports results

KEY FEATURES:
  ✓ Bug fix memory bank (learns from past fixes)
  ✓ Regression detection (catches when fixes break other things)
  ✓ GitHub solution search (finds similar issues online)
  ✓ Self-healing recommendations (auto-suggests revert)
  ✓ UI testing with browser automation (Claude in Chrome)
  ✓ Test snapshots (before/after comparison)

INTEGRATIONS:
  • Memory Manager (stores patterns)
  • GitHub MCP (searches similar issues)
  • Claude in Chrome MCP (browser automation)
  • Reinforcement Learning (learns what works)

EOF
        ;;
esac
