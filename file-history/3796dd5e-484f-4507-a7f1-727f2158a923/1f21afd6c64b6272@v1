#!/bin/bash
# Central Coordinator - Orchestrates all autonomous systems
# The intelligence layer that connects everything

set -uo pipefail

COORD_DIR="${HOME}/.claude/coordination"
COORD_STATE="$COORD_DIR/state.json"
EXECUTION_LOG="$COORD_DIR/execution.log"
LOG_FILE="${HOME}/.claude/coordinator.log"

# All integrated hooks (Phase 1-3 - Existing)
ORCHESTRATOR="${HOME}/.claude/hooks/autonomous-orchestrator-v2.sh"
AGENT_LOOP="${HOME}/.claude/hooks/agent-loop.sh"
LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
FEEDBACK_LOOP="${HOME}/.claude/hooks/feedback-loop.sh"
RISK_PREDICTOR="${HOME}/.claude/hooks/risk-predictor.sh"
PATTERN_MINER="${HOME}/.claude/hooks/pattern-miner.sh"
STRATEGY_SELECTOR="${HOME}/.claude/hooks/strategy-selector.sh"
META_REFLECTION="${HOME}/.claude/hooks/meta-reflection.sh"
HYPOTHESIS_TESTER="${HOME}/.claude/hooks/hypothesis-tester.sh"
CONTEXT_OPTIMIZER="${HOME}/.claude/hooks/context-optimizer.sh"
SELF_HEALING="${HOME}/.claude/hooks/self-healing.sh"
THINKING_FRAMEWORK="${HOME}/.claude/hooks/thinking-framework.sh"
MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
ERROR_HANDLER="${HOME}/.claude/hooks/error-handler.sh"
PLAN_EXECUTE="${HOME}/.claude/hooks/plan-execute.sh"
TASK_QUEUE="${HOME}/.claude/hooks/task-queue.sh"

# New integrated hooks (10 Advanced Features)
REASONING_MODE_SWITCHER="${HOME}/.claude/hooks/reasoning-mode-switcher.sh"
BOUNDED_AUTONOMY="${HOME}/.claude/hooks/bounded-autonomy.sh"
TREE_OF_THOUGHTS="${HOME}/.claude/hooks/tree-of-thoughts.sh"
MULTI_AGENT_ORCHESTRATOR="${HOME}/.claude/hooks/multi-agent-orchestrator.sh"
REACT_REFLEXION="${HOME}/.claude/hooks/react-reflexion.sh"
CONSTITUTIONAL_AI="${HOME}/.claude/hooks/constitutional-ai.sh"
AUTO_EVALUATOR="${HOME}/.claude/hooks/auto-evaluator.sh"
REINFORCEMENT_LEARNING="${HOME}/.claude/hooks/reinforcement-learning.sh"
ENHANCED_AUDIT_TRAIL="${HOME}/.claude/hooks/enhanced-audit-trail.sh"
PARALLEL_EXECUTION_PLANNER="${HOME}/.claude/hooks/parallel-execution-planner.sh"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

init_coordinator() {
    mkdir -p "$COORD_DIR"

    if [[ ! -f "$COORD_STATE" ]]; then
        cat > "$COORD_STATE" << 'EOF'
{
    "status": "idle",
    "currentTask": null,
    "initialized": false,
    "systems": {
        "learning": false,
        "memory": false,
        "agentLoop": false,
        "orchestrator": false
    }
}
EOF
    fi

    # Initialize all systems
    [[ -x "$LEARNING_ENGINE" ]] && "$LEARNING_ENGINE" init > /dev/null 2>&1 && update_system_status "learning" true
    [[ -x "$MEMORY_MANAGER" ]] && "$MEMORY_MANAGER" init > /dev/null 2>&1 && update_system_status "memory" true

    update_coordinator_status "initialized" true
    log "Coordinator initialized"
}

update_system_status() {
    local system="$1"
    local status="$2"

    local temp_file
    temp_file=$(mktemp)

    jq --arg system "$system" --argjson status "$status" \
        '.systems[$system] = $status' "$COORD_STATE" > "$temp_file"
    mv "$temp_file" "$COORD_STATE"
}

update_coordinator_status() {
    local key="$1"
    local value="$2"

    local temp_file
    temp_file=$(mktemp)

    jq --arg key "$key" --arg value "$value" \
        '.[$key] = $value' "$COORD_STATE" > "$temp_file"
    mv "$temp_file" "$COORD_STATE"
}

# =============================================================================
# TASK COORDINATION (MAIN ENTRY POINT)
# =============================================================================

coordinate_task() {
    local task="$1"
    local task_type="${2:-general}"
    local context="${3:-}"

    init_coordinator
    log "Coordinating task: $task (type: $task_type)"

    local start_time
    start_time=$(date +%s)

    # Phase 1: PRE-EXECUTION INTELLIGENCE
    log "Phase 1: Pre-execution analysis"

    # 1.1: State hypothesis
    local hypothesis_id=""
    if [[ -x "$HYPOTHESIS_TESTER" ]]; then
        local hypothesis="Task '$task' will succeed using recommended strategy"
        hypothesis_id=$("$HYPOTHESIS_TESTER" state "$hypothesis" "success" "$task" 2>/dev/null | jq -r '.id' || echo "")
        log "Stated hypothesis: $hypothesis_id"
    fi

    # 1.2: Get strategy recommendation
    local strategy="default"
    local strategy_confidence=0
    if [[ -x "$STRATEGY_SELECTOR" ]]; then
        local strategy_result
        strategy_result=$("$STRATEGY_SELECTOR" select "$task" "$task_type" "$context" 2>/dev/null || echo '{"strategy":"default","confidence":0}')
        strategy=$(echo "$strategy_result" | jq -r '.strategy')
        strategy_confidence=$(echo "$strategy_result" | jq -r '.confidence')
        log "Selected strategy: $strategy (confidence: $strategy_confidence)"
    fi

    # 1.3: Assess risk
    local risk_level="low"
    local risk_score=10
    if [[ -x "$RISK_PREDICTOR" ]]; then
        local risk_result
        risk_result=$("$RISK_PREDICTOR" assess "$task" "$task_type" "" "$context" 2>/dev/null || echo '{"riskLevel":"low","totalRisk":10}')
        risk_level=$(echo "$risk_result" | jq -r '.riskLevel')
        risk_score=$(echo "$risk_result" | jq -r '.totalRisk')
        log "Risk assessment: $risk_level ($risk_score/100)"
    fi

    # 1.4: Mine relevant patterns
    local patterns="[]"
    if [[ -x "$PATTERN_MINER" ]]; then
        patterns=$("$PATTERN_MINER" mine "$task_type" 2>/dev/null || echo '[]')
        local pattern_count
        pattern_count=$(echo "$patterns" | jq 'length')
        log "Found $pattern_count relevant patterns"
    fi

    # 1.5: Start thinking session
    local thinking_id=""
    if [[ -x "$THINKING_FRAMEWORK" ]]; then
        thinking_id=$("$THINKING_FRAMEWORK" start "$task" "$context" 2>/dev/null || echo "")
        [[ -n "$thinking_id" ]] && log "Started thinking session: $thinking_id"
    fi

    # 1.6: Check system health
    if [[ -x "$SELF_HEALING" ]]; then
        local health
        health=$("$SELF_HEALING" health 2>/dev/null || echo "unknown")
        log "System health: $health"

        if [[ "$health" == "unhealthy" ]]; then
            log "System unhealthy, recovering..."
            "$SELF_HEALING" recover 2>/dev/null || true
        fi
    fi

    # Phase 2: EXECUTION WITH MONITORING
    log "Phase 2: Execution"

    update_coordinator_status "status" "executing"
    update_coordinator_status "currentTask" "$task"

    # 2.1: Create execution plan
    local plan_id=""
    if [[ -x "$PLAN_EXECUTE" ]]; then
        plan_id=$("$PLAN_EXECUTE" create "$task" "$context" 2>/dev/null || echo "")
        if [[ -n "$plan_id" ]]; then
            # Decompose and add steps
            "$PLAN_EXECUTE" decompose "$task" "$task_type" 2>/dev/null | while read -r step; do
                [[ -n "$step" ]] && "$PLAN_EXECUTE" add-step "${step#* }" "shell" "" "" > /dev/null 2>&1 || true
            done
            log "Created plan: $plan_id"
        fi
    fi

    # 2.2: Start agent loop
    local agent_id=""
    local execution_result="pending"
    if [[ -x "$AGENT_LOOP" ]]; then
        agent_id=$("$AGENT_LOOP" start "$task" "strategy:$strategy,risk:$risk_level,plan:$plan_id" 2>/dev/null || echo "")
        log "Started agent loop: $agent_id"

        # Monitor execution (in real implementation, this would be event-driven)
        # For now, just record that we started it
        execution_result="started"
    fi

    # Phase 3: POST-EXECUTION LEARNING
    log "Phase 3: Post-execution learning"

    local end_time
    end_time=$(date +%s)
    local duration
    duration=$((end_time - start_time))

    # 3.1: Verify hypothesis
    if [[ -n "$hypothesis_id" && -x "$HYPOTHESIS_TESTER" ]]; then
        "$HYPOTHESIS_TESTER" verify "$hypothesis_id" "$execution_result" "Execution completed" > /dev/null 2>&1 || true
        log "Verified hypothesis: $hypothesis_id"
    fi

    # 3.2: Record outcome to feedback loop
    if [[ -x "$FEEDBACK_LOOP" ]]; then
        "$FEEDBACK_LOOP" record "$task" "$task_type" "$strategy" "$execution_result" "$duration" "" "$context" > /dev/null 2>&1 || true
        log "Recorded feedback"
    fi

    # 3.3: Create meta-reflection
    if [[ -x "$META_REFLECTION" ]]; then
        "$META_REFLECTION" reflect "what_learned" "$task" "$execution_result" "Used $strategy strategy with $risk_level risk" > /dev/null 2>&1 || true
        log "Created meta-reflection"
    fi

    # 3.4: Complete thinking session
    if [[ -n "$thinking_id" && -x "$THINKING_FRAMEWORK" ]]; then
        "$THINKING_FRAMEWORK" complete "Completed: $execution_result" 0.8 > /dev/null 2>&1 || true
        log "Completed thinking session"
    fi

    # 3.5: Complete plan
    if [[ -n "$plan_id" && -x "$PLAN_EXECUTE" ]]; then
        "$PLAN_EXECUTE" finish "$execution_result" "Coordination complete" > /dev/null 2>&1 || true
    fi

    update_coordinator_status "status" "idle"
    update_coordinator_status "currentTask" "null"

    # Return comprehensive result
    jq -n \
        --arg task "$task" \
        --arg strategy "$strategy" \
        --argjson strategyConf "$strategy_confidence" \
        --arg riskLevel "$risk_level" \
        --argjson riskScore "$risk_score" \
        --arg agentId "$agent_id" \
        --arg planId "$plan_id" \
        --arg thinkingId "$thinking_id" \
        --argjson duration "$duration" \
        --arg result "$execution_result" \
        --argjson patternCount "$(echo "$patterns" | jq 'length')" \
        '{
            task: $task,
            execution: {
                agentId: $agentId,
                planId: $planId,
                thinkingId: $thinkingId,
                result: $result,
                duration: $duration
            },
            intelligence: {
                strategy: $strategy,
                strategyConfidence: $strategyConf,
                riskLevel: $riskLevel,
                riskScore: $riskScore,
                patternsFound: $patternCount
            },
            timestamp: (now | todate)
        }'

    log "Coordination complete for: $task (result: $execution_result, duration: ${duration}s)"
}

# =============================================================================
# AUTONOMOUS ORCHESTRATION
# =============================================================================

orchestrate_autonomous() {
    init_coordinator

    log "Starting autonomous orchestration"

    # Get orchestration decisions
    if [[ ! -x "$ORCHESTRATOR" ]]; then
        log "Orchestrator not available"
        echo '{"error":"orchestrator_unavailable"}'
        return 1
    fi

    local orchestration
    orchestration=$("$ORCHESTRATOR" smart 2>/dev/null || echo '{"decisions":[],"actions":[]}')

    log "Orchestration: $(echo "$orchestration" | jq -c '.')"

    # Get actions to execute
    local actions
    actions=$(echo "$orchestration" | jq -r '.actions[]' 2>/dev/null || true)

    if [[ -z "$actions" ]]; then
        log "No actions to execute"
        echo '{"status":"no_actions","orchestration":'"$orchestration"'}'
        return
    fi

    # Execute each action through coordinator
    while IFS= read -r action; do
        [[ -z "$action" ]] && continue

        case "$action" in
            start_task:*)
                local task_id
                task_id=$(echo "$action" | cut -d: -f2)
                local task_name
                task_name=$(echo "$action" | cut -d: -f3-)

                log "Executing action: start_task $task_name"

                # Coordinate the task
                coordinate_task "$task_name" "general" "from buildguide"
                ;;
            *)
                log "Unknown action: $action"
                ;;
        esac
    done <<< "$actions"

    echo '{"status":"completed","orchestration":'"$orchestration"'}'
}

# =============================================================================
# COMMAND INTERFACE
# =============================================================================

case "${1:-help}" in
    init)
        init_coordinator
        ;;
    coordinate)
        coordinate_task "${2:-task}" "${3:-general}" "${4:-}"
        ;;
    orchestrate)
        orchestrate_autonomous
        ;;
    status)
        cat "$COORD_STATE"
        ;;
    help|*)
        echo "Central Coordinator - Intelligence Layer"
        echo ""
        echo "Usage: $0 <command> [args]"
        echo ""
        echo "Commands:"
        echo "  init                                  - Initialize coordinator"
        echo "  coordinate <task> [type] [context]    - Coordinate single task"
        echo "  orchestrate                           - Autonomous orchestration"
        echo "  status                                - Get coordinator status"
        echo ""
        echo "Examples:"
        echo "  $0 coordinate 'implement auth' feature"
        echo "  $0 orchestrate  # Run autonomous orchestration"
        ;;
esac
