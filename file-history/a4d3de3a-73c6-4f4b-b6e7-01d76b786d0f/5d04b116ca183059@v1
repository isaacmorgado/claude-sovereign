/**
 * QE DOM Razor Test Plugin for Premiere Pro UXP
 *
 * This plugin tests whether QE DOM (internal Adobe API) is accessible
 * from UXP plugins, specifically the razor() function.
 */

const { entrypoints } = require("uxp");
const ppro = require("premierepro");

// DOM elements
const output = document.getElementById("output");
const statusIndicator = document.getElementById("statusIndicator");
const statusText = document.getElementById("statusText");

// State
let qeAvailable = false;
let qeSequence = null;

// ============================================================================
// Logging Utilities
// ============================================================================

function log(msg, type = "info") {
  const timestamp = new Date().toLocaleTimeString();
  const prefix = `[${timestamp}] `;

  let className = "";
  switch (type) {
    case "success": className = "success"; break;
    case "error": className = "error"; break;
    case "warning": className = "warning"; break;
    case "info": className = "info"; break;
    case "dim": className = "dim"; break;
  }

  const span = document.createElement("span");
  span.className = className;
  span.textContent = prefix + msg + "\n";
  output.appendChild(span);
  output.scrollTop = output.scrollHeight;

  console.log(`[${type.toUpperCase()}] ${msg}`);
}

function logSection(title) {
  log(`\n${"=".repeat(50)}`, "dim");
  log(title, "info");
  log("=".repeat(50), "dim");
}

function clearLog() {
  output.innerHTML = "";
}

function setStatus(status, text) {
  statusIndicator.className = `status-indicator ${status}`;
  statusText.textContent = text;
}

// ============================================================================
// QE DOM Access Tests
// ============================================================================

async function testQEAccess() {
  clearLog();
  logSection("TESTING QE DOM ACCESS FROM UXP");

  let methodsFound = 0;
  let methodsWorking = 0;

  // -------------------------------------------------------------------------
  // Test 1: Check ppro.app object
  // -------------------------------------------------------------------------
  log("\n[Test 1] Checking ppro.app object...", "info");

  try {
    const app = ppro.app;
    if (app) {
      log("  ppro.app exists", "success");
      log(`  Type: ${typeof app}`, "dim");

      // List available methods
      const methods = Object.keys(app).filter(k => typeof app[k] === "function");
      log(`  Available methods: ${methods.join(", ") || "none visible"}`, "dim");
    } else {
      log("  ppro.app is undefined", "error");
    }
  } catch (e) {
    log(`  Error accessing ppro.app: ${e.message}`, "error");
  }

  // -------------------------------------------------------------------------
  // Test 2: Try enableQE()
  // -------------------------------------------------------------------------
  log("\n[Test 2] Trying ppro.app.enableQE()...", "info");

  try {
    if (typeof ppro.app.enableQE === "function") {
      methodsFound++;
      log("  enableQE() method EXISTS!", "success");

      const result = ppro.app.enableQE();
      log(`  enableQE() returned: ${result}`, "success");
      methodsWorking++;
    } else {
      log("  enableQE() method not found on ppro.app", "warning");

      // Try alternate access patterns
      log("  Trying alternate patterns...", "dim");

      const patterns = [
        () => ppro.enableQE?.(),
        () => ppro.Application?.enableQE?.(),
      ];

      for (const pattern of patterns) {
        try {
          const result = pattern();
          if (result !== undefined) {
            log(`  Alternate pattern worked: ${result}`, "success");
          }
        } catch (e) {
          // Silent fail, try next
        }
      }
    }
  } catch (e) {
    log(`  Error calling enableQE(): ${e.message}`, "error");
  }

  // -------------------------------------------------------------------------
  // Test 3: Check for global 'qe' object
  // -------------------------------------------------------------------------
  log("\n[Test 3] Checking for global 'qe' object...", "info");

  try {
    if (typeof qe !== "undefined") {
      methodsFound++;
      log("  Global 'qe' object EXISTS!", "success");
      log(`  Type: ${typeof qe}`, "dim");

      // Check qe.project
      if (qe.project) {
        log("  qe.project exists", "success");
        methodsWorking++;
        qeAvailable = true;

        // List qe.project methods
        try {
          const projectMethods = Object.keys(qe.project);
          log(`  qe.project methods: ${projectMethods.join(", ") || "enumeration blocked"}`, "dim");
        } catch (e) {
          log("  Cannot enumerate qe.project methods", "dim");
        }
      } else {
        log("  qe.project is undefined", "warning");
      }
    } else {
      log("  Global 'qe' object NOT found", "error");
    }
  } catch (e) {
    log(`  Error: ${e.message}`, "error");
    log("  'qe' is not defined in UXP scope", "warning");
  }

  // -------------------------------------------------------------------------
  // Test 4: Try to get QE sequence
  // -------------------------------------------------------------------------
  log("\n[Test 4] Trying to get QE active sequence...", "info");

  try {
    if (typeof qe !== "undefined" && qe.project) {
      qeSequence = qe.project.getActiveSequence();

      if (qeSequence) {
        methodsFound++;
        methodsWorking++;
        log("  qe.project.getActiveSequence() WORKS!", "success");
        log(`  Sequence name: ${qeSequence.name || "unknown"}`, "dim");

        // Check for CTI (Current Time Indicator)
        if (qeSequence.CTI) {
          log(`  CTI timecode: ${qeSequence.CTI.timecode}`, "success");
        }

        // Check for razor method
        if (typeof qeSequence.razor === "function") {
          log("  qeSequence.razor() method EXISTS!", "success");
          qeAvailable = true;
        } else {
          log("  qeSequence.razor() not found", "warning");
        }
      } else {
        log("  No active sequence (open a sequence first)", "warning");
      }
    } else {
      log("  Skipped - qe.project not available", "dim");
    }
  } catch (e) {
    log(`  Error: ${e.message}`, "error");
  }

  // -------------------------------------------------------------------------
  // Test 5: Try require() patterns
  // -------------------------------------------------------------------------
  log("\n[Test 5] Trying require() patterns...", "info");

  const requirePatterns = [
    "qe",
    "premierepro/qe",
    "ppro/qe",
    "premiere/qe",
    "uxp/qe"
  ];

  for (const pattern of requirePatterns) {
    try {
      const mod = require(pattern);
      log(`  require('${pattern}'): SUCCESS!`, "success");
      log(`  Module type: ${typeof mod}`, "dim");
      methodsFound++;
    } catch (e) {
      log(`  require('${pattern}'): ${e.message.split("\n")[0]}`, "dim");
    }
  }

  // -------------------------------------------------------------------------
  // Summary
  // -------------------------------------------------------------------------
  logSection("SUMMARY");

  if (qeAvailable) {
    setStatus("success", "QE DOM is accessible!");
    log("QE DOM IS ACCESSIBLE FROM UXP!", "success");
    log("You can use qe.project.getActiveSequence().razor()", "success");
    log("\nNext: Click 'Razor All Tracks' to test the actual razor function.", "info");
  } else {
    setStatus("error", "QE DOM not accessible");
    log("QE DOM IS NOT ACCESSIBLE FROM UXP", "error");
    log("You will need to use the manual split workaround.", "warning");
    log(`\nMethods found: ${methodsFound}`, "dim");
    log(`Methods working: ${methodsWorking}`, "dim");
  }
}

// ============================================================================
// Razor Functions
// ============================================================================

async function razorAllTracks() {
  logSection("RAZOR ALL TRACKS");

  try {
    // First check if we have QE access
    if (typeof qe === "undefined") {
      log("QE DOM not available - run 'Test QE DOM Access' first", "error");
      return;
    }

    const qeSeq = qe.project.getActiveSequence();
    if (!qeSeq) {
      log("No active sequence - open a sequence first", "error");
      return;
    }

    const timecode = qeSeq.CTI.timecode;
    log(`Current timecode: ${timecode}`, "info");
    log("Executing razor on all tracks...", "info");

    // THE MAIN EVENT - Try to razor!
    qeSeq.razor(timecode);

    log("RAZOR EXECUTED SUCCESSFULLY!", "success");
    log("Check your timeline - clips should be cut at playhead position", "success");
    setStatus("success", "Razor successful!");

  } catch (e) {
    log(`Razor failed: ${e.message}`, "error");
    log("\nStack trace:", "dim");
    log(e.stack || "No stack trace available", "dim");
    setStatus("error", "Razor failed");
  }
}

async function razorVideoOnly() {
  logSection("RAZOR VIDEO TRACKS ONLY");

  try {
    if (typeof qe === "undefined") {
      log("QE DOM not available", "error");
      return;
    }

    const qeSeq = qe.project.getActiveSequence();
    if (!qeSeq) {
      log("No active sequence", "error");
      return;
    }

    const timecode = qeSeq.CTI.timecode;
    log(`Timecode: ${timecode}`, "info");

    // Get video track count and razor each
    const numVideoTracks = qeSeq.numVideoTracks || 1;
    log(`Video tracks found: ${numVideoTracks}`, "dim");

    for (let i = 0; i < numVideoTracks; i++) {
      try {
        const track = qeSeq.getVideoTrackAt(i);
        if (track && typeof track.razor === "function") {
          track.razor(timecode);
          log(`  Razored video track ${i + 1}`, "success");
        }
      } catch (e) {
        log(`  Track ${i + 1} error: ${e.message}`, "warning");
      }
    }

    log("Video razor complete!", "success");

  } catch (e) {
    log(`Error: ${e.message}`, "error");
  }
}

async function razorAudioOnly() {
  logSection("RAZOR AUDIO TRACKS ONLY");

  try {
    if (typeof qe === "undefined") {
      log("QE DOM not available", "error");
      return;
    }

    const qeSeq = qe.project.getActiveSequence();
    if (!qeSeq) {
      log("No active sequence", "error");
      return;
    }

    const timecode = qeSeq.CTI.timecode;
    log(`Timecode: ${timecode}`, "info");

    const numAudioTracks = qeSeq.numAudioTracks || 1;
    log(`Audio tracks found: ${numAudioTracks}`, "dim");

    for (let i = 0; i < numAudioTracks; i++) {
      try {
        const track = qeSeq.getAudioTrackAt(i);
        if (track && typeof track.razor === "function") {
          track.razor(timecode);
          log(`  Razored audio track ${i + 1}`, "success");
        }
      } catch (e) {
        log(`  Track ${i + 1} error: ${e.message}`, "warning");
      }
    }

    log("Audio razor complete!", "success");

  } catch (e) {
    log(`Error: ${e.message}`, "error");
  }
}

// ============================================================================
// Sequence Info Functions
// ============================================================================

async function getSequenceInfo() {
  logSection("SEQUENCE INFORMATION");

  try {
    // UXP API
    const project = await ppro.Project.getActiveProject();
    if (!project) {
      log("No active project", "error");
      return;
    }

    const sequence = await project.getActiveSequence();
    if (!sequence) {
      log("No active sequence", "error");
      return;
    }

    log("--- UXP API Info ---", "info");
    log(`Name: ${sequence.name}`, "dim");
    log(`ID: ${sequence.id}`, "dim");

    const position = await sequence.getPlayerPosition();
    log(`Playhead: ${position.seconds}s (${position.ticks} ticks)`, "dim");

    // QE API (if available)
    if (typeof qe !== "undefined") {
      log("\n--- QE DOM Info ---", "info");
      const qeSeq = qe.project.getActiveSequence();
      if (qeSeq) {
        log(`QE Name: ${qeSeq.name}`, "dim");
        log(`QE Timecode: ${qeSeq.CTI?.timecode || "N/A"}`, "dim");
        log(`Video tracks: ${qeSeq.numVideoTracks || "N/A"}`, "dim");
        log(`Audio tracks: ${qeSeq.numAudioTracks || "N/A"}`, "dim");
      }
    }

  } catch (e) {
    log(`Error: ${e.message}`, "error");
  }
}

async function listTracks() {
  logSection("TRACK LIST");

  try {
    const project = await ppro.Project.getActiveProject();
    const sequence = await project.getActiveSequence();

    if (!sequence) {
      log("No active sequence", "error");
      return;
    }

    // Video tracks
    log("--- Video Tracks ---", "info");
    const videoTracks = await sequence.getVideoTracks();
    for (let i = 0; i < videoTracks.length; i++) {
      const track = videoTracks[i];
      const items = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      log(`  V${i + 1}: ${track.name || "Unnamed"} (${items.length} clips)`, "dim");
    }

    // Audio tracks
    log("\n--- Audio Tracks ---", "info");
    const audioTracks = await sequence.getAudioTracks();
    for (let i = 0; i < audioTracks.length; i++) {
      const track = audioTracks[i];
      const items = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      log(`  A${i + 1}: ${track.name || "Unnamed"} (${items.length} clips)`, "dim");
    }

  } catch (e) {
    log(`Error: ${e.message}`, "error");
  }
}

// ============================================================================
// Event Listeners
// ============================================================================

document.getElementById("testQE").addEventListener("click", testQEAccess);
document.getElementById("clearOutput").addEventListener("click", clearLog);
document.getElementById("testRazorAll").addEventListener("click", razorAllTracks);
document.getElementById("testRazorVideo").addEventListener("click", razorVideoOnly);
document.getElementById("testRazorAudio").addEventListener("click", razorAudioOnly);
document.getElementById("getSequenceInfo").addEventListener("click", getSequenceInfo);
document.getElementById("listTracks").addEventListener("click", listTracks);

// ============================================================================
// Entry Points Setup
// ============================================================================

entrypoints.setup({
  panels: {
    qeTestPanel: {
      create() {
        console.log("QE Test Panel created");
      },
      show() {
        console.log("QE Test Panel shown");
      },
      hide() {},
      destroy() {}
    }
  },
  commands: {
    razorAtPlayhead: {
      run() {
        razorAllTracks();
      }
    }
  }
});

// Initial log
log("QE DOM Razor Test Plugin loaded", "info");
log("Click 'Test QE DOM Access' to begin testing", "dim");
