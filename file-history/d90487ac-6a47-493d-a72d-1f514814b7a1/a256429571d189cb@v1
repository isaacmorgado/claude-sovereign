/**
 * Caption Exporter Service
 *
 * Exports transcriptions to various caption formats:
 * - SRT (SubRip Subtitle)
 * - VTT (WebVTT)
 * - Plain text
 *
 * Supports word-level and segment-level export with configurable
 * words per caption and maximum duration.
 */

const fs = require('fs');
const path = require('path');

/**
 * Format time for SRT (HH:MM:SS,mmm)
 * @param {number} seconds - Time in seconds
 * @returns {string} Formatted time string
 */
function formatSRTTime(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')},${String(ms).padStart(3, '0')}`;
}

/**
 * Format time for VTT (HH:MM:SS.mmm)
 * @param {number} seconds - Time in seconds
 * @returns {string} Formatted time string
 */
function formatVTTTime(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
}

/**
 * Group words into caption segments
 * @param {Array<{word: string, start: number, end: number}>} words - Word array
 * @param {Object} options - Grouping options
 * @param {number} options.maxWordsPerCaption - Maximum words per caption (default: 8)
 * @param {number} options.maxDuration - Maximum duration per caption in seconds (default: 5)
 * @param {number} options.minGap - Minimum gap to force new caption (default: 1.5)
 * @returns {Array<{text: string, start: number, end: number}>} Grouped captions
 */
function groupWordsIntoCaptions(words, options = {}) {
  const {
    maxWordsPerCaption = 8,
    maxDuration = 5,
    minGap = 1.5
  } = options;

  if (!words || words.length === 0) {
    return [];
  }

  const captions = [];
  let currentCaption = {
    words: [],
    start: words[0].start,
    end: words[0].end
  };

  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    const isFirstWord = currentCaption.words.length === 0;

    // Check if we should start a new caption
    const wouldExceedWordLimit = currentCaption.words.length >= maxWordsPerCaption;
    const wouldExceedDuration = (word.end - currentCaption.start) > maxDuration;
    const hasLargeGap = !isFirstWord && (word.start - currentCaption.end) > minGap;

    if (!isFirstWord && (wouldExceedWordLimit || wouldExceedDuration || hasLargeGap)) {
      // Save current caption
      captions.push({
        text: currentCaption.words.join(' '),
        start: currentCaption.start,
        end: currentCaption.end
      });

      // Start new caption
      currentCaption = {
        words: [word.word],
        start: word.start,
        end: word.end
      };
    } else {
      // Add to current caption
      currentCaption.words.push(word.word);
      currentCaption.end = word.end;
      if (isFirstWord) {
        currentCaption.start = word.start;
      }
    }
  }

  // Add final caption
  if (currentCaption.words.length > 0) {
    captions.push({
      text: currentCaption.words.join(' '),
      start: currentCaption.start,
      end: currentCaption.end
    });
  }

  return captions;
}

/**
 * Convert transcript to SRT format
 * @param {Object} transcript - Transcript with words array
 * @param {Object} options - Export options
 * @returns {string} SRT formatted string
 */
function toSRT(transcript, options = {}) {
  const words = transcript.words || [];

  // If no words, try to use segments
  if (words.length === 0 && transcript.segments) {
    return transcript.segments.map((seg, i) =>
      `${i + 1}\n${formatSRTTime(seg.start)} --> ${formatSRTTime(seg.end)}\n${seg.text.trim()}\n`
    ).join('\n');
  }

  // Group words into captions
  const captions = groupWordsIntoCaptions(words, options);

  return captions.map((cap, i) =>
    `${i + 1}\n${formatSRTTime(cap.start)} --> ${formatSRTTime(cap.end)}\n${cap.text}\n`
  ).join('\n');
}

/**
 * Convert transcript to VTT format
 * @param {Object} transcript - Transcript with words array
 * @param {Object} options - Export options
 * @returns {string} VTT formatted string
 */
function toVTT(transcript, options = {}) {
  const words = transcript.words || [];

  let vtt = 'WEBVTT\n\n';

  // If no words, try to use segments
  if (words.length === 0 && transcript.segments) {
    vtt += transcript.segments.map((seg, i) =>
      `${i + 1}\n${formatVTTTime(seg.start)} --> ${formatVTTTime(seg.end)}\n${seg.text.trim()}\n`
    ).join('\n');
    return vtt;
  }

  // Group words into captions
  const captions = groupWordsIntoCaptions(words, options);

  vtt += captions.map((cap, i) =>
    `${i + 1}\n${formatVTTTime(cap.start)} --> ${formatVTTTime(cap.end)}\n${cap.text}\n`
  ).join('\n');

  return vtt;
}

/**
 * Convert transcript to plain text
 * @param {Object} transcript - Transcript object
 * @param {Object} options - Export options
 * @param {boolean} options.includeTimestamps - Include timestamps (default: false)
 * @returns {string} Plain text
 */
function toPlainText(transcript, options = {}) {
  const { includeTimestamps = false } = options;

  if (includeTimestamps && transcript.words && transcript.words.length > 0) {
    const captions = groupWordsIntoCaptions(transcript.words, options);
    return captions.map(cap =>
      `[${formatVTTTime(cap.start)}] ${cap.text}`
    ).join('\n');
  }

  return transcript.text || '';
}

/**
 * Convert transcript to JSON format (for import into other tools)
 * @param {Object} transcript - Transcript object
 * @returns {string} JSON string
 */
function toJSON(transcript) {
  return JSON.stringify({
    text: transcript.text,
    language: transcript.language,
    duration: transcript.duration,
    words: transcript.words,
    segments: transcript.segments
  }, null, 2);
}

/**
 * Export transcript to file
 * @param {Object} transcript - Transcript object
 * @param {string} outputPath - Output file path
 * @param {string} format - Export format (srt, vtt, txt, json)
 * @param {Object} options - Export options
 * @returns {Promise<{success: boolean, path: string}>}
 */
async function exportToFile(transcript, outputPath, format = 'srt', options = {}) {
  let content;

  switch (format.toLowerCase()) {
    case 'srt':
      content = toSRT(transcript, options);
      break;
    case 'vtt':
    case 'webvtt':
      content = toVTT(transcript, options);
      break;
    case 'txt':
    case 'text':
      content = toPlainText(transcript, options);
      break;
    case 'json':
      content = toJSON(transcript);
      break;
    default:
      throw new Error(`Unsupported format: ${format}. Use srt, vtt, txt, or json.`);
  }

  // Ensure directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  await fs.promises.writeFile(outputPath, content, 'utf8');

  return {
    success: true,
    path: outputPath,
    format,
    size: content.length
  };
}

/**
 * Get supported export formats
 * @returns {Array<{format: string, extension: string, description: string}>}
 */
function getSupportedFormats() {
  return [
    { format: 'srt', extension: '.srt', description: 'SubRip Subtitle - widely supported' },
    { format: 'vtt', extension: '.vtt', description: 'WebVTT - web standard, supports styling' },
    { format: 'txt', extension: '.txt', description: 'Plain text transcript' },
    { format: 'json', extension: '.json', description: 'JSON - for programmatic use' }
  ];
}

module.exports = {
  toSRT,
  toVTT,
  toPlainText,
  toJSON,
  exportToFile,
  getSupportedFormats,
  groupWordsIntoCaptions,
  formatSRTTime,
  formatVTTTime
};
