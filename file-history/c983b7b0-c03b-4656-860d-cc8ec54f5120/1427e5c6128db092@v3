// AI Tools Panel - AI-powered analysis and editing suggestions
import { LitElement, html, css } from 'lit'
import { customElement, property, state } from 'lit/decorators.js'
import type { ClipSelection } from '@/types/plugin'
import type { AnalysisType, AIAnalysisResponse } from '@/types/api'
import { analyzeClip, isAIServiceConfigured } from '@/utils/api/ai-service'
import { canPerformOperation, incrementOperationsUsed } from '@/utils/api/plugin'
import { backendClient, type AudioJob, type User } from '@/utils/api/backend-client'
import { logger } from '@/utils/logger'
import {
  getAudioDuration,
  durationToMinutes,
  formatAudioDuration,
} from '@/utils/helpers/audio-utils'
import './CuttingPanel'
import type { TranscriptionResult } from '@/utils/api/backend-client'

type UploadState = 'idle' | 'uploading' | 'processing' | 'complete' | 'error'
type CloudTool = 'transcription' | 'vocal_isolation'

@customElement('ai-tools-panel')
export class AIToolsPanel extends LitElement {
  static styles = css`
    :host {
      display: block;
    }

    .section {
      margin-bottom: var(--space-lg);
    }

    .section-title {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--text-secondary);
      margin-bottom: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .ai-tools-grid {
      display: grid;
      gap: var(--space-sm);
    }

    .ai-tool-card {
      background: var(--bg-layer-1);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      border: 1px solid transparent;
    }

    .ai-tool-card:hover {
      background: var(--bg-layer-2);
      border-color: var(--border-hover);
    }

    .ai-tool-card.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .ai-tool-card.disabled:hover {
      background: var(--bg-layer-1);
      border-color: transparent;
    }

    .tool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
    }

    .tool-name {
      font-weight: var(--font-weight-medium);
    }

    .tool-badge {
      font-size: var(--font-size-xs);
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      background: var(--color-accent);
      color: white;
    }

    .tool-badge.premium {
      background: linear-gradient(135deg, #ffd700, #ffaa00);
      color: #1a1a1a;
    }

    .tool-description {
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
    }

    .warning-banner {
      background: var(--bg-layer-1);
      border-left: 3px solid var(--color-warning);
      padding: var(--space-md);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-md);
    }

    .warning-banner h4 {
      margin: 0 0 var(--space-xs) 0;
      color: var(--color-warning);
      font-size: var(--font-size-sm);
    }

    .warning-banner p {
      margin: 0;
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
    }

    .results-section {
      background: var(--bg-layer-1);
      border-radius: var(--radius-md);
      padding: var(--space-md);
    }

    .result-item {
      padding: var(--space-sm) 0;
      border-bottom: 1px solid var(--border-default);
    }

    .result-item:last-child {
      border-bottom: none;
    }

    .loading-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: var(--space-xl);
      gap: var(--space-md);
    }

    /* File Upload Styles */
    .upload-zone {
      border: 2px dashed var(--border-default);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      text-align: center;
      cursor: pointer;
      transition: all var(--transition-fast);
      background: var(--bg-layer-1);
    }

    .upload-zone:hover {
      border-color: var(--color-accent);
      background: var(--bg-layer-2);
    }

    .upload-zone.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .upload-zone.disabled:hover {
      border-color: var(--border-default);
      background: var(--bg-layer-1);
    }

    .upload-zone.dragover {
      border-color: var(--color-accent);
      background: var(--bg-layer-2);
    }

    .upload-icon {
      font-size: 2rem;
      margin-bottom: var(--space-sm);
    }

    .upload-text {
      color: var(--text-secondary);
      font-size: var(--font-size-sm);
    }

    .upload-text strong {
      color: var(--color-accent);
    }

    .file-input {
      display: none;
    }

    .selected-file {
      background: var(--bg-layer-1);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      display: flex;
      align-items: center;
      gap: var(--space-md);
      margin-bottom: var(--space-md);
    }

    .file-info {
      flex: 1;
      min-width: 0;
    }

    .file-name {
      font-weight: var(--font-weight-medium);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .file-size {
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
    }

    .remove-file {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: var(--space-xs);
      font-size: 1.2rem;
    }

    .remove-file:hover {
      color: var(--color-negative);
    }

    .cloud-tools-grid {
      display: grid;
      gap: var(--space-sm);
      margin-top: var(--space-md);
    }

    .cloud-tool-btn {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-md);
      background: var(--bg-layer-1);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      color: var(--text-primary);
      font-size: var(--font-size-base);
    }

    .cloud-tool-btn:hover:not(:disabled) {
      background: var(--bg-layer-2);
      border-color: var(--color-accent);
    }

    .cloud-tool-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .cloud-tool-btn .icon {
      font-size: 1.2rem;
    }

    .progress-section {
      background: var(--bg-layer-1);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      margin-top: var(--space-md);
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-sm);
    }

    .progress-status {
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
    }

    .progress-status.error {
      color: var(--color-negative);
    }

    .progress-status.complete {
      color: var(--color-positive);
    }

    .job-result {
      margin-top: var(--space-md);
      padding: var(--space-md);
      background: var(--bg-surface);
      border-radius: var(--radius-sm);
      max-height: 500px;
      overflow-y: auto;
    }

    .job-result pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: var(--font-size-sm);
    }

    .transcription-text {
      margin-bottom: var(--space-md);
      padding-bottom: var(--space-md);
      border-bottom: 1px solid var(--border-default);
    }

    .transcription-text p {
      margin: var(--space-xs) 0 0 0;
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
      max-height: 100px;
      overflow-y: auto;
    }

    .download-links {
      display: flex;
      gap: var(--space-sm);
    }

    .download-btn {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      background: var(--color-accent);
      color: white;
      text-decoration: none;
      border-radius: var(--radius-sm);
      text-align: center;
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      transition: filter 0.2s ease;
    }

    .download-btn:hover {
      filter: brightness(1.1);
    }
  `

  @property({ type: Array }) selectedClips: ClipSelection[] = []
  @property({ type: Number }) remainingOperations = 0
  @property({ type: Boolean }) isPremium = false
  @property({ type: Object }) user: User | null = null

  @state() private isAnalyzing = false
  @state() private analysisResult: AIAnalysisResponse | null = null

  // File upload state
  @state() private selectedFile: File | null = null
  @state() private uploadState: UploadState = 'idle'
  @state() private uploadProgress = 0
  @state() private currentJob: AudioJob | null = null
  @state() private errorMessage = ''
  @state() private isDragOver = false

  private aiTools = [
    {
      id: 'scene-detection' as AnalysisType,
      name: 'Scene Detection',
      description: 'Automatically detect scene changes and suggest cut points',
      premium: false,
    },
    {
      id: 'smart-cut' as AnalysisType,
      name: 'Smart Cut Suggestions',
      description: 'AI-powered suggestions for optimal edit points',
      premium: false,
    },
    {
      id: 'audio-analysis' as AnalysisType,
      name: 'Audio Analysis',
      description: 'Analyze audio for beats, silence, and speech patterns',
      premium: true,
    },
    {
      id: 'content' as AnalysisType,
      name: 'Content Analysis',
      description: 'Deep analysis of clip content and themes',
      premium: true,
    },
  ]

  private async handleToolClick(toolId: AnalysisType, isPremiumTool: boolean): Promise<void> {
    // Check if service is configured
    if (!isAIServiceConfigured()) {
      logger.warn('AI service not configured')
      return
    }

    // Check if clips are selected
    if (this.selectedClips.length === 0) {
      logger.warn('No clips selected for analysis')
      return
    }

    // Check premium requirement
    if (isPremiumTool && !this.isPremium) {
      this.dispatchEvent(new CustomEvent('upgrade-needed', { bubbles: true, composed: true }))
      return
    }

    // Check operation limit for free tier
    if (!this.isPremium && !canPerformOperation()) {
      this.dispatchEvent(new CustomEvent('upgrade-needed', { bubbles: true, composed: true }))
      return
    }

    this.isAnalyzing = true
    this.analysisResult = null

    try {
      // Use first selected clip for analysis
      const clip = this.selectedClips[0]

      const result = await analyzeClip({
        clipData: {
          duration: clip.endTime - clip.startTime,
          frameRate: 24, // Would come from actual project settings
          audioChannels: 2,
          metadata: { name: clip.name },
        },
        analysisType: toolId,
      })

      this.analysisResult = result

      // Decrement operations for free tier
      if (!this.isPremium && result.success) {
        incrementOperationsUsed()
        this.dispatchEvent(new CustomEvent('operation-used', { bubbles: true, composed: true }))
      }
    } catch (error) {
      logger.error('Analysis failed', error)
    } finally {
      this.isAnalyzing = false
    }
  }

  private canUseTool(isPremiumTool: boolean): boolean {
    if (!isAIServiceConfigured()) return false
    if (this.selectedClips.length === 0) return false
    if (isPremiumTool && !this.isPremium) return false
    if (!this.isPremium && !canPerformOperation()) return false
    return true
  }

  // ==================== File Upload Methods ====================

  private handleDragOver(e: DragEvent): void {
    e.preventDefault()
    e.stopPropagation()
    if (!this.user) return
    this.isDragOver = true
  }

  private handleDragLeave(e: DragEvent): void {
    e.preventDefault()
    e.stopPropagation()
    this.isDragOver = false
  }

  private handleDrop(e: DragEvent): void {
    e.preventDefault()
    e.stopPropagation()
    this.isDragOver = false

    if (!this.user) return

    const files = e.dataTransfer?.files
    if (files && files.length > 0) {
      this.handleFileSelect(files[0])
    }
  }

  private handleFileInputChange(e: Event): void {
    const input = e.target as HTMLInputElement
    if (input.files && input.files.length > 0) {
      this.handleFileSelect(input.files[0])
    }
  }

  private handleFileSelect(file: File): void {
    // Validate file type
    const validTypes = [
      'audio/mpeg',
      'audio/mp3',
      'audio/wav',
      'audio/wave',
      'audio/x-wav',
      'audio/aac',
      'audio/ogg',
      'audio/flac',
      'audio/m4a',
      'audio/x-m4a',
      'video/mp4',
      'video/quicktime',
    ]

    if (!validTypes.includes(file.type)) {
      this.errorMessage = 'Invalid file type. Please select an audio or video file.'
      this.uploadState = 'error'
      return
    }

    // Validate file size (500MB max)
    const maxSize = 500 * 1024 * 1024
    if (file.size > maxSize) {
      this.errorMessage = 'File too large. Maximum size is 500MB.'
      this.uploadState = 'error'
      return
    }

    this.selectedFile = file
    this.uploadState = 'idle'
    this.errorMessage = ''
    this.currentJob = null
  }

  private clearSelectedFile(): void {
    this.selectedFile = null
    this.uploadState = 'idle'
    this.errorMessage = ''
    this.currentJob = null

    // Reset file input
    const fileInput = this.shadowRoot?.querySelector('.file-input') as HTMLInputElement
    if (fileInput) {
      fileInput.value = ''
    }
  }

  private async handleCloudTool(tool: CloudTool): Promise<void> {
    if (!this.selectedFile || !this.user) return

    // Extract actual audio duration from file
    let durationSeconds: number
    try {
      this.uploadState = 'uploading'
      this.uploadProgress = 0
      this.errorMessage = ''
      logger.info('Extracting audio duration', { filename: this.selectedFile.name })
      durationSeconds = await getAudioDuration(this.selectedFile)
      logger.info('Audio duration extracted', {
        filename: this.selectedFile.name,
        durationSeconds,
        formatted: formatAudioDuration(durationSeconds),
      })
    } catch (error) {
      logger.warn('Failed to extract audio duration, using estimate', { error })
      // Fallback: estimate from file size (1 min per 10MB)
      durationSeconds = Math.max(60, (this.selectedFile.size / (10 * 1024 * 1024)) * 60)
    }
    const estimatedMinutes = durationToMinutes(durationSeconds)

    // Check if user can submit job
    try {
      const canSubmit = await backendClient.canSubmitAudioJob(estimatedMinutes)
      if (!canSubmit.allowed) {
        this.errorMessage = canSubmit.reason || 'Cannot submit job at this time.'
        this.uploadState = 'error'
        return
      }
    } catch (error) {
      this.errorMessage = error instanceof Error ? error.message : 'Failed to check usage limits.'
      this.uploadState = 'error'
      return
    }

    try {
      // Upload file to S3 with progress tracking
      // Upload progress (0-100) maps to display progress (0-50)
      logger.info('Uploading file to S3', { filename: this.selectedFile.name })
      const uploadResult = await backendClient.uploadFileWithProgress(
        this.selectedFile,
        (progress) => {
          this.uploadProgress = Math.floor(progress / 2)
        }
      )
      this.uploadProgress = 50
      logger.info('File uploaded', { publicUrl: uploadResult.publicUrl })

      // Submit job
      this.uploadState = 'processing'
      logger.info('Submitting job', { tool, audioUrl: uploadResult.publicUrl })

      let job: AudioJob
      if (tool === 'transcription') {
        job = await backendClient.submitTranscription(uploadResult.publicUrl, estimatedMinutes)
      } else {
        job = await backendClient.submitVocalIsolation(uploadResult.publicUrl, estimatedMinutes)
      }

      this.currentJob = job
      logger.info('Job submitted', { jobId: job.id })

      // Poll for completion with real-time progress updates
      const completedJob = await backendClient.pollJobUntilComplete(
        job.id,
        (updatedJob) => {
          this.currentJob = updatedJob
          // Use server-reported progress (scaled: upload=0-50%, processing=50-100%)
          if (updatedJob.status === 'processing') {
            // Scale job progress (0-100) to display progress (50-100)
            this.uploadProgress = 50 + Math.floor(updatedJob.progress / 2)
          }
        },
        { intervalMs: 2000, maxAttempts: 300 }
      )

      this.currentJob = completedJob
      this.uploadState = 'complete'
      this.uploadProgress = 100
      logger.info('Job completed', { jobId: completedJob.id })
    } catch (error) {
      logger.error('Job failed', error)
      this.errorMessage = error instanceof Error ? error.message : 'Job failed.'
      this.uploadState = 'error'
    }
  }

  private formatFileSize(bytes: number): string {
    if (bytes < 1024) return `${bytes} B`
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
  }

  private getStatusText(): string {
    switch (this.uploadState) {
      case 'uploading': {
        // uploadProgress 0-50 maps to upload 0-100%
        const uploadPercent = Math.min(this.uploadProgress * 2, 100)
        return `Uploading file... ${uploadPercent}%`
      }
      case 'processing':
        if (this.currentJob?.status === 'processing') {
          const progress = this.currentJob.progress
          if (progress < 30) return 'Starting...'
          if (progress < 60) return 'Processing audio...'
          if (progress < 90) return 'Analyzing...'
          return 'Finishing up...'
        }
        return 'Queued...'
      case 'complete':
        return 'Complete!'
      case 'error':
        return this.errorMessage || 'Error'
      default:
        return ''
    }
  }

  private isTranscriptionResult(data: unknown): data is TranscriptionResult {
    return (
      typeof data === 'object' &&
      data !== null &&
      'segments' in data &&
      Array.isArray((data as TranscriptionResult).segments)
    )
  }

  private renderJobResult() {
    if (!this.currentJob?.resultData) return null

    // For transcription jobs, show the CuttingPanel
    if (
      this.currentJob.jobType === 'transcription' &&
      this.isTranscriptionResult(this.currentJob.resultData)
    ) {
      return html`
        <div class="job-result">
          <div class="transcription-text">
            <strong>Transcription:</strong>
            <p>${this.currentJob.resultData.text}</p>
          </div>
          <cutting-panel
            .transcriptionResult=${{ segments: this.currentJob.resultData.segments }}
          ></cutting-panel>
        </div>
      `
    }

    // For vocal isolation, show download links
    if (this.currentJob.jobType === 'vocal_isolation') {
      const result = this.currentJob.resultData as { vocalsUrl: string; instrumentalUrl: string }
      return html`
        <div class="job-result">
          <div class="download-links">
            <a href=${result.vocalsUrl} target="_blank" class="download-btn">Download Vocals</a>
            <a href=${result.instrumentalUrl} target="_blank" class="download-btn">
              Download Instrumental
            </a>
          </div>
        </div>
      `
    }

    // Fallback: show raw JSON
    return html`
      <div class="job-result">
        <pre>${JSON.stringify(this.currentJob.resultData, null, 2)}</pre>
      </div>
    `
  }

  private renderUploadSection() {
    const isDisabled = !this.user
    const isBusy = this.uploadState === 'uploading' || this.uploadState === 'processing'

    return html`
      <div class="section">
        <div class="section-title">Cloud Audio Processing</div>

        ${!this.user
          ? html`
              <div class="warning-banner">
                <h4>Sign In Required</h4>
                <p>Please sign in to use cloud audio processing features.</p>
              </div>
            `
          : ''}
        ${this.selectedFile
          ? html`
              <div class="selected-file">
                <div class="file-info">
                  <div class="file-name">${this.selectedFile.name}</div>
                  <div class="file-size">${this.formatFileSize(this.selectedFile.size)}</div>
                </div>
                ${!isBusy
                  ? html`
                      <button
                        class="remove-file"
                        @click=${this.clearSelectedFile}
                        title="Remove file"
                      >
                        ‚úï
                      </button>
                    `
                  : ''}
              </div>
            `
          : html`
              <div
                class="upload-zone ${isDisabled ? 'disabled' : ''} ${this.isDragOver
                  ? 'dragover'
                  : ''}"
                @click=${() =>
                  !isDisabled &&
                  this.shadowRoot?.querySelector<HTMLInputElement>('.file-input')?.click()}
                @dragover=${this.handleDragOver}
                @dragleave=${this.handleDragLeave}
                @drop=${this.handleDrop}
              >
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">
                  <strong>Click to upload</strong> or drag and drop<br />
                  Audio files (MP3, WAV, AAC, M4A) up to 500MB
                </div>
              </div>
              <input
                type="file"
                class="file-input"
                accept="audio/*,video/mp4,video/quicktime"
                @change=${this.handleFileInputChange}
              />
            `}
        ${this.selectedFile && !isBusy && this.uploadState !== 'complete'
          ? html`
              <div class="cloud-tools-grid">
                <button
                  class="cloud-tool-btn"
                  @click=${() => this.handleCloudTool('transcription')}
                  ?disabled=${!this.user}
                >
                  <span class="icon">üé§</span>
                  <span>Transcribe Audio</span>
                </button>
                <button
                  class="cloud-tool-btn"
                  @click=${() => this.handleCloudTool('vocal_isolation')}
                  ?disabled=${!this.user}
                >
                  <span class="icon">üéµ</span>
                  <span>Isolate Vocals</span>
                </button>
              </div>
            `
          : ''}
        ${isBusy || this.uploadState === 'complete' || this.uploadState === 'error'
          ? html`
              <div class="progress-section">
                <div class="progress-header">
                  <span
                    class="progress-status ${this.uploadState === 'error'
                      ? 'error'
                      : this.uploadState === 'complete'
                        ? 'complete'
                        : ''}"
                  >
                    ${this.getStatusText()}
                  </span>
                  ${this.uploadState === 'complete' || this.uploadState === 'error'
                    ? html`
                        <button class="remove-file" @click=${this.clearSelectedFile} title="Clear">
                          ‚úï
                        </button>
                      `
                    : ''}
                </div>
                ${isBusy
                  ? html`
                      <sp-progress-bar
                        value=${this.uploadProgress}
                        label="Progress"
                      ></sp-progress-bar>
                    `
                  : ''}
                ${this.uploadState === 'complete' && this.currentJob?.resultData
                  ? this.renderJobResult()
                  : ''}
              </div>
            `
          : ''}
      </div>
    `
  }

  render() {
    if (this.isAnalyzing) {
      return html`
        <div class="loading-state">
          <sp-progress-circle indeterminate size="l" label="Analyzing clip"></sp-progress-circle>
          <p>Analyzing clip...</p>
        </div>
      `
    }

    return html`
      <!-- Cloud Audio Processing Section -->
      ${this.renderUploadSection()}

      <!-- Local AI Tools Section -->
      ${isAIServiceConfigured()
        ? html`
            ${this.selectedClips.length === 0
              ? html`
                  <div class="warning-banner">
                    <h4>No Clips Selected</h4>
                    <p>
                      Select clips in the Selection tab or Premiere Pro timeline to use local AI
                      tools.
                    </p>
                  </div>
                `
              : ''}

            <div class="section">
              <div class="section-title">Local AI Tools</div>
              <div class="ai-tools-grid">
                ${this.aiTools.map(
                  (tool) => html`
                    <div
                      class="ai-tool-card ${this.canUseTool(tool.premium) ? '' : 'disabled'}"
                      @click=${() =>
                        this.canUseTool(tool.premium) &&
                        this.handleToolClick(tool.id, tool.premium)}
                    >
                      <div class="tool-header">
                        <span class="tool-name">${tool.name}</span>
                        ${tool.premium
                          ? html`<span class="tool-badge premium">PRO</span>`
                          : html`<span class="tool-badge">AI</span>`}
                      </div>
                      <div class="tool-description">${tool.description}</div>
                    </div>
                  `
                )}
              </div>
            </div>

            ${this.analysisResult
              ? html`
                  <div class="section">
                    <div class="section-title">Analysis Results</div>
                    <div class="results-section">
                      ${this.analysisResult.success
                        ? html` <pre>${JSON.stringify(this.analysisResult.result, null, 2)}</pre> `
                        : html`
                            <p style="color: var(--color-negative)">
                              Error: ${this.analysisResult.error?.message}
                            </p>
                          `}
                    </div>
                  </div>
                `
              : ''}
          `
        : ''}
    `
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'ai-tools-panel': AIToolsPanel
  }
}
