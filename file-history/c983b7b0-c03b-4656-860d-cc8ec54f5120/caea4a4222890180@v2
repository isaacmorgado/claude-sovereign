/**
 * Audio utility functions for duration extraction
 */

// Extend Window interface for Safari's webkitAudioContext
declare global {
  interface Window {
    AudioContext?: typeof AudioContext
    webkitAudioContext?: typeof AudioContext
  }
}

/**
 * Extract audio duration from a File using Web Audio API
 * Falls back to WAV header parsing if Web Audio API fails
 */
export async function getAudioDuration(file: File): Promise<number> {
  // Try Web Audio API first (works in most browsers)
  if (typeof AudioContext !== 'undefined' || typeof window?.webkitAudioContext !== 'undefined') {
    try {
      return await getAudioDurationWebAudio(file)
    } catch {
      // Fall through to header parsing
    }
  }

  // Try HTML5 Audio element (simpler approach)
  try {
    return await getAudioDurationHtmlAudio(file)
  } catch {
    // Fall through to header parsing
  }

  // Fallback: parse WAV header for WAV files
  if (file.name.toLowerCase().endsWith('.wav') || file.type === 'audio/wav') {
    try {
      return await getWavDuration(file)
    } catch {
      // Fall through to estimation
    }
  }

  // Last resort: estimate from file size (1 min per 10MB)
  return estimateDurationFromSize(file.size)
}

/**
 * Get duration using Web Audio API (most accurate)
 */
async function getAudioDurationWebAudio(file: File): Promise<number> {
  const AudioContextClass = window.AudioContext ?? window.webkitAudioContext
  if (!AudioContextClass) {
    throw new Error('AudioContext not available')
  }

  const audioContext = new AudioContextClass()
  try {
    const arrayBuffer = await file.arrayBuffer()
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
    return audioBuffer.duration
  } finally {
    await audioContext.close()
  }
}

/**
 * Get duration using HTML5 Audio element
 */
function getAudioDurationHtmlAudio(file: File): Promise<number> {
  return new Promise((resolve, reject) => {
    const audio = new Audio()
    const url = URL.createObjectURL(file)

    const cleanup = () => {
      URL.revokeObjectURL(url)
      audio.removeEventListener('loadedmetadata', onLoad)
      audio.removeEventListener('error', onError)
    }

    const onLoad = () => {
      cleanup()
      if (isFinite(audio.duration) && audio.duration > 0) {
        resolve(audio.duration)
      } else {
        reject(new Error('Invalid duration'))
      }
    }

    const onError = () => {
      cleanup()
      reject(new Error('Failed to load audio'))
    }

    audio.addEventListener('loadedmetadata', onLoad)
    audio.addEventListener('error', onError)
    audio.src = url

    // Timeout after 5 seconds
    setTimeout(() => {
      cleanup()
      reject(new Error('Timeout loading audio'))
    }, 5000)
  })
}

/**
 * Parse WAV file header to extract duration
 * WAV format: RIFF header + fmt chunk + data chunk
 */
async function getWavDuration(file: File): Promise<number> {
  // Read first 44 bytes (standard WAV header size)
  const headerBytes = await file.slice(0, 44).arrayBuffer()
  const view = new DataView(headerBytes)

  // Verify RIFF header
  const riff = String.fromCharCode(
    view.getUint8(0),
    view.getUint8(1),
    view.getUint8(2),
    view.getUint8(3)
  )
  if (riff !== 'RIFF') {
    throw new Error('Not a valid WAV file')
  }

  // Verify WAVE format
  const wave = String.fromCharCode(
    view.getUint8(8),
    view.getUint8(9),
    view.getUint8(10),
    view.getUint8(11)
  )
  if (wave !== 'WAVE') {
    throw new Error('Not a valid WAV file')
  }

  // Read format chunk (starts at byte 12)
  // Byte 22-23: number of channels (little-endian)
  const numChannels = view.getUint16(22, true)
  // Byte 24-27: sample rate (little-endian)
  const sampleRate = view.getUint32(24, true)
  // Byte 34-35: bits per sample (little-endian)
  const bitsPerSample = view.getUint16(34, true)

  // Calculate bytes per sample
  const bytesPerSample = (bitsPerSample / 8) * numChannels

  // Data size is file size minus header (approximate, data chunk starts at 44)
  const dataSize = file.size - 44

  // Duration = data size / (sample rate * bytes per sample)
  const duration = dataSize / (sampleRate * bytesPerSample)

  return duration
}

/**
 * Estimate duration from file size (fallback)
 * Assumes ~10MB per minute for typical compressed audio
 */
function estimateDurationFromSize(fileSize: number): number {
  const bytesPerMinute = 10 * 1024 * 1024 // 10 MB
  return Math.max(60, (fileSize / bytesPerMinute) * 60) // Return seconds, minimum 60s
}

/**
 * Convert duration in seconds to minutes (rounded up)
 */
export function durationToMinutes(durationSeconds: number): number {
  return Math.ceil(durationSeconds / 60)
}

/**
 * Format duration for display
 */
export function formatAudioDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60)
  const secs = Math.floor(seconds % 60)
  return `${mins}:${secs.toString().padStart(2, '0')}`
}
