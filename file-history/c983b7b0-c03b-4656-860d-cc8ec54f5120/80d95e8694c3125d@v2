// Premiere Pro API wrapper

import type {
  PremiereProject,
  PremiereSequence,
  PremiereClip,
  SelectionState,
} from '@/types/premiere'
import type { ClipSelection } from '@/types/plugin'
import { logger } from '../logger'

// Type declarations for UXP Premiere Pro API
declare const app: {
  project: {
    name: string
    path: string
    activeSequence: unknown
    sequences: unknown[]
  }
}

export async function getActiveProject(): Promise<PremiereProject | null> {
  try {
    // Access Premiere Pro's project through UXP API
    const project = app?.project
    if (!project) {
      logger.warn('No active project found')
      return null
    }

    return {
      name: project.name,
      path: project.path,
      sequences: await getSequences(),
      activeSequence: await getActiveSequence(),
    }
  } catch (error) {
    logger.error('Failed to get active project', error)
    return null
  }
}

export async function getActiveSequence(): Promise<PremiereSequence | null> {
  try {
    const sequence = app?.project?.activeSequence
    if (!sequence) {
      logger.debug('No active sequence')
      return null
    }

    // Map the Premiere sequence to our type
    return mapSequence(sequence)
  } catch (error) {
    logger.error('Failed to get active sequence', error)
    return null
  }
}

export async function getSequences(): Promise<PremiereSequence[]> {
  try {
    const sequences = app?.project?.sequences || []
    return sequences.map(mapSequence)
  } catch (error) {
    logger.error('Failed to get sequences', error)
    return []
  }
}

export async function getSelectedClips(): Promise<ClipSelection[]> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return []

    const selectedClips: ClipSelection[] = []

    // Iterate through video tracks
    for (const track of sequence.videoTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'video',
          })
        }
      }
    }

    // Iterate through audio tracks
    for (const track of sequence.audioTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'audio',
          })
        }
      }
    }

    logger.debug('Selected clips retrieved', { count: selectedClips.length })
    return selectedClips
  } catch (error) {
    logger.error('Failed to get selected clips', error)
    return []
  }
}

export async function selectClipsByTimeRange(
  startTime: number,
  endTime: number,
  trackIndices?: number[]
): Promise<boolean> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      logger.warn('No active sequence for selection')
      return false
    }

    // This would use the actual Premiere Pro API to select clips
    // The implementation depends on the specific UXP API available
    logger.info('Selecting clips by time range', { startTime, endTime, trackIndices })

    // Placeholder for actual implementation
    return true
  } catch (error) {
    logger.error('Failed to select clips by time range', error)
    return false
  }
}

export async function selectAllClipsInTrack(
  trackIndex: number,
  trackType: 'video' | 'audio'
): Promise<boolean> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return false

    const tracks = trackType === 'video' ? sequence.videoTracks : sequence.audioTracks
    const track = tracks.find((t) => t.index === trackIndex)

    if (!track) {
      logger.warn('Track not found', { trackIndex, trackType })
      return false
    }

    // Select all clips in the track
    logger.info('Selecting all clips in track', {
      trackIndex,
      trackType,
      clipCount: track.clips.length,
    })
    return true
  } catch (error) {
    logger.error('Failed to select clips in track', error)
    return false
  }
}

export async function getSelectionState(): Promise<SelectionState> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      return { clips: [], markers: [], tracks: [] }
    }

    const selectedClips: PremiereClip[] = []

    for (const track of [...sequence.videoTracks, ...sequence.audioTracks]) {
      selectedClips.push(...track.clips.filter((c) => c.isSelected))
    }

    return {
      clips: selectedClips,
      markers: [], // Would be populated from actual API
      tracks: [],
    }
  } catch (error) {
    logger.error('Failed to get selection state', error)
    return { clips: [], markers: [], tracks: [] }
  }
}

// Helper function to map raw sequence to typed structure
function mapSequence(sequence: unknown): PremiereSequence {
  const seq = sequence as Record<string, unknown>

  return {
    id: String(seq.sequenceID || seq.id || ''),
    name: String(seq.name || 'Untitled'),
    videoTracks: [],
    audioTracks: [],
    duration: Number(seq.end || 0) - Number(seq.start || 0),
    frameRate: {
      numerator: 24000,
      denominator: 1001,
      value: 23.976,
    },
  }
}

// ============================================================================
// Clip Splitting / Cutting API
// ============================================================================

export interface CutResult {
  success: boolean
  originalClipId: string
  newClipId?: string
  cutTime: number
  error?: string
}

export interface ApplyCutsResult {
  success: boolean
  cutsApplied: number
  cutsFailed: number
  results: CutResult[]
}

/**
 * Split a clip at a specific time position.
 * This simulates a "razor cut" by:
 * 1. Adjusting the original clip's out point to the cut time
 * 2. Inserting a new clip from the same source starting at the cut time
 *
 * @param clipId - The ID of the clip to split
 * @param cutTime - The time (in seconds) at which to make the cut
 * @param trackIndex - The track index where the clip resides
 * @param trackType - Whether it's a video or audio track
 */
export async function splitClipAtTime(
  clipId: string,
  cutTime: number,
  trackIndex: number,
  trackType: 'video' | 'audio'
): Promise<CutResult> {
  try {
    const sequence = app?.project?.activeSequence as Record<string, unknown> | undefined
    if (!sequence) {
      return { success: false, originalClipId: clipId, cutTime, error: 'No active sequence' }
    }

    // Get the appropriate track collection
    const tracks = (
      trackType === 'video' ? sequence.videoTracks : sequence.audioTracks
    ) as unknown[]
    if (!tracks || !Array.isArray(tracks)) {
      return { success: false, originalClipId: clipId, cutTime, error: 'Could not access tracks' }
    }

    const track = tracks[trackIndex] as Record<string, unknown> | undefined
    if (!track) {
      return { success: false, originalClipId: clipId, cutTime, error: 'Track not found' }
    }

    // Find the clip in the track
    const clips = track.clips as unknown[]
    if (!clips || !Array.isArray(clips)) {
      return { success: false, originalClipId: clipId, cutTime, error: 'Could not access clips' }
    }

    const clipIndex = clips.findIndex((c) => {
      const clip = c as Record<string, unknown>
      return String(clip.nodeId || clip.id) === clipId
    })

    if (clipIndex === -1) {
      return { success: false, originalClipId: clipId, cutTime, error: 'Clip not found' }
    }

    const clip = clips[clipIndex] as Record<string, unknown>

    // Validate cut time is within clip bounds
    const clipStart = Number(clip.start || 0)
    const clipEnd = Number(clip.end || 0)

    if (cutTime <= clipStart || cutTime >= clipEnd) {
      return {
        success: false,
        originalClipId: clipId,
        cutTime,
        error: 'Cut time is outside clip bounds',
      }
    }

    // Get the project item (source) for this clip
    const projectItem = clip.projectItem as Record<string, unknown> | undefined
    if (!projectItem) {
      return {
        success: false,
        originalClipId: clipId,
        cutTime,
        error: 'Could not get clip source',
      }
    }

    // Calculate the new in/out points
    // Original clip: keep in point, set out point to cut time
    // New clip: in point at cut time (relative to source), out point at original out

    const originalInPoint = Number(clip.inPoint || 0)
    const originalOutPoint = Number(clip.outPoint || 0)
    const cutTimeInSource = originalInPoint + (cutTime - clipStart)

    // Step 1: Adjust original clip's out point
    if (typeof clip.end === 'number') {
      ;(clip as { end: number }).end = cutTime
    }
    if (typeof clip.outPoint === 'number') {
      ;(clip as { outPoint: number }).outPoint = cutTimeInSource
    }

    // Step 2: Insert new clip from same source
    // Use the track's insertClip method if available
    const insertClip = track.insertClip as
      | ((
          projectItem: unknown,
          time: number,
          videoTrackIndex: number,
          audioTrackIndex: number
        ) => unknown)
      | undefined

    let newClipId: string | undefined

    if (typeof insertClip === 'function') {
      const newClip = insertClip.call(
        track,
        projectItem,
        cutTime,
        trackType === 'video' ? trackIndex : -1,
        trackType === 'audio' ? trackIndex : -1
      ) as Record<string, unknown> | undefined

      if (newClip) {
        // Set the new clip's in point to match where we cut
        if (typeof newClip.inPoint === 'number') {
          ;(newClip as { inPoint: number }).inPoint = cutTimeInSource
        }
        if (typeof newClip.outPoint === 'number') {
          ;(newClip as { outPoint: number }).outPoint = originalOutPoint
        }
        newClipId = String(newClip.nodeId || newClip.id || '')
      }
    } else {
      // Fallback: Try using sequence.insertClip or other API methods
      logger.warn('Track insertClip method not available, trying alternative')

      // Alternative approach using overwriteClip if available
      const overwriteClip = sequence.overwriteClip as
        | ((projectItem: unknown, time: number) => unknown)
        | undefined

      if (typeof overwriteClip === 'function') {
        const newClip = overwriteClip.call(sequence, projectItem, cutTime) as
          | Record<string, unknown>
          | undefined
        if (newClip) {
          newClipId = String(newClip.nodeId || newClip.id || '')
        }
      }
    }

    logger.info('Clip split completed', {
      originalClipId: clipId,
      newClipId,
      cutTime,
      trackIndex,
      trackType,
    })

    return {
      success: true,
      originalClipId: clipId,
      newClipId,
      cutTime,
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    logger.error('Failed to split clip', { clipId, cutTime, error: errorMessage })
    return {
      success: false,
      originalClipId: clipId,
      cutTime,
      error: errorMessage,
    }
  }
}

/**
 * Apply multiple cuts to a clip at specified time positions.
 * Cuts are applied in reverse order (from end to start) to avoid
 * invalidating cut positions.
 *
 * @param clipId - The ID of the clip to cut
 * @param cutTimes - Array of times (in seconds) at which to make cuts
 * @param trackIndex - The track index where the clip resides
 * @param trackType - Whether it's a video or audio track
 */
export async function applyCutsToClip(
  clipId: string,
  cutTimes: number[],
  trackIndex: number,
  trackType: 'video' | 'audio'
): Promise<ApplyCutsResult> {
  // Sort cut times in descending order (apply from end to start)
  const sortedCutTimes = [...cutTimes].sort((a, b) => b - a)

  const results: CutResult[] = []

  for (const cutTime of sortedCutTimes) {
    // Since we cut from end to start, the original clip ID remains valid
    const result = await splitClipAtTime(clipId, cutTime, trackIndex, trackType)
    results.push(result)

    // If successful and we're cutting from end to start,
    // the original clip ID stays the same for the next cut
  }

  const cutsApplied = results.filter((r) => r.success).length
  const cutsFailed = results.filter((r) => !r.success).length

  logger.info('Applied cuts to clip', {
    clipId,
    totalCuts: cutTimes.length,
    cutsApplied,
    cutsFailed,
  })

  return {
    success: cutsFailed === 0,
    cutsApplied,
    cutsFailed,
    results,
  }
}

/**
 * Apply silence-based cuts to selected clips.
 * Uses transcription segments to detect silence gaps and cut at those points.
 */
export async function applySilenceCutsToSelection(cutTimes: number[]): Promise<ApplyCutsResult[]> {
  const selectedClips = await getSelectedClips()

  if (selectedClips.length === 0) {
    logger.warn('No clips selected for silence cutting')
    return []
  }

  const allResults: ApplyCutsResult[] = []

  for (const clip of selectedClips) {
    // Filter cut times to only those within this clip's bounds
    const clipCutTimes = cutTimes.filter((t) => t > clip.startTime && t < clip.endTime)

    if (clipCutTimes.length === 0) {
      continue
    }

    const result = await applyCutsToClip(clip.id, clipCutTimes, clip.trackIndex, clip.type)
    allResults.push(result)
  }

  return allResults
}
