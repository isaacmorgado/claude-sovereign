// Premiere Pro API wrapper

import type {
  PremiereProject,
  PremiereSequence,
  PremiereClip,
  SelectionState,
  TimelineMarker,
  MarkerColor,
} from '@/types/premiere'
import type { ClipSelection } from '@/types/plugin'
import { logger } from '../logger'

// Type declarations for UXP Premiere Pro API
declare const app: {
  project: {
    name: string
    path: string
    activeSequence: unknown
    sequences: unknown[]
  }
}

export async function getActiveProject(): Promise<PremiereProject | null> {
  try {
    // Access Premiere Pro's project through UXP API
    const project = app?.project
    if (!project) {
      logger.warn('No active project found')
      return null
    }

    return {
      name: project.name,
      path: project.path,
      sequences: await getSequences(),
      activeSequence: await getActiveSequence(),
    }
  } catch (error) {
    logger.error('Failed to get active project', error)
    return null
  }
}

export async function getActiveSequence(): Promise<PremiereSequence | null> {
  try {
    const sequence = app?.project?.activeSequence
    if (!sequence) {
      logger.debug('No active sequence')
      return null
    }

    // Map the Premiere sequence to our type
    return mapSequence(sequence)
  } catch (error) {
    logger.error('Failed to get active sequence', error)
    return null
  }
}

export async function getSequences(): Promise<PremiereSequence[]> {
  try {
    const sequences = app?.project?.sequences || []
    return sequences.map(mapSequence)
  } catch (error) {
    logger.error('Failed to get sequences', error)
    return []
  }
}

export async function getSelectedClips(): Promise<ClipSelection[]> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return []

    const selectedClips: ClipSelection[] = []

    // Iterate through video tracks
    for (const track of sequence.videoTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'video',
          })
        }
      }
    }

    // Iterate through audio tracks
    for (const track of sequence.audioTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'audio',
          })
        }
      }
    }

    logger.debug('Selected clips retrieved', { count: selectedClips.length })
    return selectedClips
  } catch (error) {
    logger.error('Failed to get selected clips', error)
    return []
  }
}

export async function selectClipsByTimeRange(
  startTime: number,
  endTime: number,
  trackIndices?: number[]
): Promise<boolean> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      logger.warn('No active sequence for selection')
      return false
    }

    // This would use the actual Premiere Pro API to select clips
    // The implementation depends on the specific UXP API available
    logger.info('Selecting clips by time range', { startTime, endTime, trackIndices })

    // Placeholder for actual implementation
    return true
  } catch (error) {
    logger.error('Failed to select clips by time range', error)
    return false
  }
}

export async function selectAllClipsInTrack(
  trackIndex: number,
  trackType: 'video' | 'audio'
): Promise<boolean> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return false

    const tracks = trackType === 'video' ? sequence.videoTracks : sequence.audioTracks
    const track = tracks.find((t) => t.index === trackIndex)

    if (!track) {
      logger.warn('Track not found', { trackIndex, trackType })
      return false
    }

    // Select all clips in the track
    logger.info('Selecting all clips in track', {
      trackIndex,
      trackType,
      clipCount: track.clips.length,
    })
    return true
  } catch (error) {
    logger.error('Failed to select clips in track', error)
    return false
  }
}

export async function getSelectionState(): Promise<SelectionState> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      return { clips: [], markers: [], tracks: [] }
    }

    const selectedClips: PremiereClip[] = []

    for (const track of [...sequence.videoTracks, ...sequence.audioTracks]) {
      selectedClips.push(...track.clips.filter((c) => c.isSelected))
    }

    return {
      clips: selectedClips,
      markers: [], // Would be populated from actual API
      tracks: [],
    }
  } catch (error) {
    logger.error('Failed to get selection state', error)
    return { clips: [], markers: [], tracks: [] }
  }
}

// Helper function to map raw sequence to typed structure
function mapSequence(sequence: unknown): PremiereSequence {
  const seq = sequence as Record<string, unknown>

  return {
    id: String(seq.sequenceID || seq.id || ''),
    name: String(seq.name || 'Untitled'),
    videoTracks: [],
    audioTracks: [],
    duration: Number(seq.end || 0) - Number(seq.start || 0),
    frameRate: {
      numerator: 24000,
      denominator: 1001,
      value: 23.976,
    },
  }
}
