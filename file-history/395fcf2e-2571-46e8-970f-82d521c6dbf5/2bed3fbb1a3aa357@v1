/**
 * Custom Presets E2E Tests
 *
 * Tests for Phase 1: Custom Presets Foundation
 * Each feature is tested individually then together.
 */

// Simulate localStorage for Node.js testing
const localStorageData = {};
global.localStorage = {
  getItem: (key) => localStorageData[key] || null,
  setItem: (key, value) => { localStorageData[key] = value; },
  removeItem: (key) => { delete localStorageData[key]; },
  clear: () => { Object.keys(localStorageData).forEach(k => delete localStorageData[k]); }
};

// Mock console.warn to avoid noise
const originalWarn = console.warn;
console.warn = () => {};

// =============================================================================
// COPY OF FUNCTIONS FROM settings.js (for testing without UXP)
// =============================================================================

const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';

const DEFAULT_CUSTOM_PRESETS = {
  version: 1,
  presets: {},
  order: []
};

function loadCustomPresets() {
  try {
    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
        return {
          ...DEFAULT_CUSTOM_PRESETS,
          ...parsed,
          presets: parsed.presets || {},
          order: parsed.order || []
        };
      }
    }
  } catch (e) {
    // Silently handle parse errors
  }
  return { ...DEFAULT_CUSTOM_PRESETS };
}

function saveCustomPresets(data) {
  try {
    if (!data || typeof data !== 'object') {
      return false;
    }
    const toSave = {
      version: data.version || DEFAULT_CUSTOM_PRESETS.version,
      presets: data.presets || {},
      order: data.order || []
    };
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    return true;
  } catch (e) {
    return false;
  }
}

// =============================================================================
// TEST UTILITIES
// =============================================================================

let testsPassed = 0;
let testsFailed = 0;
const startTime = Date.now();

function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function assertEqual(actual, expected, message) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(`${message}\n  Expected: ${JSON.stringify(expected)}\n  Actual: ${JSON.stringify(actual)}`);
  }
}

async function runTest(name, testFn) {
  const testStart = Date.now();
  try {
    // Clear localStorage before each test
    localStorage.clear();

    await testFn();
    const elapsed = Date.now() - testStart;
    console.log(`  âœ“ ${name} (${elapsed}ms)`);
    testsPassed++;

    // Check for performance bottleneck
    if (elapsed > 5) {
      console.log(`    âš  Performance warning: ${elapsed}ms > 5ms threshold`);
    }
  } catch (err) {
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    testsFailed++;
  }
}

// =============================================================================
// FEATURE 1.1 TESTS: localStorage Schema
// =============================================================================

async function testFeature1_1() {
  console.log('\nðŸ“¦ Feature 1.1: localStorage Schema');
  console.log('=' .repeat(50));

  // Test 1: Load returns default when empty
  await runTest('loadCustomPresets returns default when empty', async () => {
    const result = loadCustomPresets();
    assertEqual(result.version, 1, 'Version should be 1');
    assertEqual(result.presets, {}, 'Presets should be empty object');
    assertEqual(result.order, [], 'Order should be empty array');
  });

  // Test 2: Save and load round-trip
  await runTest('Save and load round-trip works', async () => {
    const testData = {
      version: 1,
      presets: {
        'test-preset': {
          id: 'test-preset',
          name: 'Test Preset',
          settings: { sensitivity: 50 }
        }
      },
      order: ['test-preset']
    };

    const saveResult = saveCustomPresets(testData);
    assert(saveResult === true, 'Save should return true');

    const loaded = loadCustomPresets();
    assertEqual(loaded.version, 1, 'Version should match');
    assertEqual(loaded.order, ['test-preset'], 'Order should match');
    assertEqual(loaded.presets['test-preset'].name, 'Test Preset', 'Preset name should match');
  });

  // Test 3: Handle corrupt data gracefully
  await runTest('Handle corrupt JSON gracefully', async () => {
    localStorage.setItem(CUSTOM_PRESETS_KEY, 'not valid json{{{');
    const result = loadCustomPresets();
    assertEqual(result.version, 1, 'Should return default version');
    assertEqual(result.presets, {}, 'Should return empty presets');
  });

  // Test 4: Handle invalid structure gracefully
  await runTest('Handle invalid structure gracefully', async () => {
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify({ foo: 'bar' }));
    const result = loadCustomPresets();
    assertEqual(result.version, 1, 'Should return default version');
    assertEqual(result.presets, {}, 'Should return empty presets');
  });

  // Test 5: Save rejects invalid data
  await runTest('Save rejects null/undefined data', async () => {
    const result1 = saveCustomPresets(null);
    assert(result1 === false, 'Should return false for null');

    const result2 = saveCustomPresets(undefined);
    assert(result2 === false, 'Should return false for undefined');

    const result3 = saveCustomPresets('string');
    assert(result3 === false, 'Should return false for string');
  });

  // Test 6: Multiple save/load cycles
  await runTest('Multiple save/load cycles work correctly', async () => {
    for (let i = 0; i < 100; i++) {
      const data = {
        version: 1,
        presets: { [`preset-${i}`]: { id: `preset-${i}`, name: `Preset ${i}` } },
        order: [`preset-${i}`]
      };
      saveCustomPresets(data);
    }

    const final = loadCustomPresets();
    assertEqual(final.order, ['preset-99'], 'Should have last preset');
  });

  // Test 7: Preserves version when saving
  await runTest('Preserves version field', async () => {
    const data = {
      version: 1,
      presets: {},
      order: []
    };
    saveCustomPresets(data);
    const loaded = loadCustomPresets();
    assertEqual(loaded.version, 1, 'Version should be preserved');
  });
}

// =============================================================================
// MAIN TEST RUNNER
// =============================================================================

async function runAllTests() {
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ§ª Custom Presets E2E Tests - Phase 1');
  console.log('='.repeat(60));

  await testFeature1_1();

  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ“Š Test Summary');
  console.log('='.repeat(60));
  console.log(`  Total: ${testsPassed + testsFailed}`);
  console.log(`  Passed: ${testsPassed}`);
  console.log(`  Failed: ${testsFailed}`);
  console.log(`  Duration: ${Date.now() - startTime}ms`);

  if (testsFailed > 0) {
    console.log('\nâŒ Some tests failed!');
    process.exit(1);
  } else {
    console.log('\nâœ… All tests passed!');
    process.exit(0);
  }
}

// Restore console.warn at the end
process.on('exit', () => {
  console.warn = originalWarn;
});

runAllTests().catch(err => {
  console.error('Test runner error:', err);
  process.exit(1);
});
