/**
 * Slice 6: Backend Integration
 *
 * Calls the backend API to analyze audio and detect takes.
 * Manages take data and UI rendering.
 */

// Store takes data for applying to timeline
let currentTakes = null;

/**
 * Render the takes list with click handlers
 */
function renderTakes() {
  const takesEl = document.getElementById('takes');
  const applyBtn = document.getElementById('applyTakesBtn');
  const labelBtn = document.getElementById('labelTimelineBtn');

  if (!currentTakes || currentTakes.length === 0) {
    takesEl.innerHTML = '<div class="no-clips">No takes detected</div>';
    applyBtn.style.display = 'none';
    labelBtn.style.display = 'none';
    return;
  }

  takesEl.innerHTML = currentTakes.map((take, i) => {
    const isBest = take.isBest ? ' best' : '';
    const star = take.isBest ? '★' : '☆';
    return `
      <div class="take-item${isBest}" data-index="${i}">
        <div class="take-header">
          <div class="take-label">Take ${take.takeNumber}</div>
          <span class="take-star">${star}</span>
        </div>
        <div class="take-time">${formatTime(take.start)} - ${formatTime(take.end)}</div>
        <div class="take-text">${take.description}</div>
      </div>
    `;
  }).join('');

  // Add click handlers to toggle best
  takesEl.querySelectorAll('.take-item').forEach(el => {
    el.addEventListener('click', () => {
      const index = parseInt(el.dataset.index);
      toggleBestTake(index);
    });
  });

  // Show buttons
  const hasBestTake = currentTakes.some(t => t.isBest);
  applyBtn.style.display = hasBestTake ? 'block' : 'none';
  labelBtn.style.display = 'block';
}

/**
 * Toggle best take selection
 * @param {number} index - Index of the take to toggle
 */
function toggleBestTake(index) {
  if (!currentTakes || index < 0 || index >= currentTakes.length) return;

  // Toggle the selected take
  currentTakes[index].isBest = !currentTakes[index].isBest;

  // Re-render the takes list
  renderTakes();

  // Update status
  const bestCount = currentTakes.filter(t => t.isBest).length;
  setStatus(`${bestCount} take(s) marked as best`);
}

/**
 * Get current takes data (for use by other slices)
 * @returns {Array|null} Current takes array
 */
function getCurrentTakes() {
  return currentTakes;
}

/**
 * Initialize the Analyze Audio button
 */
function initAnalyzer() {
  document.getElementById('analyzeBtn').addEventListener('click', async () => {
    const btn = document.getElementById('analyzeBtn');
    const resultsSection = document.getElementById('resultsSection');
    const transcriptEl = document.getElementById('transcript');

    btn.disabled = true;
    setStatus('Analyzing audio...');
    resultsSection.style.display = 'none';

    try {
      const response = await fetch(`${BACKEND_URL}/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ wavPath: WAV_PATH })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || 'Analysis failed');
      }

      // Display transcript
      transcriptEl.textContent = data.transcript.text || 'No transcript available';

      // Store takes and render
      if (data.takes && data.takes.takes && data.takes.takes.length > 0) {
        currentTakes = data.takes.takes;
      } else {
        currentTakes = null;
      }
      renderTakes();

      resultsSection.style.display = 'block';
      showSilenceSection(); // Slice 8: Show silence detection UI
      const takeCount = currentTakes ? currentTakes.length : 0;
      const bestCount = currentTakes ? currentTakes.filter(t => t.isBest).length : 0;
      setStatus(`Analysis complete: ${takeCount} take(s) found, ${bestCount} marked as best`);

    } catch (err) {
      setStatus(`Analysis error: ${err.message}`);
      console.error('SPLICE analysis error:', err);
    }

    btn.disabled = false;
  });
}
