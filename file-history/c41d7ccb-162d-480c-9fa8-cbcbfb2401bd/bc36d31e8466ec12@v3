# Claude Code Autonomous System

## Mode Control

By default, Claude runs in **normal interactive mode**. Use `/auto` to activate autonomous mode.

### Commands
| Command | Description |
|---------|-------------|
| `/auto` | Start fully autonomous mode |
| `/auto stop` | Stop autonomous mode |
| `/auto status` | Check current mode |

### Autonomous Mode (when active)
When `/auto` is running:
- Executes without asking for confirmation
- **Auto-checkpoints at 40% context** (via auto-continue hook → runs /checkpoint → compacts)
- **Auto-checkpoints after 10 file changes** (via file-change-tracker → post-edit-quality hook)
- **Auto-fixes errors** with retry strategy (error-handler classifies errors, suggests backoff)
- **Auto-revises code** that violates safety principles (Constitutional AI with max 2 revisions)
- **Auto-lints and typechecks** after every file edit (post-edit-quality hook)
- **Auto-runs UI tests** after React component changes (ui-test-framework integration)
- **Validates commands** before execution (validation-gate blocks dangerous operations)
- **Detects regressions** with before/after snapshots (debug-orchestrator integration)
- **Plans and prioritizes tasks** (thinking-framework + plan-execute + task-queue)
- **Routes to specialist agents** (6 specialists: code_writer, test_engineer, security_auditor, etc.)
- **Selects reasoning mode** (reflexive/deliberate/reactive based on task complexity/urgency/risk)
- **Analyzes parallelization** opportunities (parallel-execution-planner)
- Uses **mcp__grep__searchGitHub** for code examples and solutions
- Uses **GitHub MCP** tools when needed
- Continues until complete or blocked
- Follows Ken's Prompting Guide (short prompts, reference docs)

**All 21 features are now ACTIVE and wired** (as of 2026-01-12)

### Normal Mode (default)
- Works interactively with user
- Asks for confirmation on major actions
- Waits for user instructions

---

## Available Capabilities

### Memory System (`~/.claude/hooks/memory-manager.sh`)
Persistent memory across sessions with 3-factor retrieval scoring.

```bash
# Working memory (current session)
memory-manager.sh set-task "task" "context"
memory-manager.sh add-context "note" 8
memory-manager.sh get-working

# Episodic memory (past experiences)
memory-manager.sh record task_complete "description" success "details"
memory-manager.sh search-episodes "query"

# Semantic memory (facts & patterns)
memory-manager.sh add-fact category key "value" 0.9
memory-manager.sh add-pattern error_fix "trigger" "solution"
memory-manager.sh remember-scored "query"  # 3-factor scoring

# Project-scoped memory (auto-detected)
memory-manager.sh scope  # Shows current memory location
```

### Skill Commands
- `/re [type] [target]` - Reverse engineering (Chrome extensions, Electron apps, APIs)
- `/research-api [target]` - API reverse engineering
- `/build [feature]` - Autonomous feature builder
- `/chrome` - Browser automation
- `/checkpoint` - Save session state
- `/collect` - Research collection
- `/validate` - Validation checks
- `/rootcause` - Root cause analysis

### Automation Hooks (All Active and Wired)

**Core Execution Flow**:
- `coordinator.sh` - Central orchestrator (ReAct+Reflexion, Constitutional AI, Multi-agent routing)
- `agent-loop.sh` - Autonomous execution loop with integrated:
  - `thinking-framework.sh` - Chain-of-thought reasoning at startup
  - `plan-execute.sh` - Task decomposition and planning
  - `task-queue.sh` - Task prioritization
  - `validation-gate.sh` - Safety checks before execution (blocks dangerous commands)
  - `error-handler.sh` - Error classification and retry strategy with:
    - `debug-orchestrator.sh` - Regression detection (smart-debug + verify-fix)

**Context and Quality Management**:
- `auto-continue.sh` - Auto-checkpoint at 40% context + compact
- `post-edit-quality.sh` - After every file edit:
  - Auto-linting and typechecking
  - `file-change-tracker.sh` - Checkpoint trigger every 10 files
  - `ui-test-framework.sh` - UI test execution after component changes

**Intelligence and Optimization**:
- `reasoning-mode-switcher.sh` - Select reflexive/deliberate/reactive modes
- `parallel-execution-planner.sh` - Analyze parallelization opportunities
- `multi-agent-orchestrator.sh` - Route to specialist agents
- `tree-of-thoughts.sh` - Multi-path exploration (deliberate mode only)
- `constitutional-ai.sh` - Safety validation with auto-revision
- `self-healing.sh` - Health checks and recovery

### RE Toolkit
- `~/.claude/docs/re-prompts.md` - Copy-paste prompts for RE tasks
- `~/.claude/docs/reverse-engineering-toolkit.md` - Professional toolkit
- `~/.claude/docs/frida-scripts.md` - Mobile RE scripts

## Usage Patterns

### Starting a Task
```bash
# Set working context
memory-manager.sh set-task "Implement feature X" "Context about the task"

# Start agent loop (if needed)
agent-loop.sh start "goal" "context"
```

### Recording Progress
```bash
# After completing something
memory-manager.sh record task_complete "What was done" success "Details"

# After fixing an error
memory-manager.sh record error_fixed "Error description" success "How it was fixed"

# Learning a pattern
memory-manager.sh add-pattern error_fix "When you see X" "Do Y"
```

### Retrieving Context
```bash
# Search all memory with scoring
memory-manager.sh remember-scored "relevant query"

# Get current working context
memory-manager.sh get-working
```

## Session Notes
<!-- Auto-updated by pre-compact hook -->
