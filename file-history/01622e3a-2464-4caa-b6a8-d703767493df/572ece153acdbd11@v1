/**
 * Phase 0 E2E Tests: Core Infrastructure
 * Tests R2 Storage, Music Queue, and Database Schema
 */

const assert = require('assert');
const fs = require('fs');
const path = require('path');

// Test counters
let passed = 0;
let failed = 0;
const failures = [];

function test(name, fn) {
  try {
    fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    failures.push({ name, error: error.message });
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

// ============================================
// R2 STORAGE SERVICE TESTS
// ============================================
console.log('\n=== R2 Storage Service Tests ===\n');

const r2StoragePath = path.join(__dirname, '../services/r2Storage.js');
const r2StorageCode = fs.readFileSync(r2StoragePath, 'utf8');

test('r2Storage.js exists and is readable', () => {
  assert(fs.existsSync(r2StoragePath), 'r2Storage.js should exist');
  assert(r2StorageCode.length > 0, 'r2Storage.js should have content');
});

test('r2Storage exports generateStorageKey function', () => {
  assert(r2StorageCode.includes('function generateStorageKey'), 'Should export generateStorageKey');
  assert(r2StorageCode.includes('module.exports'), 'Should have module.exports');
  assert(r2StorageCode.includes('generateStorageKey'), 'generateStorageKey should be in exports');
});

test('r2Storage exports uploadMusic function', () => {
  assert(r2StorageCode.includes('async function uploadMusic'), 'Should have uploadMusic function');
  assert(r2StorageCode.includes("'uploadMusic'") || r2StorageCode.includes('uploadMusic'), 'uploadMusic should be exported');
});

test('r2Storage exports getSignedDownloadUrl function', () => {
  assert(r2StorageCode.includes('async function getSignedDownloadUrl'), 'Should have getSignedDownloadUrl function');
});

test('r2Storage exports deleteMusic function', () => {
  assert(r2StorageCode.includes('async function deleteMusic'), 'Should have deleteMusic function');
});

test('r2Storage exports deleteJobFiles function', () => {
  assert(r2StorageCode.includes('async function deleteJobFiles'), 'Should have deleteJobFiles function');
});

test('r2Storage exports fileExists function', () => {
  assert(r2StorageCode.includes('async function fileExists'), 'Should have fileExists function');
});

test('r2Storage uses AWS SDK v3', () => {
  assert(r2StorageCode.includes("require('@aws-sdk/client-s3')"), 'Should use @aws-sdk/client-s3');
  assert(r2StorageCode.includes("require('@aws-sdk/s3-request-presigner')"), 'Should use s3-request-presigner');
});

test('r2Storage validates environment variables', () => {
  assert(r2StorageCode.includes('R2_ACCOUNT_ID'), 'Should check R2_ACCOUNT_ID');
  assert(r2StorageCode.includes('R2_ACCESS_KEY_ID'), 'Should check R2_ACCESS_KEY_ID');
  assert(r2StorageCode.includes('R2_SECRET_ACCESS_KEY'), 'Should check R2_SECRET_ACCESS_KEY');
  assert(r2StorageCode.includes('R2_BUCKET_NAME'), 'Should check R2_BUCKET_NAME');
});

test('r2Storage sanitizes storage keys', () => {
  assert(r2StorageCode.includes('replace(/[^a-zA-Z0-9_-]/g'), 'Should sanitize customer ID');
  assert(r2StorageCode.includes('safeCustomerId'), 'Should use safe customer ID');
  assert(r2StorageCode.includes('safeJobId'), 'Should use safe job ID');
});

test('r2Storage handles content types', () => {
  assert(r2StorageCode.includes("'audio/wav'"), 'Should handle WAV content type');
  assert(r2StorageCode.includes("'audio/mpeg'"), 'Should handle MP3 content type');
  assert(r2StorageCode.includes("'application/json'"), 'Should handle JSON content type');
});

test('r2Storage has lazy initialization', () => {
  assert(r2StorageCode.includes('let s3Client = null'), 'Should have lazy s3Client');
  assert(r2StorageCode.includes('function getS3Client'), 'Should have getS3Client function');
});

// ============================================
// MUSIC QUEUE SERVICE TESTS
// ============================================
console.log('\n=== Music Queue Service Tests ===\n');

const musicQueuePath = path.join(__dirname, '../services/musicQueue.js');
const musicQueueCode = fs.readFileSync(musicQueuePath, 'utf8');

test('musicQueue.js exists and is readable', () => {
  assert(fs.existsSync(musicQueuePath), 'musicQueue.js should exist');
  assert(musicQueueCode.length > 0, 'musicQueue.js should have content');
});

test('musicQueue uses BullMQ', () => {
  assert(musicQueueCode.includes("require('bullmq')"), 'Should import BullMQ');
  assert(musicQueueCode.includes('Queue'), 'Should use Queue');
  // Note: Worker and UnrecoverableError are imported in musicWorker.js, not musicQueue.js
  // musicQueue.js only needs Queue for job submission
});

test('musicQueue defines JOB_STATUS constants', () => {
  assert(musicQueueCode.includes('JOB_STATUS'), 'Should have JOB_STATUS');
  assert(musicQueueCode.includes('PENDING'), 'Should have PENDING status');
  assert(musicQueueCode.includes('EXTRACTING'), 'Should have EXTRACTING status');
  assert(musicQueueCode.includes('IDENTIFYING'), 'Should have IDENTIFYING status');
  assert(musicQueueCode.includes('GENERATING'), 'Should have GENERATING status');
  assert(musicQueueCode.includes('UPLOADING'), 'Should have UPLOADING status');
  assert(musicQueueCode.includes('COMPLETED'), 'Should have COMPLETED status');
  assert(musicQueueCode.includes('FAILED'), 'Should have FAILED status');
});

test('musicQueue defines PROGRESS_MAP', () => {
  assert(musicQueueCode.includes('PROGRESS_MAP'), 'Should have PROGRESS_MAP');
});

test('musicQueue exports addMusicJob function', () => {
  assert(musicQueueCode.includes('async function addMusicJob'), 'Should have addMusicJob function');
});

test('musicQueue exports getJobStatus function', () => {
  assert(musicQueueCode.includes('async function getJobStatus'), 'Should have getJobStatus function');
});

test('musicQueue exports getCustomerJobs function', () => {
  assert(musicQueueCode.includes('async function getCustomerJobs'), 'Should have getCustomerJobs function');
});

test('musicQueue exports cancelJob function', () => {
  assert(musicQueueCode.includes('async function cancelJob'), 'Should have cancelJob function');
});

test('musicQueue exports retryJob function', () => {
  assert(musicQueueCode.includes('async function retryJob'), 'Should have retryJob function');
});

test('musicQueue exports getQueueStats function', () => {
  assert(musicQueueCode.includes('async function getQueueStats'), 'Should have getQueueStats function');
});

test('musicQueue exports closeQueue function', () => {
  assert(musicQueueCode.includes('async function closeQueue'), 'Should have closeQueue function');
});

test('musicQueue generates unique job IDs', () => {
  assert(musicQueueCode.includes('function generateJobId'), 'Should have generateJobId function');
  assert(musicQueueCode.includes('`music_'), 'Job IDs should start with music_');
});

test('musicQueue configures retry with exponential backoff', () => {
  assert(musicQueueCode.includes('attempts: 3'), 'Should have 3 attempts');
  assert(musicQueueCode.includes('exponential'), 'Should use exponential backoff');
  assert(musicQueueCode.includes('delay: 5000'), 'Should have 5s initial delay');
});

test('musicQueue configures job cleanup', () => {
  assert(musicQueueCode.includes('removeOnComplete'), 'Should have removeOnComplete');
  assert(musicQueueCode.includes('removeOnFail'), 'Should have removeOnFail');
});

test('musicQueue validates customerId', () => {
  assert(musicQueueCode.includes("'customerId is required'"), 'Should validate customerId');
});

test('musicQueue clamps duration to 30-180 seconds', () => {
  assert(musicQueueCode.includes('Math.min(Math.max'), 'Should clamp duration');
  assert(musicQueueCode.includes('30'), 'Should have minimum duration');
  assert(musicQueueCode.includes('180'), 'Should have maximum duration');
});

test('musicQueue uses Upstash Redis URL', () => {
  assert(musicQueueCode.includes('UPSTASH_REDIS_URL'), 'Should use UPSTASH_REDIS_URL');
});

test('musicQueue has maxRetriesPerRequest: null for workers', () => {
  assert(musicQueueCode.includes('maxRetriesPerRequest: null'), 'Should have maxRetriesPerRequest: null');
});

// ============================================
// MUSIC WORKER TESTS
// ============================================
console.log('\n=== Music Worker Tests ===\n');

const musicWorkerPath = path.join(__dirname, '../workers/musicWorker.js');
const musicWorkerCode = fs.readFileSync(musicWorkerPath, 'utf8');

test('musicWorker.js exists and is readable', () => {
  assert(fs.existsSync(musicWorkerPath), 'musicWorker.js should exist');
  assert(musicWorkerCode.length > 0, 'musicWorker.js should have content');
});

test('musicWorker imports from musicQueue', () => {
  assert(musicWorkerCode.includes("require('../services/musicQueue')"), 'Should import musicQueue');
  assert(musicWorkerCode.includes('getRedisConnection'), 'Should use getRedisConnection');
  assert(musicWorkerCode.includes('JOB_STATUS'), 'Should use JOB_STATUS');
  assert(musicWorkerCode.includes('PROGRESS_MAP'), 'Should use PROGRESS_MAP');
});

test('musicWorker exports createMusicWorker function', () => {
  assert(musicWorkerCode.includes('function createMusicWorker'), 'Should have createMusicWorker');
});

test('musicWorker exports shutdownWorker function', () => {
  assert(musicWorkerCode.includes('async function shutdownWorker'), 'Should have shutdownWorker');
});

test('musicWorker exports processJob function', () => {
  assert(musicWorkerCode.includes('async function processJob'), 'Should have processJob');
});

test('musicWorker exports buildGenerationPrompt function', () => {
  assert(musicWorkerCode.includes('function buildGenerationPrompt'), 'Should have buildGenerationPrompt');
});

test('musicWorker exports isUnrecoverableError function', () => {
  assert(musicWorkerCode.includes('function isUnrecoverableError'), 'Should have isUnrecoverableError');
});

test('musicWorker handles all job steps', () => {
  assert(musicWorkerCode.includes('EXTRACTING'), 'Should handle EXTRACTING step');
  assert(musicWorkerCode.includes('IDENTIFYING'), 'Should handle IDENTIFYING step');
  assert(musicWorkerCode.includes('GENERATING'), 'Should handle GENERATING step');
  assert(musicWorkerCode.includes('UPLOADING'), 'Should handle UPLOADING step');
  assert(musicWorkerCode.includes('COMPLETED'), 'Should handle COMPLETED step');
});

test('musicWorker uses UnrecoverableError for permanent failures', () => {
  assert(musicWorkerCode.includes('UnrecoverableError'), 'Should use UnrecoverableError');
  assert(musicWorkerCode.includes('isUnrecoverableError'), 'Should check isUnrecoverableError');
});

test('musicWorker identifies unrecoverable errors correctly', () => {
  assert(musicWorkerCode.includes('quota exceeded'), 'Should identify quota exceeded');
  assert(musicWorkerCode.includes('invalid api key'), 'Should identify invalid api key');
  assert(musicWorkerCode.includes('authentication failed'), 'Should identify authentication failed');
  assert(musicWorkerCode.includes('insufficient credits'), 'Should identify insufficient credits');
});

test('musicWorker updates job progress', () => {
  assert(musicWorkerCode.includes('job.updateProgress'), 'Should update job progress');
});

test('musicWorker updates job data for resumption', () => {
  assert(musicWorkerCode.includes('job.updateData'), 'Should update job data');
});

test('musicWorker logs job progress', () => {
  assert(musicWorkerCode.includes("console.log(`[Job"), 'Should log job progress');
});

test('musicWorker has event handlers', () => {
  assert(musicWorkerCode.includes("worker.on('completed'"), 'Should handle completed event');
  assert(musicWorkerCode.includes("worker.on('failed'"), 'Should handle failed event');
  assert(musicWorkerCode.includes("worker.on('progress'"), 'Should handle progress event');
  assert(musicWorkerCode.includes("worker.on('error'"), 'Should handle error event');
  assert(musicWorkerCode.includes("worker.on('stalled'"), 'Should handle stalled event');
});

test('musicWorker handles graceful shutdown', () => {
  assert(musicWorkerCode.includes('SIGTERM'), 'Should handle SIGTERM');
  assert(musicWorkerCode.includes('SIGINT'), 'Should handle SIGINT');
  assert(musicWorkerCode.includes('worker.close'), 'Should close worker');
});

test('musicWorker can run standalone', () => {
  assert(musicWorkerCode.includes('require.main === module'), 'Should check if run directly');
});

test('musicWorker builds generation prompt correctly', () => {
  assert(musicWorkerCode.includes('referenceSong.title'), 'Should include reference song title');
  assert(musicWorkerCode.includes('referenceSong.artist'), 'Should include reference artist');
  assert(musicWorkerCode.includes('referenceSong.bpm'), 'Should include BPM');
  assert(musicWorkerCode.includes('referenceSong.key'), 'Should include key');
  assert(musicWorkerCode.includes('Instrumental only'), 'Should specify instrumental');
});

test('musicWorker has configurable concurrency', () => {
  assert(musicWorkerCode.includes('options.concurrency'), 'Should accept concurrency option');
  assert(musicWorkerCode.includes('|| 3'), 'Should default to 3 concurrent jobs');
});

// ============================================
// DATABASE MIGRATION TESTS
// ============================================
console.log('\n=== Database Migration Tests ===\n');

const migrationPath = path.join(__dirname, '../migrations/001_music_generation.sql');
const migrationCode = fs.readFileSync(migrationPath, 'utf8');

test('migration file exists and is readable', () => {
  assert(fs.existsSync(migrationPath), 'Migration should exist');
  assert(migrationCode.length > 0, 'Migration should have content');
});

test('migration creates generated_music table', () => {
  assert(migrationCode.includes('CREATE TABLE IF NOT EXISTS generated_music'), 'Should create generated_music table');
});

test('migration has all required columns', () => {
  const requiredColumns = [
    'id SERIAL PRIMARY KEY',
    'user_id INTEGER',
    'stripe_customer_id VARCHAR',
    'job_id VARCHAR',
    'status VARCHAR',
    'reference_song_title',
    'reference_artist',
    'reference_youtube_url',
    'reference_bpm',
    'reference_key',
    'reference_mood',
    'prompt TEXT',
    'duration_seconds INTEGER',
    'instruments TEXT[]',
    'mood VARCHAR',
    'mureka_task_id',
    'r2_key VARCHAR',
    'r2_preview_key',
    'file_size_bytes',
    'audio_duration_seconds',
    'title VARCHAR',
    'created_at TIMESTAMP',
    'completed_at TIMESTAMP',
    'error_message TEXT'
  ];

  requiredColumns.forEach(col => {
    const colName = col.split(' ')[0];
    assert(migrationCode.includes(colName), `Should have column: ${colName}`);
  });
});

test('migration has valid_status constraint', () => {
  assert(migrationCode.includes('CONSTRAINT valid_status CHECK'), 'Should have status constraint');
  assert(migrationCode.includes("'pending'"), 'Should allow pending status');
  assert(migrationCode.includes("'completed'"), 'Should allow completed status');
  assert(migrationCode.includes("'failed'"), 'Should allow failed status');
});

test('migration has valid_duration constraint', () => {
  assert(migrationCode.includes('CONSTRAINT valid_duration CHECK'), 'Should have duration constraint');
  assert(migrationCode.includes('>= 30'), 'Should have minimum duration');
  assert(migrationCode.includes('<= 180'), 'Should have maximum duration');
});

test('migration creates required indexes', () => {
  assert(migrationCode.includes('idx_generated_music_customer'), 'Should have customer index');
  assert(migrationCode.includes('idx_generated_music_job_id'), 'Should have job_id index');
  assert(migrationCode.includes('idx_generated_music_status'), 'Should have status index');
  assert(migrationCode.includes('idx_generated_music_created_at'), 'Should have created_at index');
  assert(migrationCode.includes('idx_generated_music_user_id'), 'Should have user_id index');
});

test('migration adds music credits to users table', () => {
  assert(migrationCode.includes('ALTER TABLE users'), 'Should alter users table');
  assert(migrationCode.includes('music_credits_remaining'), 'Should add music_credits_remaining');
  assert(migrationCode.includes('music_credits_total'), 'Should add music_credits_total');
  assert(migrationCode.includes('music_credits_reset_at'), 'Should add music_credits_reset_at');
});

test('migration creates get_music_credits function', () => {
  assert(migrationCode.includes('CREATE OR REPLACE FUNCTION get_music_credits'), 'Should create get_music_credits function');
});

test('migration creates deduct_music_credit function', () => {
  assert(migrationCode.includes('CREATE OR REPLACE FUNCTION deduct_music_credit'), 'Should create deduct_music_credit function');
  assert(migrationCode.includes('FOR UPDATE'), 'Should lock row for update');
});

test('migration creates reset_music_credits function', () => {
  assert(migrationCode.includes('CREATE OR REPLACE FUNCTION reset_music_credits'), 'Should create reset_music_credits function');
  assert(migrationCode.includes("'starter'"), 'Should handle starter tier');
  assert(migrationCode.includes("'pro'"), 'Should handle pro tier');
  assert(migrationCode.includes("'team'"), 'Should handle team tier');
});

test('migration creates add_music_credits function', () => {
  assert(migrationCode.includes('CREATE OR REPLACE FUNCTION add_music_credits'), 'Should create add_music_credits function');
});

test('migration has library index for completed music', () => {
  assert(migrationCode.includes('idx_generated_music_library'), 'Should have library index');
  assert(migrationCode.includes("status = 'completed'"), 'Should filter by completed status');
});

test('migration has table comments', () => {
  assert(migrationCode.includes('COMMENT ON TABLE'), 'Should have table comments');
  assert(migrationCode.includes('COMMENT ON COLUMN'), 'Should have column comments');
});

// ============================================
// INTEGRATION TESTS
// ============================================
console.log('\n=== Integration Tests ===\n');

test('r2Storage and musicQueue are compatible', () => {
  // Verify r2Storage uses same key format expected by musicQueue
  assert(r2StorageCode.includes('customerId'), 'r2Storage should use customerId');
  assert(r2StorageCode.includes('jobId'), 'r2Storage should use jobId');
  assert(musicQueueCode.includes('customerId'), 'musicQueue should use customerId');
});

test('musicWorker uses correct imports from both services', () => {
  assert(musicWorkerCode.includes("require('../services/r2Storage')"), 'Should import r2Storage');
  assert(musicWorkerCode.includes("require('../services/musicQueue')"), 'Should import musicQueue');
});

test('all files use consistent job ID format', () => {
  // Job ID format: music_{timestamp}_{random}
  assert(musicQueueCode.includes('`music_'), 'musicQueue should use music_ prefix');
});

test('worker concurrency matches queue configuration', () => {
  // Both should allow configuration
  assert(musicQueueCode.includes('defaultJobOptions'), 'Queue should have job options');
  assert(musicWorkerCode.includes('concurrency'), 'Worker should have concurrency');
});

// ============================================
// UI WIRING TESTS (Preparation for Phase 3)
// ============================================
console.log('\n=== UI Wiring Preparation Tests ===\n');

test('musicQueue exports are suitable for API endpoints', () => {
  // Check that returned data structures are JSON-serializable
  assert(musicQueueCode.includes('jobId'), 'Should return jobId');
  assert(musicQueueCode.includes('status'), 'Should return status');
  assert(musicQueueCode.includes('progress'), 'Should return progress');
  assert(musicQueueCode.includes('createdAt'), 'Should return createdAt');
});

test('r2Storage returns signed URLs for frontend', () => {
  assert(r2StorageCode.includes('getSignedDownloadUrl'), 'Should provide download URLs');
  assert(r2StorageCode.includes('expiresIn'), 'Should have URL expiration');
});

// ============================================
// SUMMARY
// ============================================
console.log('\n========================================');
console.log(`Phase 0 E2E Tests: ${passed} passed, ${failed} failed`);
console.log('========================================\n');

if (failures.length > 0) {
  console.log('Failures:');
  failures.forEach(f => {
    console.log(`  - ${f.name}: ${f.error}`);
  });
  console.log('');
}

// Exit with appropriate code
process.exit(failed > 0 ? 1 : 0);
