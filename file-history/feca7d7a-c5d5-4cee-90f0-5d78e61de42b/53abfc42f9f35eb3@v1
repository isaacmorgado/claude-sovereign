"""
Rate limiting configuration for the LOOKSMAXX API.

Uses slowapi with Redis backend when available, falls back to in-memory storage.
"""

import os
import logging

from fastapi import Request
from slowapi import Limiter
from slowapi.util import get_remote_address

logger = logging.getLogger(__name__)


def get_user_identifier(request: Request) -> str:
    """
    Get rate limit key based on authenticated user or IP address.

    For authenticated users, uses user ID for more accurate per-user limiting.
    For anonymous users, falls back to IP address.
    """
    # Check if user is authenticated (set by auth middleware/dependency)
    if hasattr(request.state, "user") and request.state.user:
        return f"user:{request.state.user.id}"

    # Check authorization header for JWT token presence
    auth_header = request.headers.get("authorization", "")
    if auth_header.startswith("Bearer "):
        # Token exists but user not loaded yet - use token hash as key
        # This handles cases where rate limit runs before auth dependency
        token = auth_header[7:]
        # Use first 16 chars of token as identifier (enough for uniqueness)
        return f"token:{token[:16]}"

    # Fall back to IP address for anonymous users
    return get_remote_address(request)


def create_limiter() -> Limiter:
    """
    Create a rate limiter with Redis backend if available, otherwise in-memory.

    Redis URL is read from REDIS_URL environment variable.
    """
    redis_url = os.environ.get("REDIS_URL")

    if redis_url:
        try:
            # Use Redis backend for distributed rate limiting
            from slowapi.middleware import SlowAPIMiddleware

            limiter = Limiter(
                key_func=get_user_identifier,
                storage_uri=redis_url,
                strategy="fixed-window",  # More predictable than moving-window
            )
            logger.info("[RATE_LIMIT] Using Redis backend for rate limiting")
            return limiter
        except Exception as e:
            logger.warning(f"[RATE_LIMIT] Failed to connect to Redis: {e}, falling back to in-memory")

    # Fall back to in-memory storage (single-instance only)
    limiter = Limiter(
        key_func=get_user_identifier,
        strategy="fixed-window",
    )
    logger.info("[RATE_LIMIT] Using in-memory backend for rate limiting")
    return limiter


# Create global limiter instance
limiter = create_limiter()


# Rate limit constants for forum endpoints
class ForumRateLimits:
    """Rate limits for forum operations."""

    # Posts: 5 per minute per user
    POSTS = "5/minute"

    # Comments: 20 per minute per user
    COMMENTS = "20/minute"

    # Votes: 30 per minute per user
    VOTES = "30/minute"

    # Reports: 10 per hour per user (to prevent spam reports)
    REPORTS = "10/hour"

    # Read operations: Higher limits for browsing
    READ = "60/minute"

    # Moderation: Reasonable limit for mod actions
    MODERATION = "30/minute"
