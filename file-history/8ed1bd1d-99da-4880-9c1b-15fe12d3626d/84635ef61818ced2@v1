/**
 * SPLICE CEP Music Module
 * AI-powered music generation for video projects
 */

// ============================================
// STATE
// ============================================
const musicState = {
  jobs: [],
  selectedJob: null,
  isIdentifying: false,
  isGenerating: false,
  identifiedSong: null,
  audioPlayer: null,
  pollInterval: null,
  currentPollingJobId: null,  // Track which job we're polling to prevent race conditions
  variationsJob: null,
  variationsPollingInterval: null,
  variationsAbortController: null,  // FIX: CEP-CRIT-003 - AbortController for variations polling
  currentVariationsJobId: null,  // Track which variations job we're polling
  selectedVariationIndex: null,
  variationPlayers: [null, null, null],
  sceneAwareEnabled: false,
  isAligning: false,
  alignmentOptions: null,
  beatAnalysis: null,
  isGeneratingTimeline: false,
  timelineOptions: null,
  // FIX: CEP-CRIT-006 - AbortControllers for network request cancellation
  identifyAbortController: null,
  generateAbortController: null,
  // FIX: CEP-CRIT-007 - Prevent duplicate event listener registration
  listenersInitialized: false
};

// ============================================
// CONSTANTS
// ============================================
const MUSIC_POLL_INTERVAL = 5000;

const MOOD_OPTIONS = [
  { id: 'energetic', name: 'Energetic', description: 'Upbeat, high energy' },
  { id: 'relaxed', name: 'Relaxed', description: 'Calm, peaceful' },
  { id: 'melancholic', name: 'Melancholic', description: 'Sad, emotional' },
  { id: 'intense', name: 'Intense', description: 'Powerful, dramatic' },
  { id: 'happy', name: 'Happy', description: 'Joyful, cheerful' },
  { id: 'mysterious', name: 'Mysterious', description: 'Dark, suspenseful' },
  { id: 'romantic', name: 'Romantic', description: 'Warm, intimate' },
  { id: 'epic', name: 'Epic', description: 'Grand, orchestral' },
  { id: 'chill', name: 'Chill', description: 'Lo-fi, laid-back' },
  { id: 'neutral', name: 'Neutral', description: 'Balanced, versatile' }
];

const INSTRUMENT_OPTIONS = [
  { id: 'acoustic', name: 'Acoustic', description: 'Guitar, piano, strings' },
  { id: 'electronic', name: 'Electronic', description: 'Synths, beats' },
  { id: 'rock', name: 'Rock', description: 'Electric guitars, drums' },
  { id: 'orchestral', name: 'Orchestral', description: 'Strings, brass, woodwinds' },
  { id: 'minimal', name: 'Minimal', description: 'Piano, ambient' },
  { id: 'hiphop', name: 'Hip-Hop', description: '808s, trap drums' }
];

const DURATION_OPTIONS = [
  { value: 30, label: '30 seconds' },
  { value: 60, label: '1 minute' },
  { value: 90, label: '1.5 minutes' },
  { value: 120, label: '2 minutes' },
  { value: 180, label: '3 minutes' }
];

// ============================================
// DOM ELEMENT CACHE
// ============================================
const musicElements = {
  section: null,
  panel: null,
  status: null,
  creditsBadge: null,
  youtubeUrl: null,
  identifyBtn: null,
  referenceDisplay: null,
  moodSelector: null,
  instrumentSelector: null,
  durationSlider: null,
  durationValue: null,
  promptInput: null,
  generateBtn: null,
  variationsCheckbox: null,
  sceneAwareToggle: null,
  timelineBtn: null,
  jobsList: null,
  library: null,
  variationsPanel: null,
  variationsList: null,
  progressContainer: null,
  progressBar: null,
  progressText: null,
  tabGenerate: null,
  tabIdentify: null,
  tabLibrary: null
};

// ============================================
// AUDIO PLAYER DISPOSAL
// ============================================

/**
 * FIX: CEP-CRIT-004 - Music Audio Disposal
 * Properly dispose of Audio objects to prevent memory leaks
 * Audio objects hold memory for decoded audio data and event listeners
 * After 100 previews @ ~20MB each = 2GB memory leak
 */
function disposeAudioPlayers() {
  musicState.variationPlayers.forEach((player, index) => {
    if (player) {
      // Pause playback
      player.pause();

      // Remove all event listeners by cloning and replacing
      // (Audio objects don't expose removeAllListeners)
      const clone = player.cloneNode();
      player.parentNode?.replaceChild(clone, player);

      // Clear source to release decoded audio buffer
      player.src = '';
      player.srcObject = null;

      // Force garbage collection of audio data
      player.load();

      // Null the reference
      musicState.variationPlayers[index] = null;
    }
  });
}

function cacheMusicElements() {
  musicElements.section = document.getElementById('musicSection');
  musicElements.panel = document.getElementById('music-panel');
  musicElements.status = document.getElementById('music-status');
  musicElements.creditsBadge = document.getElementById('music-credits-badge');
  musicElements.youtubeUrl = document.getElementById('music-youtube-url');
  musicElements.identifyBtn = document.getElementById('music-identify-btn');
  musicElements.referenceDisplay = document.getElementById('music-identify-result');
  musicElements.moodSelector = document.getElementById('music-mood-selector');
  musicElements.instrumentSelector = document.getElementById('music-instrument-selector');
  musicElements.durationSlider = document.getElementById('music-duration-slider');
  musicElements.durationValue = document.getElementById('music-duration-value');
  musicElements.promptInput = document.getElementById('music-custom-prompt');
  musicElements.generateBtn = document.getElementById('music-generate-btn');
  musicElements.variationsCheckbox = document.getElementById('music-variations');
  musicElements.sceneAwareToggle = document.getElementById('music-scene-aware');
  musicElements.timelineBtn = document.getElementById('music-timeline-btn');
  musicElements.jobsList = document.getElementById('music-jobs-list');
  musicElements.library = document.getElementById('music-library-list');
  musicElements.variationsPanel = document.getElementById('music-variations-panel');
  musicElements.variationsList = document.getElementById('music-variations-list');
  musicElements.progressContainer = document.getElementById('music-progress');
  musicElements.progressBar = document.getElementById('music-progress-bar');
  musicElements.progressText = document.getElementById('music-progress-text');

  // Tab elements
  musicElements.tabGenerate = document.getElementById('music-tab-generate');
  musicElements.tabIdentify = document.getElementById('music-tab-identify');
  musicElements.tabLibrary = document.getElementById('music-tab-library');
}

// ============================================
// API FUNCTIONS
// ============================================

async function identifySong(youtubeUrl) {
  // FIX: CEP-CRIT-006 - Abort previous identify request if still pending
  if (musicState.identifyAbortController) {
    musicState.identifyAbortController.abort();
  }

  // Create new AbortController for this request
  musicState.identifyAbortController = new AbortController();
  const signal = musicState.identifyAbortController.signal;

  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  try {
    const response = await fetchFn(`${backendUrl}/music/identify`, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({ youtubeUrl }),
      signal  // Pass AbortController signal
    }, 90000);

    if (!response.ok) {
      const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
      throw new Error(error.message || 'Failed to identify song');
    }

    musicState.identifyAbortController = null;  // Clear controller on success
    return response.json();
  } catch (error) {
    musicState.identifyAbortController = null;  // Clear controller on error
    if (error.name === 'AbortError') {
      throw new Error('Song identification was cancelled');
    }
    throw error;
  }
}

async function generateMusicRequest(options) {
  // FIX: CEP-CRIT-006 - Abort previous generate request if still pending
  if (musicState.generateAbortController) {
    musicState.generateAbortController.abort();
  }

  // Create new AbortController for this request
  musicState.generateAbortController = new AbortController();
  const signal = musicState.generateAbortController.signal;

  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  try {
    const response = await fetchFn(`${backendUrl}/music/generate`, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify(options),
      signal  // Pass AbortController signal
    });

    if (!response.ok) {
      const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
      throw new Error(error.message || 'Failed to start music generation');
    }

    musicState.generateAbortController = null;  // Clear controller on success
    return response.json();
  } catch (error) {
    musicState.generateAbortController = null;  // Clear controller on error
    if (error.name === 'AbortError') {
      throw new Error('Music generation was cancelled');
    }
    throw error;
  }
}

async function getJobStatus(jobId) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/status/${jobId}`, { headers });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to get job status');
  }
  return response.json();
}

async function getMusicLibrary() {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/library`, { headers });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to load music library');
  }
  return response.json();
}

async function getMusicFile(jobId) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/${jobId}`, { headers });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to get music file');
  }
  return response.json();
}

async function deleteMusicFile(jobId) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/${jobId}`, { method: 'DELETE', headers });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to delete music');
  }
  return response.json();
}

async function getMusicCredits() {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/credits`, { headers });

  if (!response.ok) {
    return { remaining: 0, total: 0 };
  }
  return response.json();
}

// ============================================
// VARIATIONS API FUNCTIONS
// ============================================

async function generateVariationsRequest(options) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/generate-variations`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(options)
  });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to start variations generation');
  }
  return response.json();
}

async function getVariationsStatus(jobId, signal = null) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  // FIX: CEP-CRIT-003 - Pass AbortController signal to cancel in-flight requests
  const fetchOptions = { headers };
  if (signal) {
    fetchOptions.signal = signal;
  }

  const response = await fetchFn(`${backendUrl}/music/variations/status/${jobId}`, fetchOptions);

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to get variations status');
  }
  return response.json();
}

async function selectVariation(jobId, variationIndex) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/variations/${jobId}/select`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({ variationIndex })
  });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to select variation');
  }
  return response.json();
}

// ============================================
// SCENE-AWARE API FUNCTIONS
// ============================================

async function generateSceneAwareRequest(options, segments) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/generate-scene-aware`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({ ...options, segments })
  });

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to start scene-aware music generation');
  }
  return response.json();
}

function getCurrentTranscriptSegments() {
  if (window.currentTranscript && window.currentTranscript.segments) {
    return window.currentTranscript.segments;
  }
  return null;
}

// ============================================
// ALIGNMENT API FUNCTIONS
// ============================================

async function alignMusicRequest(jobId, targetDuration, options = {}) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/align`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jobId,
      targetDuration,
      fadeDuration: options.fadeDuration,
      beatAlign: options.beatAlign !== false,
      searchWindow: options.searchWindow
    })
  }, 120000);

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to align music');
  }
  return response.json();
}

async function analyzeBeatsRequest(jobId) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/analyze-beats`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({ jobId })
  }, 60000);

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to analyze beats');
  }
  return response.json();
}

async function getAlignmentOptions() {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/alignment-options`, { headers });

  if (!response.ok) {
    return {
      fadeDuration: { default: 2, min: 0.5, max: 5 },
      searchWindow: { default: 3, min: 0.5, max: 10 },
      minAudioDuration: 5
    };
  }
  return response.json();
}

// ============================================
// TIMELINE API FUNCTIONS
// ============================================

async function generateTimelineRequest(transcript, options = {}) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/generate-timeline`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      transcript,
      maxChapters: options.maxChapters || 10,
      minChapterLength: options.minChapterLength || 60,
      crossfadeDuration: options.crossfadeDuration || 2,
      instruments: options.instruments || [],
      prompt: options.prompt || ''
    })
  }, 600000);

  if (!response.ok) {
    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
    throw new Error(error.message || 'Failed to generate timeline music');
  }
  return response.json();
}

async function getTimelineOptions() {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/timeline-options`, { headers });

  if (!response.ok) {
    return {
      defaults: { maxChapters: 10, minChapterLength: 60, crossfadeDuration: 2 },
      constraints: { minCrossfadeDuration: 0.5, maxCrossfadeDuration: 5 }
    };
  }
  return response.json();
}

async function estimateTimelineRequest(transcript, options = {}) {
  const backendUrl = getBackendUrl();
  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

  const response = await fetchFn(`${backendUrl}/music/timeline-estimate`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      transcript,
      maxChapters: options.maxChapters,
      minChapterLength: options.minChapterLength
    })
  });

  if (!response.ok) {
    return { estimatedChapters: 3, estimatedMinutes: 12, estimatedTimeDisplay: '10-15 minutes' };
  }
  return response.json();
}

function getCurrentTranscript() {
  if (window.currentTranscript) {
    return window.currentTranscript;
  }
  return null;
}

async function getSequenceDuration() {
  try {
    const result = await jsx.call('getSequenceDuration');
    if (result && result.duration) {
      return result.duration;
    }
  } catch (error) {
    console.error('Could not get sequence duration:', error);
  }
  return null;
}

// ============================================
// INITIALIZATION
// ============================================

function initMusicModule() {
  console.log('[SPLICE] Initializing music module');

  cacheMusicElements();
  setupMusicEventListeners();
  setupTabSwitching();
  populateMoodSelector();
  populateInstrumentSelector();
  setupDurationSlider();
  loadMusicLibrary();
  updateMusicCreditsDisplay();

  console.log('[SPLICE] Music module initialized');
}

function setupTabSwitching() {
  const tabs = document.querySelectorAll('.music-tab');
  const contents = {
    generate: musicElements.tabGenerate || document.getElementById('music-tab-generate'),
    identify: musicElements.tabIdentify || document.getElementById('music-tab-identify'),
    library: musicElements.tabLibrary || document.getElementById('music-tab-library')
  };

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const tabName = tab.dataset.tab;

      // Update tab buttons
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');

      // Update tab content
      Object.entries(contents).forEach(([name, content]) => {
        if (content) {
          content.classList.toggle('active', name === tabName);
        }
      });

      // Refresh library when switching to library tab
      if (tabName === 'library') {
        loadMusicLibrary();
      }
    });
  });
}

function setupMusicEventListeners() {
  // FIX: CEP-CRIT-007 - Music Event Duplication
  // Guard flag prevents duplicate listeners (60 requests after 20 tab switches)
  if (musicState.listenersInitialized) {
    console.log('[SPLICE Music] Event listeners already initialized, skipping');
    return;
  }

  console.log('[SPLICE Music] Initializing event listeners (one-time)');
  musicState.listenersInitialized = true;

  document.addEventListener('input', (e) => {
    if (e.target.id === 'music-youtube-url') {
      handleYoutubeUrlChange();
    }
  });

  document.addEventListener('click', (e) => {
    const id = e.target.id;

    switch (id) {
      case 'music-identify-btn':
        handleIdentifySong();
        break;
      case 'music-generate-btn':
        handleGenerateMusic();
        break;
      case 'musicClearRefBtn':
        handleClearReference();
        break;
      case 'music-timeline-btn':
        showTimelineModal();
        break;
    }

    // Library action buttons
    if (e.target.classList.contains('music-action-btn')) {
      handleLibraryAction(e);
    }
  });

  document.addEventListener('change', (e) => {
    if (e.target.id === 'music-scene-aware') {
      handleSceneAwareToggle();
    }
    if (e.target.id === 'music-variations') {
      // Handle variations checkbox - will be checked in handleGenerateMusic
    }
  });

  updateSceneAwareAvailability();
  updateTimelineAvailability();
}

function handleSceneAwareToggle() {
  const toggle = musicElements.sceneAwareToggle || document.getElementById('music-scene-aware');
  musicState.sceneAwareEnabled = toggle?.checked || false;

  const indicator = document.getElementById('sceneAwareIndicator');
  if (indicator) {
    indicator.style.display = musicState.sceneAwareEnabled ? 'block' : 'none';
  }

  if (musicState.sceneAwareEnabled) {
    const segments = getCurrentTranscriptSegments();
    if (segments) {
      setMusicStatus(`Scene-aware enabled: ${segments.length} segments detected`, 'info');
    } else {
      setMusicStatus('Scene-aware enabled: Run transcription first for best results', 'warning');
    }
  }
}

function updateSceneAwareAvailability() {
  const toggle = musicElements.sceneAwareToggle || document.getElementById('music-scene-aware');
  const segments = getCurrentTranscriptSegments();

  if (toggle) {
    toggle.disabled = !segments;
    toggle.parentElement?.classList.toggle('disabled', !segments);
  }
}

// ============================================
// UI POPULATION (Card-Based)
// ============================================

function populateMoodSelector() {
  const container = musicElements.moodSelector || document.getElementById('music-mood-selector');
  if (!container) return;

  container.innerHTML = MOOD_OPTIONS.map(mood =>
    `<div class="music-mood-card ${mood.id === 'neutral' ? 'selected' : ''}" data-mood="${mood.id}" title="${mood.description}">
      <span class="mood-name">${mood.name}</span>
    </div>`
  ).join('');

  // Add click handlers
  container.querySelectorAll('.music-mood-card').forEach(card => {
    card.addEventListener('click', () => {
      container.querySelectorAll('.music-mood-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
    });
  });
}

function populateInstrumentSelector() {
  const container = musicElements.instrumentSelector || document.getElementById('music-instrument-selector');
  if (!container) return;

  container.innerHTML = INSTRUMENT_OPTIONS.map(inst =>
    `<div class="music-instrument-card ${inst.id === 'acoustic' ? 'selected' : ''}" data-instrument="${inst.id}" title="${inst.description}">
      <span class="instrument-name">${inst.name}</span>
    </div>`
  ).join('');

  // Add click handlers
  container.querySelectorAll('.music-instrument-card').forEach(card => {
    card.addEventListener('click', () => {
      container.querySelectorAll('.music-instrument-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
    });
  });
}

function setupDurationSlider() {
  const slider = musicElements.durationSlider || document.getElementById('music-duration-slider');
  const valueDisplay = musicElements.durationValue || document.getElementById('music-duration-value');
  if (!slider) return;

  slider.addEventListener('input', () => {
    if (valueDisplay) valueDisplay.textContent = slider.value;
  });
}

function getSelectedMood() {
  const container = musicElements.moodSelector || document.getElementById('music-mood-selector');
  const selected = container?.querySelector('.music-mood-card.selected');
  return selected?.dataset.mood || 'neutral';
}

function getSelectedInstrument() {
  const container = musicElements.instrumentSelector || document.getElementById('music-instrument-selector');
  const selected = container?.querySelector('.music-instrument-card.selected');
  return selected?.dataset.instrument || 'acoustic';
}

function getSelectedDuration() {
  const slider = musicElements.durationSlider || document.getElementById('music-duration-slider');
  return parseInt(slider?.value) || 60;
}

// ============================================
// YOUTUBE URL HANDLING
// ============================================

function handleYoutubeUrlChange() {
  const urlInput = musicElements.youtubeUrl || document.getElementById('music-youtube-url');
  const identifyBtn = musicElements.identifyBtn || document.getElementById('music-identify-btn');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  const isValidUrl = isValidYouTubeUrl(url);
  identifyBtn.disabled = !isValidUrl;

  if (musicState.identifiedSong) {
    handleClearReference();
  }
}

function isValidYouTubeUrl(url) {
  if (!url) return false;
  const patterns = [
    /youtube\.com\/watch\?v=[\w-]{11}/,
    /youtu\.be\/[\w-]{11}/,
    /youtube\.com\/embed\/[\w-]{11}/
  ];
  return patterns.some(p => p.test(url));
}

async function handleIdentifySong() {
  const urlInput = musicElements.youtubeUrl || document.getElementById('music-youtube-url');
  const identifyBtn = musicElements.identifyBtn || document.getElementById('music-identify-btn');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  if (!isValidYouTubeUrl(url)) {
    setMusicStatus('Invalid YouTube URL', 'error');
    return;
  }

  try {
    musicState.isIdentifying = true;
    identifyBtn.disabled = true;
    identifyBtn.textContent = 'Identifying...';
    setMusicStatus('Identifying song...', 'info');

    const result = await identifySong(url);

    if (result.identified) {
      musicState.identifiedSong = result;
      displayIdentifiedSong(result);
      setMusicStatus(`Identified: ${result.title} by ${result.artist}`, 'success');
    } else {
      setMusicStatus('Could not identify song. You can still generate music.', 'warning');
    }

  } catch (error) {
    console.error('Identification error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isIdentifying = false;
    identifyBtn.disabled = false;
    identifyBtn.textContent = 'Identify';
  }
}

function displayIdentifiedSong(song) {
  const display = musicElements.referenceDisplay || document.getElementById('music-identify-result');
  if (!display) return;

  const details = [];
  if (song.bpm) details.push(`${song.bpm} BPM`);
  if (song.key) details.push(song.key);
  if (song.mood) details.push(song.mood);

  display.innerHTML = `
    <div class="music-reference-card">
      <div class="music-ref-title">${escapeHtml(song.title)}</div>
      <div class="music-ref-artist">${escapeHtml(song.artist)}</div>
      <div class="music-ref-details">${details.join(' - ')}</div>
      <button id="musicClearRefBtn" class="music-clear-ref-btn" title="Clear reference">x</button>
    </div>
  `;
  display.style.display = 'block';
}

function handleClearReference() {
  musicState.identifiedSong = null;

  const display = musicElements.referenceDisplay || document.getElementById('music-identify-result');
  if (display) {
    display.innerHTML = '';
    display.style.display = 'none';
  }

  const urlInput = musicElements.youtubeUrl || document.getElementById('music-youtube-url');
  if (urlInput) urlInput.value = '';

  const identifyBtn = musicElements.identifyBtn || document.getElementById('music-identify-btn');
  if (identifyBtn) identifyBtn.disabled = true;
}

// ============================================
// MUSIC GENERATION
// ============================================

async function handleGenerateMusic() {
  const generateBtn = musicElements.generateBtn || document.getElementById('music-generate-btn');
  const promptInput = musicElements.promptInput || document.getElementById('music-custom-prompt');
  const variationsCheckbox = musicElements.variationsCheckbox || document.getElementById('music-variations');

  if (!generateBtn) return;

  // Check if variations mode is enabled
  const generateVariations = variationsCheckbox?.checked || false;
  if (generateVariations) {
    return handleGenerateVariations();
  }

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';

    const options = {
      mood: getSelectedMood(),
      instruments: [getSelectedInstrument()],
      duration: getSelectedDuration(),
      prompt: promptInput?.value || '',
      youtubeUrl: musicState.identifiedSong?.sourceUrl || null,
      referenceSong: musicState.identifiedSong || null
    };

    let result;

    if (musicState.sceneAwareEnabled) {
      const segments = getCurrentTranscriptSegments();
      if (segments && segments.length > 0) {
        setMusicStatus('Analyzing transcript and generating scene-aware music...', 'info');
        result = await generateSceneAwareRequest(options, segments);
        setMusicStatus(`Scene-aware generation started! Job ID: ${result.jobId}`, 'success');
      } else {
        setMusicStatus('No transcript available, using regular generation...', 'warning');
        result = await generateMusicRequest(options);
        setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
      }
    } else {
      setMusicStatus('Submitting generation request...', 'info');
      result = await generateMusicRequest(options);
      setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
    }

    addJobToList(result.jobId, options, result.isSceneAware);
    startPollingJob(result.jobId);
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Generation error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate Music';
  }
}

// ============================================
// VARIATIONS
// ============================================

async function handleGenerateVariations() {
  const generateBtn = musicElements.generateBtn || document.getElementById('music-generate-btn');
  const promptInput = musicElements.promptInput || document.getElementById('music-custom-prompt');

  if (!generateBtn) return;

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';
    setMusicStatus('Generating 3 variations... This may take 5-8 minutes.', 'info');

    const options = {
      mood: getSelectedMood(),
      instruments: [getSelectedInstrument()],
      duration: getSelectedDuration(),
      prompt: promptInput?.value || '',
      referenceSong: musicState.identifiedSong || null
    };

    const result = await generateVariationsRequest(options);
    setMusicStatus(`Variations generation started! Job ID: ${result.jobId}`, 'success');

    musicState.variationsJob = { jobId: result.jobId, status: 'pending', options };
    startPollingVariations(result.jobId);
    showVariationsPanel();
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Variations error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate 3 Variations';
  }
}

function startPollingVariations(jobId) {
  // FIX: CEP-CRIT-003 - Music Polling Memory Leak
  // Clear any existing polling AND abort in-flight requests
  if (musicState.variationsPollingInterval) {
    clearInterval(musicState.variationsPollingInterval);
  }
  if (musicState.variationsAbortController) {
    musicState.variationsAbortController.abort();
  }

  // Create new AbortController for this polling session
  musicState.variationsAbortController = new AbortController();
  const signal = musicState.variationsAbortController.signal;

  // Track which variations job we're polling for (race condition fix)
  musicState.currentVariationsJobId = jobId;

  musicState.variationsPollingInterval = setInterval(async () => {
    // Race condition check: verify we're still polling for this job
    if (musicState.currentVariationsJobId !== jobId) {
      return; // A new variations job started polling, ignore this callback
    }

    try {
      // Pass abort signal to cancel in-flight requests
      const status = await getVariationsStatus(jobId, signal);

      // Double-check after async operation
      if (musicState.currentVariationsJobId !== jobId) {
        return;
      }

      musicState.variationsJob = { ...musicState.variationsJob, ...status };
      renderVariationsProgress(status);

      if (status.status === 'selecting' || status.status === 'completed') {
        clearInterval(musicState.variationsPollingInterval);
        musicState.variationsPollingInterval = null;
        musicState.currentVariationsJobId = null;
        if (musicState.variationsAbortController) {
          musicState.variationsAbortController.abort();
          musicState.variationsAbortController = null;
        }

        if (status.variations && status.variations.length > 0) {
          setMusicStatus('Variations ready! Select your favorite.', 'success');
          renderVariationsSelection(status.variations);
        }
      } else if (status.status === 'failed') {
        clearInterval(musicState.variationsPollingInterval);
        musicState.variationsPollingInterval = null;
        musicState.currentVariationsJobId = null;
        if (musicState.variationsAbortController) {
          musicState.variationsAbortController.abort();
          musicState.variationsAbortController = null;
        }
        setMusicStatus(`Variations failed: ${status.failedReason || 'Unknown error'}`, 'error');
      }
    } catch (error) {
      // Don't log errors if request was aborted (expected behavior)
      if (error.name !== 'AbortError') {
        console.error('Variations polling error:', error);
      }
    }
  }, MUSIC_POLL_INTERVAL);
}

function showVariationsPanel() {
  let panel = musicElements.variationsPanel || document.getElementById('variationsPanel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'variationsPanel';
    panel.className = 'variations-panel';
    const section = musicElements.section || document.getElementById('musicSection');
    if (section) section.appendChild(panel);
  }

  panel.style.display = 'block';
  panel.innerHTML = `
    <div class="variations-header">
      <h4>Generating 3 Variations</h4>
      <button id="variationsCancelBtn" class="variations-cancel-btn" title="Cancel">x</button>
    </div>
    <div class="variations-progress">
      <div class="variation-progress-item" data-index="0">
        <span class="variation-name">Version A</span>
        <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
        <span class="progress-text">0%</span>
      </div>
      <div class="variation-progress-item" data-index="1">
        <span class="variation-name">Version B</span>
        <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
        <span class="progress-text">0%</span>
      </div>
      <div class="variation-progress-item" data-index="2">
        <span class="variation-name">Version C</span>
        <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
        <span class="progress-text">0%</span>
      </div>
    </div>
    <div id="variationsSelection" class="variations-selection" style="display: none;"></div>
  `;

  document.getElementById('variationsCancelBtn')?.addEventListener('click', hideVariationsPanel);
}

function hideVariationsPanel() {
  const panel = musicElements.variationsPanel || document.getElementById('variationsPanel');
  if (panel) {
    panel.style.display = 'none';
    panel.innerHTML = '';
  }

  if (musicState.variationsPollingInterval) {
    clearInterval(musicState.variationsPollingInterval);
    musicState.variationsPollingInterval = null;
  }

  // FIX: CEP-CRIT-004 - Properly dispose audio players to prevent memory leak
  disposeAudioPlayers();
  musicState.variationPlayers = [null, null, null];
  musicState.variationsJob = null;
  musicState.selectedVariationIndex = null;
}

function renderVariationsProgress(status) {
  const progressItems = document.querySelectorAll('.variation-progress-item');
  const variationProgress = status.variationProgress || [0, 0, 0];

  progressItems.forEach((item, index) => {
    const progress = variationProgress[index] || 0;
    const fill = item.querySelector('.progress-fill');
    const text = item.querySelector('.progress-text');

    if (fill) fill.style.width = `${progress}%`;
    if (text) text.textContent = `${progress}%`;
    if (progress >= 100) item.classList.add('completed');
  });
}

function renderVariationsSelection(variations) {
  const container = document.getElementById('variationsSelection');
  if (!container) return;

  // FIX: CEP-CRIT-004 - Dispose old audio players before rendering new variations
  disposeAudioPlayers();
  musicState.variationPlayers = [null, null, null];

  const progressContainer = document.querySelector('.variations-progress');
  if (progressContainer) progressContainer.style.display = 'none';

  container.style.display = 'block';
  container.innerHTML = `
    <div class="variations-header">
      <h4>Select Your Favorite</h4>
      <p class="variations-subtitle">Preview each variation and choose one to keep</p>
    </div>
    <div class="variations-cards">
      ${variations.map((v, index) => `
        <div class="variation-card ${v.status === 'failed' ? 'failed' : ''}" data-index="${index}">
          <div class="variation-card-header">
            <span class="variation-name">${escapeHtml(v.variationName)}</span>
            ${v.status === 'failed' ? '<span class="failed-badge">Failed</span>' : ''}
          </div>
          ${v.promptDescription ? `<div class="variation-description">${escapeHtml(v.promptDescription)}</div>` : ''}
          ${v.status !== 'failed' ? `
            <div class="variation-player" data-index="${index}">
              <button class="play-btn" data-action="play" data-index="${index}" data-url="${v.previewUrl || ''}">Play</button>
              <span class="duration">${v.duration ? `${v.duration}s` : '--'}</span>
            </div>
            <button class="select-variation-btn btn btn-primary" data-index="${index}">Select This Version</button>
          ` : `<div class="variation-error">${escapeHtml(v.error || 'Generation failed')}</div>`}
        </div>
      `).join('')}
    </div>
  `;

  container.querySelectorAll('.play-btn').forEach(btn => btn.addEventListener('click', handleVariationPlay));
  container.querySelectorAll('.select-variation-btn').forEach(btn => btn.addEventListener('click', handleVariationSelect));
}

async function handleVariationPlay(event) {
  const btn = event.target;
  const index = parseInt(btn.dataset.index);
  const url = btn.dataset.url;

  if (!url) { setMusicStatus('No preview available', 'warning'); return; }

  musicState.variationPlayers.forEach((player, i) => {
    if (player && i !== index) {
      player.pause();
      const otherBtn = document.querySelector(`.play-btn[data-index="${i}"]`);
      if (otherBtn) otherBtn.textContent = 'Play';
    }
  });

  if (!musicState.variationPlayers[index]) {
    musicState.variationPlayers[index] = new Audio();
    musicState.variationPlayers[index].addEventListener('ended', () => { btn.textContent = 'Play'; });
  }

  const player = musicState.variationPlayers[index];

  if (player.paused || player.src !== url) {
    player.src = url;
    try {
      await player.play();
      btn.textContent = 'Pause';
    } catch (error) {
      console.error('Play error:', error);
      setMusicStatus('Could not play preview', 'error');
    }
  } else {
    player.pause();
    btn.textContent = 'Play';
  }
}

async function handleVariationSelect(event) {
  const btn = event.target;
  const index = parseInt(btn.dataset.index);
  const jobId = musicState.variationsJob?.jobId;

  if (!jobId) { setMusicStatus('No variations job found', 'error'); return; }

  try {
    document.querySelectorAll('.select-variation-btn').forEach(b => { b.disabled = true; });
    btn.textContent = 'Selecting...';
    setMusicStatus('Finalizing your selection...', 'info');

    const result = await selectVariation(jobId, index);
    setMusicStatus(`Selected ${result.variationName}! Music added to library.`, 'success');

    musicState.variationPlayers.forEach(player => { if (player) player.pause(); });
    hideVariationsPanel();
    loadMusicLibrary();
    updateMusicCreditsDisplay();

  } catch (error) {
    console.error('Selection error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
    document.querySelectorAll('.select-variation-btn').forEach(b => { b.disabled = false; });
    btn.textContent = 'Select This Version';
  }
}

// ============================================
// JOBS LIST
// ============================================

function addJobToList(jobId, options, isSceneAware = false) {
  const job = {
    jobId,
    status: 'pending',
    progress: 0,
    mood: options.mood,
    duration: options.duration,
    isSceneAware,
    createdAt: new Date().toISOString()
  };
  musicState.jobs.unshift(job);
  renderJobsList();
}

function startPollingJob(jobId) {
  // Clear any existing polling
  if (musicState.pollInterval) clearInterval(musicState.pollInterval);

  // Track which job we're now polling for (race condition fix)
  musicState.currentPollingJobId = jobId;

  musicState.pollInterval = setInterval(async () => {
    // Race condition check: verify we're still polling for this job
    if (musicState.currentPollingJobId !== jobId) {
      return; // A new job started polling, ignore this callback
    }

    try {
      const status = await getJobStatus(jobId);

      // Double-check after async operation
      if (musicState.currentPollingJobId !== jobId) {
        return;
      }

      const jobIndex = musicState.jobs.findIndex(j => j.jobId === jobId);
      if (jobIndex !== -1) {
        musicState.jobs[jobIndex] = { ...musicState.jobs[jobIndex], ...status };
        renderJobsList();
      }

      if (status.status === 'completed' || status.status === 'failed') {
        clearInterval(musicState.pollInterval);
        musicState.pollInterval = null;
        musicState.currentPollingJobId = null;
        if (status.status === 'completed') {
          setMusicStatus('Music generation completed!', 'success');
          loadMusicLibrary();
        } else {
          setMusicStatus(`Generation failed: ${status.failedReason || 'Unknown error'}`, 'error');
        }
      }
    } catch (error) {
      console.error('Polling error:', error);
    }
  }, MUSIC_POLL_INTERVAL);
}

function renderJobsList() {
  const container = musicElements.jobsList || document.getElementById('music-jobs-list');
  if (!container) return;

  if (musicState.jobs.length === 0) {
    container.innerHTML = '<div class="music-empty">No generation jobs yet</div>';
    return;
  }

  // FIX: CEP-CRIT-005 - Music DOM Thrashing
  // Use DocumentFragment + requestAnimationFrame to prevent 500ms UI freeze
  // Previously: innerHTML in loop caused reflow on every iteration
  const fragment = document.createDocumentFragment();

  musicState.jobs.forEach(job => {
    const jobItem = document.createElement('div');
    jobItem.className = `music-job-item ${job.status}`;
    jobItem.setAttribute('data-job-id', job.jobId);

    const statusDiv = document.createElement('div');
    statusDiv.className = `music-job-status ${job.status}`;
    jobItem.appendChild(statusDiv);

    const infoDiv = document.createElement('div');
    infoDiv.className = 'music-job-info';

    const moodSpan = document.createElement('span');
    moodSpan.className = 'music-job-mood';
    moodSpan.textContent = `${job.mood || 'Music'}${job.isSceneAware ? ' Scene' : ''}`;
    infoDiv.appendChild(moodSpan);

    const durationSpan = document.createElement('span');
    durationSpan.className = 'music-job-duration';
    durationSpan.textContent = `${job.duration}s`;
    infoDiv.appendChild(durationSpan);

    jobItem.appendChild(infoDiv);

    const progressDiv = document.createElement('div');
    progressDiv.className = 'music-job-progress';
    progressDiv.textContent = job.status === 'completed' ? 'Done' :
                              job.status === 'failed' ? 'Failed' :
                              `${job.progress}%`;
    jobItem.appendChild(progressDiv);

    fragment.appendChild(jobItem);
  });

  // Batch DOM update in next animation frame to prevent blocking
  requestAnimationFrame(() => {
    container.textContent = ''; // Clear efficiently
    container.appendChild(fragment);
  });
}

// ============================================
// MUSIC LIBRARY
// ============================================

async function loadMusicLibrary() {
  const container = musicElements.library || document.getElementById('music-library-list');
  if (!container) return;

  try {
    container.innerHTML = '<div class="music-loading">Loading library...</div>';
    const library = await getMusicLibrary();

    if (library.length === 0) {
      container.innerHTML = '<div class="music-empty">Your music library is empty</div>';
      return;
    }

    // SECURITY: Escape dynamic content to prevent XSS
    container.innerHTML = library.map(item => {
      const safeJobId = escapeHtml(item.jobId);
      return `
        <div class="music-library-item" data-job-id="${safeJobId}">
          <div class="music-item-info">
            <div class="music-item-title">${escapeHtml(item.title || 'Untitled')}</div>
            <div class="music-item-meta">${escapeHtml(item.duration)}s - ${escapeHtml(item.mood || 'Music')}</div>
          </div>
          <div class="music-item-actions">
            <button class="music-action-btn btn btn-small" data-action="preview" data-job-id="${safeJobId}" title="Preview">Play</button>
            <button class="music-action-btn btn btn-small" data-action="align" data-job-id="${safeJobId}" title="Align to Video">Align</button>
            <button class="music-action-btn btn btn-small btn-secondary" data-action="delete" data-job-id="${safeJobId}" title="Delete">Del</button>
          </div>
        </div>
      `;
    }).join('');

  } catch (error) {
    console.error('Library load error:', error);
    container.innerHTML = '<div class="music-error">Failed to load library</div>';
  }
}

async function handleLibraryAction(event) {
  const btn = event.target;
  const action = btn.dataset.action;
  const jobId = btn.dataset.jobId;

  switch (action) {
    case 'preview': await previewMusic(jobId); break;
    case 'align': await showAlignmentModal(jobId); break;
    case 'delete': await confirmDeleteMusic(jobId); break;
  }
}

async function previewMusic(jobId) {
  try {
    setMusicStatus('Loading preview...', 'info');
    const music = await getMusicFile(jobId);

    if (!music.previewUrl && !music.downloadUrl) {
      setMusicStatus('No preview available', 'warning');
      return;
    }

    if (!musicState.audioPlayer) {
      musicState.audioPlayer = new Audio();
      musicState.audioPlayer.addEventListener('ended', () => { setMusicStatus('Preview finished', 'info'); });
    }

    musicState.audioPlayer.src = music.previewUrl || music.downloadUrl;
    musicState.audioPlayer.play();
    setMusicStatus('Playing preview...', 'success');

  } catch (error) {
    console.error('Preview error:', error);
    setMusicStatus(`Preview error: ${error.message}`, 'error');
  }
}

async function confirmDeleteMusic(jobId) {
  if (!confirm('Are you sure you want to delete this music file?')) return;

  try {
    setMusicStatus('Deleting...', 'info');
    await deleteMusicFile(jobId);
    setMusicStatus('Music deleted', 'success');
    loadMusicLibrary();
  } catch (error) {
    console.error('Delete error:', error);
    setMusicStatus(`Delete error: ${error.message}`, 'error');
  }
}

// ============================================
// ALIGNMENT UI
// ============================================

async function showAlignmentModal(jobId) {
  try {
    setMusicStatus('Loading alignment options...', 'info');
    const options = await getAlignmentOptions();
    musicState.alignmentOptions = options;

    const sequenceDuration = await getSequenceDuration();

    setMusicStatus('Analyzing beats...', 'info');
    const beatAnalysis = await analyzeBeatsRequest(jobId);
    musicState.beatAnalysis = beatAnalysis;

    renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration);
    setMusicStatus('', 'info');

  } catch (error) {
    console.error('Alignment modal error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  }
}

function renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration) {
  const modal = document.getElementById('music-align-modal');
  if (!modal) {
    console.error('Alignment modal not found in DOM');
    return;
  }

  // Populate Info
  const infoEl = document.getElementById('music-align-info');
  if (infoEl) {
    const defaultDuration = sequenceDuration ? Math.round(sequenceDuration) : Math.round(beatAnalysis.duration * 0.8);

    // SECURITY: Escape dynamic content to prevent XSS
    let html = `
          <p><strong>Original Duration:</strong> ${escapeHtml(formatDuration(beatAnalysis.duration))}</p>
          <p><strong>Detected BPM:</strong> ${escapeHtml(beatAnalysis.bpm || 'Unknown')}</p>
          <p><strong>Beat Count:</strong> ${escapeHtml(beatAnalysis.beatCount)}</p>
      `;
    if (sequenceDuration) {
      html += `<p class="highlight"><strong>Sequence Duration:</strong> ${escapeHtml(formatDuration(sequenceDuration))}</p>`;
    }
    infoEl.innerHTML = html;

    // Set default target duration
    const targetInput = document.getElementById('music-align-target');
    if (targetInput) {
      targetInput.value = defaultDuration;
      targetInput.max = Math.ceil(beatAnalysis.duration);
    }
  }

  // Setup Fade Slider
  const fadeSlider = document.getElementById('music-fade-slider');
  const fadeValue = document.getElementById('music-fade-value');
  if (fadeSlider && fadeValue) {
    fadeSlider.min = options.fadeDuration.min;
    fadeSlider.max = options.fadeDuration.max;
    fadeSlider.value = options.fadeDuration.default;
    fadeValue.textContent = options.fadeDuration.default;

    // Remove old listener to avoid duplicates if any
    const newSlider = fadeSlider.cloneNode(true);
    fadeSlider.parentNode.replaceChild(newSlider, fadeSlider);

    newSlider.addEventListener('input', (e) => {
      if (fadeValue) fadeValue.textContent = e.target.value;
    });
  }

  // Setup Match Sequence Button
  const matchBtn = document.getElementById('music-align-match-seq');
  if (matchBtn) {
    if (sequenceDuration) {
      matchBtn.style.display = 'inline-block';
      matchBtn.onclick = () => {
        const targetInput = document.getElementById('music-align-target');
        if (targetInput) targetInput.value = Math.round(sequenceDuration);
      };
    } else {
      matchBtn.style.display = 'none';
    }
  }

  // Setup Confirm Button
  const confirmBtn = document.getElementById('music-align-btn');
  if (confirmBtn) {
    confirmBtn.onclick = (e) => handleAlignmentConfirm(e, jobId);
    confirmBtn.disabled = false;
    confirmBtn.textContent = 'Align & Trim';
  }

  // Setup Close Handlers
  const closeBtn = document.getElementById('music-align-close');
  if (closeBtn) closeBtn.onclick = hideAlignmentModal;

  // Show Modal
  modal.classList.remove('hidden');
}

function hideAlignmentModal() {
  const modal = document.getElementById('music-align-modal');
  if (modal) {
    modal.classList.add('hidden');
  }
  musicState.beatAnalysis = null;
}

async function handleAlignmentConfirm(event, jobId) {
  const btn = event.target;
  // jobId is passed directly now, or fallback to state? 
  // The original code used dataset.jobId. We passed it in the onclick handler closure.

  const targetInput = document.getElementById('music-align-target');
  const fadeInput = document.getElementById('music-fade-slider'); // It's a slider now in HTML
  const beatAlignInput = document.getElementById('music-beat-align');

  const targetDuration = parseFloat(targetInput?.value);
  const fadeDuration = parseFloat(fadeInput?.value);
  const beatAlign = beatAlignInput?.checked;

  if (!targetDuration || targetDuration < 5) {
    setMusicStatus('Target duration must be at least 5 seconds', 'error');
    return;
  }

  try {
    musicState.isAligning = true;
    btn.disabled = true;
    btn.textContent = 'Aligning...';
    setMusicStatus('Aligning music to video duration...', 'info');

    const result = await alignMusicRequest(jobId, targetDuration, { fadeDuration, beatAlign });
    setMusicStatus(`Aligned! Cut at ${formatDuration(result.actualDuration)} (${result.wasAligned ? 'beat-aligned' : 'exact'})`, 'success');
    hideAlignmentModal();

    if (result.downloadUrl) {
      showAlignedDownload(result);
    }

  } catch (error) {
    console.error('Alignment error:', error);
    setMusicStatus(`Alignment failed: ${error.message}`, 'error');
    btn.disabled = false;
    btn.textContent = 'Align Music';
  } finally {
    musicState.isAligning = false;
  }
}

function showAlignedDownload(result) {
  const notification = document.createElement('div');
  notification.className = 'alignment-notification';

  // SECURITY: Escape URL to prevent XSS - use encodeURI for URL safety
  const safeUrl = escapeHtml(result.downloadUrl || '');
  const safeDuration = escapeHtml(formatDuration(result.actualDuration));

  notification.innerHTML = `
    <div class="notification-content">
      <span class="notification-icon">Done</span>
      <div class="notification-text">
        <strong>Music Aligned!</strong>
        <span>Duration: ${safeDuration}</span>
      </div>
      <div class="notification-actions">
        <button class="btn btn-small" data-action="download">Download</button>
        <button class="btn-close" data-action="close">x</button>
      </div>
    </div>
  `;

  const container = musicElements.section || document.getElementById('musicSection') || document.body;
  container.appendChild(notification);

  // Store URL safely via JS property instead of data attribute
  const downloadBtn = notification.querySelector('[data-action="download"]');
  downloadBtn._downloadUrl = result.downloadUrl;
  downloadBtn.addEventListener('click', (e) => {
    window.open(e.target._downloadUrl, '_blank');
    notification.remove();
  });

  notification.querySelector('[data-action="close"]').addEventListener('click', () => { notification.remove(); });
  setTimeout(() => notification.remove(), 30000);
}

// ============================================
// TIMELINE UI
// ============================================

function updateTimelineAvailability() {
  const btn = musicElements.timelineBtn || document.getElementById('music-timeline-btn');
  const transcript = getCurrentTranscript();

  if (btn) {
    btn.disabled = !transcript || !transcript.segments || transcript.segments.length === 0;
    if (!transcript) {
      btn.title = 'Run transcription first to enable mood timeline';
    } else if (!transcript.segments || transcript.segments.length === 0) {
      btn.title = 'No transcript segments available';
    } else {
      btn.title = 'Generate per-chapter music with mood matching';
    }
  }
}

async function showTimelineModal() {
  const transcript = getCurrentTranscript();
  if (!transcript) {
    setMusicStatus('Run transcription first to generate mood timeline', 'error');
    return;
  }

  try {
    setMusicStatus('Loading timeline options...', 'info');
    const options = await getTimelineOptions();
    musicState.timelineOptions = options;
    const estimate = await estimateTimelineRequest(transcript);
    renderTimelineModal(transcript, options, estimate);
    setMusicStatus('', 'info');
  } catch (error) {
    console.error('Timeline modal error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  }
}

function renderTimelineModal(transcript, options, estimate) {
  let modal = document.getElementById('timelineModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'timelineModal';
    modal.className = 'modal-overlay';
    document.body.appendChild(modal);
  }

  const defaults = options.defaults || {};
  const constraints = options.constraints || {};

  modal.innerHTML = `
    <div class="modal-content timeline-modal">
      <div class="modal-header">
        <h3>Generate Mood Timeline</h3>
        <button class="modal-close-btn" id="timelineCloseBtn">x</button>
      </div>
      <div class="modal-body">
        <div class="timeline-info">
          <p>Video Duration: ${formatDuration(transcript.duration)}</p>
          <p>Transcript Segments: ${transcript.segments?.length || 0}</p>
          <p><strong>Estimated Chapters: ${estimate.estimatedChapters}</strong></p>
          <p><strong>Estimated Time: ${estimate.estimatedTimeDisplay}</strong></p>
        </div>
        <p>This will analyze your video transcript to detect chapters and their emotional tone, then generate unique music for each chapter with crossfades between them.</p>
        <p><strong>Cost:</strong> 3 music credits</p>
        <div class="timeline-form">
          <div class="form-group">
            <label for="timelineMaxChapters">Maximum Chapters</label>
            <input type="number" id="timelineMaxChapters" value="${defaults.maxChapters || 10}" min="1" max="20" step="1">
          </div>
          <div class="form-group">
            <label for="timelineMinLength">Minimum Chapter Length (seconds)</label>
            <input type="number" id="timelineMinLength" value="${defaults.minChapterLength || 60}" min="30" max="300" step="10">
          </div>
          <div class="form-group">
            <label for="timelineCrossfade">Crossfade Duration (seconds)</label>
            <input type="number" id="timelineCrossfade" value="${defaults.crossfadeDuration || 2}" min="${constraints.minCrossfadeDuration || 0.5}" max="${constraints.maxCrossfadeDuration || 5}" step="0.5">
          </div>
          <div class="form-group">
            <label for="timelineInstruments">Instrument Style</label>
            <select id="timelineInstruments">
              <option value="">Auto-detect from content</option>
              ${INSTRUMENT_OPTIONS.map(i => `<option value="${i.id}">${i.name} - ${i.description}</option>`).join('')}
            </select>
          </div>
          <div class="form-group">
            <label for="timelinePrompt">Additional Instructions (optional)</label>
            <textarea id="timelinePrompt" rows="2" placeholder="E.g., 'Modern electronic feel'"></textarea>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" id="timelineCancelBtn" class="btn btn-secondary">Cancel</button>
        <button type="button" id="timelineConfirmBtn" class="btn btn-primary">Generate Timeline Music (3 credits)</button>
      </div>
    </div>
  `;

  modal.style.display = 'flex';

  document.getElementById('timelineCloseBtn').addEventListener('click', hideTimelineModal);
  document.getElementById('timelineCancelBtn').addEventListener('click', hideTimelineModal);
  document.getElementById('timelineConfirmBtn').addEventListener('click', handleTimelineConfirm);
  modal.addEventListener('click', (e) => { if (e.target === modal) hideTimelineModal(); });
}

function hideTimelineModal() {
  const modal = document.getElementById('timelineModal');
  if (modal) { modal.style.display = 'none'; modal.innerHTML = ''; }
}

async function handleTimelineConfirm() {
  const transcript = getCurrentTranscript();
  if (!transcript) {
    setMusicStatus('Transcript not available', 'error');
    return;
  }

  const maxChapters = parseInt(document.getElementById('timelineMaxChapters').value) || 10;
  const minChapterLength = parseInt(document.getElementById('timelineMinLength').value) || 60;
  const crossfadeDuration = parseFloat(document.getElementById('timelineCrossfade').value) || 2;
  const instruments = document.getElementById('timelineInstruments').value;
  const prompt = document.getElementById('timelinePrompt').value || '';

  const confirmBtn = document.getElementById('timelineConfirmBtn');

  try {
    musicState.isGeneratingTimeline = true;
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'Generating...';

    setMusicStatus('Generating mood timeline... This may take several minutes.', 'info');
    hideTimelineModal();

    const result = await generateTimelineRequest(transcript, {
      maxChapters,
      minChapterLength,
      crossfadeDuration,
      instruments: instruments ? [instruments] : [],
      prompt
    });

    setMusicStatus(`Timeline generated! ${result.chapters?.length || 0} chapters, ${formatDuration(result.duration)}`, 'success');

    if (result.audioUrl) {
      showTimelineResult(result);
    }

    loadMusicLibrary();
    updateMusicCreditsDisplay();

  } catch (error) {
    console.error('Timeline generation error:', error);
    setMusicStatus(`Timeline generation failed: ${error.message}`, 'error');
  } finally {
    musicState.isGeneratingTimeline = false;
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.textContent = 'Generate Timeline Music (3 credits)';
    }
  }
}

function showTimelineResult(result) {
  let resultPanel = document.getElementById('timelineResultPanel');
  if (!resultPanel) {
    resultPanel = document.createElement('div');
    resultPanel.id = 'timelineResultPanel';
    resultPanel.className = 'timeline-result-panel';
    const container = musicElements.section || document.getElementById('musicSection') || document.body;
    container.insertBefore(resultPanel, container.firstChild);
  }

  // SECURITY: Escape dynamic content to prevent XSS
  const chapterList = (result.chapters || []).map((ch, i) => `
    <div class="timeline-chapter">
      <span class="chapter-num">${i + 1}</span>
      <span class="chapter-title">${escapeHtml(ch.title)}</span>
      <span class="chapter-mood">${escapeHtml(ch.mood || 'neutral')}</span>
    </div>
  `).join('');

  resultPanel.innerHTML = `
    <div class="timeline-result-content">
      <div class="timeline-result-header">
        <span class="result-icon">Done</span>
        <span class="result-title">Mood Timeline Generated!</span>
        <button class="close-btn" data-action="close">x</button>
      </div>
      <div class="timeline-result-stats">
        <p>Duration: ${escapeHtml(formatDuration(result.duration))}</p>
        <p>Chapters: ${escapeHtml(result.chapters?.length || 0)}</p>
        <p>Credits Used: ${escapeHtml(result.creditCost || 3)}</p>
      </div>
      <div class="timeline-chapters"><h4>Chapters</h4>${chapterList}</div>
      <div class="timeline-result-actions">
        <button class="btn btn-primary" data-action="download" data-url="${escapeHtml(result.audioUrl)}">Download</button>
      </div>
    </div>
  `;

  resultPanel.style.display = 'block';

  resultPanel.querySelector('[data-action="close"]').addEventListener('click', () => { resultPanel.style.display = 'none'; });
  resultPanel.querySelector('[data-action="download"]').addEventListener('click', (e) => {
    window.open(e.target.dataset.url, '_blank');
  });

  setTimeout(() => { if (resultPanel) resultPanel.style.display = 'none'; }, 60000);
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

function formatDuration(seconds) {
  if (!seconds) return '0:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.round(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

async function updateMusicCreditsDisplay() {
  const badge = musicElements.creditsBadge || document.getElementById('music-credits-badge');
  if (!badge) return;

  try {
    const credits = await getMusicCredits();
    badge.textContent = `${credits.remaining}/${credits.total} songs`;
    badge.className = 'music-credits-badge';
    if (credits.remaining === 0) badge.classList.add('empty');
    else if (credits.remaining <= 2) badge.classList.add('low');
  } catch (error) {
    badge.textContent = 'Credits: --';
  }
}

function setMusicStatus(message, type = 'info') {
  const status = musicElements.status || document.getElementById('music-status');
  if (!status) return;

  status.textContent = message;
  status.className = `music-status music-status-${type}`;
  status.style.display = 'block';

  if (type !== 'error') {
    setTimeout(() => { status.style.display = 'none'; }, 5000);
  }
}

function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ============================================
// EXPORTS
// ============================================

window.musicModule = {
  init: initMusicModule,
  identifySong,
  generateMusicRequest,
  getMusicLibrary,
  getMusicCredits,
  loadMusicLibrary,
  previewMusic,
  generateVariationsRequest,
  getVariationsStatus,
  selectVariation,
  handleGenerateVariations,
  showVariationsPanel,
  hideVariationsPanel,
  generateSceneAwareRequest,
  getCurrentTranscriptSegments,
  handleSceneAwareToggle,
  updateSceneAwareAvailability,
  alignMusicRequest,
  analyzeBeatsRequest,
  getAlignmentOptions,
  showAlignmentModal,
  hideAlignmentModal,
  formatDuration,
  getSequenceDuration,
  generateTimelineRequest,
  getTimelineOptions,
  estimateTimelineRequest,
  getCurrentTranscript,
  showTimelineModal,
  hideTimelineModal,
  updateTimelineAvailability,
  MOOD_OPTIONS,
  INSTRUMENT_OPTIONS,
  DURATION_OPTIONS
};

window.initMusicModule = initMusicModule;
