/**
 * Workflow Automation UI Controller
 * Based on FireCut's workflow system
 *
 * Features:
 * - Load and execute saved workflows
 * - Create and edit workflows with WorkflowBuilder
 * - Display workflow steps and progress
 * - Sequential execution with error handling
 */

(function() {
  'use strict';

  // DOM Elements
  let workflowsPanel = null;
  let workflowsToggle = null;
  let workflowSelector = null;
  let newWorkflowBtn = null;
  let editWorkflowBtn = null;
  let executeWorkflowBtn = null;
  let workflowStatus = null;
  let workflowStepsList = null;
  let workflowProgress = null;
  let workflowProgressBar = null;
  let workflowProgressText = null;
  let workflowScope = null;

  // State
  let workflows = [];
  let selectedWorkflow = null;
  let isExecuting = false;

  /**
   * Initialize Workflows UI
   */
  function init() {
    console.log('[Workflows] Initializing...');

    // Get DOM elements
    workflowsPanel = document.getElementById('workflows-panel');
    workflowsToggle = document.getElementById('workflowsToggle');
    workflowSelector = document.getElementById('workflow-selector');
    newWorkflowBtn = document.getElementById('new-workflow-btn');
    editWorkflowBtn = document.getElementById('edit-workflow-btn');
    executeWorkflowBtn = document.getElementById('execute-workflow-btn');
    workflowStatus = document.getElementById('workflow-status');
    workflowStepsList = document.getElementById('workflow-steps-list');
    workflowProgress = document.getElementById('workflow-progress');
    workflowProgressBar = document.getElementById('workflow-progress-bar');
    workflowProgressText = document.getElementById('workflow-progress-text');
    workflowScope = document.getElementById('workflow-scope');

    if (!workflowsPanel || !workflowsToggle) {
      console.error('[Workflows] Required DOM elements not found');
      return;
    }

    // Setup event listeners
    setupEventListeners();

    // Load workflows
    loadWorkflows();

    console.log('[Workflows] Initialized successfully');
  }

  /**
   * Setup event listeners
   */
  function setupEventListeners() {
    // Toggle panel
    workflowsToggle.addEventListener('click', togglePanel);

    // Workflow selector
    if (workflowSelector) {
      workflowSelector.addEventListener('change', onWorkflowSelected);
    }

    // Action buttons
    if (newWorkflowBtn) {
      newWorkflowBtn.addEventListener('click', createNewWorkflow);
    }
    if (editWorkflowBtn) {
      editWorkflowBtn.addEventListener('click', editWorkflow);
    }
    if (executeWorkflowBtn) {
      executeWorkflowBtn.addEventListener('click', executeWorkflow);
    }
  }

  /**
   * Toggle panel visibility
   */
  function togglePanel() {
    if (!workflowsPanel) return;

    const isCollapsed = workflowsPanel.classList.contains('collapsed');
    workflowsPanel.classList.toggle('collapsed');

    const icon = workflowsToggle.querySelector('.toggle-icon');
    if (icon) {
      icon.textContent = isCollapsed ? '-' : '+';
    }

    // Load workflows when panel is opened
    if (isCollapsed) {
      loadWorkflows();
    }
  }

  /**
   * Load workflows from backend
   */
  async function loadWorkflows() {
    try {
      updateStatus('Loading workflows...', 'info');

      const response = await fetch(`${getBackendUrl()}/workflows`, {
        method: 'GET',
        headers: {
          'x-stripe-customer-id': getCustomerId()
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to load workflows: ${response.statusText}`);
      }

      workflows = await response.json();
      updateWorkflowSelector();
      updateStatus(`Loaded ${workflows.length} workflow(s)`, 'success');

    } catch (error) {
      console.error('[Workflows] Load error:', error);
      updateStatus(`Error: ${error.message}`, 'error');
    }
  }

  /**
   * Update workflow selector dropdown
   */
  function updateWorkflowSelector() {
    if (!workflowSelector) return;

    // Clear existing options (except first)
    while (workflowSelector.options.length > 1) {
      workflowSelector.remove(1);
    }

    // Add workflows
    workflows.forEach(workflow => {
      const option = document.createElement('option');
      option.value = workflow.id;
      option.textContent = workflow.name;
      workflowSelector.appendChild(option);
    });
  }

  /**
   * Handle workflow selection
   */
  function onWorkflowSelected(e) {
    const workflowId = e.target.value;

    if (!workflowId) {
      selectedWorkflow = null;
      executeWorkflowBtn.disabled = true;
      editWorkflowBtn.disabled = true;
      displayWorkflowSteps([]);
      return;
    }

    selectedWorkflow = workflows.find(w => w.id === workflowId);

    if (selectedWorkflow) {
      executeWorkflowBtn.disabled = false;
      editWorkflowBtn.disabled = false;
      displayWorkflowSteps(selectedWorkflow.steps);
      updateStatus(`Selected: ${selectedWorkflow.name}`, 'info');
    }
  }

  /**
   * Display workflow steps
   */
  function displayWorkflowSteps(steps) {
    if (!workflowStepsList) return;

    workflowStepsList.innerHTML = '';

    if (!steps || steps.length === 0) {
      const emptyState = document.createElement('div');
      emptyState.className = 'workflow-empty-state';
      emptyState.textContent = 'No workflow selected';
      workflowStepsList.appendChild(emptyState);
      return;
    }

    steps.forEach((step, index) => {
      const stepEl = document.createElement('div');
      stepEl.className = 'workflow-step-item';
      stepEl.innerHTML = `
        <span class="workflow-step-number">${index + 1}</span>
        <span class="workflow-step-name">${getStepName(step.type)}</span>
        <span class="workflow-step-status">${step.enabled ? 'âœ“' : '-'}</span>
      `;
      workflowStepsList.appendChild(stepEl);
    });
  }

  /**
   * Get friendly step name
   */
  function getStepName(type) {
    const names = {
      silence: 'Cut Silence',
      fillerWords: 'Remove Filler Words',
      zooms: 'Auto Zoom',
      captions: 'Generate Captions',
      chapters: 'Add Chapters',
      removeProfanity: 'Remove Profanity',
      music: 'Add Music'
    };
    return names[type] || type;
  }

  /**
   * Create new workflow
   */
  function createNewWorkflow() {
    // Check if WorkflowBuilder is available
    if (typeof WorkflowBuilder === 'undefined') {
      updateStatus('WorkflowBuilder not loaded', 'error');
      return;
    }

    // Open workflow builder in new window or modal
    // TODO: Implement workflow builder UI
    updateStatus('Opening workflow builder...', 'info');
    console.log('[Workflows] Create new workflow');
  }

  /**
   * Edit selected workflow
   */
  function editWorkflow() {
    if (!selectedWorkflow) {
      updateStatus('No workflow selected', 'warning');
      return;
    }

    // Check if WorkflowBuilder is available
    if (typeof WorkflowBuilder === 'undefined') {
      updateStatus('WorkflowBuilder not loaded', 'error');
      return;
    }

    // Open workflow builder with selected workflow
    // TODO: Implement workflow builder UI
    updateStatus(`Editing: ${selectedWorkflow.name}`, 'info');
    console.log('[Workflows] Edit workflow:', selectedWorkflow);
  }

  /**
   * Execute selected workflow
   */
  async function executeWorkflow() {
    if (!selectedWorkflow) {
      updateStatus('No workflow selected', 'warning');
      return;
    }

    if (isExecuting) {
      updateStatus('Workflow already running', 'warning');
      return;
    }

    try {
      isExecuting = true;
      executeWorkflowBtn.disabled = true;
      showProgress();

      updateStatus('Executing workflow...', 'info');

      // Get scope
      const scope = workflowScope ? workflowScope.value : 'entire_sequence';

      // Get active sequence
      const sequence = await getActiveSequence();
      if (!sequence) {
        throw new Error('No active sequence found');
      }

      // Call backend API to execute workflow
      const response = await fetch(`${getBackendUrl()}/workflows/${selectedWorkflow.id}/execute`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-stripe-customer-id': getCustomerId()
        },
        body: JSON.stringify({
          sequenceId: sequence.id,
          scope: scope
        })
      });

      if (!response.ok) {
        throw new Error(`Execution failed: ${response.statusText}`);
      }

      const result = await response.json();

      // Poll for execution status
      await pollExecutionStatus(result.executionId);

      updateStatus('Workflow completed successfully', 'success');

    } catch (error) {
      console.error('[Workflows] Execution error:', error);
      updateStatus(`Error: ${error.message}`, 'error');
    } finally {
      isExecuting = false;
      executeWorkflowBtn.disabled = false;
      hideProgress();
    }
  }

  /**
   * Poll execution status
   */
  async function pollExecutionStatus(executionId) {
    const pollInterval = 1000; // 1 second
    const maxPolls = 600; // 10 minutes max

    for (let i = 0; i < maxPolls; i++) {
      const response = await fetch(`${getBackendUrl()}/workflows/executions/${executionId}`, {
        method: 'GET',
        headers: {
          'x-stripe-customer-id': getCustomerId()
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to get execution status: ${response.statusText}`);
      }

      const execution = await response.json();

      // Update progress
      updateProgress(execution.progress, `Step ${execution.current_step}/${execution.total_steps}`);

      // Check status
      if (execution.status === 'completed') {
        return execution;
      } else if (execution.status === 'failed') {
        throw new Error(execution.error_message || 'Workflow failed');
      } else if (execution.status === 'cancelled') {
        throw new Error('Workflow was cancelled');
      }

      // Wait before next poll
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    throw new Error('Workflow execution timed out');
  }

  /**
   * Show progress bar
   */
  function showProgress() {
    if (workflowProgress) {
      workflowProgress.classList.remove('hidden');
    }
    updateProgress(0, 'Starting...');
  }

  /**
   * Hide progress bar
   */
  function hideProgress() {
    if (workflowProgress) {
      workflowProgress.classList.add('hidden');
    }
  }

  /**
   * Update progress bar
   */
  function updateProgress(percent, text) {
    if (workflowProgressBar) {
      workflowProgressBar.style.width = `${percent}%`;
    }
    if (workflowProgressText) {
      workflowProgressText.textContent = text;
    }
  }

  /**
   * Update status message
   */
  function updateStatus(message, type = 'info') {
    if (!workflowStatus) return;

    workflowStatus.textContent = message;
    workflowStatus.className = 'workflow-status ' + type;
    workflowStatus.style.display = 'block';
  }

  /**
   * Get active Premiere Pro sequence
   */
  async function getActiveSequence() {
    try {
      const ppro = require('premierepro');
      const project = await ppro.Project.getActiveProject();
      if (!project) {
        throw new Error('No active project found');
      }

      const sequence = await project.getActiveSequence();
      if (!sequence) {
        throw new Error('No active sequence found');
      }

      return {
        id: sequence.sequenceID,
        name: sequence.name
      };
    } catch (error) {
      console.error('[Workflows] Failed to get active sequence:', error);
      throw error;
    }
  }

  /**
   * Get authentication token
   */
  function getAuthToken() {
    return localStorage.getItem('authToken') || '';
  }

  /**
   * Get customer ID from settings
   */
  function getCustomerId() {
    if (typeof window.getSettings === 'function') {
      const settings = window.getSettings();
      return settings?.customerId || '';
    }
    const settingsStr = localStorage.getItem('spliceSettings');
    if (settingsStr) {
      try {
        const settings = JSON.parse(settingsStr);
        return settings.customerId || '';
      } catch (e) {
        console.warn('[Workflows] Failed to parse settings:', e);
      }
    }
    return '';
  }

  /**
   * Get backend URL helper
   */
  function getBackendUrl() {
    if (typeof window.getBackendUrl === 'function') {
      return window.getBackendUrl();
    }
    return 'https://splice-api-production.up.railway.app';
  }

  // Initialize on DOM load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Export for testing
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
      loadWorkflows,
      executeWorkflow
    };
  }
})();
