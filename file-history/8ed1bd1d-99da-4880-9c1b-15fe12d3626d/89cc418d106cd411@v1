/**
 * Auto Zoom with Face Detection
 * Based on FireCut's face detection system
 *
 * Features:
 * - Face detection using SSD MobileNet v1 or MTCNN
 * - Transcript synchronization
 * - Smooth zoom transitions
 * - Safe coordinate clamping (25% margin for 150% zoom)
 */

(function() {
  'use strict';

  // DOM Elements
  let zoomPanel = null;
  let zoomToggle = null;
  let detectFacesBtn = null;
  let applyZoomBtn = null;
  let zoomStatus = null;
  let zoomPreviewList = null;

  // Settings
  let detectionModel = 'ssd';
  let confidenceThreshold = 0.7;
  let zoomLevel = 150;
  let syncWithTranscript = true;
  let smoothTransitions = true;
  let transitionDuration = 0.3;

  // Detection results
  let detectedFaces = [];
  let currentSequence = null;

  /**
   * Initialize Auto Zoom UI
   */
  function init() {
    console.log('[AutoZoom] Initializing...');

    // Get DOM elements
    zoomPanel = document.getElementById('auto-zoom-panel');
    zoomToggle = document.getElementById('autoZoomToggle');
    detectFacesBtn = document.getElementById('detect-faces-btn');
    applyZoomBtn = document.getElementById('apply-zoom-btn');
    zoomStatus = document.getElementById('zoom-status');
    zoomPreviewList = document.getElementById('zoom-preview-list');

    if (!zoomPanel || !zoomToggle) {
      console.error('[AutoZoom] Required DOM elements not found');
      return;
    }

    // Setup event listeners
    setupEventListeners();

    console.log('[AutoZoom] Initialized successfully');
  }

  /**
   * Setup event listeners
   */
  function setupEventListeners() {
    // Toggle panel
    zoomToggle.addEventListener('click', togglePanel);

    // Detection model selector
    const modelSelect = document.getElementById('zoom-detection-model');
    if (modelSelect) {
      modelSelect.addEventListener('change', (e) => {
        detectionModel = e.target.value;
        console.log('[AutoZoom] Detection model changed:', detectionModel);
      });
    }

    // Confidence slider
    const confidenceSlider = document.getElementById('zoom-confidence-slider');
    const confidenceValue = document.getElementById('zoom-confidence-value');
    if (confidenceSlider && confidenceValue) {
      confidenceSlider.addEventListener('input', (e) => {
        confidenceThreshold = parseFloat(e.target.value);
        confidenceValue.textContent = confidenceThreshold.toFixed(1);
      });
    }

    // Zoom level slider
    const zoomSlider = document.getElementById('zoom-level-slider');
    const zoomValue = document.getElementById('zoom-level-value');
    if (zoomSlider && zoomValue) {
      zoomSlider.addEventListener('input', (e) => {
        zoomLevel = parseInt(e.target.value);
        zoomValue.textContent = zoomLevel;
      });
    }

    // Sync with transcript checkbox
    const syncCheckbox = document.getElementById('zoom-sync-transcript');
    if (syncCheckbox) {
      syncCheckbox.addEventListener('change', (e) => {
        syncWithTranscript = e.target.checked;
      });
    }

    // Smooth transitions checkbox
    const smoothCheckbox = document.getElementById('zoom-smooth-transitions');
    if (smoothCheckbox) {
      smoothCheckbox.addEventListener('change', (e) => {
        smoothTransitions = e.target.checked;
        updateTransitionGroup();
      });
    }

    // Transition duration slider
    const transitionSlider = document.getElementById('zoom-transition-slider');
    const transitionValue = document.getElementById('zoom-transition-value');
    if (transitionSlider && transitionValue) {
      transitionSlider.addEventListener('input', (e) => {
        transitionDuration = parseFloat(e.target.value);
        transitionValue.textContent = transitionDuration.toFixed(1);
      });
    }

    // Action buttons
    if (detectFacesBtn) {
      detectFacesBtn.addEventListener('click', detectFaces);
    }
    if (applyZoomBtn) {
      applyZoomBtn.addEventListener('click', applyZoom);
    }
  }

  /**
   * Toggle panel visibility
   */
  function togglePanel() {
    if (!zoomPanel) return;

    const isCollapsed = zoomPanel.classList.contains('collapsed');
    zoomPanel.classList.toggle('collapsed');

    const icon = zoomToggle.querySelector('.toggle-icon');
    if (icon) {
      icon.textContent = isCollapsed ? '-' : '+';
    }
  }

  /**
   * Update transition group visibility
   */
  function updateTransitionGroup() {
    const transitionGroup = document.getElementById('zoom-transition-group');
    if (transitionGroup) {
      transitionGroup.style.display = smoothTransitions ? 'block' : 'none';
    }
  }

  /**
   * Detect faces in active sequence
   */
  async function detectFaces() {
    try {
      updateStatus('Detecting faces...', 'info');
      detectFacesBtn.disabled = true;

      // Get active sequence
      currentSequence = await getActiveSequence();
      if (!currentSequence) {
        throw new Error('No active sequence found');
      }

      // TODO: Export video frames for detection
      // For now, simulate API call
      updateStatus('Analyzing video frames...', 'info');

      // Call backend face detection API
      const response = await fetch(`${window.API_BASE_URL}/zoom-pro/detect-faces`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${getAuthToken()}`
        },
        body: JSON.stringify({
          videoPath: '/path/to/video.mp4', // TODO: Get actual video path
          model: detectionModel,
          minConfidence: confidenceThreshold
        })
      });

      if (!response.ok) {
        throw new Error(`Detection failed: ${response.statusText}`);
      }

      const result = await response.json();
      detectedFaces = result.detections || [];

      updateStatus(`Detected ${detectedFaces.length} face(s)`, 'success');
      displayDetectionPreview(detectedFaces);
      applyZoomBtn.disabled = detectedFaces.length === 0;

    } catch (error) {
      console.error('[AutoZoom] Detection error:', error);
      updateStatus(`Error: ${error.message}`, 'error');
    } finally {
      detectFacesBtn.disabled = false;
    }
  }

  /**
   * Apply zoom to detected faces
   */
  async function applyZoom() {
    if (detectedFaces.length === 0) {
      updateStatus('No faces detected. Run detection first.', 'warning');
      return;
    }

    try {
      updateStatus('Applying auto zoom...', 'info');
      applyZoomBtn.disabled = true;

      // Get transcript for synchronization if enabled
      let transcript = null;
      if (syncWithTranscript) {
        updateStatus('Loading transcript...', 'info');
        transcript = await getTranscript();
      }

      // Apply zoom effects to sequence
      let applied = 0;
      for (const detection of detectedFaces) {
        const zoomData = {
          time: detection.time,
          box: detection.box,
          zoomLevel: zoomLevel,
          duration: smoothTransitions ? transitionDuration : 0
        };

        // Sync with transcript word if enabled
        if (transcript && syncWithTranscript) {
          const word = findClosestWord(transcript, detection.time);
          if (word) {
            zoomData.time = word.start;
            zoomData.duration = word.end - word.start;
          }
        }

        await applyZoomToClip(zoomData);
        applied++;

        updateStatus(`Applying zoom ${applied}/${detectedFaces.length}...`, 'info');
      }

      updateStatus(`Successfully applied ${applied} zoom effect(s)`, 'success');

    } catch (error) {
      console.error('[AutoZoom] Apply error:', error);
      updateStatus(`Error: ${error.message}`, 'error');
    } finally {
      applyZoomBtn.disabled = false;
    }
  }

  /**
   * Display detection preview
   */
  function displayDetectionPreview(faces) {
    if (!zoomPreviewList) return;

    zoomPreviewList.innerHTML = '';

    if (faces.length === 0) {
      zoomPreviewList.classList.add('hidden');
      return;
    }

    zoomPreviewList.classList.remove('hidden');

    const header = document.createElement('label');
    header.textContent = 'Detected Faces:';
    zoomPreviewList.appendChild(header);

    faces.forEach((face, index) => {
      const item = document.createElement('div');
      item.className = 'zoom-preview-item';
      item.innerHTML = `
        <span>Face ${index + 1}</span>
        <span>${face.time.toFixed(2)}s</span>
        <span>${(face.confidence * 100).toFixed(0)}%</span>
      `;
      zoomPreviewList.appendChild(item);
    });
  }

  /**
   * Update status message
   */
  function updateStatus(message, type = 'info') {
    if (!zoomStatus) return;

    zoomStatus.textContent = message;
    zoomStatus.className = 'zoom-status ' + type;
    zoomStatus.style.display = 'block';
  }

  /**
   * Get active Premiere Pro sequence
   */
  async function getActiveSequence() {
    try {
      const ppro = require('premierepro');
      const project = await ppro.Project.getActiveProject();
      if (!project) {
        throw new Error('No active project found');
      }

      const sequence = await project.getActiveSequence();
      if (!sequence) {
        throw new Error('No active sequence found');
      }

      return {
        id: sequence.sequenceID,
        name: sequence.name,
        duration: sequence.end / sequence.timebase,
        timebase: sequence.timebase,
        sequence: sequence // Keep reference for applying effects
      };
    } catch (error) {
      console.error('[AutoZoom] Failed to get active sequence:', error);
      throw error;
    }
  }

  /**
   * Get transcript from sequence
   */
  async function getTranscript() {
    // TODO: Implement transcript retrieval
    // For now, return mock data
    return {
      words: [
        { text: 'Hello', start: 0.0, end: 0.5 },
        { text: 'world', start: 0.6, end: 1.0 }
      ]
    };
  }

  /**
   * Find closest transcript word to given time
   */
  function findClosestWord(transcript, time) {
    if (!transcript || !transcript.words) return null;

    let closest = null;
    let minDiff = Infinity;

    for (const word of transcript.words) {
      const diff = Math.abs(word.start - time);
      if (diff < minDiff) {
        minDiff = diff;
        closest = word;
      }
    }

    return closest;
  }

  /**
   * Apply zoom effect to clip at given time
   */
  async function applyZoomToClip(zoomData) {
    // TODO: Implement Premiere Pro API call to apply motion effect
    console.log('[AutoZoom] Applying zoom:', zoomData);

    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  /**
   * Get authentication token
   */
  function getAuthToken() {
    // TODO: Implement token retrieval from auth system
    return localStorage.getItem('authToken') || '';
  }

  // Initialize on DOM load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Export for testing
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
      detectFaces,
      applyZoom
    };
  }
})();
