/**
 * Phase 5: Security E2E Tests
 *
 * Tests for:
 * 1. Path validation - preventing traversal attacks
 * 2. Command injection prevention - safe command execution
 * 3. DB pool limits - connection management
 * 4. Auth verification - customer ID validation
 */

const path = require('path');
const fs = require('fs');

// =============================================================================
// TEST FRAMEWORK
// =============================================================================

let passCount = 0;
let failCount = 0;

function test(name, fn) {
  try {
    const result = fn();
    if (result instanceof Promise) {
      return result.then(() => {
        passCount++;
        console.log(`  ✓ ${name}`);
      }).catch(err => {
        failCount++;
        console.log(`  ✗ ${name}`);
        console.log(`    Error: ${err.message}`);
      });
    }
    passCount++;
    console.log(`  ✓ ${name}`);
  } catch (err) {
    failCount++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${err.message}`);
  }
}

async function asyncTest(name, fn) {
  try {
    await fn();
    passCount++;
    console.log(`  ✓ ${name}`);
  } catch (err) {
    failCount++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${err.message}`);
  }
}

function assertEqual(actual, expected, message = '') {
  if (actual !== expected) {
    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

function assertTrue(condition, message = '') {
  if (!condition) {
    throw new Error(`${message}: Expected true, got false`);
  }
}

function assertFalse(condition, message = '') {
  if (condition) {
    throw new Error(`${message}: Expected false, got true`);
  }
}

function assertThrows(fn, message = '') {
  try {
    fn();
    throw new Error(`${message}: Expected function to throw, but it didn't`);
  } catch (err) {
    if (err.message.includes('Expected function to throw')) throw err;
    // Good - it threw as expected
  }
}

async function assertRejects(promise, message = '') {
  try {
    await promise;
    throw new Error(`${message}: Expected promise to reject, but it didn't`);
  } catch (err) {
    if (err.message.includes('Expected promise to reject')) throw err;
    // Good - it rejected as expected
  }
}

// =============================================================================
// SECURITY UTILS TESTS
// =============================================================================

console.log('\n=== Phase 5: Security E2E Tests ===\n');

console.log('1. Path Validation Tests');

const { validatePath, validateAudioPath, safeTempPath, ALLOWED_BASE_DIRS } = require('../services/securityUtils');

(async () => {
  // Test 1: Valid paths
  await asyncTest('should accept valid absolute path in /tmp', async () => {
    const testFile = '/tmp/test_audio.wav';
    // Create a temp file for testing
    fs.writeFileSync(testFile, 'test');
    const result = await validateAudioPath(testFile);
    assertTrue(result.valid, 'Should be valid');
    assertEqual(result.path, testFile, 'Path should match');
    fs.unlinkSync(testFile);
  });

  await asyncTest('should accept valid path in home directory', async () => {
    const homePath = process.env.HOME;
    const testFile = path.join(homePath, 'test_splice_audio.wav');
    fs.writeFileSync(testFile, 'test');
    const result = await validateAudioPath(testFile);
    assertTrue(result.valid, 'Should be valid');
    fs.unlinkSync(testFile);
  });

  // Test 2: Path traversal attacks
  await asyncTest('should reject path with .. traversal', async () => {
    const result = await validatePath('/tmp/../etc/passwd', { mustExist: false });
    // After normalization, this resolves to /etc/passwd which may not be under allowed dirs
    // depending on system config
    if (result.valid) {
      // If valid, the path should have been normalized
      assertFalse(result.path.includes('..'), 'Normalized path should not contain ..');
    }
  });

  await asyncTest('should reject path with null bytes', async () => {
    const result = await validatePath('/tmp/file\0.wav', { mustExist: false });
    assertFalse(result.valid, 'Should reject null bytes');
    assertTrue(result.error.includes('null bytes'), 'Error should mention null bytes');
  });

  // Test 3: Command injection characters
  await asyncTest('should reject path with backticks', async () => {
    const result = await validatePath('/tmp/file`whoami`.wav', { mustExist: false });
    assertFalse(result.valid, 'Should reject backticks');
    assertTrue(result.error.includes('dangerous'), 'Error should mention dangerous characters');
  });

  await asyncTest('should reject path with $() substitution', async () => {
    const result = await validatePath('/tmp/file$(cat /etc/passwd).wav', { mustExist: false });
    assertFalse(result.valid, 'Should reject command substitution');
  });

  await asyncTest('should reject path with semicolon', async () => {
    const result = await validatePath('/tmp/file;rm -rf /.wav', { mustExist: false });
    assertFalse(result.valid, 'Should reject semicolon');
  });

  await asyncTest('should reject path with pipe', async () => {
    const result = await validatePath('/tmp/file|cat.wav', { mustExist: false });
    assertFalse(result.valid, 'Should reject pipe');
  });

  // Test 4: Extension validation
  await asyncTest('should accept valid audio extensions', async () => {
    const testFile = '/tmp/test.wav';
    fs.writeFileSync(testFile, 'test');
    const result = await validateAudioPath(testFile);
    assertTrue(result.valid, 'Should accept .wav');
    fs.unlinkSync(testFile);
  });

  await asyncTest('should reject non-audio extensions', async () => {
    const testFile = '/tmp/test.exe';
    fs.writeFileSync(testFile, 'test');
    const result = await validateAudioPath(testFile);
    assertFalse(result.valid, 'Should reject .exe');
    fs.unlinkSync(testFile);
  });

  // Test 5: Non-existent files
  await asyncTest('should reject non-existent files when mustExist=true', async () => {
    const result = await validatePath('/tmp/nonexistent_file_12345.wav', { mustExist: true });
    assertFalse(result.valid, 'Should reject non-existent file');
    assertTrue(result.error.includes('not exist') || result.error.includes('not readable'), 'Error should mention file not found');
  });

  // Test 6: Safe temp path generation
  test('should generate unique temp paths', () => {
    const path1 = safeTempPath('test', '.raw');
    const path2 = safeTempPath('test', '.raw');
    assertTrue(path1 !== path2, 'Temp paths should be unique');
    assertTrue(path1.startsWith('/tmp/'), 'Should be in /tmp');
    assertTrue(path1.endsWith('.raw'), 'Should have correct extension');
  });

  // =============================================================================
  // DB POOL CONFIGURATION TESTS
  // =============================================================================

  console.log('\n2. Database Pool Configuration Tests');

  // Read usageTracking.js to verify pool configuration
  const usageTrackingSource = fs.readFileSync(path.join(__dirname, '../services/usageTracking.js'), 'utf8');

  test('should have max connections set', () => {
    assertTrue(usageTrackingSource.includes('max: 20'), 'Should have max: 20');
  });

  test('should have idle timeout set', () => {
    assertTrue(usageTrackingSource.includes('idleTimeoutMillis: 30000'), 'Should have idleTimeoutMillis: 30000');
  });

  test('should have connection timeout set', () => {
    assertTrue(usageTrackingSource.includes('connectionTimeoutMillis: 5000'), 'Should have connectionTimeoutMillis: 5000');
  });

  test('should have composite index for usage history', () => {
    assertTrue(usageTrackingSource.includes('idx_usage_log_customer_created'), 'Should have composite index');
  });

  // =============================================================================
  // COMMAND INJECTION PREVENTION TESTS
  // =============================================================================

  console.log('\n3. Command Injection Prevention Tests');

  // Verify ffprobeSilence.js uses safe execution
  const ffprobeSilenceSource = fs.readFileSync(path.join(__dirname, '../services/ffprobeSilence.js'), 'utf8');

  test('ffprobeSilence.js should use validateAudioPath', () => {
    assertTrue(ffprobeSilenceSource.includes('validateAudioPath'), 'Should validate audio path');
  });

  test('ffprobeSilence.js should use safeFFprobe', () => {
    assertTrue(ffprobeSilenceSource.includes('safeFFprobe'), 'Should use safe FFprobe execution');
  });

  test('ffprobeSilence.js should not use exec with string interpolation', () => {
    // Check that we don't have vulnerable patterns
    const hasVulnerableExec = /exec\s*\(\s*`/.test(ffprobeSilenceSource);
    assertFalse(hasVulnerableExec, 'Should not use exec with template literals');
  });

  // Verify rmsSilenceDetection.js uses safe execution
  const rmsSilenceSource = fs.readFileSync(path.join(__dirname, '../services/rmsSilenceDetection.js'), 'utf8');

  test('rmsSilenceDetection.js should use validateAudioPath', () => {
    assertTrue(rmsSilenceSource.includes('validateAudioPath'), 'Should validate audio path');
  });

  test('rmsSilenceDetection.js should use safeFFprobe', () => {
    assertTrue(rmsSilenceSource.includes('safeFFprobe'), 'Should use safe FFprobe execution');
  });

  test('rmsSilenceDetection.js should use safeFFmpeg', () => {
    assertTrue(rmsSilenceSource.includes('safeFFmpeg'), 'Should use safe FFmpeg execution');
  });

  test('rmsSilenceDetection.js should use safeTempPath', () => {
    assertTrue(rmsSilenceSource.includes('safeTempPath'), 'Should use safe temp path generation');
  });

  // Verify multitrackAnalysis.js uses safe execution
  const multitrackSource = fs.readFileSync(path.join(__dirname, '../services/multitrackAnalysis.js'), 'utf8');

  test('multitrackAnalysis.js should use validateAudioPath', () => {
    assertTrue(multitrackSource.includes('validateAudioPath'), 'Should validate audio path');
  });

  test('multitrackAnalysis.js should use safeFFprobe', () => {
    assertTrue(multitrackSource.includes('safeFFprobe'), 'Should use safe FFprobe execution');
  });

  test('multitrackAnalysis.js should use safeFFmpeg', () => {
    assertTrue(multitrackSource.includes('safeFFmpeg'), 'Should use safe FFmpeg execution');
  });

  test('multitrackAnalysis.js should use async file operations', () => {
    assertTrue(multitrackSource.includes('fsPromises.readFile'), 'Should use async readFile');
    assertTrue(multitrackSource.includes('fsPromises.unlink'), 'Should use async unlink');
  });

  // =============================================================================
  // SECURITY UTILS FUNCTION TESTS
  // =============================================================================

  console.log('\n4. Security Utils Integration Tests');

  const securityUtilsSource = fs.readFileSync(path.join(__dirname, '../services/securityUtils.js'), 'utf8');

  test('securityUtils.js should define ALLOWED_BASE_DIRS', () => {
    assertTrue(securityUtilsSource.includes('ALLOWED_BASE_DIRS'), 'Should define allowed directories');
  });

  test('securityUtils.js should export validatePath', () => {
    assertTrue(securityUtilsSource.includes('validatePath'), 'Should export validatePath');
  });

  test('securityUtils.js should export validateAudioPath', () => {
    assertTrue(securityUtilsSource.includes('validateAudioPath'), 'Should export validateAudioPath');
  });

  test('securityUtils.js should export safeFFprobe', () => {
    assertTrue(securityUtilsSource.includes('safeFFprobe'), 'Should export safeFFprobe');
  });

  test('securityUtils.js should export safeFFmpeg', () => {
    assertTrue(securityUtilsSource.includes('safeFFmpeg'), 'Should export safeFFmpeg');
  });

  test('securityUtils.js should check for dangerous characters', () => {
    assertTrue(securityUtilsSource.includes('dangerousChars'), 'Should check dangerous characters');
  });

  // =============================================================================
  // SUMMARY
  // =============================================================================

  console.log('\n=== Test Summary ===');
  console.log(`  Passed: ${passCount}`);
  console.log(`  Failed: ${failCount}`);
  console.log(`  Total: ${passCount + failCount}`);

  if (failCount > 0) {
    console.log('\n❌ Some tests failed');
    process.exit(1);
  } else {
    console.log('\n✓ All Phase 5 Security tests passed');
    process.exit(0);
  }
})();
