/**
 * Phase 3: Performance Optimization Tests
 *
 * Tests for:
 * - 3.1 Levenshtein Distance Algorithm Optimization
 * - 3.2 Array Spread in Hot Loop Fix
 * - 3.3 Database Round-Trip Reduction
 * - 3.4 Cache TTL for Transcription
 */

const assert = require('assert');

// Test helpers
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`✅ ${name}`);
    passed++;
  } catch (err) {
    console.log(`❌ ${name}`);
    console.log(`   Error: ${err.message}`);
    failed++;
  }
}

// eslint-disable-next-line no-unused-vars -- available for async tests
async function asyncTest(name, fn) {
  try {
    await fn();
    console.log(`✅ ${name}`);
    passed++;
  } catch (err) {
    console.log(`❌ ${name}`);
    console.log(`   Error: ${err.message}`);
    failed++;
  }
}

// =============================================================================
// 3.1 Levenshtein Distance Tests
// =============================================================================

console.log('\n=== 3.1 Levenshtein Distance Optimization ===\n');

const { levenshteinDistance, calculateSimilarity, detectStutters } = require('../services/repetitionDetection');

test('levenshtein: identical strings return 0', () => {
  assert.strictEqual(levenshteinDistance('hello', 'hello'), 0);
  assert.strictEqual(levenshteinDistance('', ''), 0);
  assert.strictEqual(levenshteinDistance('a', 'a'), 0);
});

test('levenshtein: empty string returns length', () => {
  assert.strictEqual(levenshteinDistance('', 'hello'), 5);
  assert.strictEqual(levenshteinDistance('hello', ''), 5);
});

test('levenshtein: single character operations', () => {
  assert.strictEqual(levenshteinDistance('hello', 'hallo'), 1); // substitution
  assert.strictEqual(levenshteinDistance('hello', 'hell'), 1);  // deletion
  assert.strictEqual(levenshteinDistance('hell', 'hello'), 1);  // insertion
});

test('levenshtein: multiple operations', () => {
  assert.strictEqual(levenshteinDistance('kitten', 'sitting'), 3);
  assert.strictEqual(levenshteinDistance('saturday', 'sunday'), 3);
});

test('levenshtein: long strings (100+ chars) work correctly', () => {
  const s1 = 'a'.repeat(100);
  const s2 = 'a'.repeat(100);
  assert.strictEqual(levenshteinDistance(s1, s2), 0);

  const s3 = 'a'.repeat(100);
  const s4 = 'b'.repeat(100);
  assert.strictEqual(levenshteinDistance(s3, s4), 100);
});

test('levenshtein: threshold early exit works', () => {
  // With threshold, should exit early
  const result = levenshteinDistance('abcdefghij', 'xxxxxxxxxx', 3);
  assert(result > 3, 'Should return value > threshold');
});

test('levenshtein: performance on 1000-word simulated transcript', () => {
  // Generate 1000 random words
  const words = [];
  for (let i = 0; i < 1000; i++) {
    words.push('word' + (i % 100));
  }

  // Simulate phrase comparison (100 comparisons)
  const startTime = Date.now();
  let count = 0;
  for (let i = 0; i < 100; i++) {
    for (let j = i + 1; j < Math.min(i + 10, 100); j++) {
      levenshteinDistance(words[i], words[j]);
      count++;
    }
  }
  const elapsed = Date.now() - startTime;

  console.log(`   Performed ${count} comparisons in ${elapsed}ms`);
  assert(elapsed < 100, `Expected < 100ms, got ${elapsed}ms`);
});

test('calculateSimilarity: uses optimized levenshtein', () => {
  const arr1 = ['hello', 'world', 'test'];
  const arr2 = ['hello', 'world', 'test'];
  assert.strictEqual(calculateSimilarity(arr1, arr2), 1.0);

  const arr3 = ['hallo', 'world', 'test'];  // one char diff
  const sim = calculateSimilarity(arr1, arr3);
  assert(sim > 0.9 && sim < 1.0, `Expected 0.9 < ${sim} < 1.0`);
});

test('stutter detection: 1000-word transcript in < 10ms', () => {
  // Generate transcript with some stutters
  const words = [];
  for (let i = 0; i < 1000; i++) {
    if (i % 50 === 0) {
      // Add stutters every 50 words
      words.push({ word: 'the', start: i * 0.5, end: i * 0.5 + 0.3 });
      words.push({ word: 'the', start: i * 0.5 + 0.35, end: i * 0.5 + 0.65 });
      words.push({ word: 'the', start: i * 0.5 + 0.7, end: i * 0.5 + 1.0 });
    } else {
      words.push({ word: `word${i}`, start: i * 0.5, end: i * 0.5 + 0.4 });
    }
  }

  const startTime = Date.now();
  const result = detectStutters({ words });
  const elapsed = Date.now() - startTime;

  console.log(`   Detected ${result.stutters.length} stutters in ${elapsed}ms`);
  assert(elapsed < 10, `Expected < 10ms, got ${elapsed}ms`);
  assert(result.stutters.length > 0, 'Should detect stutters');
});

// =============================================================================
// 3.2 Array Spread Tests
// =============================================================================

console.log('\n=== 3.2 Array Spread in Hot Loop ===\n');

const rmsSilence = require('../services/rmsSilenceDetection');

test('RMS: computeDBFSStats works for large arrays', () => {
  // Test that we can process arrays > 100k elements without stack overflow
  const largeArray = new Float32Array(500000);
  for (let i = 0; i < largeArray.length; i++) {
    largeArray[i] = -50 + Math.random() * 50;
  }

  // This should NOT throw "Maximum call stack size exceeded"
  let minDB = Infinity, maxDB = -Infinity, sum = 0;
  for (const v of largeArray) {
    if (v < minDB) minDB = v;
    if (v > maxDB) maxDB = v;
    sum += v;
  }
  const avgDB = sum / largeArray.length;

  assert(minDB < maxDB, 'minDB should be less than maxDB');
  assert(avgDB > -100 && avgDB < 0, 'avgDB should be reasonable');
});

test('RMS: push pattern is more efficient than concat', () => {
  // Simulate the chunked processing pattern
  let allValues = [];
  for (let chunk = 0; chunk < 100; chunk++) {
    const chunkData = Array.from({ length: 1000 }, () => Math.random());
    // New pattern: direct push instead of concat
    for (let k = 0; k < chunkData.length; k++) {
      allValues.push(chunkData[k]);
    }
  }

  assert.strictEqual(allValues.length, 100000);
});

test('RMS: calculateRMSWindows does not overflow stack', () => {
  // Create a large sample array (simulating 30 min of 16kHz audio)
  // 30 min * 60 sec * 16000 samples = 28,800,000 samples
  // But we'll use a smaller size for test speed
  const samples = new Float32Array(160000); // ~10 seconds
  for (let i = 0; i < samples.length; i++) {
    samples[i] = Math.sin(i / 100) * 0.5;
  }

  // This should not throw
  const rmsValues = rmsSilence.calculateRMSWindows(samples, {
    windowSize: 800,
    hopSize: 400
  });

  assert(rmsValues.length > 0, 'Should produce RMS values');
  console.log(`   Processed ${samples.length} samples into ${rmsValues.length} RMS windows`);
});

test('RMS: rmsToDBFS handles edge cases', () => {
  assert.strictEqual(rmsSilence.rmsToDBFS(0), -100);
  assert.strictEqual(rmsSilence.rmsToDBFS(-1), -100);
  assert.strictEqual(rmsSilence.rmsToDBFS(1), 0);
  assert(rmsSilence.rmsToDBFS(0.5) < 0, 'Half amplitude should be negative dBFS');
});

// =============================================================================
// 3.3 Database Round-Trip Tests
// =============================================================================

console.log('\n=== 3.3 Database Round-Trip Reduction ===\n');

// These tests verify the RETURNING clause is used
const usageTrackingPath = require.resolve('../services/usageTracking');
const usageTrackingSource = require('fs').readFileSync(usageTrackingPath, 'utf-8');

test('deductUsage: should use RETURNING clause', () => {
  // Check if the pattern `RETURNING` is used after UPDATE in deductUsage
  const deductFnMatch = usageTrackingSource.match(/async function deductUsage[\s\S]*?finally\s*\{[\s\S]*?\}/);
  assert(deductFnMatch, 'deductUsage function not found');

  const fnBody = deductFnMatch[0];
  const hasReturning = fnBody.includes('RETURNING');
  const hasGetBalance = fnBody.includes('getBalance(');

  console.log(`   RETURNING clause in deductUsage: ${hasReturning}`);
  console.log(`   Avoids getBalance call: ${!hasGetBalance}`);

  assert(hasReturning, 'deductUsage should use RETURNING clause');
  assert(!hasGetBalance, 'deductUsage should NOT call getBalance (uses RETURNING instead)');
});

test('resetHours: should use RETURNING clause', () => {
  const fnMatch = usageTrackingSource.match(/async function resetHours[\s\S]*?^}/m);
  assert(fnMatch, 'resetHours function not found');

  const hasReturning = fnMatch[0].includes('RETURNING');
  console.log(`   RETURNING clause in resetHours: ${hasReturning}`);
  assert(hasReturning, 'resetHours should use RETURNING clause');
});

test('updateTier: should use upsert with RETURNING', () => {
  const fnMatch = usageTrackingSource.match(/async function updateTier[\s\S]*?^}/m);
  assert(fnMatch, 'updateTier function not found');

  const fnBody = fnMatch[0];
  const hasUpsert = fnBody.includes('ON CONFLICT');
  const hasReturning = fnBody.includes('RETURNING');
  const noCheckExists = !fnBody.includes('SELECT * FROM users WHERE');

  console.log(`   Uses upsert (ON CONFLICT): ${hasUpsert}`);
  console.log(`   RETURNING clause: ${hasReturning}`);
  console.log(`   No separate SELECT check: ${noCheckExists}`);

  assert(hasUpsert, 'updateTier should use ON CONFLICT upsert');
  assert(hasReturning, 'updateTier should use RETURNING');
});

test('PERF-005: getOrCreateUser should use single-query upsert', () => {
  // Match the getOrCreateUser function
  const fnMatch = usageTrackingSource.match(/async function getOrCreateUser[\s\S]*?return result\.rows\[0\];\s*}/);
  assert(fnMatch, 'getOrCreateUser function not found');

  const fnBody = fnMatch[0];
  const hasUpsert = fnBody.includes('ON CONFLICT');
  const hasReturning = fnBody.includes('RETURNING');
  const noSeparateSelect = !fnBody.includes('SELECT * FROM users WHERE');
  const noClientConnect = !fnBody.includes('pool.connect()');

  console.log(`   Uses upsert (ON CONFLICT): ${hasUpsert}`);
  console.log(`   RETURNING clause: ${hasReturning}`);
  console.log(`   No separate SELECT: ${noSeparateSelect}`);
  console.log(`   No pool.connect() (uses pool.query): ${noClientConnect}`);

  assert(hasUpsert, 'getOrCreateUser should use ON CONFLICT upsert');
  assert(hasReturning, 'getOrCreateUser should use RETURNING');
  assert(noSeparateSelect, 'getOrCreateUser should NOT have separate SELECT query');
  assert(noClientConnect, 'getOrCreateUser should use pool.query() not pool.connect()');
});

test('confirmReservation: should minimize database calls', () => {
  // Count how many times getBalance is called
  const fnMatch = usageTrackingSource.match(/async function confirmReservation[\s\S]*?finally\s*\{[\s\S]*?\}/);
  assert(fnMatch, 'confirmReservation function not found');

  const fnBody = fnMatch[0];
  const getBalanceCalls = (fnBody.match(/getBalance\(/g) || []).length;
  const hasReturning = fnBody.includes('RETURNING');

  console.log(`   getBalance calls in confirmReservation: ${getBalanceCalls}`);
  console.log(`   Uses RETURNING: ${hasReturning}`);

  assert(getBalanceCalls === 0, 'confirmReservation should NOT call getBalance');
  assert(hasReturning, 'confirmReservation should use RETURNING');
});

test('releaseReservation: should minimize database calls', () => {
  const fnMatch = usageTrackingSource.match(/async function releaseReservation[\s\S]*?finally\s*\{[\s\S]*?\}/);
  assert(fnMatch, 'releaseReservation function not found');

  const fnBody = fnMatch[0];
  const getBalanceCalls = (fnBody.match(/getBalance\(/g) || []).length;
  const hasReturning = fnBody.includes('RETURNING');

  console.log(`   getBalance calls in releaseReservation: ${getBalanceCalls}`);
  console.log(`   Uses RETURNING: ${hasReturning}`);

  assert(getBalanceCalls === 0, 'releaseReservation should NOT call getBalance');
  assert(hasReturning, 'releaseReservation should use RETURNING');
});

// =============================================================================
// 3.4 Cache TTL Tests
// =============================================================================

console.log('\n=== 3.4 Cache TTL for Transcription ===\n');

const transcriptionPath = require.resolve('../services/transcription');
const transcriptionSource = require('fs').readFileSync(transcriptionPath, 'utf-8');

test('transcription cache: has TTL configuration', () => {
  const hasTTL = transcriptionSource.includes('CACHE_TTL_MS');
  const hasCleanup = transcriptionSource.includes('cleanExpiredEntries');
  console.log(`   TTL constant present: ${hasTTL}`);
  console.log(`   Cleanup function present: ${hasCleanup}`);
  assert(hasTTL, 'Should have CACHE_TTL_MS constant');
  assert(hasCleanup, 'Should have cleanExpiredEntries function');
});

test('transcription cache: has cachedAt timestamp', () => {
  const hasCachedAt = transcriptionSource.includes('cachedAt');
  const hasCacheGet = transcriptionSource.includes('function cacheGet');
  console.log(`   cachedAt timestamp used: ${hasCachedAt}`);
  console.log(`   cacheGet function present: ${hasCacheGet}`);
  assert(hasCachedAt, 'Should track cachedAt timestamp');
  assert(hasCacheGet, 'Should have TTL-aware cacheGet function');
});

test('transcription cache: TTL-aware cacheGet implementation', () => {
  // Verify cacheGet checks TTL
  const cacheGetMatch = transcriptionSource.match(/function cacheGet[\s\S]*?^}/m);
  assert(cacheGetMatch, 'cacheGet function not found');

  const fnBody = cacheGetMatch[0];
  const checksTTL = fnBody.includes('CACHE_TTL_MS');
  const deletesExpired = fnBody.includes('transcriptCache.delete');

  console.log(`   cacheGet checks TTL: ${checksTTL}`);
  console.log(`   cacheGet deletes expired: ${deletesExpired}`);

  assert(checksTTL, 'cacheGet should check CACHE_TTL_MS');
  assert(deletesExpired, 'cacheGet should delete expired entries');
});

test('transcription cache: LRU eviction works', () => {
  // Mock OPENAI_API_KEY to allow module load
  const originalKey = process.env.OPENAI_API_KEY;
  process.env.OPENAI_API_KEY = 'test-key-for-cache-test';

  try {
    // Clear require cache to reload with mocked key
    delete require.cache[require.resolve('../services/transcription')];
    const { clearCache, getCacheStats } = require('../services/transcription');

    // Clear cache first
    clearCache();

    const stats = getCacheStats();
    assert.strictEqual(stats.entries, 0, 'Cache should be empty after clear');
    assert(stats.ttlMs > 0, 'Should report TTL in ms');
    assert(stats.ttlMinutes > 0, 'Should report TTL in minutes');
    console.log(`   TTL configured: ${stats.ttlMinutes} minutes`);
  } finally {
    // Restore original key
    if (originalKey) {
      process.env.OPENAI_API_KEY = originalKey;
    } else {
      delete process.env.OPENAI_API_KEY;
    }
  }
});

test('transcription cache: getCacheStats includes TTL info', () => {
  const originalKey = process.env.OPENAI_API_KEY;
  process.env.OPENAI_API_KEY = 'test-key-for-cache-test';

  try {
    delete require.cache[require.resolve('../services/transcription')];
    const { getCacheStats } = require('../services/transcription');

    const stats = getCacheStats();
    assert('ttlMs' in stats, 'Stats should include ttlMs');
    assert('ttlMinutes' in stats, 'Stats should include ttlMinutes');
    assert('maxSize' in stats, 'Stats should include maxSize');
    assert('details' in stats, 'Stats should include details array');
    console.log(`   Stats fields: ttlMs=${stats.ttlMs}, maxSize=${stats.maxSize}`);
  } finally {
    if (originalKey) {
      process.env.OPENAI_API_KEY = originalKey;
    } else {
      delete process.env.OPENAI_API_KEY;
    }
  }
});

// =============================================================================
// 3.5 PERF-008: Auto-Balance Level Caching
// =============================================================================

console.log('\n=== 3.5 PERF-008: Auto-Balance Level Caching ===\n');

const multitrackPath = require.resolve('../services/multitrackAnalysis');
const multitrackSource = require('fs').readFileSync(multitrackPath, 'utf-8');

test('PERF-008: analyzeMultitrackFromLevels function exists', () => {
  const fnMatch = multitrackSource.match(/function analyzeMultitrackFromLevels\s*\([^)]*\)/);
  assert(fnMatch, 'analyzeMultitrackFromLevels function should exist');
  console.log(`   Function found: ${fnMatch[0].substring(0, 50)}...`);
});

test('PERF-008: analyzeMultitrackFromLevels is exported', () => {
  const multitrack = require('../services/multitrackAnalysis');
  assert(typeof multitrack.analyzeMultitrackFromLevels === 'function',
    'analyzeMultitrackFromLevels should be exported');
  console.log('   Function is exported and callable');
});

test('PERF-008: autoBalanceMultitrack caches levels', () => {
  const fnMatch = multitrackSource.match(/async function autoBalanceMultitrack[\s\S]*?return \{[\s\S]*?\};[\s\r\n]*\}/);
  assert(fnMatch, 'autoBalanceMultitrack function not found');

  const fnBody = fnMatch[0];
  const hasCachedLevels = fnBody.includes('cachedLevels');
  const extractsOnce = (fnBody.match(/extractTrackLevels/g) || []).length === 1;
  const usesFromLevels = fnBody.includes('analyzeMultitrackFromLevels');
  const noRepeatedAnalyze = !fnBody.includes('await analyzeMultitrack(audioPaths');

  console.log(`   Uses cachedLevels variable: ${hasCachedLevels}`);
  console.log(`   Extracts levels once: ${extractsOnce}`);
  console.log(`   Uses analyzeMultitrackFromLevels: ${usesFromLevels}`);
  console.log(`   No repeated analyzeMultitrack calls: ${noRepeatedAnalyze}`);

  assert(hasCachedLevels, 'Should use cachedLevels variable');
  assert(extractsOnce, 'Should call extractTrackLevels only once');
  assert(usesFromLevels, 'Should use analyzeMultitrackFromLevels in loop');
  assert(noRepeatedAnalyze, 'Should NOT call analyzeMultitrack(audioPaths) repeatedly');
});

test('PERF-008: analyzeMultitrackFromLevels skips FFmpeg', () => {
  const fnMatch = multitrackSource.match(/function analyzeMultitrackFromLevels[\s\S]*?return \{[\s\S]*?\};[\s\r\n]*\}/);
  assert(fnMatch, 'analyzeMultitrackFromLevels function not found');

  const fnBody = fnMatch[0];
  const noExtractCall = !fnBody.includes('extractTrackLevels');
  const noFFmpeg = !fnBody.includes('safeFFmpeg') && !fnBody.includes('safeFFprobe');
  const noAwait = !fnBody.includes('await ');

  console.log(`   No extractTrackLevels call: ${noExtractCall}`);
  console.log(`   No FFmpeg calls: ${noFFmpeg}`);
  console.log(`   Synchronous (no await): ${noAwait}`);

  assert(noExtractCall, 'Should not call extractTrackLevels');
  assert(noFFmpeg, 'Should not call FFmpeg');
  assert(noAwait, 'Should be synchronous (no async I/O)');
});

// =============================================================================
// Summary
// =============================================================================

console.log('\n' + '='.repeat(50));
console.log(`Phase 3 Performance Tests: ${passed} passed, ${failed} failed`);
console.log('='.repeat(50) + '\n');

process.exit(failed > 0 ? 1 : 0);
