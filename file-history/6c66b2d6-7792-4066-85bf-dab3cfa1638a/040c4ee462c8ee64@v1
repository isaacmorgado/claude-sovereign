'use client';

import { useMemo, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Eye, ZoomIn, ZoomOut, Maximize2 } from 'lucide-react';
import { LandmarkPoint } from '@/lib/landmarks';
import { Ratio, getScoreColor, getCategoryColor } from '@/types/results';

interface FaceOverlayProps {
  photo: string;
  landmarks: LandmarkPoint[];
  selectedRatio: Ratio | null;
  profileType: 'front' | 'side';
  showAllLandmarks?: boolean;
  compact?: boolean; // For smaller inline previews
}

// Calculate label position along a line
function getLabelPosition(
  x1: number, y1: number, x2: number, y2: number,
  position: 'start' | 'middle' | 'end' = 'middle'
): { x: number; y: number; anchor: string } {
  const t = position === 'start' ? 0.15 : position === 'end' ? 0.85 : 0.5;
  const x = x1 + (x2 - x1) * t;
  const y = y1 + (y2 - y1) * t;

  // Calculate perpendicular offset for label
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.sqrt(dx * dx + dy * dy);
  const offsetX = len > 0 ? (-dy / len) * 2.5 : 0;
  const offsetY = len > 0 ? (dx / len) * 2.5 : 0;

  return {
    x: x + offsetX,
    y: y + offsetY,
    anchor: dx > 0 ? 'start' : 'end'
  };
}

// Calculate angle between three points (in degrees)
function calculateAngle(p1: { x: number; y: number }, vertex: { x: number; y: number }, p3: { x: number; y: number }): number {
  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
  const v2 = { x: p3.x - vertex.x, y: p3.y - vertex.y };

  const dot = v1.x * v2.x + v1.y * v2.y;
  const cross = v1.x * v2.y - v1.y * v2.x;

  return Math.atan2(Math.abs(cross), dot) * (180 / Math.PI);
}

export function FaceOverlay({
  photo,
  landmarks,
  selectedRatio,
  profileType,
  showAllLandmarks = false,
  compact = false,
}: FaceOverlayProps) {
  const [zoom, setZoom] = useState(1);

  // Get landmark positions by ID
  const landmarkMap = useMemo(() => {
    const map: Record<string, LandmarkPoint> = {};
    landmarks.forEach(l => {
      map[l.id] = l;
    });
    return map;
  }, [landmarks]);

  // Get lines, points, and labels to draw for selected ratio
  const visualizationData = useMemo(() => {
    if (!selectedRatio?.illustration) return null;

    const points: Array<{ x: number; y: number; id: string; label?: string }> = [];
    const lines: Array<{
      x1: number; y1: number; x2: number; y2: number;
      color: string; label?: string; labelPosition?: 'start' | 'middle' | 'end'
    }> = [];
    const angles: Array<{
      vertex: { x: number; y: number };
      p1: { x: number; y: number };
      p2: { x: number; y: number };
      color: string;
      angle: number;
    }> = [];

    // Process points
    Object.entries(selectedRatio.illustration.points).forEach(([key, point]) => {
      if (point.type === 'landmark' && point.landmarkId) {
        const landmark = landmarkMap[point.landmarkId];
        if (landmark) {
          points.push({
            x: landmark.x * 100,
            y: landmark.y * 100,
            id: point.landmarkId,
            label: landmark.label,
          });
        }
      } else if (point.x !== undefined && point.y !== undefined) {
        points.push({
          x: point.x * 100,
          y: point.y * 100,
          id: key,
          label: point.label,
        });
      }
    });

    // Process lines
    Object.entries(selectedRatio.illustration.lines).forEach(([, line]) => {
      const fromLandmark = landmarkMap[line.from];
      const toLandmark = landmarkMap[line.to];

      if (fromLandmark && toLandmark) {
        lines.push({
          x1: fromLandmark.x * 100,
          y1: fromLandmark.y * 100,
          x2: toLandmark.x * 100,
          y2: toLandmark.y * 100,
          color: line.color || getCategoryColor(selectedRatio.category),
          label: line.label,
          labelPosition: line.labelPosition,
        });
      }
    });

    // Detect if this is an angle measurement (3 connected points forming an angle)
    // Look for patterns like: line1 ends where line2 starts (shared vertex)
    if (lines.length === 2) {
      const l1 = lines[0];
      const l2 = lines[1];

      // Check for shared vertex
      let sharedVertex: { x: number; y: number } | null = null;
      let p1: { x: number; y: number } | null = null;
      let p2: { x: number; y: number } | null = null;

      // l1 end connects to l2 start
      if (Math.abs(l1.x2 - l2.x1) < 0.5 && Math.abs(l1.y2 - l2.y1) < 0.5) {
        sharedVertex = { x: l1.x2, y: l1.y2 };
        p1 = { x: l1.x1, y: l1.y1 };
        p2 = { x: l2.x2, y: l2.y2 };
      }
      // l1 start connects to l2 start
      else if (Math.abs(l1.x1 - l2.x1) < 0.5 && Math.abs(l1.y1 - l2.y1) < 0.5) {
        sharedVertex = { x: l1.x1, y: l1.y1 };
        p1 = { x: l1.x2, y: l1.y2 };
        p2 = { x: l2.x2, y: l2.y2 };
      }
      // l1 end connects to l2 end
      else if (Math.abs(l1.x2 - l2.x2) < 0.5 && Math.abs(l1.y2 - l2.y2) < 0.5) {
        sharedVertex = { x: l1.x2, y: l1.y2 };
        p1 = { x: l1.x1, y: l1.y1 };
        p2 = { x: l2.x1, y: l2.y1 };
      }
      // l1 start connects to l2 end
      else if (Math.abs(l1.x1 - l2.x2) < 0.5 && Math.abs(l1.y1 - l2.y2) < 0.5) {
        sharedVertex = { x: l1.x1, y: l1.y1 };
        p1 = { x: l1.x2, y: l1.y2 };
        p2 = { x: l2.x1, y: l2.y1 };
      }

      if (sharedVertex && p1 && p2) {
        const angle = calculateAngle(p1, sharedVertex, p2);
        angles.push({
          vertex: sharedVertex,
          p1,
          p2,
          color: l1.color,
          angle,
        });
      }
    }

    return { points, lines, angles };
  }, [selectedRatio, landmarkMap]);

  // Generate arc path for angle visualization
  const generateArcPath = (
    vertex: { x: number; y: number },
    p1: { x: number; y: number },
    p2: { x: number; y: number },
    radius: number = 4
  ): string => {
    // Calculate angles for the arc
    const angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
    const angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);

    // Arc endpoints
    const x1 = vertex.x + radius * Math.cos(angle1);
    const y1 = vertex.y + radius * Math.sin(angle1);
    const x2 = vertex.x + radius * Math.cos(angle2);
    const y2 = vertex.y + radius * Math.sin(angle2);

    // Determine if we should use the large arc
    let angleDiff = angle2 - angle1;
    if (angleDiff < 0) angleDiff += 2 * Math.PI;
    const largeArc = angleDiff > Math.PI ? 1 : 0;

    return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`;
  };

  return (
    <div className={`bg-neutral-900/80 border border-neutral-800 rounded-xl overflow-hidden ${compact ? 'text-xs' : ''}`}>
      {/* Header */}
      {!compact && (
        <div className="p-3 border-b border-neutral-800 flex items-center justify-between">
          <h4 className="text-sm font-medium text-white">
            {profileType === 'front' ? 'Front' : 'Side'} Profile
          </h4>
          <div className="flex items-center gap-1">
            <button
              onClick={() => setZoom(z => Math.max(1, z - 0.25))}
              className="p-1.5 hover:bg-neutral-800 rounded transition-colors"
              disabled={zoom <= 1}
            >
              <ZoomOut size={16} className={zoom <= 1 ? 'text-neutral-700' : 'text-neutral-500'} />
            </button>
            <span className="text-xs text-neutral-500 w-10 text-center">{Math.round(zoom * 100)}%</span>
            <button
              onClick={() => setZoom(z => Math.min(2, z + 0.25))}
              className="p-1.5 hover:bg-neutral-800 rounded transition-colors"
              disabled={zoom >= 2}
            >
              <ZoomIn size={16} className={zoom >= 2 ? 'text-neutral-700' : 'text-neutral-500'} />
            </button>
            {zoom !== 1 && (
              <button
                onClick={() => setZoom(1)}
                className="p-1.5 hover:bg-neutral-800 rounded transition-colors ml-1"
              >
                <Maximize2 size={16} className="text-neutral-500" />
              </button>
            )}
          </div>
        </div>
      )}

      {/* Image container */}
      <div className={`relative ${compact ? 'aspect-square' : 'aspect-[3/4]'} bg-neutral-950 overflow-hidden`}>
        {/* Photo with zoom */}
        <div
          className="absolute inset-0 transition-transform duration-200 ease-out"
          style={{
            transform: `scale(${zoom})`,
            transformOrigin: 'center center'
          }}
        >
          <img
            src={photo}
            alt={`${profileType} profile`}
            className="w-full h-full object-cover"
          />

          {/* SVG Overlay */}
          <svg
            className="absolute inset-0 w-full h-full pointer-events-none"
            viewBox="0 0 100 100"
            preserveAspectRatio="none"
          >
            {/* Defs for filters and gradients */}
            <defs>
              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="0.5" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <filter id="dropShadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0" dy="0" stdDeviation="0.3" floodOpacity="0.8"/>
              </filter>
            </defs>

            {/* All landmarks (optional) */}
            {showAllLandmarks && landmarks.map((landmark) => (
              <circle
                key={landmark.id}
                cx={landmark.x * 100}
                cy={landmark.y * 100}
                r="0.5"
                fill="#67e8f9"
                opacity="0.3"
              />
            ))}

            {/* Selected ratio visualization */}
            <AnimatePresence>
              {visualizationData && (
                <g filter="url(#glow)">
                  {/* Lines with glow effect */}
                  {visualizationData.lines.map((line, i) => (
                    <g key={`line-group-${i}`}>
                      {/* Glow/shadow line */}
                      <motion.line
                        x1={line.x1}
                        y1={line.y1}
                        x2={line.x2}
                        y2={line.y2}
                        stroke={line.color}
                        strokeWidth="1.2"
                        strokeLinecap="round"
                        opacity="0.3"
                        initial={{ pathLength: 0 }}
                        animate={{ pathLength: 1 }}
                        exit={{ pathLength: 0 }}
                        transition={{ duration: 0.5 }}
                      />
                      {/* Main line */}
                      <motion.line
                        x1={line.x1}
                        y1={line.y1}
                        x2={line.x2}
                        y2={line.y2}
                        stroke={line.color}
                        strokeWidth="0.5"
                        strokeLinecap="round"
                        initial={{ pathLength: 0, opacity: 0 }}
                        animate={{ pathLength: 1, opacity: 1 }}
                        exit={{ pathLength: 0, opacity: 0 }}
                        transition={{ duration: 0.5 }}
                      />
                      {/* Line label */}
                      {line.label && !compact && (
                        <motion.g
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          exit={{ opacity: 0 }}
                          transition={{ delay: 0.3 }}
                        >
                          {(() => {
                            const labelPos = getLabelPosition(
                              line.x1, line.y1, line.x2, line.y2,
                              line.labelPosition || 'middle'
                            );
                            return (
                              <>
                                {/* Label background */}
                                <rect
                                  x={labelPos.x - 3}
                                  y={labelPos.y - 1.2}
                                  width={line.label.length * 1.1 + 2}
                                  height={2.4}
                                  fill="rgba(0,0,0,0.7)"
                                  rx="0.5"
                                />
                                {/* Label text */}
                                <text
                                  x={labelPos.x}
                                  y={labelPos.y}
                                  fill={line.color}
                                  fontSize="1.8"
                                  fontWeight="600"
                                  fontFamily="system-ui, sans-serif"
                                  dominantBaseline="middle"
                                  textAnchor="start"
                                >
                                  {line.label}
                                </text>
                              </>
                            );
                          })()}
                        </motion.g>
                      )}
                    </g>
                  ))}

                  {/* Angle arcs */}
                  {visualizationData.angles.map((angle, i) => (
                    <motion.g key={`angle-${i}`}>
                      {/* Arc */}
                      <motion.path
                        d={generateArcPath(angle.vertex, angle.p1, angle.p2, 5)}
                        fill="none"
                        stroke={angle.color}
                        strokeWidth="0.4"
                        strokeDasharray="1 0.5"
                        initial={{ pathLength: 0, opacity: 0 }}
                        animate={{ pathLength: 1, opacity: 0.8 }}
                        exit={{ pathLength: 0, opacity: 0 }}
                        transition={{ duration: 0.5, delay: 0.2 }}
                      />
                      {/* Angle value label */}
                      {!compact && (
                        <motion.g
                          initial={{ opacity: 0, scale: 0 }}
                          animate={{ opacity: 1, scale: 1 }}
                          exit={{ opacity: 0, scale: 0 }}
                          transition={{ delay: 0.5 }}
                        >
                          <rect
                            x={angle.vertex.x + 2}
                            y={angle.vertex.y - 3}
                            width={5}
                            height={2.5}
                            fill="rgba(0,0,0,0.8)"
                            rx="0.5"
                          />
                          <text
                            x={angle.vertex.x + 4.5}
                            y={angle.vertex.y - 1.5}
                            fill={angle.color}
                            fontSize="1.8"
                            fontWeight="bold"
                            fontFamily="system-ui, sans-serif"
                            textAnchor="middle"
                            dominantBaseline="middle"
                          >
                            {Math.round(angle.angle)}Â°
                          </text>
                        </motion.g>
                      )}
                    </motion.g>
                  ))}

                  {/* Points with enhanced styling */}
                  {visualizationData.points.map((point, i) => (
                    <motion.g
                      key={`point-${i}`}
                      initial={{ scale: 0, opacity: 0 }}
                      animate={{ scale: 1, opacity: 1 }}
                      exit={{ scale: 0, opacity: 0 }}
                      transition={{ duration: 0.3, delay: i * 0.05 }}
                    >
                      {/* Outer glow pulse */}
                      <motion.circle
                        cx={point.x}
                        cy={point.y}
                        r="2"
                        fill={getCategoryColor(selectedRatio?.category || '')}
                        opacity="0.15"
                        animate={{
                          r: [2, 2.5, 2],
                          opacity: [0.15, 0.25, 0.15]
                        }}
                        transition={{
                          duration: 2,
                          repeat: Infinity,
                          ease: "easeInOut"
                        }}
                      />
                      {/* Outer ring */}
                      <circle
                        cx={point.x}
                        cy={point.y}
                        r="1.2"
                        fill="none"
                        stroke={getCategoryColor(selectedRatio?.category || '')}
                        strokeWidth="0.2"
                        opacity="0.5"
                      />
                      {/* Inner dot */}
                      <circle
                        cx={point.x}
                        cy={point.y}
                        r="0.6"
                        fill="#fff"
                        stroke={getCategoryColor(selectedRatio?.category || '')}
                        strokeWidth="0.15"
                      />
                    </motion.g>
                  ))}
                </g>
              )}
            </AnimatePresence>
          </svg>
        </div>

        {/* No selection message */}
        {!selectedRatio && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/40">
            <div className="text-center p-4">
              <Eye size={compact ? 24 : 32} className="mx-auto text-neutral-600 mb-2" />
              <p className={`text-neutral-500 ${compact ? 'text-xs' : 'text-sm'}`}>
                {compact ? 'Click a ratio to visualize' : 'Expand a measurement card\nto see it visualized here'}
              </p>
            </div>
          </div>
        )}
      </div>

      {/* Selected ratio info */}
      {selectedRatio && !compact && (
        <motion.div
          className="p-3 border-t border-neutral-800"
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="flex items-center justify-between">
            <div>
              <h5 className="text-sm font-medium text-white">{selectedRatio.name}</h5>
              <p className="text-xs text-neutral-500">{selectedRatio.category}</p>
            </div>
            <div
              className="px-2 py-1 rounded text-sm font-bold"
              style={{
                backgroundColor: `${getScoreColor(selectedRatio.score)}15`,
                color: getScoreColor(selectedRatio.score),
              }}
            >
              {selectedRatio.score.toFixed(1)}
            </div>
          </div>

          {/* Landmarks used */}
          {selectedRatio.usedLandmarks && selectedRatio.usedLandmarks.length > 0 && (
            <div className="mt-2">
              <p className="text-xs text-neutral-500 mb-1">Landmarks used:</p>
              <div className="flex flex-wrap gap-1">
                {selectedRatio.usedLandmarks.slice(0, 4).map(id => {
                  const landmark = landmarkMap[id];
                  return (
                    <span
                      key={id}
                      className="px-1.5 py-0.5 bg-neutral-800 rounded text-[10px] text-neutral-400"
                    >
                      {landmark?.label || id}
                    </span>
                  );
                })}
                {selectedRatio.usedLandmarks.length > 4 && (
                  <span className="px-1.5 py-0.5 text-[10px] text-neutral-500">
                    +{selectedRatio.usedLandmarks.length - 4} more
                  </span>
                )}
              </div>
            </div>
          )}
        </motion.div>
      )}

      {/* Compact info bar */}
      {selectedRatio && compact && (
        <div className="px-2 py-1.5 border-t border-neutral-800 flex items-center justify-between">
          <span className="text-xs text-white truncate">{selectedRatio.name}</span>
          <span
            className="text-xs font-bold ml-2"
            style={{ color: getScoreColor(selectedRatio.score) }}
          >
            {selectedRatio.score.toFixed(1)}
          </span>
        </div>
      )}
    </div>
  );
}
