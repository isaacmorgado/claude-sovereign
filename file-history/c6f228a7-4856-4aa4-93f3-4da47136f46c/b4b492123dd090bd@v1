/**
 * Loads chapter data and creates markers in the sequence
 * @param {Array} chapters - Array of chapter objects (if null, loads from file)
 * @param {Object} params - Optional parameters including marker_color
 */
async function test_33_load_chapter_set_and_create_markers(chapters = null, params = null) {
    // Load chapters from file if not provided
    if (chapters == null) {
        chapters = JSON.parse(fs.readFileSync(path.join(DIR_temporary_files, 'chapters.json'), 'utf8'));
    }

    let markerColor = params?.marker_color || $('#select-chapters-marker-colour').val();
    let chapterParams = params || await test_45_get_chapters_params();

    for (let i = 0; i < chapters.length; i++) {
        console.log(chapters[i]);

        if (!chapterParams.mark_regions) {
            // Create point marker
            const evalString = 'createChapterMarker(' + chapters[i].time + ', "' + chapters[i].name + '", 0, "' + chapters[i].name + '", ' + markerColor + ')';
            console.log('eval_string', evalString);

            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('result', result);
                    resolve(result);
                });
            });
        } else {
            // Create region marker
            let endTime;

            if (i < chapters.length - 1) {
                endTime = chapters[i + 1].time;
            } else {
                endTime = g_chapter_detection_inout.outPoint;
                if (endTime <= chapters[i].time) {
                    endTime = chapters[i].time + 5;
                }
            }

            const evalString = 'createChapterMarker(' + chapters[i].time + ', "' + chapters[i].name + '", ' + (endTime - chapters[i].time) + ', "", ' + markerColor + ')';
            console.log('eval_string', evalString);

            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('result', result);
                    resolve(result);
                });
            });
        }
    }
}

/**
 * Adds chapter divider clips to the sequence with custom gradient colors
 * @param {Array} chapters - Array of chapter objects
 * @param {string} mogrtPath - Path to the MOGRT template file
 * @param {Object} colorOptions - Optional color options
 * @returns {boolean} Success status
 */
async function test_35_chapter_dividers_with_custom_colors(chapters, mogrtPath, colorOptions = null) {
    // Get number of video tracks
    var evalString = 'app.project.activeSequence.videoTracks.numTracks';
    console.log('eval_string', evalString);

    var numTracks = await new Promise((resolve, reject) => {
        jsx.evalScript(evalString, function(result) {
            console.log('result', result);
            resolve(result);
        });
    });
    numTracks = parseInt(numTracks);

    // Add new tracks for the chapter clips
    var audioTrackIndex = 0;
    evalString = 'qe.project.getActiveSequence().addTracks(1,' + numTracks + ',1,' + audioTrackIndex + ')';
    console.log('eval_string', evalString);

    result = await new Promise((resolve, reject) => {
        jsx.evalScript(evalString, function(result) {
            console.log('result', result);
            resolve(result);
        });
    });

    if (result != 'true') {
        console.log('ERROR: Could not add new tracks');
        showError('Could not add new tracks. Please share your log and report the issue. Thanks!');
        hideSpinner();
        return false;
    }

    // Get clip colors
    const fontColor = [
        colorOptions?.clipTextColour || colour_chapter_clips_font_colour.getColor().toHSLA()[0],
        colour_chapter_clips_font_colour.getColor().toHSLA()[1],
        colour_chapter_clips_font_colour.getColor().toHSLA()[2]
    ];

    let gradientColors = calculate_gradient_colours_from_middle_colour(fontColor, colorOptions?.clipGradient);
    let startColor = gradientColors.start_colour;
    let endColor = gradientColors.end_colour;

    // Convert HSL to RGB
    startColor = tools.HSLToRGB(startColor[0], startColor[1], startColor[2]);
    endColor = tools.HSLToRGB(endColor[0], endColor[1], endColor[2]);

    console.log(JSON.stringify(startColor));
    console.log(JSON.stringify(endColor));

    // Add chapter clips
    for (let i = 0; i < chapters.length; i++) {
        console.log(chapters[i]);

        showSpinner('Adding clip ' + (i + 1) + ' of ' + chapters.length + '...');

        // Clean chapter name (replace dashes, slashes, underscores with spaces)
        chapter_name_clean = chapters[i].name.replace(/[-\/_]/g, ' ');

        evalString = 'addChapterClipWithColours("' + mogrtPath + '", ' + chapters[i].time + ', ' + numTracks + ', ' + audioTrackIndex + ', "' + chapter_name_clean + '", "[' + startColor + ']", "[' + endColor + ']")';

        console.log('eval_string', evalString);

        result = await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result', result);
                resolve(result);
            });
        });

        if (result != 'true') {
            console.log('ERROR: Could not add clip');
            showError('Could not add clip. Please share your log and report the issue. Thanks!');
            hideSpinner();
            return false;
        }
    }

    // Remove temporary audio track
    evalString = 'qe.project.getActiveSequence().removeAudioTrack(' + audioTrackIndex + ')';
    console.log('eval_string', evalString);

    result = await new Promise((resolve, reject) => {
        jsx.evalScript(evalString, function(result) {
            console.log('result', result);
            resolve(result);
        });
    });

    if (result != 'true') {
        console.log('ERROR: Could not remove temporary audio track');
        showError('Could not remove temporary audio track. Please share your log and report the issue. Thanks!');
        hideSpinner();
        return false;
    }

    hideSpinner();
    return true;
}

/**
 * Deletes a chapter from the list
 * @param {number} chapterNumber - The 1-based index of the chapter to delete
 */
function chapter_markers_delete_chapter(chapterNumber) {
    chapters = chapter_markers_read_HTML();
    chapters.splice(chapterNumber - 1, 1);
    chapter_markers_write_HTML(chapters);
}

/**
 * Adds a new empty chapter to the list
 */
function chapter_markers_add_chapter() {
    chapters = chapter_markers_read_HTML();
    chapters.push({
        'name': '',
        'time': 0,
        'newly_added_chapter_tag': true
    });
    chapter_markers_write_HTML(chapters);
}

/**
 * Gets chapter starting points using OpenAI API
 * @param {string} transcript - The transcript text
 * @param {string} language - Language code (default: 'en')
 * @param {Array} existingChapters - Array of existing chapters for follow-up requests
 * @param {number} chaptersMin - Minimum number of chapters
 * @param {number} chaptersMax - Maximum number of chapters
 * @returns {Object} Parsed chapter data from API response
 */
async function openaiGetChapterStartingPoints(transcript, language = 'en', existingChapters, chaptersMin = null, chaptersMax = null) {
    let systemInstructions = '(none found in client)';

    if (translations.detect_chapters.systemInstructions[language] != undefined) {
        systemInstructions = translations.detect_chapters.systemInstructions[language];
    }

    console.log('systemInstructions:', systemInstructions);

    let extraParams = {};
    let endpoint = 'detect_chapters';

    // If there are existing chapters, use follow-up endpoint
    if (existingChapters.length > 0) {
        extraParams.previous_chapters = existingChapters.map(chapter => chapter.name).join(',');
        endpoint = 'detect_chapters_followup';
    }

    if (chaptersMin) {
        extraParams.chapters_min = chaptersMin;
    }

    if (chaptersMax) {
        extraParams.chapters_max = chaptersMax;
    }

    const userContent = transcript;

    const response = await editai_api.createChatCompletion(openai_data = {
        'model': 'gpt-4',
        'temperature': 0.35,
        'messages': [
            {
                'role': 'system',
                'content': systemInstructions
            },
            {
                'role': 'user',
                'content': userContent
            }
        ]
    }, Z = endpoint, R = extraParams, n = language);

    var returnMessage = response.data.choices[0].message.content;
    console.log('return_message: ', returnMessage);

    const parsedChapters = JSON.parse(returnMessage);
    console.log('chapters: ', parsedChapters);

    return parsedChapters;
}

/**
 * Calculates gradient start and end colors from a middle color
 * @param {Array} middleColor - HSL color array [hue, saturation, lightness]
 * @param {boolean} useGradient - Force gradient mode (default: use checkbox)
 * @returns {Object} Object with start_colour and end_colour arrays
 */
function calculate_gradient_colours_from_middle_colour(middleColor, useGradient = false) {
    if (useGradient || $('#chapter-colours-gradient').is(':checked')) {
        return {
            'start_colour': [
                (middleColor[0] + 21) % 360,
                96,
                Math.min(100, (3 / 2) * middleColor[2])
            ],
            'end_colour': [
                (middleColor[0] - 21) % 360,
                96,
                Math.max(0, (1 / 2) * middleColor[2])
            ]
        };
    } else {
        return {
            'start_colour': middleColor,
            'end_colour': middleColor
        };
    }
}

/**
 * Downloads a MOGRT file if not already present locally
 * @param {string} url - URL to download the MOGRT from
 * @returns {string} Local path to the MOGRT file
 */
async function checkOrDownloadMogrt(url) {
    const filename = url.split('/').pop();
    const mogrtDir = path.join(DIR_media, 'mogrt').toCEP();
    const localPath = path.join(mogrtDir, filename).toCEP();

    // Create directory if it doesn't exist
    if (!fs.existsSync(mogrtDir)) {
        fs.mkdirSync(mogrtDir);
    }

    // Return existing file if available
    if (fs.existsSync(localPath)) {
        return localPath;
    }

    // Download with retry logic
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
        const retryMessage = attempts > 0 ? 'retry ' + (attempts + 1) + '/' + maxAttempts : '';
        showSpinner('Downloading mogrt file... ' + retryMessage);

        try {
            const response = await fetch(url, {
                'cache': 'no-store'
            });

            if (!response.ok) {
                throw new Error('Failed to download mogrt: ' + response.statusText);
            }

            const blob = await response.blob();
            const arrayBuffer = await blob.arrayBuffer();

            fs.writeFileSync(localPath, Buffer.from(arrayBuffer));
            return localPath;

        } catch (error) {
            await new Promise(resolve => setTimeout(resolve, 2000));

            if (attempts === maxAttempts - 1) {
                throw error;
            }

            attempts++;
        }
    }
}

/**
 * Loads available chapter clip templates from API
 */
async function loadChapterClips() {
    const spinner = $('#chapters-add-clips-selection-spinner');
    const errorWrapper = $('#chapters-add-clips-selection-error-wrapper');

    spinner.removeClass('hidden');
    errorWrapper.addClass('hidden');

    const apiUrl = API_URL + 'api/get_chapter_clips/';

    let requestData = {
        'license_key': apiKey_editai,
        'app_version': app_version,
        'engine': engine
    };

    try {
        let response = await retryFetch(apiUrl, {
            'method': 'POST',
            'body': JSON.stringify(requestData),
            'headers': {
                'Content-type': 'application/json; charset=UTF-8'
            }
        }, 3, 1000, 60000);

        renderChapterClips(response.data);

    } catch (error) {
        handleErrorNotification(error);
        spinner.addClass('hidden');
        errorWrapper.removeClass('hidden');
    }
}
