/**
 * Analyzes audio for filler words using the first analysis method
 * Extracts audio, transcribes it, and identifies filler words
 */
async function filler_words_analyze() {
    const isLicenseValid = await verify_license_throttled();

    if (!isLicenseValid) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    if (!check_function_availability('filler_words_analyze')) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    test_52_schedule_log_upload(time_delay = 0);
    regular_license_key_checker();
    await test_45_save_state('Before analyzing filler words');
    await test_46_retrieve_undo_state_info();

    const trackingId = tracker.start('filler_words_analyze');

    try {
        showSpinner();
        filler_words_params = await test_54_get_filler_words_params();
        console.log('filler_words_params', filler_words_params);

        if (filler_words_params.keyAudioTrackIndices.length == 0) {
            showError('Please select at least one audio track');
            hideSpinner();
            return;
        }

        if (!filler_words_params.scopeValid) {
            showError('Please ensure your In/Out points are valid');
            hideSpinner();
            return;
        }

        // Get current mute state
        var evalString = 'getMuteState()';
        console.log('eval_string', evalString);

        let muteState = await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result', result);
                resolve(result);
            });
        });

        if (muteState.includes('EvalScript')) {
            throw new Error(muteState);
        }

        muteState = JSON.parse(muteState);
        var newMuteState = JSON.parse(JSON.stringify(muteState));

        // Mute tracks not in key audio track indices
        newMuteState.audio = newMuteState.audio.map((value, index) => {
            return +!filler_words_params.keyAudioTrackIndices.includes(index);
        });

        evalString = 'setMuteState(\'' + JSON.stringify(newMuteState) + '\')';
        console.log('eval_string', evalString);

        await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result of setting mute state', result);
                resolve(result);
            });
        });

        showSpinner('Rendering audio');

        let audioFilePath = await test_1_extract_audio_from_sequence(filler_words_params.scope, 'mp3');

        showSpinner('Detecting filler words');
        console.log('test_1 complete');

        const transcriptResponse = await transcribe_audio_file_filler_words(audioFilePath, filler_words_params.language);
        g_transcript_word_level_filler_canonical = JSON.parse(transcriptResponse);

        console.log('g_transcript_word_level_filler_canonical BEFORE offsetting times');
        console.log(JSON.parse(JSON.stringify(g_transcript_word_level_filler_canonical)));

        // Offset timestamps if using in/out scope
        if (filler_words_params.scope == 'inout') {
            for (let i = 0; i < g_transcript_word_level_filler_canonical.segments.length; i++) {
                g_transcript_word_level_filler_canonical.segments[i].start += filler_words_params.inPoint;
                g_transcript_word_level_filler_canonical.segments[i].end += filler_words_params.inPoint;

                for (let j = 0; j < g_transcript_word_level_filler_canonical.segments[i].words.length; j++) {
                    g_transcript_word_level_filler_canonical.segments[i].words[j].start += filler_words_params.inPoint;
                    g_transcript_word_level_filler_canonical.segments[i].words[j].end += filler_words_params.inPoint;
                }
            }
        }

        console.log('g_transcript_word_level_filler_canonical AFTER offsetting times');
        console.log(JSON.parse(JSON.stringify(g_transcript_word_level_filler_canonical)));

        g_transcript_word_level_filler = JSON.parse(JSON.stringify(g_transcript_word_level_filler_canonical));

        open_menu('remove-filler-words-results');

        // Restore original mute state
        evalString = 'setMuteState(\'' + JSON.stringify(muteState) + '\')';
        console.log('eval_string', evalString);

        await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result of setting ORIGINAL mute state', result);
                resolve(result);
            });
        });

    } catch (error) {
        handleErrorNotification(error);

    } finally {
        hideSpinner();
        clear_abort_undo_state();
        tracker.end(trackingId);
        test_52_schedule_log_upload(600);
    }
}

/**
 * Analyzes audio for filler words using chunked processing (method 2)
 * Breaks audio into chunks for parallel processing
 */
async function filler_words_analyze_2() {
    const isLicenseValid = await verify_license_throttled();

    if (!isLicenseValid) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    if (!check_function_availability('filler_words_analyze_2')) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    test_52_schedule_log_upload(time_delay = 0);
    regular_license_key_checker();
    await test_45_save_state('Before analyzing filler words');
    await test_46_retrieve_undo_state_info();

    const trackingId = tracker.start('filler_words_analyze_2');

    try {
        showSpinner();
        filler_words_params = await test_54_get_filler_words_params();
        console.log('filler_words_params', filler_words_params);

        if (filler_words_params.keyAudioTrackIndices.length == 0) {
            showError('Please select at least one audio track');
            hideSpinner();
            return;
        }

        if (!filler_words_params.scopeValid) {
            showError('Please ensure your In/Out points are valid');
            hideSpinner();
            return;
        }

        if ((filler_words_params.outPoint - filler_words_params.inPoint) > filler_words_analyze_max_duration) {
            showError('As an experimental feature, the maximum duration for filler words analysis is currently ' + (filler_words_analyze_max_duration / 60) + ' minutes. Please reduce the scope.');
            hideSpinner();
            return;
        }

        if (filler_words_params.outPoint - filler_words_params.inPoint < 15) {
            showError('Please include at least 15 seconds of audio.');
            hideSpinner();
            return;
        }

        // Get current mute state
        var evalString = 'getMuteState()';
        console.log('eval_string', evalString);

        let muteState = await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result', result);
                resolve(result);
            });
        });

        if (muteState.includes('EvalScript')) {
            throw new Error(muteState);
        }

        muteState = JSON.parse(muteState);
        var newMuteState = JSON.parse(JSON.stringify(muteState));

        // Mute tracks not in key audio track indices
        newMuteState.audio = newMuteState.audio.map((value, index) => {
            return +!filler_words_params.keyAudioTrackIndices.includes(index);
        });

        evalString = 'setMuteState(\'' + JSON.stringify(newMuteState) + '\')';
        console.log('eval_string', evalString);

        await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result of setting mute state', result);
                resolve(result);
            });
        });

        // Create chunks for processing
        g_filler_words_chunks = chunk(
            start = filler_words_params.inPoint,
            end = filler_words_params.outPoint,
            chunk_size = filler_words_analyze_buffer,
            upto_twice = true
        );

        writeHTML_transcript_filler_words_spinners_only();
        open_menu('remove-filler-words-results');

        // Create filler_words directory if it doesn't exist
        if (!fs.existsSync(path.join(DIR_temporary_files, 'filler_words'))) {
            console.log('making dir', path.join(DIR_temporary_files, 'filler_words'));
            fs.mkdirSync(path.join(DIR_temporary_files, 'filler_words'));
        }

        // Initialize arrays for chunk processing
        g_filler_words_transcript = Array.from({ length: g_filler_words_chunks.length }, () => null);
        g_filler_words_transcript_word_level = Array.from({ length: g_filler_words_chunks.length }, () => null);
        g_filler_words_chunks_status = Array.from({ length: g_filler_words_chunks.length }, () => ['identified']);

        // Process each chunk
        for (let i = 0; i < g_filler_words_chunks.length; i++) {
            let chunkPath = path.join(DIR_temporary_files, 'filler_words', i + '.mp3');

            // Set in point for chunk
            evalString = 'app.project.activeSequence.setInPoint(' + g_filler_words_chunks[i][0] + ')';
            console.log('eval_string', evalString);

            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('result', result);
                    resolve(parseFloat(result));
                });
            });

            // Set out point for chunk
            evalString = 'app.project.activeSequence.setOutPoint(' + g_filler_words_chunks[i][1] + ')';
            console.log('eval_string', evalString);

            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('result', result);
                    resolve(parseFloat(result));
                });
            });

            g_filler_words_chunks_status[i] = ['rendering'];

            let renderedPath = await render('app.project.activeSequence', 'mp3', 'inout', chunkPath.toCEP());
            console.log('mp3_file_path', renderedPath);

            test_58_filler_words_analyze_chunk(renderedPath, i);
        }

        // Restore original mute state
        evalString = 'setMuteState(\'' + JSON.stringify(muteState) + '\')';
        console.log('eval_string', evalString);

        await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result of setting ORIGINAL mute state', result);
                resolve(result);
            });
        });

    } catch (error) {
        handleErrorNotification(error);

    } finally {
        hideSpinner();
        clear_abort_undo_state();
        tracker.end(trackingId);
        test_52_schedule_log_upload(600);
    }
}

/**
 * Analyzes audio for filler words using method 3
 * More advanced chunked processing with word-level timestamps
 */
async function filler_words_analyze_3() {
    const isLicenseValid = await verify_license_throttled();

    if (!isLicenseValid) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    if (!check_function_availability('filler_words_analyze_3')) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    test_52_schedule_log_upload(time_delay = 0);
    regular_license_key_checker();
    await test_45_save_state('Before analyzing filler words');
    await test_46_retrieve_undo_state_info();

    const trackingId = tracker.start('filler_words_analyze_3');

    try {
        showSpinner();
        filler_words_params = await test_54_get_filler_words_params();
        console.log('filler_words_params', filler_words_params);

        if (filler_words_params.keyAudioTrackIndices.length == 0) {
            showError('Please select at least one audio track');
            hideSpinner();
            return;
        }

        if (!filler_words_params.scopeValid) {
            showError('Please ensure your In/Out points are valid');
            hideSpinner();
            return;
        }

        if ((filler_words_params.outPoint - filler_words_params.inPoint) > filler_words_analyze_max_duration) {
            showError('As an experimental feature, the maximum duration for filler words analysis is currently ' + (filler_words_analyze_max_duration / 60) + ' minutes. Please reduce the scope.');
            hideSpinner();
            return;
        }

        if ((filler_words_params.outPoint - filler_words_params.inPoint) < 15) {
            showError('Please include at least 15 seconds of audio.');
            hideSpinner();
            return;
        }

        // Get current mute state
        var evalString = 'getMuteState()';
        console.log('eval_string', evalString);

        let muteState = await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result', result);
                resolve(result);
            });
        });

        if (muteState.includes('EvalScript')) {
            throw new Error(muteState);
        }

        muteState = JSON.parse(muteState);
        var newMuteState = JSON.parse(JSON.stringify(muteState));

        // Mute tracks not in key audio track indices
        newMuteState.audio = newMuteState.audio.map((value, index) => {
            return +!filler_words_params.keyAudioTrackIndices.includes(index);
        });

        evalString = 'setMuteState(\'' + JSON.stringify(newMuteState) + '\')';
        console.log('eval_string', evalString);

        await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result of setting mute state', result);
                resolve(result);
            });
        });

        // Create chunks for processing (smaller chunks without doubling)
        g_filler_words_chunks = chunk(
            start = filler_words_params.inPoint,
            end = filler_words_params.outPoint,
            chunk_size = 600 - 15, // 10 minutes minus buffer
            upto_twice = false
        );

        writeHTML_transcript_filler_words_spinners_only();
        open_menu('remove-filler-words-results');
        hideSpinner();

        // Create filler_words directory if it doesn't exist
        if (!fs.existsSync(path.join(DIR_temporary_files, 'filler_words'))) {
            console.log('making dir', path.join(DIR_temporary_files, 'filler_words'));
            fs.mkdirSync(path.join(DIR_temporary_files, 'filler_words'));
        }

        // Initialize arrays for chunk processing
        g_filler_words_transcript = Array.from({ length: g_filler_words_chunks.length }, () => null);
        g_filler_words_transcript_word_level = Array.from({ length: g_filler_words_chunks.length }, () => null);
        g_filler_words_chunks_status = Array.from({ length: g_filler_words_chunks.length }, () => 'identified');
        g_selected_transcript_word_level_filler = null;

        filler_words_params = await test_54_get_filler_words_params();

        let foundFillerWords = 0;
        let totalWords = 0;

        // Process each chunk
        for (let chunkIndex = 0; chunkIndex < g_filler_words_chunks.length; chunkIndex++) {
            let chunkPath = path.join(DIR_temporary_files, 'filler_words', chunkIndex + '.mp3');

            // Set in point
            evalString = 'app.project.activeSequence.setInPoint(' + g_filler_words_chunks[chunkIndex][0] + ')';
            console.log('eval_string', evalString);

            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('result', result);
                    resolve(parseFloat(result));
                });
            });

            // Set out point
            evalString = 'app.project.activeSequence.setOutPoint(' + g_filler_words_chunks[chunkIndex][1] + ')';
            console.log('eval_string', evalString);

            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('result', result);
                    resolve(parseFloat(result));
                });
            });

            g_filler_words_chunks_status[chunkIndex] = 'rendering';

            let renderedPath = await render('app.project.activeSequence', 'mp3', 'inout', chunkPath.toCEP());
            console.log('mp3_file_path', renderedPath);
            console.log('Chunk path', renderedPath);

            g_filler_words_chunks_status[chunkIndex] = 'sent to openai';

            const chunkStartOffset = g_filler_words_chunks[chunkIndex][0];

            // Transcribe chunk with filler word detection
            const whisperResponse = await transcribeAudioFileForFillerWords(renderedPath, filler_words_params.language);

            g_filler_words_chunks_status[chunkIndex] = 'received from openai';
            console.log('Received OPENAI API transcript for chunk', chunkIndex);

            g_filler_words_transcript[chunkIndex] = whisperResponse;
            g_filler_words_transcript_word_level[chunkIndex] = JSON.parse(JSON.stringify(whisperResponse));

            // Check for filler words in segments
            for (let segmentIndex = 0; segmentIndex < whisperResponse.segments.length; segmentIndex++) {
                const segment = whisperResponse.segments[segmentIndex];
                let hasFillerWords = false;

                for (let wordIndex = 0; wordIndex < segment.words.length; wordIndex++) {
                    const word = segment.words[wordIndex];
                    const cleanWord = cleanFillerWord(word.word || word.text);

                    totalWords++;

                    if (g_filler_words_extended.includes(cleanWord)) {
                        foundFillerWords++;
                        hasFillerWords = true;
                    }
                }

                if (hasFillerWords) {
                    g_filler_words_chunks_status[chunkIndex] = 'queued for sending to word level timestamps API';
                } else {
                    if (g_filler_words_chunks_status[chunkIndex] === 'received from openai') {
                        g_filler_words_chunks_status[chunkIndex] = 'no filler words in segment';
                    }
                }
            }

            // Process word-level timestamps if filler words found
            if (g_filler_words_chunks_status[chunkIndex] === 'queued for sending to word level timestamps API') {
                // Get word-level timestamps for better accuracy
                if (whisperResponse.segments.length > 0) {
                    const segmentIds = whisperResponse.segments.map(s => s.id);

                    const wordLevelResponse = await test_67_improve_accuracy_words_only_chunked(
                        renderedPath,
                        whisperResponse,
                        0,
                        filler_words_params.language,
                        segmentIds
                    );

                    console.log('whisper_response_for_chunk', clone(wordLevelResponse));

                    // Update word-level transcript with accurate timestamps
                    for (let j = 0; j < wordLevelResponse.segments.length; j++) {
                        const segment = wordLevelResponse.segments[j];

                        for (let k = 0; k < segment.words.length; k++) {
                            const word = segment.words[k];

                            // Offset timestamps by chunk start
                            word.start = Math.max((word.start + chunkStartOffset) - filler_prompt_duration, 0);
                            word.end = Math.max((word.end + chunkStartOffset) - filler_prompt_duration, 0);

                            console.log('g_filler_words_transcript_word_level[chunk_index].segments[j].words[k]');

                            // Handle edge case where start equals end
                            if (word.start == word.end) {
                                if (k > 0) {
                                    const prevWordEnd = wordLevelResponse.segments[j].words[k - 1].end;
                                    word.start -= (word.start - prevWordEnd) / 2;
                                }
                                if (k < wordLevelResponse.segments[j].words.length - 1) {
                                    const nextWordStart = wordLevelResponse.segments[j].words[k + 1].start;
                                    word.end += (nextWordStart - word.end) / 2;
                                }
                            }

                            console.log('whisper_response_for_chunk.segments[j].words[k]');
                            g_filler_words_transcript_word_level[chunkIndex].segments[j].words[k] = word;
                        }
                    }
                }
            }

            writeHTML_filler_words_results();
        }

        // Check if no filler words were found
        if (foundFillerWords === 0) {
            showMessage('Sorry, no filler words found. If there are definitely filler words in your audio, please make sure you\'ve followed the \'best practices\' in the previous menu. If still no luck, let us know in the \'share feedback\' menu and we\'ll continue to improve detection!');
            open_menu('remove-filler-words');
        }

        // Check for overdetection
        if (foundFillerWords > 0 && totalWords > 0) {
            const fillerRatio = foundFillerWords / totalWords;
            if (fillerRatio > 0.5) {
                console.log('Overdetection of filler words! Showing message to say we didn\'t find any.');
                showMessage('Sorry, no filler words found. If there are definitely filler words in your audio, please make sure you\'ve followed the \'best practices\' in the previous menu. If still no luck, let us know in the \'share feedback\' menu and we\'ll continue to improve detection!');
                open_menu('remove-filler-words');
            }
        }

        // Restore original mute state
        evalString = 'setMuteState(\'' + JSON.stringify(muteState) + '\')';
        console.log('eval_string', evalString);

        await new Promise((resolve, reject) => {
            jsx.evalScript(evalString, function(result) {
                console.log('result of setting ORIGINAL mute state', result);
                resolve(result);
            });
        });

    } catch (error) {
        handleErrorNotification(error);

    } finally {
        hideSpinner();
        clear_abort_undo_state();
        tracker.end(trackingId);
        test_52_schedule_log_upload(600);
    }
}

/**
 * Removes detected filler words from the sequence
 * Creates cuts at filler word timestamps and removes the segments
 */
async function filler_words_remove() {
    const isLicenseValid = await verify_license_throttled();

    if (!isLicenseValid) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    if (!check_function_availability('filler_words_remove')) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    test_52_schedule_log_upload(time_delay = 0);
    regular_license_key_checker();
    await test_45_save_state('Before removing filler words');
    await test_46_retrieve_undo_state_info();

    const trackingId = tracker.start('filler_words_remove');

    try {
        showSpinner('Removing filler words');

        // Get filler word timings to remove
        const fillerTimings = getFillerWordsTimings(true);
        console.log('filler_words_timings', fillerTimings);

        if (fillerTimings.length === 0) {
            showError('No filler words selected for removal.');
            hideSpinner();
            return;
        }

        // Remove filler words from sequence
        for (let i = fillerTimings.length - 1; i >= 0; i--) {
            const timing = fillerTimings[i];
            const inPoint = timing[0];
            const outPoint = timing[1];

            // Set in/out points
            let evalString = 'app.project.activeSequence.setInPoint(' + inPoint + ')';
            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    resolve(result);
                });
            });

            evalString = 'app.project.activeSequence.setOutPoint(' + outPoint + ')';
            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    resolve(result);
                });
            });

            // Extract in/out (ripple delete)
            evalString = 'app.project.activeSequence.extractSelection()';
            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('extract result', result);
                    resolve(result);
                });
            });
        }

        showMessage(fillerTimings.length + ' filler word(s) removed successfully.');

    } catch (error) {
        handleErrorNotification(error);

    } finally {
        hideSpinner();
        clear_abort_undo_state();
        tracker.end(trackingId);
        test_52_schedule_log_upload(600);
    }
}

/**
 * Adds markers at filler word locations without removing them
 */
async function filler_words_add_markers() {
    const isLicenseValid = await verify_license_throttled();

    if (!isLicenseValid) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    if (!check_function_availability('filler_words_add_markers')) {
        showError('Please provide a valid license key in the Settings menu');
        return;
    }

    test_52_schedule_log_upload(time_delay = 0);
    regular_license_key_checker();
    await test_45_save_state('Before adding filler word markers');
    await test_46_retrieve_undo_state_info();

    const trackingId = tracker.start('filler_words_add_markers');

    try {
        showSpinner('Adding filler word markers');

        // Get filler word timings
        const fillerTimings = getFillerWordsTimings(false);
        console.log('filler_words_timings', fillerTimings);

        if (fillerTimings.length === 0) {
            showError('No filler words selected for marking.');
            hideSpinner();
            return;
        }

        // Add marker for each filler word
        for (let i = 0; i < fillerTimings.length; i++) {
            const timing = fillerTimings[i];
            const markerTime = timing[0];

            const evalString = 'createFillerWordMarker(' + markerTime + ')';
            await new Promise((resolve, reject) => {
                jsx.evalScript(evalString, function(result) {
                    console.log('marker result', result);
                    resolve(result);
                });
            });
        }

        showMessage(fillerTimings.length + ' filler word marker(s) added successfully.');

    } catch (error) {
        handleErrorNotification(error);

    } finally {
        hideSpinner();
        clear_abort_undo_state();
        tracker.end(trackingId);
        test_52_schedule_log_upload(600);
    }
}
