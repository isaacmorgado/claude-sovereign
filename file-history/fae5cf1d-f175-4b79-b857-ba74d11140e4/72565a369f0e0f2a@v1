/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as os from 'node:os';
import {
  parseMarkdownAgent,
  markdownToAgentDefinition,
  loadMarkdownAgentsFromDirectory,
  MarkdownAgentLoadError,
} from './markdown-loader.js';
import type { LocalAgentDefinition } from './types.js';

describe('markdown-loader', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'md-agent-test-'));
  });

  afterEach(async () => {
    if (tempDir) {
      await fs.rm(tempDir, { recursive: true, force: true });
    }
  });

  async function writeAgentMarkdown(content: string, fileName = 'test.md') {
    const filePath = path.join(tempDir, fileName);
    await fs.writeFile(filePath, content);
    return filePath;
  }

  describe('parseMarkdownAgent', () => {
    it('should parse a valid markdown agent file', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
description: A test agent for testing
---

You are a helpful test agent.

When asked to do something:
1. Think carefully
2. Take action
3. Report results
`);

      const result = await parseMarkdownAgent(filePath);

      expect(result.frontmatter).toEqual({
        name: 'test-agent',
        description: 'A test agent for testing',
      });
      expect(result.systemPrompt).toContain('You are a helpful test agent.');
      expect(result.systemPrompt).toContain('1. Think carefully');
    });

    it('should parse all supported frontmatter fields', async () => {
      const filePath = await writeAgentMarkdown(`---
name: full-agent
description: An agent with all fields
display_name: Full Agent
tools: read_file, glob, grep
model: gemini-2.5-pro
temperature: 0.7
max_turns: 10
max_time_minutes: 15
query: Do the task: \${goal}
---

Full system prompt.
`);

      const result = await parseMarkdownAgent(filePath);

      expect(result.frontmatter).toEqual({
        name: 'full-agent',
        description: 'An agent with all fields',
        display_name: 'Full Agent',
        tools: 'read_file, glob, grep',
        model: 'gemini-2.5-pro',
        temperature: 0.7,
        max_turns: 10,
        max_time_minutes: 15,
        query: 'Do the task: ${goal}',
      });
    });

    it('should throw MarkdownAgentLoadError if file does not exist', async () => {
      const filePath = path.join(tempDir, 'non-existent.md');
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /Could not read file/,
      );
    });

    it('should throw MarkdownAgentLoadError if frontmatter is missing', async () => {
      const filePath = await writeAgentMarkdown(`
This is just a regular markdown file without frontmatter.
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /No valid YAML frontmatter found/,
      );
    });

    it('should throw MarkdownAgentLoadError if name is invalid', async () => {
      const filePath = await writeAgentMarkdown(`---
name: Invalid Agent Name!
description: A test agent
---

System prompt.
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /Name must be a valid slug/,
      );
    });

    it('should throw MarkdownAgentLoadError if description is missing', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
---

System prompt.
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /Validation failed/,
      );
    });

    it('should throw MarkdownAgentLoadError if system prompt is empty', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
description: A test agent
---
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /must contain a system prompt/,
      );
    });

    it('should throw MarkdownAgentLoadError if delegate_to_agent is in tools', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
description: A test agent
tools: read_file, delegate_to_agent
---

System prompt.
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /tools list cannot include 'delegate_to_agent'/,
      );
    });

    it('should throw MarkdownAgentLoadError for invalid tool names', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
description: A test agent
tools: read_file, invalid_tool_that_doesnt_exist
---

System prompt.
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        /Invalid tool name/,
      );
    });

    it('should accept valid tool names', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
description: A test agent
tools: read_file, glob, grep, run_shell_command
---

System prompt.
`);

      const result = await parseMarkdownAgent(filePath);
      expect(result.frontmatter.tools).toBe(
        'read_file, glob, grep, run_shell_command',
      );
    });

    it('should handle temperature validation', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test-agent
description: A test agent
temperature: 3.0
---

System prompt.
`);

      await expect(parseMarkdownAgent(filePath)).rejects.toThrow(
        MarkdownAgentLoadError,
      );
    });

    it('should accept names with underscores', async () => {
      const filePath = await writeAgentMarkdown(`---
name: test_agent_name
description: A test agent
---

System prompt.
`);

      const result = await parseMarkdownAgent(filePath);
      expect(result.frontmatter.name).toBe('test_agent_name');
    });
  });

  describe('markdownToAgentDefinition', () => {
    it('should convert frontmatter to AgentDefinition with defaults', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
      };
      const systemPrompt = 'You are a test agent.';

      const result = markdownToAgentDefinition(frontmatter, systemPrompt);

      expect(result).toMatchObject({
        kind: 'local',
        name: 'test-agent',
        description: 'A test agent',
        promptConfig: {
          systemPrompt: 'You are a test agent.',
        },
        modelConfig: {
          model: 'inherit',
          temp: 1,
          top_p: 0.95,
        },
        runConfig: {
          max_time_minutes: 5,
        },
        inputConfig: {
          inputs: {
            query: {
              type: 'string',
              description: 'The task for the agent.',
              required: false,
            },
          },
        },
      });
    });

    it('should use provided model and temperature', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
        model: 'gemini-2.5-flash',
        temperature: 0.3,
      };
      const systemPrompt = 'System prompt.';

      const result = markdownToAgentDefinition(
        frontmatter,
        systemPrompt,
      ) as LocalAgentDefinition;

      expect(result.modelConfig.model).toBe('gemini-2.5-flash');
      expect(result.modelConfig.temp).toBe(0.3);
    });

    it('should parse and include tools', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
        tools: 'read_file, glob, grep',
      };
      const systemPrompt = 'System prompt.';

      const result = markdownToAgentDefinition(
        frontmatter,
        systemPrompt,
      ) as LocalAgentDefinition;

      expect(result.toolConfig).toEqual({
        tools: ['read_file', 'glob', 'grep'],
      });
    });

    it('should include display name when provided', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
        display_name: 'Test Agent Display Name',
      };
      const systemPrompt = 'System prompt.';

      const result = markdownToAgentDefinition(frontmatter, systemPrompt);

      expect(result.displayName).toBe('Test Agent Display Name');
    });

    it('should include query template when provided', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
        query: 'Execute: ${task}',
      };
      const systemPrompt = 'System prompt.';

      const result = markdownToAgentDefinition(
        frontmatter,
        systemPrompt,
      ) as LocalAgentDefinition;

      expect(result.promptConfig.query).toBe('Execute: ${task}');
    });

    it('should include run config settings', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
        max_turns: 20,
        max_time_minutes: 10,
      };
      const systemPrompt = 'System prompt.';

      const result = markdownToAgentDefinition(
        frontmatter,
        systemPrompt,
      ) as LocalAgentDefinition;

      expect(result.runConfig.max_turns).toBe(20);
      expect(result.runConfig.max_time_minutes).toBe(10);
    });

    it('should not include toolConfig when no tools provided', () => {
      const frontmatter = {
        name: 'test-agent',
        description: 'A test agent',
      };
      const systemPrompt = 'System prompt.';

      const result = markdownToAgentDefinition(
        frontmatter,
        systemPrompt,
      ) as LocalAgentDefinition;

      expect(result.toolConfig).toBeUndefined();
    });
  });

  describe('loadMarkdownAgentsFromDirectory', () => {
    it('should load all valid markdown agents from directory', async () => {
      await writeAgentMarkdown(
        `---
name: agent-one
description: First agent
---

First agent prompt.
`,
        'agent-one.md',
      );

      await writeAgentMarkdown(
        `---
name: agent-two
description: Second agent
---

Second agent prompt.
`,
        'agent-two.md',
      );

      const result = await loadMarkdownAgentsFromDirectory(tempDir);

      expect(result.agents).toHaveLength(2);
      expect(result.errors).toHaveLength(0);
      expect(result.agents.map((a) => a.name)).toContain('agent-one');
      expect(result.agents.map((a) => a.name)).toContain('agent-two');
    });

    it('should ignore non-markdown files', async () => {
      await writeAgentMarkdown(
        `---
name: valid-agent
description: Valid agent
---

System prompt.
`,
        'valid.md',
      );

      // Create a non-markdown file
      await fs.writeFile(path.join(tempDir, 'other.txt'), 'not an agent');
      await fs.writeFile(path.join(tempDir, 'config.toml'), '[agent]');

      const result = await loadMarkdownAgentsFromDirectory(tempDir);

      expect(result.agents).toHaveLength(1);
      expect(result.agents[0].name).toBe('valid-agent');
    });

    it('should ignore files starting with underscore', async () => {
      await writeAgentMarkdown(
        `---
name: visible-agent
description: Visible agent
---

System prompt.
`,
        'visible.md',
      );

      await writeAgentMarkdown(
        `---
name: hidden-agent
description: Hidden agent
---

System prompt.
`,
        '_hidden.md',
      );

      const result = await loadMarkdownAgentsFromDirectory(tempDir);

      expect(result.agents).toHaveLength(1);
      expect(result.agents[0].name).toBe('visible-agent');
    });

    it('should return empty result if directory does not exist', async () => {
      const nonExistentDir = path.join(tempDir, 'does-not-exist');

      const result = await loadMarkdownAgentsFromDirectory(nonExistentDir);

      expect(result.agents).toHaveLength(0);
      expect(result.errors).toHaveLength(0);
    });

    it('should capture errors for malformed files without failing', async () => {
      await writeAgentMarkdown(
        `---
name: valid-agent
description: Valid agent
---

System prompt.
`,
        'valid.md',
      );

      // Malformed file - missing description
      await writeAgentMarkdown(
        `---
name: invalid-agent
---

System prompt.
`,
        'invalid.md',
      );

      const result = await loadMarkdownAgentsFromDirectory(tempDir);

      expect(result.agents).toHaveLength(1);
      expect(result.agents[0].name).toBe('valid-agent');
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0]).toBeInstanceOf(MarkdownAgentLoadError);
      expect(result.errors[0].filePath).toContain('invalid.md');
    });

    it('should handle multiple errors in different files', async () => {
      // File with invalid name
      await writeAgentMarkdown(
        `---
name: Invalid Name!
description: Bad name agent
---

System prompt.
`,
        'bad-name.md',
      );

      // File without frontmatter
      await fs.writeFile(
        path.join(tempDir, 'no-frontmatter.md'),
        'Just regular markdown content.',
      );

      const result = await loadMarkdownAgentsFromDirectory(tempDir);

      expect(result.agents).toHaveLength(0);
      expect(result.errors).toHaveLength(2);
    });

    it('should handle directory read errors', async () => {
      // Create a file instead of directory to cause read error
      const filePath = path.join(tempDir, 'not-a-dir');
      await fs.writeFile(filePath, 'content');

      // Try to treat file as directory
      const result = await loadMarkdownAgentsFromDirectory(filePath);

      expect(result.agents).toHaveLength(0);
      expect(result.errors).toHaveLength(1);
    });
  });

  describe('MarkdownAgentLoadError', () => {
    it('should have correct name and message', () => {
      const error = new MarkdownAgentLoadError('/path/to/agent.md', 'Test error');

      expect(error.name).toBe('MarkdownAgentLoadError');
      expect(error.message).toBe(
        'Failed to load agent from /path/to/agent.md: Test error',
      );
      expect(error.filePath).toBe('/path/to/agent.md');
    });
  });
});
