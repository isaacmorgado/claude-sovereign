/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { TaskOutputTool, ListTasksTool } from './task-output-tool.js';
import type { AgentTaskManager, AgentTask } from './task-manager.js';
import { AgentTerminateMode } from './types.js';
import { TASK_OUTPUT_TOOL_NAME } from '../tools/tool-names.js';
import type { ToolResult } from '../tools/tools.js';

const createMockTask = (overrides: Partial<AgentTask> = {}): AgentTask => ({
  id: 'task-123',
  agentName: 'test-agent',
  agentDisplayName: 'Test Agent',
  status: 'completed',
  createdAt: new Date('2025-01-01T10:00:00Z'),
  startedAt: new Date('2025-01-01T10:00:01Z'),
  completedAt: new Date('2025-01-01T10:00:10Z'),
  result: {
    terminate_reason: AgentTerminateMode.GOAL,
    result: 'Task completed successfully',
  },
  inputs: { query: 'test query' },
  ...overrides,
});

const createMockTaskManager = (): AgentTaskManager => ({
  getOutput: vi.fn(),
  listTasks: vi.fn(),
  spawnBackground: vi.fn(),
  cancelTask: vi.fn(),
  listTasksByStatus: vi.fn(),
  clearFinishedTasks: vi.fn(),
  getTask: vi.fn(),
  hasRunningTasks: vi.fn(),
} as unknown as AgentTaskManager);

// Helper to extract text from llmContent
const getLlmText = (result: ToolResult): string => {
  const content = result.llmContent;
  if (typeof content === 'string') {
    return content;
  }
  if (Array.isArray(content) && content.length > 0) {
    const firstPart = content[0];
    if (typeof firstPart === 'object' && 'text' in firstPart) {
      return firstPart.text ?? '';
    }
  }
  return '';
};

// Create a mock AbortSignal for tests
const createAbortSignal = (): AbortSignal => {
  const controller = new AbortController();
  return controller.signal;
};

describe('TaskOutputTool', () => {
  let mockTaskManager: AgentTaskManager;
  let tool: TaskOutputTool;

  beforeEach(() => {
    vi.resetAllMocks();
    mockTaskManager = createMockTaskManager();
    tool = new TaskOutputTool(mockTaskManager);
  });

  describe('metadata', () => {
    it('should have correct name and description', () => {
      expect(tool.name).toBe(TASK_OUTPUT_TOOL_NAME);
      expect(tool.displayName).toBe('Task Output');
      expect(tool.description).toContain('background agent task');
    });

    it('should have correct schema', () => {
      const schema = tool.schema;
      expect(schema).toBeDefined();
      expect(schema.parametersJsonSchema).toBeDefined();
      const jsonSchema = schema.parametersJsonSchema as Record<string, unknown>;
      const properties = jsonSchema['properties'] as Record<string, unknown>;
      expect(properties).toHaveProperty('task_id');
      expect(properties).toHaveProperty('block');
      expect(properties).toHaveProperty('timeout');
    });
  });

  describe('execute', () => {
    it('should return completed task output', async () => {
      const mockTask = createMockTask();
      vi.mocked(mockTaskManager.getOutput).mockResolvedValue(mockTask);

      const invocation = tool.createInvocationForTest({
        task_id: 'task-123',
        block: true,
        timeout: 30000,
      });

      const result = await invocation.execute(createAbortSignal());

      expect(mockTaskManager.getOutput).toHaveBeenCalledWith('task-123', {
        block: true,
        timeout: 30000,
      });

      expect(result.llmContent).toBeDefined();
      const llmText = getLlmText(result);
      expect(llmText).toContain('task-123');
      expect(llmText).toContain('completed');

      expect(result.returnDisplay).toContain('## Task: task-123');
      expect(result.returnDisplay).toContain('**Status**: completed');
      expect(result.returnDisplay).toContain('Task completed successfully');
    });

    it('should return running task status', async () => {
      const mockTask = createMockTask({
        status: 'running',
        completedAt: undefined,
        result: undefined,
      });
      vi.mocked(mockTaskManager.getOutput).mockResolvedValue(mockTask);

      const invocation = tool.createInvocationForTest({
        task_id: 'task-123',
        block: false,
      });

      const result = await invocation.execute(createAbortSignal());

      expect(result.returnDisplay).toContain('**Status**: running');
      expect(result.returnDisplay).toContain('*Task is running...*');
    });

    it('should return error task output', async () => {
      const mockTask = createMockTask({
        status: 'error',
        result: undefined,
        error: 'Something went wrong',
      });
      vi.mocked(mockTaskManager.getOutput).mockResolvedValue(mockTask);

      const invocation = tool.createInvocationForTest({
        task_id: 'task-123',
      });

      const result = await invocation.execute(createAbortSignal());

      expect(result.returnDisplay).toContain('**Status**: error');
      expect(result.returnDisplay).toContain('### Error');
      expect(result.returnDisplay).toContain('Something went wrong');
    });

    it('should return cancelled task output', async () => {
      const mockTask = createMockTask({
        status: 'cancelled',
        result: undefined,
        error: 'Task was cancelled',
      });
      vi.mocked(mockTaskManager.getOutput).mockResolvedValue(mockTask);

      const invocation = tool.createInvocationForTest({
        task_id: 'task-123',
      });

      const result = await invocation.execute(createAbortSignal());

      expect(result.returnDisplay).toContain('**Status**: cancelled');
      expect(result.returnDisplay).toContain('*Task was cancelled.*');
    });

    it('should handle task not found error', async () => {
      vi.mocked(mockTaskManager.getOutput).mockRejectedValue(
        new Error("Task 'unknown' not found"),
      );

      const invocation = tool.createInvocationForTest({
        task_id: 'unknown',
      });

      const result = await invocation.execute(createAbortSignal());

      expect(result.error).toBeDefined();
      expect(result.error?.message).toContain('not found');
      expect(result.returnDisplay).toContain('**Error**');
    });

    it('should include duration for completed tasks', async () => {
      const mockTask = createMockTask({
        startedAt: new Date('2025-01-01T10:00:00Z'),
        completedAt: new Date('2025-01-01T10:00:15Z'), // 15 seconds later
      });
      vi.mocked(mockTaskManager.getOutput).mockResolvedValue(mockTask);

      const invocation = tool.createInvocationForTest({
        task_id: 'task-123',
      });

      const result = await invocation.execute(createAbortSignal());

      expect(result.returnDisplay).toContain('**Duration**: 15.0s');
    });

    it('should pass provided values for block and timeout', async () => {
      const mockTask = createMockTask();
      vi.mocked(mockTaskManager.getOutput).mockResolvedValue(mockTask);

      const invocation = tool.createInvocationForTest({
        task_id: 'task-123',
      });

      await invocation.execute(createAbortSignal());

      // The tool passes the params as-is to getOutput
      expect(mockTaskManager.getOutput).toHaveBeenCalledWith('task-123', {
        block: undefined,
        timeout: undefined,
      });
    });
  });

  describe('invocation description', () => {
    it('should provide a meaningful description', () => {
      const invocation = tool.createInvocationForTest({
        task_id: 'task-456',
      });

      expect(invocation.getDescription()).toBe(
        "Getting output for task 'task-456'",
      );
    });
  });
});

describe('ListTasksTool', () => {
  let mockTaskManager: AgentTaskManager;
  let tool: ListTasksTool;

  beforeEach(() => {
    vi.resetAllMocks();
    mockTaskManager = createMockTaskManager();
    tool = new ListTasksTool(mockTaskManager);
  });

  describe('metadata', () => {
    it('should have correct name and description', () => {
      expect(tool.name).toBe('list_tasks');
      expect(tool.displayName).toBe('List Tasks');
      expect(tool.description).toContain('background agent tasks');
    });

    it('should have empty schema (no parameters)', () => {
      const schema = tool.schema;
      expect(schema).toBeDefined();
      expect(schema.parametersJsonSchema).toBeDefined();
      const jsonSchema = schema.parametersJsonSchema as Record<string, unknown>;
      expect(jsonSchema['type']).toBe('object');
      expect(jsonSchema['properties']).toEqual({});
    });
  });

  describe('execute', () => {
    it('should list all tasks', async () => {
      const mockTasks = [
        createMockTask({ id: 'task-1', agentName: 'agent-1', agentDisplayName: 'Agent One', status: 'completed' }),
        createMockTask({ id: 'task-2', agentName: 'agent-2', agentDisplayName: 'Agent Two', status: 'running' }),
        createMockTask({ id: 'task-3', agentName: 'agent-3', agentDisplayName: 'Agent Three', status: 'error' }),
      ];
      vi.mocked(mockTaskManager.listTasks).mockReturnValue(mockTasks);

      const invocation = tool.createInvocationForTest();

      const result = await invocation.execute(createAbortSignal());

      expect(mockTaskManager.listTasks).toHaveBeenCalled();

      // Check display output - uses agentDisplayName when available
      expect(result.returnDisplay).toContain('## Background Tasks');
      expect(result.returnDisplay).toContain('task-1');
      expect(result.returnDisplay).toContain('Agent One');
      expect(result.returnDisplay).toContain('COMPLETED');
      expect(result.returnDisplay).toContain('RUNNING');
      expect(result.returnDisplay).toContain('ERROR');

      // Check LLM output (JSON)
      const llmText = getLlmText(result);
      const parsed = JSON.parse(llmText);
      expect(parsed).toHaveLength(3);
      expect(parsed[0].id).toBe('task-1');
      expect(parsed[1].status).toBe('running');
    });

    it('should handle empty task list', async () => {
      vi.mocked(mockTaskManager.listTasks).mockReturnValue([]);

      const invocation = tool.createInvocationForTest();

      const result = await invocation.execute(createAbortSignal());

      expect(result.llmContent).toBe('No background tasks found.');
      expect(result.returnDisplay).toContain('*No background tasks.*');
    });

    it('should show truncated task IDs in display', async () => {
      const mockTasks = [
        createMockTask({
          id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
          agentName: 'test-agent',
        }),
      ];
      vi.mocked(mockTaskManager.listTasks).mockReturnValue(mockTasks);

      const invocation = tool.createInvocationForTest();

      const result = await invocation.execute(createAbortSignal());

      // Should show first 8 characters + "..."
      expect(result.returnDisplay).toContain('a1b2c3d4...');
    });

    it('should use display name when available', async () => {
      const mockTasks = [
        createMockTask({
          agentName: 'internal-name',
          agentDisplayName: 'Friendly Display Name',
        }),
      ];
      vi.mocked(mockTaskManager.listTasks).mockReturnValue(mockTasks);

      const invocation = tool.createInvocationForTest();

      const result = await invocation.execute(createAbortSignal());

      expect(result.returnDisplay).toContain('Friendly Display Name');
    });
  });

  describe('invocation description', () => {
    it('should provide a meaningful description', () => {
      const invocation = tool.createInvocationForTest();

      expect(invocation.getDescription()).toBe('Listing all background tasks');
    });
  });
});

// Helper method extension for testing
declare module './task-output-tool.js' {
  interface TaskOutputTool {
    createInvocationForTest(
      params: { task_id: string; block?: boolean; timeout?: number },
    ): ReturnType<TaskOutputTool['createInvocation']>;
  }
  interface ListTasksTool {
    createInvocationForTest(): ReturnType<ListTasksTool['createInvocation']>;
  }
}

// Add test helper methods to the classes
TaskOutputTool.prototype.createInvocationForTest = function (params) {
  return this['createInvocation'](params);
};

ListTasksTool.prototype.createInvocationForTest = function () {
  return this['createInvocation']();
};
