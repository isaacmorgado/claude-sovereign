import type { Request, Response, NextFunction } from 'express'
import { z } from 'zod'
import * as audioService from '../services/audio-service.js'
import { s3Service } from '../services/s3-service.js'
import type { AuthenticatedRequest, ApiResponse } from '../types/api.js'
import type { AudioJobPublic } from '../types/audio.js'

const presignedUrlSchema = z.object({
  filename: z.string().min(1),
  contentType: z.string().min(1),
  fileSize: z.number().positive().max(500 * 1024 * 1024), // 500MB max
})

type JobResponse = ApiResponse<AudioJobPublic>
type JobListResponse = ApiResponse<AudioJobPublic[]>
type CanSubmitResponse = ApiResponse<{ allowed: boolean; reason?: string }>

export async function submitTranscription(
  req: Request,
  res: Response<JobResponse>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const validated = audioService.submitJobSchema.parse(req.body)

    const job = await audioService.submitTranscriptionJob(
      authReq.user,
      validated.audioUrl,
      validated.audioDurationMinutes
    )

    res.status(201).json({
      success: true,
      data: job,
    })
  } catch (error) {
    next(error)
  }
}

export async function submitVocalIsolation(
  req: Request,
  res: Response<JobResponse>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const validated = audioService.submitJobSchema.parse(req.body)

    const job = await audioService.submitVocalIsolationJob(
      authReq.user,
      validated.audioUrl,
      validated.audioDurationMinutes
    )

    res.status(201).json({
      success: true,
      data: job,
    })
  } catch (error) {
    next(error)
  }
}

export async function getJob(
  req: Request,
  res: Response<JobResponse>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const { jobId } = req.params

    if (!jobId) {
      res.status(400).json({
        success: false,
        error: 'Job ID is required',
      })
      return
    }

    const job = await audioService.getJobStatus(authReq.user, jobId)

    res.json({
      success: true,
      data: job,
    })
  } catch (error) {
    next(error)
  }
}

export async function listJobs(
  req: Request,
  res: Response<JobListResponse>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const limit = Math.min(parseInt(req.query.limit as string) || 20, 100)
    const offset = parseInt(req.query.offset as string) || 0

    const jobs = await audioService.getUserJobs(authReq.user, limit, offset)

    res.json({
      success: true,
      data: jobs,
    })
  } catch (error) {
    next(error)
  }
}

export async function canSubmit(
  req: Request,
  res: Response<CanSubmitResponse>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const durationMinutes = parseFloat(req.query.minutes as string)

    if (isNaN(durationMinutes) || durationMinutes <= 0) {
      res.status(400).json({
        success: false,
        error: 'Valid minutes parameter is required',
      })
      return
    }

    const allowed = await audioService.canSubmitJob(authReq.user, durationMinutes)

    res.json({
      success: true,
      data: {
        allowed,
        reason: allowed ? undefined : 'Usage limit exceeded or too many pending jobs',
      },
    })
  } catch (error) {
    next(error)
  }
}
