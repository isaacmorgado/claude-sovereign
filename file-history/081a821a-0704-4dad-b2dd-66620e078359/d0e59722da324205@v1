// Selection Panel - Core selection tools for Premiere Pro
import { LitElement, html, css } from 'lit'
import { customElement, property, state } from 'lit/decorators.js'
import type { ClipSelection } from '@/types/plugin'
import { selectClipsByTimeRange, selectAllClipsInTrack } from '@/utils/api/premiere'
import { formatTimecode, formatDuration } from '@/utils/helpers/formatters'
import { logger } from '@/utils/logger'

@customElement('selection-panel')
export class SelectionPanel extends LitElement {
  static styles = css`
    :host {
      display: block;
    }

    .section {
      margin-bottom: var(--space-lg);
    }

    .section-title {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      color: var(--text-secondary);
      margin-bottom: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .selection-summary {
      background: var(--bg-layer-1);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      margin-bottom: var(--space-md);
    }

    .summary-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-xs) 0;
    }

    .summary-stat:not(:last-child) {
      border-bottom: 1px solid var(--border-default);
    }

    .stat-label {
      color: var(--text-secondary);
      font-size: var(--font-size-sm);
    }

    .stat-value {
      font-weight: var(--font-weight-medium);
    }

    .clip-list {
      max-height: 200px;
      overflow-y: auto;
      background: var(--bg-layer-1);
      border-radius: var(--radius-md);
    }

    .clip-item {
      display: flex;
      align-items: center;
      padding: var(--space-sm) var(--space-md);
      gap: var(--space-sm);
      border-bottom: 1px solid var(--border-default);
    }

    .clip-item:last-child {
      border-bottom: none;
    }

    .clip-icon {
      width: 16px;
      height: 16px;
      border-radius: 2px;
    }

    .clip-icon.video {
      background: var(--color-primary);
    }

    .clip-icon.audio {
      background: var(--color-accent);
    }

    .clip-info {
      flex: 1;
      min-width: 0;
    }

    .clip-name {
      font-size: var(--font-size-sm);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .clip-time {
      font-size: var(--font-size-xs);
      color: var(--text-secondary);
    }

    .empty-state {
      text-align: center;
      padding: var(--space-xl);
      color: var(--text-secondary);
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: var(--space-md);
      opacity: 0.5;
    }

    .quick-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-sm);
    }

    .time-range-form {
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
    }

    .time-inputs {
      display: flex;
      gap: var(--space-sm);
    }

    .time-inputs sp-textfield {
      flex: 1;
    }
  `

  @property({ type: Array }) selectedClips: ClipSelection[] = []
  @property({ type: Boolean }) isLoading = false

  @state() private startTime = ''
  @state() private endTime = ''
  @state() private selectedTrack = -1

  private handleRefresh(): void {
    this.dispatchEvent(new CustomEvent('refresh', { bubbles: true, composed: true }))
  }

  private async handleTimeRangeSelect(): Promise<void> {
    if (!this.startTime || !this.endTime) return

    try {
      const start = parseFloat(this.startTime)
      const end = parseFloat(this.endTime)

      if (isNaN(start) || isNaN(end) || end <= start) {
        logger.warn('Invalid time range')
        return
      }

      await selectClipsByTimeRange(start, end)
      this.handleRefresh()
    } catch (error) {
      logger.error('Failed to select by time range', error)
    }
  }

  private async handleSelectAllInTrack(trackIndex: number, type: 'video' | 'audio'): Promise<void> {
    try {
      await selectAllClipsInTrack(trackIndex, type)
      this.handleRefresh()
    } catch (error) {
      logger.error('Failed to select all in track', error)
    }
  }

  private getTotalDuration(): number {
    return this.selectedClips.reduce((total, clip) => total + (clip.endTime - clip.startTime), 0)
  }

  private getVideoClipsCount(): number {
    return this.selectedClips.filter((c) => c.type === 'video').length
  }

  private getAudioClipsCount(): number {
    return this.selectedClips.filter((c) => c.type === 'audio').length
  }

  render() {
    if (this.isLoading) {
      return html`
        <div class="empty-state">
          <sp-progress-circle indeterminate size="l" label="Loading selection"></sp-progress-circle>
          <p>Loading selection...</p>
        </div>
      `
    }

    return html`
      <div class="section">
        <div class="section-title">Current Selection</div>

        ${this.selectedClips.length > 0
          ? html`
              <div class="selection-summary">
                <div class="summary-stat">
                  <span class="stat-label">Total Clips</span>
                  <span class="stat-value">${this.selectedClips.length}</span>
                </div>
                <div class="summary-stat">
                  <span class="stat-label">Video / Audio</span>
                  <span class="stat-value"
                    >${this.getVideoClipsCount()} / ${this.getAudioClipsCount()}</span
                  >
                </div>
                <div class="summary-stat">
                  <span class="stat-label">Total Duration</span>
                  <span class="stat-value">${formatDuration(this.getTotalDuration())}</span>
                </div>
              </div>

              <div class="clip-list">
                ${this.selectedClips.map(
                  (clip) => html`
                    <div class="clip-item">
                      <div class="clip-icon ${clip.type}"></div>
                      <div class="clip-info">
                        <div class="clip-name">${clip.name}</div>
                        <div class="clip-time">
                          ${formatTimecode(clip.startTime)} - ${formatTimecode(clip.endTime)}
                        </div>
                      </div>
                    </div>
                  `
                )}
              </div>
            `
          : html`
              <div class="empty-state">
                <div class="empty-state-icon">ðŸŽ¬</div>
                <p>No clips selected</p>
                <p>Select clips in Premiere Pro timeline or use the tools below</p>
              </div>
            `}
      </div>

      <div class="section">
        <div class="section-title">Quick Actions</div>
        <div class="quick-actions">
          <sp-button variant="secondary" @click=${this.handleRefresh}>
            Refresh Selection
          </sp-button>
          <sp-button variant="secondary" @click=${() => this.handleSelectAllInTrack(0, 'video')}>
            Select V1 Track
          </sp-button>
        </div>
      </div>

      <div class="section">
        <div class="section-title">Select by Time Range</div>
        <div class="time-range-form">
          <div class="time-inputs">
            <sp-textfield
              placeholder="Start (sec)"
              .value=${this.startTime}
              @input=${(e: Event) => (this.startTime = (e.target as HTMLInputElement).value)}
            ></sp-textfield>
            <sp-textfield
              placeholder="End (sec)"
              .value=${this.endTime}
              @input=${(e: Event) => (this.endTime = (e.target as HTMLInputElement).value)}
            ></sp-textfield>
          </div>
          <sp-button variant="primary" @click=${this.handleTimeRangeSelect}>
            Select Range
          </sp-button>
        </div>
      </div>
    `
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'selection-panel': SelectionPanel
  }
}
