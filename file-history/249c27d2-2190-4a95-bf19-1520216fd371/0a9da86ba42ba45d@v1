import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

// We need to mock the module before importing
vi.mock('uxp', () => ({
  storage: {
    localFileSystem: {
      getDataFolder: vi.fn().mockResolvedValue({
        getEntry: vi.fn().mockRejectedValue(new Error('File not found')),
        createFile: vi.fn().mockResolvedValue({
          write: vi.fn().mockResolvedValue(undefined),
          read: vi.fn().mockResolvedValue('{}'),
          delete: vi.fn().mockResolvedValue(undefined),
        }),
      }),
    },
  },
}))

// Mock fetch before importing the module
const mockFetch = vi.fn()
global.fetch = mockFetch

// Helper to create mock responses
function createMockResponse<T>(data: T, options: { ok?: boolean; status?: number } = {}) {
  const { ok = true, status = 200 } = options
  return {
    ok,
    status,
    statusText: ok ? 'OK' : 'Error',
    json: vi.fn().mockResolvedValue({ success: true, data }),
  }
}

function createErrorResponse(error: string, status = 400) {
  return {
    ok: false,
    status,
    statusText: 'Error',
    json: vi.fn().mockResolvedValue({ success: false, error }),
  }
}

describe('BackendClient', () => {
  let backendClient: typeof import('@/utils/api/backend-client').backendClient

  beforeEach(async () => {
    vi.clearAllMocks()
    mockFetch.mockReset()

    // Reset module state by re-importing to get a fresh singleton
    vi.resetModules()
    const module = await import('@/utils/api/backend-client')
    backendClient = module.backendClient

    // Clear any tokens that may have been loaded
    backendClient.clearTokens()
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('Authentication', () => {
    describe('login', () => {
      it('should login successfully and store tokens', async () => {
        const mockUser = {
          id: 'user-123',
          email: 'test@example.com',
          name: 'Test User',
          plan: 'free' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'access-token-123',
          refreshToken: 'refresh-token-456',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )

        const result = await backendClient.login('test@example.com', 'password123')

        expect(mockFetch).toHaveBeenCalledWith(
          'http://localhost:3001/api/auth/login',
          expect.objectContaining({
            method: 'POST',
            headers: expect.objectContaining({
              'Content-Type': 'application/json',
            }),
            body: JSON.stringify({ email: 'test@example.com', password: 'password123' }),
          })
        )

        expect(result.user).toEqual(mockUser)
        expect(result.tokens).toEqual(mockTokens)
        expect(backendClient.isAuthenticated()).toBe(true)
        expect(backendClient.getUser()).toEqual(mockUser)
      })

      it('should throw error on invalid credentials', async () => {
        mockFetch.mockResolvedValueOnce(createErrorResponse('Invalid credentials', 401))

        await expect(backendClient.login('test@example.com', 'wrong')).rejects.toThrow(
          'Invalid credentials'
        )
      })

      it('should throw error on network failure', async () => {
        mockFetch.mockRejectedValueOnce(new Error('Network error'))

        await expect(backendClient.login('test@example.com', 'password')).rejects.toThrow(
          'Network error'
        )
      })
    })

    describe('register', () => {
      it('should register successfully and store tokens', async () => {
        const mockUser = {
          id: 'user-new',
          email: 'new@example.com',
          name: 'New User',
          plan: 'free' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'new-access-token',
          refreshToken: 'new-refresh-token',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )

        const result = await backendClient.register('new@example.com', 'password123', 'New User')

        expect(mockFetch).toHaveBeenCalledWith(
          'http://localhost:3001/api/auth/register',
          expect.objectContaining({
            method: 'POST',
            body: JSON.stringify({
              email: 'new@example.com',
              password: 'password123',
              name: 'New User',
            }),
          })
        )

        expect(result.user).toEqual(mockUser)
        expect(result.tokens).toEqual(mockTokens)
      })

      it('should register without name', async () => {
        const mockUser = {
          id: 'user-new',
          email: 'new@example.com',
          plan: 'free' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'new-access-token',
          refreshToken: 'new-refresh-token',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )

        await backendClient.register('new@example.com', 'password123')

        expect(mockFetch).toHaveBeenCalledWith(
          expect.any(String),
          expect.objectContaining({
            body: JSON.stringify({
              email: 'new@example.com',
              password: 'password123',
              name: undefined,
            }),
          })
        )
      })

      it('should throw error on duplicate email', async () => {
        mockFetch.mockResolvedValueOnce(createErrorResponse('Email already exists', 409))

        await expect(
          backendClient.register('existing@example.com', 'password')
        ).rejects.toThrow('Email already exists')
      })
    })

    describe('logout', () => {
      it('should logout and clear tokens', async () => {
        // First login to set tokens
        const mockUser = {
          id: 'user-123',
          email: 'test@example.com',
          plan: 'free' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'access-token',
          refreshToken: 'refresh-token',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )
        await backendClient.login('test@example.com', 'password')

        // Now logout
        mockFetch.mockResolvedValueOnce(createMockResponse({}))
        await backendClient.logout()

        expect(backendClient.isAuthenticated()).toBe(false)
        expect(backendClient.getUser()).toBeNull()
      })

      it('should clear tokens even if logout API fails', async () => {
        // First login
        const mockUser = {
          id: 'user-123',
          email: 'test@example.com',
          plan: 'free' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'access-token',
          refreshToken: 'refresh-token',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )
        await backendClient.login('test@example.com', 'password')

        // Logout fails (returns error response) but tokens should still be cleared
        mockFetch.mockResolvedValueOnce(createErrorResponse('Server error', 500))
        await backendClient.logout()

        expect(backendClient.isAuthenticated()).toBe(false)
        expect(backendClient.getUser()).toBeNull()
      })
    })

    describe('getMe', () => {
      it('should fetch current user', async () => {
        // Login first
        const mockUser = {
          id: 'user-123',
          email: 'test@example.com',
          plan: 'pro' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'access-token',
          refreshToken: 'refresh-token',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )
        await backendClient.login('test@example.com', 'password')

        // Get me
        mockFetch.mockResolvedValueOnce(createMockResponse(mockUser))
        const user = await backendClient.getMe()

        expect(user).toEqual(mockUser)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/auth/me',
          expect.objectContaining({
            headers: expect.objectContaining({
              Authorization: 'Bearer access-token',
            }),
          })
        )
      })
    })

    describe('isAuthenticated', () => {
      it('should return false when not logged in', () => {
        // Clear any existing auth state
        backendClient.clearTokens()
        expect(backendClient.isAuthenticated()).toBe(false)
      })

      it('should return true when logged in', async () => {
        const mockUser = {
          id: 'user-123',
          email: 'test@example.com',
          plan: 'free' as const,
          createdAt: '2024-01-01T00:00:00Z',
        }
        const mockTokens = {
          accessToken: 'access-token',
          refreshToken: 'refresh-token',
        }

        mockFetch.mockResolvedValueOnce(
          createMockResponse({ user: mockUser, tokens: mockTokens })
        )
        await backendClient.login('test@example.com', 'password')

        expect(backendClient.isAuthenticated()).toBe(true)
      })
    })
  })

  describe('Token Refresh Flow', () => {
    it('should refresh token on 401 and retry request', async () => {
      // Login first
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'pro' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'old-access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')

      // First request fails with 401
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        json: vi.fn().mockResolvedValue({ error: 'Token expired' }),
      })

      // Token refresh succeeds
      const newTokens = {
        accessToken: 'new-access-token',
        refreshToken: 'new-refresh-token',
      }
      mockFetch.mockResolvedValueOnce(createMockResponse(newTokens))

      // Retry succeeds
      const usageStats = { used: 10, limit: 300, resetDate: '2024-02-01', plan: 'pro' }
      mockFetch.mockResolvedValueOnce(createMockResponse(usageStats))

      const result = await backendClient.getUsage()

      expect(result).toEqual(usageStats)
      expect(mockFetch).toHaveBeenCalledTimes(4) // login + 401 + refresh + retry
    })

    it('should clear tokens and throw on refresh failure', async () => {
      // Login first
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'pro' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'old-access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')

      // First request fails with 401
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        json: vi.fn().mockResolvedValue({ error: 'Token expired' }),
      })

      // Token refresh fails
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        json: vi.fn().mockResolvedValue({ error: 'Invalid refresh token' }),
      })

      await expect(backendClient.getUsage()).rejects.toThrow()
      expect(backendClient.isAuthenticated()).toBe(false)
    })
  })

  describe('Auth Change Callbacks', () => {
    it('should notify callbacks on login', async () => {
      const callback = vi.fn()
      backendClient.onAuthChange(callback)

      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'free' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')

      expect(callback).toHaveBeenCalledWith(mockUser)
    })

    it('should notify callbacks on logout', async () => {
      const callback = vi.fn()

      // Login first
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'free' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')

      backendClient.onAuthChange(callback)

      // Logout
      mockFetch.mockResolvedValueOnce(createMockResponse({}))
      await backendClient.logout()

      expect(callback).toHaveBeenCalledWith(null)
    })

    it('should allow unsubscribing from callbacks', async () => {
      const callback = vi.fn()
      const unsubscribe = backendClient.onAuthChange(callback)
      unsubscribe()

      // Login - callback should not be called
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'free' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')

      expect(callback).not.toHaveBeenCalled()
    })
  })

  describe('Usage', () => {
    beforeEach(async () => {
      // Login before each usage test
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'pro' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')
    })

    describe('getUsage', () => {
      it('should fetch usage stats', async () => {
        const usageStats = {
          used: 50,
          limit: 300,
          resetDate: '2024-02-01T00:00:00Z',
          plan: 'pro',
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(usageStats))
        const result = await backendClient.getUsage()

        expect(result).toEqual(usageStats)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/usage',
          expect.objectContaining({
            headers: expect.objectContaining({
              Authorization: 'Bearer access-token',
            }),
          })
        )
      })
    })

    describe('checkUsageLimit', () => {
      it('should check if user can use minutes', async () => {
        const checkResult = { allowed: true, remaining: 250 }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkResult))
        const result = await backendClient.checkUsageLimit(50)

        expect(result).toEqual(checkResult)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/usage/check?minutes=50',
          expect.any(Object)
        )
      })

      it('should return not allowed when exceeding limit', async () => {
        const checkResult = { allowed: false, remaining: 10 }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkResult))
        const result = await backendClient.checkUsageLimit(100)

        expect(result.allowed).toBe(false)
        expect(result.remaining).toBe(10)
      })
    })

    describe('canSubmitAudioJob', () => {
      it('should check if user can submit audio job', async () => {
        const checkResult = { allowed: true }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkResult))
        const result = await backendClient.canSubmitAudioJob(50)

        expect(result).toEqual(checkResult)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/audio/check?minutes=50',
          expect.any(Object)
        )
      })

      it('should return reason when not allowed', async () => {
        const checkResult = { allowed: false, reason: 'Usage limit exceeded or too many pending jobs' }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkResult))
        const result = await backendClient.canSubmitAudioJob(100)

        expect(result.allowed).toBe(false)
        expect(result.reason).toBe('Usage limit exceeded or too many pending jobs')
      })
    })
  })

  describe('Audio Jobs', () => {
    beforeEach(async () => {
      // Login before each test
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'pro' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')
    })

    describe('submitTranscription', () => {
      it('should submit transcription job with audio URL and duration', async () => {
        const mockJob = {
          id: 'job-123',
          jobType: 'transcription' as const,
          status: 'pending' as const,
          audioDurationMinutes: 5,
          resultUrl: null,
          resultData: null,
          errorMessage: null,
          createdAt: '2024-01-01T00:00:00Z',
          completedAt: null,
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(mockJob))

        const result = await backendClient.submitTranscription('https://storage.example.com/audio.wav', 5)

        expect(result).toEqual(mockJob)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/audio/transcribe',
          expect.objectContaining({
            method: 'POST',
            headers: expect.objectContaining({
              'Content-Type': 'application/json',
              Authorization: 'Bearer access-token',
            }),
            body: JSON.stringify({ audioUrl: 'https://storage.example.com/audio.wav', audioDurationMinutes: 5 }),
          })
        )
      })
    })

    describe('submitVocalIsolation', () => {
      it('should submit vocal isolation job with audio URL and duration', async () => {
        const mockJob = {
          id: 'job-456',
          jobType: 'vocal_isolation' as const,
          status: 'pending' as const,
          audioDurationMinutes: 3.5,
          resultUrl: null,
          resultData: null,
          errorMessage: null,
          createdAt: '2024-01-01T00:00:00Z',
          completedAt: null,
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(mockJob))

        const result = await backendClient.submitVocalIsolation('https://storage.example.com/audio.mp3', 3.5)

        expect(result).toEqual(mockJob)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/audio/isolate-vocals',
          expect.objectContaining({
            method: 'POST',
            headers: expect.objectContaining({
              'Content-Type': 'application/json',
              Authorization: 'Bearer access-token',
            }),
            body: JSON.stringify({ audioUrl: 'https://storage.example.com/audio.mp3', audioDurationMinutes: 3.5 }),
          })
        )
      })
    })

    describe('getJobs', () => {
      it('should fetch all jobs for user', async () => {
        const mockJobs = [
          {
            id: 'job-1',
            jobType: 'transcription' as const,
            status: 'completed' as const,
            audioDurationMinutes: 5,
            resultUrl: 'https://results.example.com/job-1',
            resultData: { text: 'Hello', segments: [], language: 'en', confidence: 0.95 },
            errorMessage: null,
            createdAt: '2024-01-01T00:00:00Z',
            completedAt: '2024-01-01T00:05:00Z',
          },
          {
            id: 'job-2',
            jobType: 'vocal_isolation' as const,
            status: 'processing' as const,
            audioDurationMinutes: 3,
            resultUrl: null,
            resultData: null,
            errorMessage: null,
            createdAt: '2024-01-02T00:00:00Z',
            completedAt: null,
          },
        ]

        mockFetch.mockResolvedValueOnce(createMockResponse(mockJobs))
        const result = await backendClient.getJobs()

        expect(result).toEqual(mockJobs)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/audio/jobs?limit=20&offset=0',
          expect.any(Object)
        )
      })

      it('should support limit and offset parameters', async () => {
        mockFetch.mockResolvedValueOnce(createMockResponse([]))
        await backendClient.getJobs(10, 5)

        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/audio/jobs?limit=10&offset=5',
          expect.any(Object)
        )
      })
    })

    describe('getJob', () => {
      it('should fetch specific job by id', async () => {
        const mockJob = {
          id: 'job-123',
          jobType: 'transcription' as const,
          status: 'completed' as const,
          audioDurationMinutes: 1,
          resultUrl: 'https://results.example.com/job-123',
          resultData: {
            text: 'Hello world',
            segments: [{ start: 0, end: 1, text: 'Hello world', confidence: 0.95 }],
            language: 'en',
            confidence: 0.95,
          },
          errorMessage: null,
          createdAt: '2024-01-01T00:00:00Z',
          completedAt: '2024-01-01T00:01:00Z',
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(mockJob))
        const result = await backendClient.getJob('job-123')

        expect(result).toEqual(mockJob)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/audio/jobs/job-123',
          expect.any(Object)
        )
      })

      it('should throw error for non-existent job', async () => {
        mockFetch.mockResolvedValueOnce(createErrorResponse('Job not found', 404))

        await expect(backendClient.getJob('non-existent')).rejects.toThrow('Job not found')
      })
    })

    describe('pollJobUntilComplete', () => {
      it('should poll until job completes', async () => {
        vi.useFakeTimers()

        const pendingJob = {
          id: 'job-123',
          jobType: 'transcription' as const,
          status: 'processing' as const,
          audioDurationMinutes: 1,
          resultUrl: null,
          resultData: null,
          errorMessage: null,
          createdAt: '2024-01-01T00:00:00Z',
          completedAt: null,
        }

        const completedJob = {
          ...pendingJob,
          status: 'completed' as const,
          resultUrl: 'https://results.example.com/job-123',
          resultData: {
            text: 'Hello world',
            segments: [],
            language: 'en',
            confidence: 0.95,
          },
          completedAt: '2024-01-01T00:01:00Z',
        }

        // First poll returns processing
        mockFetch.mockResolvedValueOnce(createMockResponse(pendingJob))
        // Second poll returns completed
        mockFetch.mockResolvedValueOnce(createMockResponse(completedJob))

        const onProgress = vi.fn()
        const pollPromise = backendClient.pollJobUntilComplete('job-123', onProgress, { intervalMs: 1000 })

        // Advance timers to trigger polls
        await vi.advanceTimersByTimeAsync(0) // First poll
        await vi.advanceTimersByTimeAsync(1000) // Second poll

        const result = await pollPromise

        expect(result.status).toBe('completed')
        expect(onProgress).toHaveBeenCalledTimes(2)
        expect(onProgress).toHaveBeenNthCalledWith(1, pendingJob)
        expect(onProgress).toHaveBeenNthCalledWith(2, completedJob)

        vi.useRealTimers()
      })

      it('should reject when job fails', async () => {
        const failedJob = {
          id: 'job-123',
          jobType: 'transcription' as const,
          status: 'failed' as const,
          audioDurationMinutes: 1,
          resultUrl: null,
          resultData: null,
          errorMessage: 'Processing failed',
          createdAt: '2024-01-01T00:00:00Z',
          completedAt: null,
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(failedJob))

        await expect(backendClient.pollJobUntilComplete('job-123')).rejects.toThrow(
          'Processing failed'
        )
      })

      it('should reject on network error during polling', async () => {
        mockFetch.mockRejectedValueOnce(new Error('Network error'))

        await expect(backendClient.pollJobUntilComplete('job-123')).rejects.toThrow(
          'Network error'
        )
      })

      it('should timeout after max attempts', async () => {
        const pendingJob = {
          id: 'job-123',
          jobType: 'transcription' as const,
          status: 'processing' as const,
          audioDurationMinutes: 1,
          resultUrl: null,
          resultData: null,
          errorMessage: null,
          createdAt: '2024-01-01T00:00:00Z',
          completedAt: null,
        }

        // Return processing for all attempts
        mockFetch
          .mockResolvedValueOnce(createMockResponse(pendingJob))
          .mockResolvedValueOnce(createMockResponse(pendingJob))
          .mockResolvedValueOnce(createMockResponse(pendingJob))

        // Use very short interval and max 3 attempts to trigger timeout quickly
        await expect(
          backendClient.pollJobUntilComplete('job-123', undefined, {
            intervalMs: 1,
            maxAttempts: 3
          })
        ).rejects.toThrow('Job polling timed out')
      })
    })
  })

  describe('Billing', () => {
    beforeEach(async () => {
      // Login before each test
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'free' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')
    })

    describe('createCheckout', () => {
      it('should create checkout session for pro monthly', async () => {
        const checkoutResult = { sessionId: 'cs_123', url: 'https://checkout.stripe.com/session123' }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkoutResult))
        const result = await backendClient.createCheckout('pro', 'monthly')

        expect(result).toEqual(checkoutResult)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/billing/checkout',
          expect.objectContaining({
            method: 'POST',
            body: JSON.stringify({ tier: 'pro', interval: 'monthly' }),
          })
        )
      })

      it('should create checkout session for pro yearly', async () => {
        const checkoutResult = { sessionId: 'cs_456', url: 'https://checkout.stripe.com/session456' }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkoutResult))
        const result = await backendClient.createCheckout('pro', 'yearly')

        expect(result).toEqual(checkoutResult)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/billing/checkout',
          expect.objectContaining({
            body: JSON.stringify({ tier: 'pro', interval: 'yearly' }),
          })
        )
      })

      it('should default to monthly interval', async () => {
        const checkoutResult = { sessionId: 'cs_789', url: 'https://checkout.stripe.com/session789' }

        mockFetch.mockResolvedValueOnce(createMockResponse(checkoutResult))
        await backendClient.createCheckout('pro')

        expect(mockFetch).toHaveBeenLastCalledWith(
          expect.any(String),
          expect.objectContaining({
            body: JSON.stringify({ tier: 'pro', interval: 'monthly' }),
          })
        )
      })
    })

    describe('createPortal', () => {
      it('should create portal session', async () => {
        const portalResult = { url: 'https://billing.stripe.com/portal/session123' }

        mockFetch.mockResolvedValueOnce(createMockResponse(portalResult))
        const result = await backendClient.createPortal()

        expect(result).toEqual(portalResult)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/billing/portal',
          expect.objectContaining({
            method: 'POST',
          })
        )
      })
    })

    describe('getBillingStatus', () => {
      it('should get billing status for active subscription', async () => {
        const statusResult = {
          tier: 'pro' as const,
          status: 'active' as const,
          currentPeriodEnd: '2024-02-01T00:00:00Z',
          cancelAtPeriodEnd: false,
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(statusResult))
        const result = await backendClient.getBillingStatus()

        expect(result).toEqual(statusResult)
        expect(mockFetch).toHaveBeenLastCalledWith(
          'http://localhost:3001/api/billing/status',
          expect.any(Object)
        )
      })

      it('should get billing status for free tier', async () => {
        const statusResult = {
          tier: 'free' as const,
          status: 'none' as const,
          currentPeriodEnd: null,
          cancelAtPeriodEnd: false,
        }

        mockFetch.mockResolvedValueOnce(createMockResponse(statusResult))
        const result = await backendClient.getBillingStatus()

        expect(result.tier).toBe('free')
        expect(result.status).toBe('none')
      })
    })
  })

  describe('Error Handling', () => {
    beforeEach(async () => {
      // Login before each test
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        plan: 'pro' as const,
        createdAt: '2024-01-01T00:00:00Z',
      }
      const mockTokens = {
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
      }

      mockFetch.mockResolvedValueOnce(
        createMockResponse({ user: mockUser, tokens: mockTokens })
      )
      await backendClient.login('test@example.com', 'password')
    })

    it('should handle API error with error field', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 400,
        statusText: 'Bad Request',
        json: vi.fn().mockResolvedValue({ error: 'Invalid input' }),
      })

      await expect(backendClient.getUsage()).rejects.toThrow('Invalid input')
    })

    it('should handle API error with message field', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: vi.fn().mockResolvedValue({ message: 'Server error' }),
      })

      await expect(backendClient.getUsage()).rejects.toThrow('Server error')
    })

    it('should handle non-JSON error response', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 503,
        statusText: 'Service Unavailable',
        json: vi.fn().mockRejectedValue(new Error('Invalid JSON')),
      })

      await expect(backendClient.getUsage()).rejects.toThrow('Service Unavailable')
    })

    it('should handle successful response with success: false', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: 'OK',
        json: vi.fn().mockResolvedValue({ success: false, error: 'Operation failed' }),
      })

      await expect(backendClient.getUsage()).rejects.toThrow('Operation failed')
    })

    it('should handle successful response with missing data', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: 'OK',
        json: vi.fn().mockResolvedValue({ success: true }),
      })

      await expect(backendClient.getUsage()).rejects.toThrow('Request failed')
    })
  })
})
