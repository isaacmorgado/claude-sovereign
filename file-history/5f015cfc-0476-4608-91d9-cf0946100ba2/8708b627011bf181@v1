#!/bin/bash
# SPLICE CEP Patch Script for Danny
# Fixes EvalScript errors in Tests 3-6

set -e

CEP_DIR="$HOME/Library/Application Support/Adobe/CEP/extensions/com.splice.cep"

echo "=== SPLICE CEP Patch ==="
echo ""

# Check if extension is installed
if [ ! -d "$CEP_DIR" ]; then
    echo "ERROR: CEP extension not found at:"
    echo "  $CEP_DIR"
    echo ""
    echo "Please install SPLICE first, then run this patch."
    exit 1
fi

echo "Found extension at: $CEP_DIR"
echo ""

# Create backup
BACKUP_DIR="$CEP_DIR/backup-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"
cp "$CEP_DIR/jsx/hostScript.jsx" "$BACKUP_DIR/" 2>/dev/null || true
cp "$CEP_DIR/panel/js/main.js" "$BACKUP_DIR/" 2>/dev/null || true
echo "Backup created at: $BACKUP_DIR"

# Patch hostScript.jsx - Fix getActiveSequence and add getAllSequences
echo "Patching hostScript.jsx..."
cat > "/tmp/splice-patch-host.jsx" << 'HOSTPATCH'
function getActiveSequence() {
    try {
        var seq = app.project.activeSequence;
        if (!seq) return JSON.stringify({ error: "No active sequence" });

        // Safely get settings with fallbacks
        var frameRate = null;
        try {
            var settings = seq.getSettings();
            if (settings && settings.videoFrameRate) {
                frameRate = settings.videoFrameRate.seconds;
            }
        } catch (settingsErr) {
            $.writeln('[SPLICE] getActiveSequence: Failed to get settings: ' + settingsErr.message);
        }

        return JSON.stringify({
            name: seq.name || "Unknown",
            id: seq.sequenceID || null,
            duration: seq.end || 0,
            videoTrackCount: seq.videoTracks ? seq.videoTracks.numTracks : 0,
            audioTrackCount: seq.audioTracks ? seq.audioTracks.numTracks : 0,
            frameRate: frameRate,
            width: seq.frameSizeHorizontal || 0,
            height: seq.frameSizeVertical || 0
        });
    } catch (e) {
        $.writeln('[SPLICE] getActiveSequence error: ' + e.message);
        return JSON.stringify({ error: "getActiveSequence failed: " + e.message });
    }
}

function getAllSequences() {
    try {
        if (!app || !app.project || !app.project.sequences) {
            return JSON.stringify({ error: "No project open" });
        }

        var sequences = [];
        var numSeqs = app.project.sequences.numSequences;

        for (var i = 0; i < numSeqs; i++) {
            var seq = app.project.sequences[i];
            if (seq) {
                sequences.push({
                    name: seq.name || "Unknown",
                    id: seq.sequenceID || null,
                    index: i
                });
            }
        }

        return JSON.stringify(sequences);
    } catch (e) {
        $.writeln('[SPLICE] getAllSequences error: ' + e.message);
        return JSON.stringify({ error: "getAllSequences failed: " + e.message });
    }
}
HOSTPATCH

# Replace the old getActiveSequence function and add getAllSequences
# Using sed to find and replace the function block
HOSTFILE="$CEP_DIR/jsx/hostScript.jsx"

# Check if getAllSequences already exists
if grep -q "function getAllSequences" "$HOSTFILE"; then
    echo "  getAllSequences already exists, skipping..."
else
    # Find the line after getActiveSequence function ends and insert getAllSequences
    # First, let's replace getActiveSequence with the fixed version

    # Create a Python script to do the replacement (more reliable than sed for multiline)
    python3 << PYTHONSCRIPT
import re

with open("$HOSTFILE", "r") as f:
    content = f.read()

# Pattern to match the old getActiveSequence function
old_pattern = r'function getActiveSequence\(\) \{\s*var seq = app\.project\.activeSequence;\s*if \(!seq\) return JSON\.stringify\(\{ error: "No active sequence" \}\);\s*return JSON\.stringify\(\{\s*name: seq\.name,\s*id: seq\.sequenceID,\s*duration: seq\.end,\s*videoTrackCount: seq\.videoTracks\.numTracks,\s*audioTrackCount: seq\.audioTracks\.numTracks,\s*frameRate: seq\.getSettings\(\)\.videoFrameRate\.seconds,\s*width: seq\.frameSizeHorizontal,\s*height: seq\.frameSizeVertical\s*\}\);\s*\}'

new_code = '''function getActiveSequence() {
    try {
        var seq = app.project.activeSequence;
        if (!seq) return JSON.stringify({ error: "No active sequence" });

        // Safely get settings with fallbacks
        var frameRate = null;
        try {
            var settings = seq.getSettings();
            if (settings && settings.videoFrameRate) {
                frameRate = settings.videoFrameRate.seconds;
            }
        } catch (settingsErr) {
            $.writeln('[SPLICE] getActiveSequence: Failed to get settings: ' + settingsErr.message);
        }

        return JSON.stringify({
            name: seq.name || "Unknown",
            id: seq.sequenceID || null,
            duration: seq.end || 0,
            videoTrackCount: seq.videoTracks ? seq.videoTracks.numTracks : 0,
            audioTrackCount: seq.audioTracks ? seq.audioTracks.numTracks : 0,
            frameRate: frameRate,
            width: seq.frameSizeHorizontal || 0,
            height: seq.frameSizeVertical || 0
        });
    } catch (e) {
        $.writeln('[SPLICE] getActiveSequence error: ' + e.message);
        return JSON.stringify({ error: "getActiveSequence failed: " + e.message });
    }
}

function getAllSequences() {
    try {
        if (!app || !app.project || !app.project.sequences) {
            return JSON.stringify({ error: "No project open" });
        }

        var sequences = [];
        var numSeqs = app.project.sequences.numSequences;

        for (var i = 0; i < numSeqs; i++) {
            var seq = app.project.sequences[i];
            if (seq) {
                sequences.push({
                    name: seq.name || "Unknown",
                    id: seq.sequenceID || null,
                    index: i
                });
            }
        }

        return JSON.stringify(sequences);
    } catch (e) {
        $.writeln('[SPLICE] getAllSequences error: ' + e.message);
        return JSON.stringify({ error: "getAllSequences failed: " + e.message });
    }
}'''

new_content = re.sub(old_pattern, new_code, content, flags=re.DOTALL)

if new_content == content:
    print("  Warning: Pattern not found, may already be patched")
else:
    with open("$HOSTFILE", "w") as f:
        f.write(new_content)
    print("  hostScript.jsx patched successfully")
PYTHONSCRIPT
fi

# Patch main.js - Fix Test 5 and Test 6 inline scripts
echo "Patching main.js..."

MAINFILE="$CEP_DIR/panel/js/main.js"

python3 << 'PYTHONSCRIPT2'
import re

mainfile = "/Users/$USER/Library/Application Support/Adobe/CEP/extensions/com.splice.cep/panel/js/main.js".replace("$USER", __import__("os").environ["USER"])

with open(mainfile, "r") as f:
    content = f.read()

# Fix Test 5 - wrap in IIFE
old_test5 = r'''const result = await jsx\.evalScript\(`
                if \(app && app\.project && app\.project\.activeSequence\) \{
                    JSON\.stringify\(\{
                        success: true,
                        name: app\.project\.activeSequence\.name,
                        id: app\.project\.activeSequence\.sequenceID
                    \}\);
                \} else \{
                    JSON\.stringify\(\{
                        success: false,
                        reason: app \? \(app\.project \? 'app\.project\.activeSequence is null' : 'app\.project is null'\) : 'app is null'
                    \}\);
                \}
            `\);'''

new_test5 = '''const result = await jsx.evalScript(`
                (function() {
                    try {
                        if (app && app.project && app.project.activeSequence) {
                            return JSON.stringify({
                                success: true,
                                name: app.project.activeSequence.name,
                                id: app.project.activeSequence.sequenceID
                            });
                        } else {
                            return JSON.stringify({
                                success: false,
                                reason: app ? (app.project ? 'app.project.activeSequence is null' : 'app.project is null') : 'app is null'
                            });
                        }
                    } catch (e) {
                        return JSON.stringify({ success: false, reason: 'Error: ' + e.message });
                    }
                })()
            `);'''

content = re.sub(old_test5, new_test5.replace("\\", "\\\\"), content)

# Fix Test 6 - wrap in IIFE
old_test6 = r'''const qeResult = await jsx\.evalScript\(`
                if \(typeof qe !== 'undefined' && qe !== null\) \{
                    JSON\.stringify\(\{ available: true \}\);
                \} else \{
                    JSON\.stringify\(\{ available: false \}\);
                \}
            `\);'''

new_test6 = '''const qeResult = await jsx.evalScript(`
                (function() {
                    try {
                        if (typeof qe !== 'undefined' && qe !== null) {
                            return JSON.stringify({ available: true });
                        } else {
                            return JSON.stringify({ available: false });
                        }
                    } catch (e) {
                        return JSON.stringify({ available: false, error: e.message });
                    }
                })()
            `);'''

content = re.sub(old_test6, new_test6.replace("\\", "\\\\"), content)

# Also update the QE result handler to show error if present
old_qe_handler = "addDiagnosticLog('✗ QE DOM is NOT available');"
new_qe_handler = "addDiagnosticLog('✗ QE DOM is NOT available' + (qeData.error ? ': ' + qeData.error : ''));"
content = content.replace(old_qe_handler, new_qe_handler)

with open(mainfile, "w") as f:
    f.write(content)

print("  main.js patched successfully")
PYTHONSCRIPT2

echo ""
echo "=== Patch Complete ==="
echo ""
echo "IMPORTANT: Restart Premiere Pro for changes to take effect."
echo ""
echo "After restarting, open SPLICE panel and click 'Run Diagnostics'"
echo "Tests 3-6 should now pass."
