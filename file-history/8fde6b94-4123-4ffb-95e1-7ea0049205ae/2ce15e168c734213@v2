/**
 * Health Check Routes
 *
 * System health and status endpoints
 */

const express = require('express');
const { isFFprobeInstalled } = require('../services/ffprobeSilence');
const { isReplicateConfigured } = require('../services/vocalIsolation');
const { checkDatabase } = require('../services/usageTracking');

/**
 * Create health routes
 * @param {Object} options - Route configuration options
 * @returns {express.Router}
 */
function createHealthRoutes(_options = {}) {
  const router = express.Router();

  /**
   * GET / - API information
   */
  router.get('/', (req, res) => {
    res.json({
      service: 'splice-backend',
      version: '6.0.3',
      endpoints: {
        'GET /': 'This info',
        'GET /health': 'Health check',
        'GET /ffprobe-check': 'Check if FFprobe is installed',
        'GET /replicate-check': 'Check if Replicate API is configured',
        'POST /analyze': 'Analyze WAV file { wavPath }',
        'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',
        'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',
        'POST /silences-rms': 'Detect silences via RMS analysis { wavPath, threshold: -30, minSilenceLength: 0.5, paddingStart: 0.1, paddingEnd: 0.05, autoThreshold: false, sensitivity: 50 }',
        'POST /profanity': 'Detect profanity in transcript { wavPath, language: "en", customBlocklist: [], customAllowlist: [] }',
        'GET /profanity/languages': 'Get supported languages for profanity detection',
        'GET /profanity/bleeps': 'Get available bleep sounds',
        'POST /repetitions': 'Detect phrase repetitions and stutters { wavPath, phraseSize: 5, tolerance: 0.7, useOpenAI: false }',
        'POST /fillers': 'Detect filler words (um, uh, like, etc.) { wavPath, customFillers: [] }',
        'POST /stutters': 'Detect single-word stutters only { wavPath, minRepeats: 2 }',
        'POST /export/captions': 'Export transcript to caption format { wavPath, format: srt|vtt|txt|json, outputPath? }',
        'GET /export/formats': 'Get supported caption export formats',
        'POST /multitrack': 'Analyze multiple audio tracks for multicam { audioPaths: [], speakerNames: [], videoTrackMapping: {} }',
        'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',
        'POST /multitrack/advanced-balance': 'Advanced GA-optimized balancing { audioPaths: [], maxConsecutiveSeconds: 30, momentumFactor: 0.7 }',
        'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',
        'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',
        'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',
        'POST /zoom': 'Generate zoom points from transcript { transcript, settings: { frequency, preset, placement } }',
        'GET /zoom/presets': 'Get available zoom presets and frequencies',
        'POST /chapters': 'Detect chapters in transcript using AI { transcript, settings: { maxChapters, minChapterLength } }',
        'POST /chapters/fallback': 'Detect chapters without AI (gap-based) { transcript, settings }',
        'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',
        'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',
        'GET /batch/status/:jobId': 'Get batch job status',
        'GET /batch/results/:jobId': 'Get full batch job results',
        'GET /batch/jobs': 'List all batch jobs',
        'DELETE /batch/:jobId': 'Delete a batch job',
        'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',
        'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',
        'POST /webhooks/stripe': 'Stripe webhook endpoint',
        'GET /referral/code': 'Get or create referral code for user',
        'POST /referral/validate': 'Validate a referral code',
        'POST /referral/apply': 'Apply referral code at signup',
        'GET /referral/stats': 'Get referral statistics for user',
        'POST /license/activate': 'Activate license key { key: "SPLICE-XXXX-XXXX-XXXX" }',
        'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)',
        'POST /license/resend': 'Resend license key to customer email { customerId? }'
      }
    });
  });

  /**
   * GET /health - Health check with database connectivity
   */
  router.get('/health', async (req, res) => {
    const health = {
      status: 'ok',
      service: 'splice-backend',
      version: '6.0.3',
      timestamp: new Date().toISOString(),
      checks: {
        database: 'unknown'
      }
    };

    try {
      const dbHealthy = await checkDatabase();
      health.checks.database = dbHealthy ? 'healthy' : 'unhealthy';
    } catch (err) {
      health.checks.database = 'error';
      health.status = 'degraded';
      console.error('[Health] Database check failed:', err.message);
    }

    const statusCode = health.status === 'ok' ? 200 : 503;
    res.status(statusCode).json(health);
  });

  /**
   * GET /ffprobe-check - Check if FFprobe is installed
   */
  router.get('/ffprobe-check', async (req, res) => {
    const installed = await isFFprobeInstalled();
    res.json({
      installed,
      message: installed
        ? 'FFprobe is available'
        : 'FFprobe not found. Install with: brew install ffmpeg'
    });
  });

  /**
   * GET /replicate-check - Check if Replicate API is configured
   */
  router.get('/replicate-check', async (req, res) => {
    const configured = isReplicateConfigured();
    res.json({
      configured,
      message: configured
        ? 'Replicate API is configured'
        : 'REPLICATE_API_TOKEN not set. Add to .env file.'
    });
  });

  return router;
}

module.exports = createHealthRoutes;
