/**
 * SPLICE CEP Panel - Main Entry Point
 * v4.0.0 - CEP Migration
 */

// ============================================================================
// CACHED DOM ELEMENTS
// ============================================================================
const ui = {};

function cacheUIElements() {
    ui.status = document.getElementById('status');
    ui.goBtn = document.getElementById('goBtn');
    ui.optionsToggle = document.getElementById('optionsToggle');
    ui.optionsPanel = document.getElementById('optionsPanel');

    // DIAGNOSTIC: Log critical element status immediately
    const criticalElements = {
        'status': ui.status,
        'goBtn': ui.goBtn,
        'optionsToggle': ui.optionsToggle,
        'optionsPanel': ui.optionsPanel
    };
    const missingCritical = Object.entries(criticalElements)
        .filter(([name, el]) => !el)
        .map(([name]) => name);

    if (missingCritical.length > 0) {
        console.error('[SPLICE] CRITICAL: Missing UI elements during cache:', missingCritical);
        console.error('[SPLICE] DOM readyState:', document.readyState);
    }

    // Sliders and options
    ui.sensitivitySlider = document.getElementById('sensitivitySlider');
    ui.sensitivityValue = document.getElementById('sensitivityValue');
    ui.sourceOriginal = document.getElementById('sourceOriginal');
    ui.sourceIsolated = document.getElementById('sourceIsolated');

    // Feature toggles
    ui.enableTakesDetection = document.getElementById('enableTakesDetection');
    ui.enableJCut = document.getElementById('enableJCut');
    ui.jcutSettings = document.getElementById('jcutSettings');
    ui.jcutLeadIn = document.getElementById('jcutLeadIn');
    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');
    ui.jcutLeadOut = document.getElementById('jcutLeadOut');
    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');

    // Zoom settings
    ui.enableZoom = document.getElementById('enableZoom');
    ui.zoomSettings = document.getElementById('zoomSettings');
    ui.zoomFrequency = document.getElementById('zoomFrequency');
    ui.zoomPreset = document.getElementById('zoomPreset');
    ui.zoomPlacement = document.getElementById('zoomPlacement');

    // Chapter settings
    ui.enableChapters = document.getElementById('enableChapters');
    ui.chapterSettings = document.getElementById('chapterSettings');
    ui.maxChapters = document.getElementById('maxChapters');
    ui.minChapterLength = document.getElementById('minChapterLength');

    // Profanity settings
    ui.enableProfanity = document.getElementById('enableProfanity');
    ui.profanitySettings = document.getElementById('profanitySettings');

    // Filler word settings
    ui.enableFillerDetection = document.getElementById('enableFillerDetection');
    ui.fillerSettings = document.getElementById('fillerSettings');

    // Progress
    ui.progressContainer = document.getElementById('progressContainer');
    ui.progressBar = document.getElementById('progressBar');
    ui.progressText = document.getElementById('progressText');
    ui.resultsEmpty = document.getElementById('resultsEmpty');

    // Preview
    ui.combinedPreview = document.getElementById('combinedPreview');
    ui.previewList = document.getElementById('previewList');
    ui.silenceCount = document.getElementById('silenceCount');
    ui.takeCount = document.getElementById('takeCount');
    ui.selectedCount = document.getElementById('selectedCount');
    ui.selectAllSilences = document.getElementById('selectAllSilences');
    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');

    // Results
    ui.zoomResults = document.getElementById('zoomResults');
    ui.zoomList = document.getElementById('zoomList');
    ui.chapterResults = document.getElementById('chapterResults');
    ui.chapterList = document.getElementById('chapterList');
    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');
    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');

    // Modals
    ui.settingsBtn = document.getElementById('settingsBtn');
    ui.settingsModal = document.getElementById('settingsModal');
    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
    ui.loginModal = document.getElementById('loginModal');
    ui.closeLoginBtn = document.getElementById('closeLoginBtn');
    ui.licenseKeyInput = document.getElementById('licenseKeyInput');
    ui.saveLoginBtn = document.getElementById('saveLoginBtn');

    // Debug modal
    ui.debugBtn = document.getElementById('debugBtn');
    ui.debugModal = document.getElementById('debugModal');
    ui.closeDebugBtn = document.getElementById('closeDebugBtn');
    ui.debugQuickDiagnosis = document.getElementById('debugQuickDiagnosis');
    ui.debugLogs = document.getElementById('debugLogs');
    ui.runDiagnosticsBtn = document.getElementById('runDiagnosticsBtn');
    ui.copyDiagnosticsBtn = document.getElementById('copyDiagnosticsBtn');

    // Credit badge
    ui.creditBadge = document.getElementById('creditBadge');

    // Preset selector
    ui.presetSelector = document.getElementById('presetSelector');
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================
let previewSilences = [];
let previewTakes = [];
let currentChapters = [];
let currentZooms = [];
let currentProfanity = [];
let selectedSilenceIndices = new Set();
let isOperationInProgress = false;
let lastDetectionResult = null;
let currentAudioPath = null;
let currentSequenceInfo = null;
let currentTranscript = null;

// Global state for captions/reframe modules
window.spliceState = {
    lastTranscript: null,
    currentVideoPath: null,
    activeSequence: null,
    audioPath: null
};

// Also expose transcript globally for music module
window.currentTranscript = null;

// FIX: Operation lock to prevent race conditions on GO button
let operationLock = {
    locked: false,
    async acquire() {
        while (this.locked) {
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        this.locked = true;
    },
    release() {
        this.locked = false;
    }
};

// ============================================================================
// INITIALIZATION
// ============================================================================
document.addEventListener('DOMContentLoaded', async () => {
    // DIAGNOSTIC: Panel initialization start
    console.log('[SPLICE DIAGNOSTIC] ========== PANEL INITIALIZATION START ==========');
    console.log('[SPLICE DIAGNOSTIC] Document readyState:', document.readyState);

    try {
        console.log('[SPLICE] Initializing CEP panel...');

    // Get loader elements for progress updates
    const loader = document.getElementById('loading-overlay');
    const loaderText = loader ? loader.querySelector('.loader-text') : null;

    // Add timeout warning after 5 seconds
    const timeoutWarning = setTimeout(() => {
        if (loaderText && loader && !loader.classList.contains('hidden')) {
            loaderText.textContent = 'Still loading, please wait...';
            console.warn('[SPLICE] Initialization taking longer than expected');
        }
    }, 5000);

    // Debug: Show init started
    const statusEl = document.getElementById('status');
    if (statusEl) statusEl.textContent = 'Initializing...';

    // Cache DOM elements
    cacheUIElements();

    // Load settings
    loadSettingsToUI();

    // Initialize UI handlers
    initOptionsToggle();
    initSliders();
    initFeatureToggles();
    initPresetSelector();
    initGoButton();
    initPreviewHandlers();
    initModals();
    initLoginModal();
    initCredits();
    initHelpButton();
    initDebugModal();

    // Initialize offline detection
    if (typeof initOfflineDetection === 'function') {
        initOfflineDetection();
    }

    // Initialize multitrack UI
    if (typeof initMultitrackUI === 'function') {
        initMultitrackUI();
    }

    // Initialize animated captions UI
    if (typeof initAnimatedCaptions === 'function') {
        initAnimatedCaptions();
    }

    // Initialize text editor UI
    if (typeof initTextEditor === 'function') {
        initTextEditor();
    }

    // Initialize text editor section toggle
    initTextEditorToggle();

    // Initialize social reframe UI
    if (typeof initSocialReframe === 'function') {
        initSocialReframe();
    }

    // Initialize social reframe section toggle
    initSocialReframeToggle();

    // Initialize music UI
    if (typeof initMusicModule === 'function') {
        initMusicModule();
    }

    // Initialize music section toggle
    initMusicToggle();

    // Initialize JSX bridge first, then check connection
    // This ensures jsx.init() completes before checkJSXConnection() uses it
    console.log('[SPLICE DIAGNOSTIC] ========== JSX INITIALIZATION START ==========');
    if (loaderText) loaderText.textContent = 'Connecting to Premiere Pro...';

    try {
        await jsx.init();
        console.log('[SPLICE DIAGNOSTIC] jsx.init() completed successfully');
    } catch (e) {
        console.error('[SPLICE DIAGNOSTIC] jsx.init() FAILED:', e);
        console.error('[SPLICE DIAGNOSTIC] Error stack:', e.stack);
    }

    console.log('[SPLICE DIAGNOSTIC] Calling checkJSXConnection()...');
    await checkJSXConnection();

    // FIX: Wait for Premiere Pro API to be fully ready
    console.log('[SPLICE] Waiting for Premiere Pro API to be ready...');
    if (loaderText) loaderText.textContent = 'Waiting for Premiere Pro API...';

    const premiereReady = await waitForPremiereReady(10, 500);
    if (!premiereReady) {
        console.warn('[SPLICE] Premiere Pro API not ready after timeout');
        setStatus('Warning: Premiere Pro API not fully initialized', true);
    } else {
        console.log('[SPLICE] Premiere Pro API ready');
    }

    // Detect Premiere Pro features after JSX is ready
    if (typeof SpliceCompatibility !== 'undefined') {
        try {
            const premiereFeatures = await SpliceCompatibility.detectPremiereFeatures();
            debugLog('Premiere features detected:', premiereFeatures);
        } catch (e) {
            console.warn('[SPLICE] Failed to detect Premiere features:', e.message);
        }
    }

    // Initialize sequence event listeners for real-time state updates
    initSequenceEventListeners();

    // DIAGNOSTIC: Verify all critical UI elements are properly initialized
    verifyUIInitialization();

    // Clear timeout warning and hide loader with smooth transition
    clearTimeout(timeoutWarning);
    if (loader) {
        setTimeout(() => {
            loader.classList.add('hidden');
            console.log('[SPLICE DIAGNOSTIC] Loading overlay hidden after initialization complete');
        }, 300); // Small delay for smooth perception
    }

    setStatus('Ready');
    debugLog('CEP panel initialized');

    } catch (initError) {
        console.error('[SPLICE] CRITICAL: Panel initialization failed:', initError);
        console.error('[SPLICE] Error stack:', initError.stack);

        // Try to show error to user
        const statusEl = document.getElementById('status');
        if (statusEl) statusEl.textContent = 'Initialization failed - see console';

        // Clear timeout and hide loader even on error
        if (typeof timeoutWarning !== 'undefined') clearTimeout(timeoutWarning);
        const loader = document.getElementById('loading-overlay');
        if (loader) loader.classList.add('hidden');
    }
});

/**
 * Post-initialization diagnostic to verify all critical UI elements
 * are properly cached and event listeners are attached
 */
function verifyUIInitialization() {
    const criticalElements = {
        'goBtn': { el: ui.goBtn, desc: 'GO button (main action)' },
        'settingsBtn': { el: ui.settingsBtn, desc: 'Settings button' },
        'creditBadge': { el: ui.creditBadge, desc: 'Credit badge' },
        'status': { el: ui.status, desc: 'Status bar' },
        'optionsToggle': { el: ui.optionsToggle, desc: 'Options toggle' },
        'optionsPanel': { el: ui.optionsPanel, desc: 'Options panel' }
    };

    const missingElements = [];
    const presentElements = [];

    Object.entries(criticalElements).forEach(([id, { el, desc }]) => {
        if (!el) {
            missingElements.push(`#${id} (${desc})`);
        } else {
            presentElements.push(id);
        }
    });

    if (missingElements.length > 0) {
        console.error('[SPLICE] ⚠️ UI INITIALIZATION INCOMPLETE');
        console.error('[SPLICE] Missing critical elements:', missingElements);
        console.error('[SPLICE] Panel may not function correctly. Check index.html structure.');

        // Show error in status bar if available
        const statusEl = document.getElementById('status');
        if (statusEl) {
            statusEl.textContent = 'Init error: ' + missingElements.length + ' UI elements missing';
            statusEl.classList.add('error');
        }
    } else {
        console.log('[SPLICE] ✓ All critical UI elements initialized:', presentElements.join(', '));
    }

    // Verify GO button has click listener
    if (ui.goBtn) {
        const listeners = getEventListeners ? getEventListeners(ui.goBtn) : null;
        if (!listeners || !listeners.click || listeners.click.length === 0) {
            // Can't check in production, but log that we tried
            console.log('[SPLICE] GO button present - click handler should be attached');
        }
    }
}

// ============================================================================
// SEQUENCE EVENT LISTENERS
// ============================================================================
/**
 * Initialize event listeners for sequence state changes
 * This provides real-time updates when sequences are activated/deactivated
 */
function initSequenceEventListeners() {
    if (!jsx.cs) {
        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');
        return;
    }

    try {
        // Listen for sequence activation events
        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {
            debugLog('Sequence activated event received');
            try {
                const seqInfo = await jsx.call('getActiveSequence');
                if (seqInfo && !seqInfo.error) {
                    window.spliceState.activeSequence = seqInfo;
                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));
                    debugLog('Active sequence updated:', seqInfo.name);
                }
            } catch (e) {
                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);
            }
        });

        // Listen for sequence close/deactivation
        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {
            debugLog('Sequence deactivated event');
            window.spliceState.activeSequence = null;
            setStatus('No sequence open', true);
        });

        // Listen for project item selection changes (includes sequences)
        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {
            // Debounce rapid selection changes
            if (window._selectionChangeTimeout) {
                clearTimeout(window._selectionChangeTimeout);
            }
            // FIX: Increased debounce to 500ms to allow Premiere Pro state to settle
            window._selectionChangeTimeout = setTimeout(async () => {
                try {
                    // FIX: Use retries (2 attempts, 300ms delay) to handle timing issues
                    // Previous code used (0, 0) which caused race conditions
                    const hasSequence = await checkSequenceOpen(2, 300);
                    if (hasSequence) {
                        const seqInfo = await jsx.call('getActiveSequence');
                        if (seqInfo && !seqInfo.error) {
                            // Check if sequence actually changed by comparing IDs
                            const currentId = window.spliceState.activeSequence ? window.spliceState.activeSequence.id : null;

                            // Always update if ID changed or we didn't have a sequence before
                            if (currentId !== seqInfo.id) {
                                window.spliceState.activeSequence = seqInfo;
                                setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));
                                debugLog('Active sequence changed:', seqInfo.name, '(ID: ' + seqInfo.id + ')');
                            }
                        }
                    } else {
                        // If we had a sequence but now don't, likely closed or lost focus
                        if (window.spliceState.activeSequence) {
                            debugLog('Sequence check failed - potentially lost focus');
                            // We don't verify strict nulling here to avoid flickering, 
                            // as SequenceDeactivated event should handle the explicit close.
                        }
                    }
                } catch (e) {
                    // FIX: Log errors instead of silently ignoring
                    console.warn('[SPLICE] Selection change handler error:', e.message);
                    debugLog('Selection change failed:', e.message);
                }
            }, 500);
        });

        debugLog('Sequence event listeners initialized');
    } catch (e) {
        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);
    }
}

// ============================================================================
// JSX CONNECTION CHECK
// ============================================================================
async function checkJSXConnection() {
    try {
        const result = await jsx.call('getVersion');
        debugLog('JSX connection OK, version:', result);
        return true;
    } catch (e) {
        console.warn('[SPLICE] JSX connection failed:', e.message);
        const errorDetail = e.message || 'Unknown error';
        setStatus(`Premiere Pro connection failed: ${errorDetail}`, true);

        // Also try to log to a visible area if possible (detection log)
        const logArea = document.getElementById('detection-log');
        if (logArea) {
            logArea.innerHTML += `<div class="error-item">JSX Error: ${errorDetail}</div>`;
        }

        return false;
    }
}

/**
 * Wait for Premiere Pro API to be ready
 * FIX: Ensures app.project and activeSequence APIs are available before operations
 * @param {number} maxAttempts - Maximum number of attempts (default: 10)
 * @param {number} delayMs - Delay between attempts in ms (default: 500)
 * @returns {Promise<boolean>} true if Premiere Pro is ready
 */
async function waitForPremiereReady(maxAttempts = 10, delayMs = 500) {
    console.log('[SPLICE] waitForPremiereReady: Starting with maxAttempts=' + maxAttempts);

    for (let i = 0; i < maxAttempts; i++) {
        try {
            console.log('[SPLICE] waitForPremiereReady: Attempt ' + (i + 1) + ' of ' + maxAttempts);
            const ready = await jsx.call('checkPremiereReady');

            if (ready === true || ready === 'true') {
                console.log('[SPLICE] waitForPremiereReady: ✓ Premiere Pro is ready');
                return true;
            }

            console.log('[SPLICE] waitForPremiereReady: Not ready yet, waiting ' + delayMs + 'ms...');
            await new Promise(r => setTimeout(r, delayMs));
        } catch (e) {
            console.warn('[SPLICE] waitForPremiereReady: Attempt ' + (i + 1) + ' failed:', e.message);
            await new Promise(r => setTimeout(r, delayMs));
        }
    }

    console.error('[SPLICE] waitForPremiereReady: Failed after ' + maxAttempts + ' attempts');
    return false;
}

/**
 * Check if a sequence is currently open in the Timeline
 * Enhanced with logging and retry logic
 * @param {number} retries - Number of retry attempts (default: 2)
 * @param {number} delayMs - Delay between retries in ms (default: 300)
 * @returns {Promise<boolean>} true if sequence is open
 */
async function checkSequenceOpen(retries = 2, delayMs = 300) {
    console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');
    console.log('[SPLICE] checkSequenceOpen: retries=' + retries + ', delayMs=' + delayMs);
    console.log('[SPLICE] checkSequenceOpen: window.spliceState.activeSequence =', window.spliceState.activeSequence);

    for (let attempt = 0; attempt <= retries; attempt++) {
        try {
            console.log('[SPLICE] checkSequenceOpen: Attempt ' + (attempt + 1) + ' of ' + (retries + 1));
            console.log('[SPLICE] checkSequenceOpen: Calling jsx.callWithTimeout("checkSequenceOpen", [], JSX_TIMEOUTS.QUICK)...');
            // FIX: Use QUICK timeout (5s) instead of DEFAULT (30s) for fast feedback
            const result = await jsx.callWithTimeout('checkSequenceOpen', [], JSX_TIMEOUTS.QUICK);
            console.log('[SPLICE] checkSequenceOpen: JSX call returned');
            console.log('[SPLICE] checkSequenceOpen: result =', result, '(type:', typeof result + ')');
            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);

            if (result === true || result === 'true') {
                console.log('[SPLICE] checkSequenceOpen: Returning TRUE - sequence is open');
                console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');
                return true;
            }

            // If false, wait and retry (sequence might be loading)
            if (attempt < retries) {
                console.log('[SPLICE] checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');
                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');
                await new Promise(r => setTimeout(r, delayMs));
            }
        } catch (error) {
            console.error('[SPLICE] checkSequenceOpen: Attempt', attempt + 1, 'failed with exception:', error.message);
            console.error('[SPLICE] checkSequenceOpen: Error stack:', error.stack);

            // On last attempt, return false but log the actual error
            if (attempt === retries) {
                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);
                // Store error for diagnostics
                window.spliceState.lastSequenceCheckError = error.message;
                console.log('[SPLICE] checkSequenceOpen: Stored error in window.spliceState.lastSequenceCheckError:', error.message);
                console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');
                return false;
            }

            // Wait before retry
            console.log('[SPLICE] checkSequenceOpen: Waiting', delayMs, 'ms before retry...');
            await new Promise(r => setTimeout(r, delayMs));
        }
    }
    console.log('[SPLICE] checkSequenceOpen: All attempts completed without finding sequence');
    console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');
    return false;
}

/**
 * Get active sequence info with retry logic
 * FIX: Enhanced version with automatic retries on failure
 * @param {number} retries - Number of retry attempts (default: 3)
 * @param {number} delayMs - Delay between retries in ms (default: 300)
 * @returns {Promise<Object|null>} Sequence info or null on failure
 */
async function getActiveSequenceWithRetry(retries = 3, delayMs = 300) {
    console.log('[SPLICE] getActiveSequenceWithRetry: Starting with retries=' + retries);

    for (let attempt = 0; attempt <= retries; attempt++) {
        try {
            console.log('[SPLICE] getActiveSequenceWithRetry: Attempt ' + (attempt + 1) + ' of ' + (retries + 1));
            const seqInfo = await jsx.call('getActiveSequence');

            if (seqInfo && !seqInfo.error) {
                console.log('[SPLICE] getActiveSequenceWithRetry: ✓ Got sequence:', seqInfo.name);
                return seqInfo;
            }

            if (seqInfo && seqInfo.error) {
                console.warn('[SPLICE] getActiveSequenceWithRetry: Error from JSX:', seqInfo.error);
            }

            // Retry if not last attempt
            if (attempt < retries) {
                console.log('[SPLICE] getActiveSequenceWithRetry: No sequence found, retrying in ' + delayMs + 'ms...');
                await new Promise(r => setTimeout(r, delayMs));
            }
        } catch (error) {
            console.error('[SPLICE] getActiveSequenceWithRetry: Attempt failed:', error.message);
            if (attempt === retries) {
                console.error('[SPLICE] getActiveSequenceWithRetry: All attempts failed');
                return null;
            }
            await new Promise(r => setTimeout(r, delayMs));
        }
    }
    console.log('[SPLICE] getActiveSequenceWithRetry: Returning null after all attempts');
    return null;
}

// ============================================================================
// OPTIONS TOGGLE
// ============================================================================
function initOptionsToggle() {
    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);
    if (ui.optionsToggle && ui.optionsPanel) {
        ui.optionsToggle.addEventListener('click', () => {
            debugLog('Options toggle clicked');
            // Check current state BEFORE toggling
            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');
            ui.optionsPanel.classList.toggle('collapsed');
            // If it was collapsed, it's now expanded (show 'expanded' class)
            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);
            saveSettings({ expandedOptions: wasCollapsed });
        });

        // Restore state
        const settings = getSettings();
        if (!settings.expandedOptions) {
            ui.optionsPanel.classList.add('collapsed');
            ui.optionsToggle.classList.remove('expanded');
        } else {
            ui.optionsToggle.classList.add('expanded');
            ui.optionsPanel.classList.remove('collapsed');
        }
    }
}

// ============================================================================
// TEXT EDITOR TOGGLE
// ============================================================================
function initTextEditorToggle() {
    const toggle = document.getElementById('textEditorToggle');
    const panel = document.getElementById('text-editor-panel');
    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);

    if (toggle && panel) {
        toggle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            debugLog('Text Editor toggle clicked');
            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));
            // Check state BEFORE toggling
            const wasCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            const icon = toggle.querySelector('.toggle-icon');
            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);
            if (icon) {
                // If it was collapsed, it's now expanded (show -)
                icon.textContent = wasCollapsed ? '-' : '+';
            }
        });
    } else {
        console.error('[SPLICE] Text Editor toggle elements not found!');
    }
}

// ============================================================================
// SOCIAL REFRAME TOGGLE
// ============================================================================
function initSocialReframeToggle() {
    const toggle = document.getElementById('socialReframeToggle');
    const panel = document.getElementById('social-reframe-panel');
    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);

    if (toggle && panel) {
        toggle.addEventListener('click', () => {
            debugLog('Social Reframe toggle clicked');
            // Check state BEFORE toggling
            const wasCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            const icon = toggle.querySelector('.toggle-icon');
            if (icon) {
                // If it was collapsed, it's now expanded (show -)
                icon.textContent = wasCollapsed ? '-' : '+';
            }
        });
    } else {
        console.error('[SPLICE] Social Reframe toggle elements not found!');
    }
}

// ============================================================================
// MUSIC TOGGLE
// ============================================================================
function initMusicToggle() {
    const toggle = document.getElementById('musicToggle');
    const panel = document.getElementById('music-panel');
    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);

    if (toggle && panel) {
        toggle.addEventListener('click', () => {
            debugLog('Music toggle clicked');
            // Check state BEFORE toggling
            const wasCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            const icon = toggle.querySelector('.toggle-icon');
            if (icon) {
                // If it was collapsed, it's now expanded (show -)
                icon.textContent = wasCollapsed ? '-' : '+';
            }
        });
    } else {
        console.error('[SPLICE] Music toggle elements not found!');
    }
}

// ============================================================================
// SLIDERS
// ============================================================================
function initSliders() {
    // Sensitivity slider
    if (ui.sensitivitySlider && ui.sensitivityValue) {
        ui.sensitivitySlider.addEventListener('input', () => {
            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;
            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });
        });
    }

    // J-Cut sliders
    if (ui.jcutLeadIn && ui.jcutLeadInValue) {
        ui.jcutLeadIn.addEventListener('input', () => {
            const val = (ui.jcutLeadIn.value / 100).toFixed(2);
            ui.jcutLeadInValue.textContent = val + 's';
            saveSettings({ jcutLeadIn: parseFloat(val) });
        });
    }

    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {
        ui.jcutLeadOut.addEventListener('input', () => {
            const val = (ui.jcutLeadOut.value / 100).toFixed(2);
            ui.jcutLeadOutValue.textContent = val + 's';
            saveSettings({ jcutLeadOut: parseFloat(val) });
        });
    }
}

// ============================================================================
// FEATURE TOGGLES
// ============================================================================
function initFeatureToggles() {
    // J-Cut toggle
    if (ui.enableJCut && ui.jcutSettings) {
        ui.enableJCut.addEventListener('change', () => {
            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);
            saveSettings({ enableJCut: ui.enableJCut.checked });
        });
    }

    // Zoom toggle
    if (ui.enableZoom && ui.zoomSettings) {
        ui.enableZoom.addEventListener('change', () => {
            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);
            saveSettings({ enableZoom: ui.enableZoom.checked });
        });
    }

    // Chapters toggle
    if (ui.enableChapters && ui.chapterSettings) {
        ui.enableChapters.addEventListener('change', () => {
            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);
            saveSettings({ enableChapters: ui.enableChapters.checked });
        });
    }

    // Takes detection toggle
    if (ui.enableTakesDetection) {
        ui.enableTakesDetection.addEventListener('change', () => {
            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });
        });
    }

    // Profanity detection toggle
    if (ui.enableProfanity && ui.profanitySettings) {
        ui.enableProfanity.addEventListener('change', () => {
            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);
            saveSettings({ enableProfanity: ui.enableProfanity.checked });
        });
    }

    // Filler word detection toggle
    if (ui.enableFillerDetection && ui.fillerSettings) {
        ui.enableFillerDetection.addEventListener('change', () => {
            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);
            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });
        });
    }
}

// ============================================================================
// PRESET SELECTOR
// ============================================================================
// PRESETS is defined in config.js

function initPresetSelector() {
    if (!ui.presetSelector) return;

    ui.presetSelector.addEventListener('change', () => {
        const presetId = ui.presetSelector.value;
        applyPreset(presetId);
    });

    // Load current preset
    const settings = getSettings();
    if (settings.activePreset) {
        ui.presetSelector.value = settings.activePreset;
    }
}

function applyPreset(presetId) {
    const preset = PRESETS[presetId];
    if (!preset) return;

    // Custom preset - keep current settings
    if (presetId === 'custom' || !preset.settings) {
        saveSettings({ activePreset: 'custom' });
        setStatus('Using custom settings');
        return;
    }

    const settings = preset.settings;

    // Apply to UI
    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {
        ui.sensitivitySlider.value = settings.sensitivity;
        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;
    }

    if (ui.enableJCut) {
        ui.enableJCut.checked = settings.enableJCut || false;
        if (ui.jcutSettings) {
            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);
        }
    }

    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {
        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);
        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';
    }

    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {
        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);
        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';
    }

    // Save merged settings
    saveSettings({
        activePreset: presetId,
        sensitivity: settings.sensitivity,
        threshold: settings.threshold,
        minSilenceLength: settings.minSilenceLength,
        paddingStart: settings.paddingStart,
        paddingEnd: settings.paddingEnd,
        enableTakesDetection: settings.enableTakesDetection,
        enableJCut: settings.enableJCut || false,
        jcutLeadIn: settings.jCutLeadIn || 0.3,
        jcutLeadOut: settings.jCutLeadOut || 0.2
    });

    setStatus(`Applied ${preset.name} preset`);
}

// ============================================================================
// LOAD SETTINGS TO UI
// ============================================================================
function loadSettingsToUI() {
    const settings = getSettings();

    if (ui.sensitivitySlider) {
        ui.sensitivitySlider.value = settings.sensitivity;
        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;
    }

    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;
    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;
    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;
    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;

    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);
    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);
    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);

    if (ui.jcutLeadIn) {
        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);
        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';
    }
    if (ui.jcutLeadOut) {
        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);
        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';
    }

    if (ui.presetSelector && settings.activePreset) {
        ui.presetSelector.value = settings.activePreset;
    }
}

// ============================================================================
// GO BUTTON - MAIN WORKFLOW
// ============================================================================
function initGoButton() {
    if (!ui.goBtn) {
        console.error('[SPLICE] initGoButton FAILED: #goBtn element not found in DOM');
        console.error('[SPLICE] Check that index.html contains <button id="goBtn">');
        return;
    }

    ui.goBtn.addEventListener('click', async () => {
        // FIX: Use operation lock to prevent race conditions
        await operationLock.acquire();
        try {
            await runDetection();
        } finally {
            operationLock.release();
        }
    });
    console.log('[SPLICE] initGoButton: GO button initialized successfully');
}

async function runDetection() {
    if (isOperationInProgress) return;

    // FIX: Add 200ms initial delay to allow Premiere Pro DOM to settle
    // This handles the race condition where user just opened/switched a sequence
    // and the DOM APIs haven't updated yet (100-200ms lag observed)
    setStatus('Checking sequence...');
    await new Promise(r => setTimeout(r, 200));

    // Check sequence with enhanced error messaging
    const hasSequence = await checkSequenceOpen();
    if (!hasSequence) {
        // Check if there was a communication error vs just no sequence
        const lastError = window.spliceState.lastSequenceCheckError;
        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {
            setStatus('Premiere Pro connection issue - try reopening panel', true);
            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);
        } else {
            setStatus('Please open a sequence in the Timeline first', true);
            debugLog('runDetection: No active sequence in Timeline');
        }
        // Clear the error for next check
        window.spliceState.lastSequenceCheckError = null;
        return;
    }

    // Check online
    if (!isOnline()) {
        setStatus('Offline - Check your connection', true);
        return;
    }

    isOperationInProgress = true;
    ui.goBtn.disabled = true;
    showProgress('Detecting silences...');

    try {
        const settings = getSettings();

        // FIX: Get sequence info with retry logic
        const seqInfo = await getActiveSequenceWithRetry(3, 300);
        debugLog('Sequence info:', seqInfo);

        if (!seqInfo) {
            console.warn('[SPLICE] runDetection: getActiveSequenceWithRetry failed after retries');
            setStatus('Could not access active sequence info', true);
            ui.goBtn.disabled = false;
            isOperationInProgress = false;
            hideProgress();
            return;
        }

        // Store sequence info for later use
        currentSequenceInfo = seqInfo;
        window.spliceState.activeSequence = seqInfo;
        if (seqInfo && seqInfo.videoPath) {
            window.spliceState.currentVideoPath = seqInfo.videoPath;
        }

        // Export audio via JSX for silence detection
        updateProgress(10, 'Exporting audio...');

        let audioFilePath = null;
        try {
            // FIX: CEP-CRIT-010 - Main.js Export Timeout
            // Use LONG timeout (120s) for export operations
            const exportResult = await jsx.callWithTimeout(
                'exportSequenceAudioForAnalysis',
                [],
                JSX_TIMEOUTS.LONG
            );
            if (exportResult && exportResult.success && exportResult.outputPath) {
                audioFilePath = exportResult.outputPath;
                debugLog('Audio exported to:', audioFilePath);
            } else if (exportResult && exportResult.error) {
                throw new Error(exportResult.error);
            }
        } catch (exportError) {
            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);
            // Try to get audio from first clip in timeline
            try {
                const clipInfo = await jsx.call('getFirstClipAudioPath');
                if (clipInfo && clipInfo.path) {
                    audioFilePath = clipInfo.path;
                    debugLog('Using clip audio path:', audioFilePath);
                }
            } catch (clipError) {
                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);
            }
        }

        if (!audioFilePath) {
            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');
        }

        // Store audio path globally for other modules
        currentAudioPath = audioFilePath;
        window.spliceState.audioPath = audioFilePath;

        // Call backend for silence detection with audio file path
        updateProgress(30, 'Detecting silences...');
        const silenceResponse = await fetchWithTimeout(
            `${getBackendUrl()}/silences-rms`,
            {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    wavPath: audioFilePath,
                    sensitivity: settings.sensitivity,
                    minSilenceLength: settings.minSilenceLength || 0.5
                })
            }
        );

        if (!silenceResponse.ok) {
            throw new Error(await parseErrorResponse(silenceResponse));
        }

        const silenceData = await silenceResponse.json();
        previewSilences = silenceData.silences || [];

        // Detect takes if enabled
        if (settings.enableTakesDetection) {
            updateProgress(60, 'Detecting takes...');
            try {
                const analyzeResponse = await fetchWithTimeout(
                    `${getBackendUrl()}/analyze`,
                    {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            wavPath: audioFilePath,
                            detectTakes: true
                        })
                    }
                );

                if (analyzeResponse.ok) {
                    const analyzeData = await analyzeResponse.json();
                    previewTakes = analyzeData.takes || [];

                    // Store transcript for captions/music modules
                    if (analyzeData.transcript) {
                        currentTranscript = analyzeData.transcript;
                        window.currentTranscript = analyzeData.transcript;
                        window.spliceState.lastTranscript = analyzeData.transcript;
                    }
                } else {
                    // Handle specific error codes
                    const errorMsg = await parseErrorResponse(analyzeResponse);
                    if (analyzeResponse.status === 402) {
                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');
                        setStatus('Takes detection skipped: insufficient credits', true);
                    } else if (analyzeResponse.status === 401) {
                        console.warn('[SPLICE] Takes detection skipped: authentication required');
                    } else {
                        console.warn('[SPLICE] Takes detection failed:', errorMsg);
                    }
                }
            } catch (e) {
                console.warn('[SPLICE] Takes detection failed:', e.message);
            }
        }

        // Detect profanity if enabled
        if (settings.enableProfanity) {
            updateProgress(65, 'Detecting profanity...');
            try {
                const profanityResponse = await fetchWithTimeout(
                    `${getBackendUrl()}/profanity`,
                    {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            wavPath: audioFilePath,
                            language: settings.profanityLanguage || 'en',
                            bleepType: settings.bleepType || 'standard'
                        })
                    }
                );

                if (profanityResponse.ok) {
                    const profanityData = await profanityResponse.json();
                    // Backend returns 'words' array, not 'instances'
                    currentProfanity = profanityData.words || profanityData.instances || [];
                    if (currentProfanity.length > 0) {
                        debugLog(`Found ${currentProfanity.length} profanity instances`);
                    }
                } else {
                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));
                }
            } catch (e) {
                console.warn('[SPLICE] Profanity detection failed:', e.message);
            }
        }

        // Detect chapters if enabled
        if (settings.enableChapters) {
            updateProgress(80, 'Detecting chapters...');
            try {
                const chapterResponse = await fetchWithTimeout(
                    `${getBackendUrl()}/chapters`,
                    {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            wavPath: audioFilePath,
                            transcript: currentTranscript,
                            maxChapters: settings.maxChapters || 10,
                            minChapterLength: settings.minChapterLength || 60
                        })
                    }
                );

                if (chapterResponse.ok) {
                    const chapterData = await chapterResponse.json();
                    currentChapters = chapterData.chapters || [];
                } else {
                    const errorMsg = await parseErrorResponse(chapterResponse);
                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);
                    // Don't block workflow, just notify user
                    setStatus('Chapter detection skipped: ' + errorMsg, true);
                }
            } catch (e) {
                console.warn('[SPLICE] Chapter detection failed:', e);
                setStatus('Chapter detection failed - continuing without chapters', true);
            }
        }

        // Detect zoom points if enabled
        if (settings.enableZoom) {
            updateProgress(90, 'Detecting zoom points...');
            try {
                const zoomResponse = await fetchWithTimeout(
                    `${getBackendUrl()}/zoom`,
                    {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            wavPath: audioFilePath,
                            transcript: currentTranscript,
                            frequency: settings.zoomFrequency || 'medium',
                            preset: settings.zoomPreset || 'medium',
                            placement: settings.zoomPlacement || 'sentence_start'
                        })
                    }
                );

                if (zoomResponse.ok) {
                    const zoomData = await zoomResponse.json();
                    currentZooms = zoomData.zoomPoints || [];
                } else {
                    const errorMsg = await parseErrorResponse(zoomResponse);
                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);
                    setStatus('Zoom detection skipped: ' + errorMsg, true);
                }
            } catch (e) {
                console.warn('[SPLICE] Zoom detection failed:', e);
                setStatus('Zoom detection failed - continuing without zoom points', true);
            }
        }

        // Store results
        lastDetectionResult = {
            silences: previewSilences,
            takes: previewTakes,
            chapters: currentChapters,
            zooms: currentZooms
        };

        // Show preview
        hideProgress();
        showCombinedPreview();
        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);

    } catch (error) {
        console.error('[SPLICE] Detection error:', error);
        setStatus('Detection failed: ' + error.message, true);
        hideProgress();
    } finally {
        isOperationInProgress = false;
        ui.goBtn.disabled = false;
    }
}

// ============================================================================
// PROGRESS UI
// ============================================================================
function showProgress(message) {
    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');
    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');
    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');
    updateProgress(0, message);
}

function updateProgress(percent, message) {
    if (ui.progressBar) ui.progressBar.style.width = percent + '%';
    if (ui.progressText) ui.progressText.textContent = message || '';
}

function hideProgress() {
    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');
}

// ============================================================================
// COMBINED PREVIEW
// ============================================================================
function showCombinedPreview() {
    if (!ui.combinedPreview) return;

    ui.combinedPreview.classList.remove('hidden');
    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');

    // Update counts
    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;
    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;

    // Select all by default
    selectedSilenceIndices.clear();
    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
    updateSelectedCount();

    // Render preview list
    renderPreviewList();

    // Show chapter results if available
    if (currentChapters.length > 0 && ui.chapterResults) {
        ui.chapterResults.classList.remove('hidden');
        renderChapterList();
    }

    // Show zoom results if available
    if (currentZooms.length > 0 && ui.zoomResults) {
        ui.zoomResults.classList.remove('hidden');
    }
}

function renderPreviewList() {
    if (!ui.previewList) return;

    const html = [];

    // Render silences
    previewSilences.forEach((silence, i) => {
        const isSelected = selectedSilenceIndices.has(i);
        const duration = silence.end - silence.start;
        html.push(`
            <div class="preview-item ${isSelected ? '' : 'excluded'}" data-index="${i}" data-type="silence">
                <input type="checkbox" class="preview-item-check" ${isSelected ? 'checked' : ''}>
                <div class="preview-item-info">
                    <div class="preview-item-time">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>
                    <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
                </div>
            </div>
        `);
    });

    // Render takes
    previewTakes.forEach((take, i) => {
        // SECURITY: Escape take label to prevent XSS
        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));
        html.push(`
            <div class="preview-item take-item" data-index="${i}" data-type="take">
                <div class="preview-item-icon">🎬</div>
                <div class="preview-item-info">
                    <div class="preview-item-time">${formatTime(take.start)} - ${formatTime(take.end)}</div>
                    <div class="preview-item-label">${safeLabel}</div>
                </div>
            </div>
        `);
    });

    ui.previewList.innerHTML = html.join('');

    // Add click handlers
    ui.previewList.querySelectorAll('.preview-item').forEach(item => {
        item.addEventListener('click', (e) => {
            const index = parseInt(item.dataset.index);
            const type = item.dataset.type;

            if (e.target.classList.contains('preview-item-check')) {
                // Checkbox clicked
                toggleSilenceSelection(index);
            } else {
                // Item clicked - seek to time
                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];
                seekToTime(data.start);
            }
        });
    });
}

function toggleSilenceSelection(index) {
    if (selectedSilenceIndices.has(index)) {
        selectedSilenceIndices.delete(index);
    } else {
        selectedSilenceIndices.add(index);
    }
    updateSelectedCount();
    renderPreviewList();
}

function updateSelectedCount() {
    if (ui.selectedCount) {
        ui.selectedCount.textContent = selectedSilenceIndices.size;
    }
    if (ui.selectAllSilences) {
        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;
    }
}

async function seekToTime(seconds) {
    try {
        // FIX: Removed invalid 'app' check - 'app' is ExtendScript DOM, not available in panel JS
        // The JSX evalScript will handle the error case if no sequence is open

        // Use JSX to set playhead position
        // Note: setPlayerPosition expects ticks as a string without quotes around the number value
        const ticks = Math.round(seconds * 254016000000);
        const result = await jsx.evalScript(`
            (function() {
                try {
                    if (!app.project.activeSequence) {
                        return JSON.stringify({ error: 'No active sequence' });
                    }
                    app.project.activeSequence.setPlayerPosition('${ticks}');
                    return JSON.stringify({ success: true });
                } catch (e) {
                    return JSON.stringify({ error: e.message });
                }
            })()
        `);

        // Check for errors
        if (result && typeof result === 'string') {
            try {
                const parsed = JSON.parse(result);
                if (parsed.error) {
                    debugLog('Seek failed:', parsed.error);
                }
            } catch (parseErr) {
                // Result wasn't JSON, ignore
            }
        }
    } catch (e) {
        console.warn('[SPLICE] Seek failed:', e);
    }
}

// ============================================================================
// CHAPTER LIST
// ============================================================================
function renderChapterList() {
    if (!ui.chapterList) return;

    const html = currentChapters.map((chapter, i) => {
        // SECURITY: Escape chapter title to prevent XSS
        const safeTitle = escapeHtml(chapter.title);
        return `
            <div class="chapter-item" data-index="${i}">
                <div class="chapter-time">${formatTime(chapter.startTime)}</div>
                <div class="chapter-title">${safeTitle}</div>
            </div>
        `;
    }).join('');

    ui.chapterList.innerHTML = html;

    // Add click handlers
    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {
        item.addEventListener('click', () => {
            const index = parseInt(item.dataset.index);
            seekToTime(currentChapters[index].startTime);
        });
    });
}

// ============================================================================
// PREVIEW HANDLERS
// ============================================================================
function initPreviewHandlers() {
    // Select all checkbox
    if (ui.selectAllSilences) {
        ui.selectAllSilences.addEventListener('change', () => {
            if (ui.selectAllSilences.checked) {
                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
            } else {
                selectedSilenceIndices.clear();
            }
            updateSelectedCount();
            renderPreviewList();
        });
    }

    // Apply button
    if (ui.applyPreviewBtn) {
        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);
    }

    // Cancel button
    if (ui.cancelPreviewBtn) {
        ui.cancelPreviewBtn.addEventListener('click', hidePreview);
    }

    // Build sequence button
    if (ui.buildSequenceBtn) {
        ui.buildSequenceBtn.addEventListener('click', buildSequence);
    }

    // Copy YouTube timestamps
    if (ui.copyYouTubeBtn) {
        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);
    }

    // Add chapter markers
    if (ui.addChapterMarkersBtn) {
        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);
    }

    // Apply zoom markers
    const applyZoomsBtn = document.getElementById('applyZoomsBtn');
    if (applyZoomsBtn) {
        applyZoomsBtn.addEventListener('click', applyZoomMarkers);
    }
}

async function applyPreviewAndMarkers() {
    if (isOperationInProgress) return;

    isOperationInProgress = true;
    setStatus('Adding markers...');

    try {
        // Add silence markers
        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));
        for (const silence of selectedSilences) {
            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);
        }

        // Add take markers
        for (const take of previewTakes) {
            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);
        }

        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);
    } catch (error) {
        setStatus('Failed to add markers: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

function hidePreview() {
    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');
    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');
    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');
    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');
    previewSilences = [];
    previewTakes = [];
    selectedSilenceIndices.clear();
}

async function buildSequence() {
    if (isOperationInProgress) return;

    isOperationInProgress = true;
    setStatus('Building sequence...');

    try {
        const settings = getSettings();

        // Ensure we have sequence info
        if (!currentSequenceInfo) {
            currentSequenceInfo = await jsx.call('getActiveSequence');
        }

        // Create cut list from selected silences
        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));

        // Calculate total duration from sequence info or last silence
        let duration = 0;
        if (currentSequenceInfo && currentSequenceInfo.duration) {
            duration = currentSequenceInfo.duration;
        } else if (previewSilences.length > 0) {
            const lastSilence = previewSilences[previewSilences.length - 1];
            duration = lastSilence.end + 10; // Add buffer
        }

        // Call backend to generate cut list
        const cutListResponse = await fetchWithTimeout(
            `${getBackendUrl()}/cut-list`,
            {
                method: 'POST',
                headers: getAuthHeaders(),
                body: JSON.stringify({
                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',
                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',
                    duration: duration,
                    silences: selectedSilences,
                    takes: previewTakes,
                    enableTakes: settings.enableTakesDetection,
                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,
                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0
                })
            }
        );

        if (!cutListResponse.ok) {
            throw new Error(await parseErrorResponse(cutListResponse));
        }

        const cutList = await cutListResponse.json();

        // Build sequence via JSX
        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));

        if (result && result.success) {
            setStatus(`Built sequence: ${result.sequenceName}`);
            hidePreview();
        } else {
            throw new Error(result?.error || 'Build failed');
        }
    } catch (error) {
        setStatus('Build failed: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

function copyYouTubeTimestamps() {
    if (currentChapters.length === 0) return;

    const timestamps = currentChapters.map(ch =>
        `${formatTime(ch.startTime)} ${ch.title}`
    ).join('\n');

    navigator.clipboard.writeText(timestamps).then(() => {
        setStatus('Copied YouTube timestamps');
    }).catch(() => {
        setStatus('Failed to copy', true);
    });
}

async function addChapterMarkers() {
    if (isOperationInProgress || currentChapters.length === 0) return;

    isOperationInProgress = true;
    setStatus('Adding chapter markers...');

    try {
        for (const chapter of currentChapters) {
            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);
        }
        setStatus(`Added ${currentChapters.length} chapter markers`);
    } catch (error) {
        setStatus('Failed to add markers: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

/**
 * Apply zoom point markers to the timeline
 */
async function applyZoomMarkers() {
    if (isOperationInProgress || currentZooms.length === 0) return;

    isOperationInProgress = true;
    setStatus('Adding zoom markers...');

    try {
        for (const zoom of currentZooms) {
            // Create a marker for each zoom point with zoom intensity info
            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;
            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);
        }
        setStatus(`Added ${currentZooms.length} zoom markers`);
    } catch (error) {
        setStatus('Failed to add zoom markers: ' + error.message, true);
    } finally {
        isOperationInProgress = false;
    }
}

// ============================================================================
// MODALS
// ============================================================================
function initModals() {
    // Settings modal
    if (ui.settingsBtn && ui.settingsModal) {
        ui.settingsBtn.addEventListener('click', () => {
            ui.settingsModal.classList.remove('hidden');
            // Sync remember options checkbox with current settings
            const rememberOptions = document.getElementById('rememberOptions');
            if (rememberOptions) {
                rememberOptions.checked = getSettings().rememberOptions;
            }
        });
        console.log('[SPLICE] initModals: Settings button initialized');
    } else {
        console.error('[SPLICE] initModals: Settings modal FAILED -',
            !ui.settingsBtn ? '#settingsBtn missing' : '',
            !ui.settingsModal ? '#settingsModal missing' : '');
    }

    if (ui.closeSettingsBtn && ui.settingsModal) {
        ui.closeSettingsBtn.addEventListener('click', () => {
            ui.settingsModal.classList.add('hidden');
        });
    }

    // Remember options checkbox
    const rememberOptions = document.getElementById('rememberOptions');
    if (rememberOptions) {
        rememberOptions.addEventListener('change', () => {
            saveSettings({ rememberOptions: rememberOptions.checked });
            if (rememberOptions.checked) {
                setStatus('Options will be remembered');
            } else {
                setStatus('Options will reset to defaults');
            }
        });
    }

    // Credit badge click handler (handles login, retry, and refresh)
    if (ui.creditBadge) {
        ui.creditBadge.addEventListener('click', () => {
            // Use the centralized handler from credits.js
            if (typeof handleCreditBadgeClick === 'function') {
                handleCreditBadgeClick();
            } else {
                // Fallback if credits.js not loaded yet
                const settings = getSettings();
                if (!settings.customerId) {
                    showLoginModal();
                }
            }
        });
        console.log('[SPLICE] initModals: Credit badge initialized');
    } else {
        console.error('[SPLICE] initModals: Credit badge FAILED - #creditBadge missing');
    }

    if (ui.closeLoginBtn && ui.loginModal) {
        ui.closeLoginBtn.addEventListener('click', () => {
            ui.loginModal.classList.add('hidden');
        });
    }

    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)
    // to avoid duplicate event listeners

    // License lookup button
    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');
    if (lookupLicenseBtn) {
        lookupLicenseBtn.addEventListener('click', lookupLicense);
    }

    // Close modals on backdrop click
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.add('hidden');
            }
        });
    });

    // ACCESSIBILITY: Close modals on Escape key press
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const openModal = document.querySelector('.modal:not(.hidden)');
            if (openModal) {
                openModal.classList.add('hidden');
                // Announce to screen readers
                announceToScreenReader('Dialog closed');
            }
        }
    });
}

/**
 * ACCESSIBILITY: Announce message to screen readers via ARIA live region
 * @param {string} message - Message to announce
 * @param {string} priority - 'polite' or 'assertive'
 */
function announceToScreenReader(message, priority = 'polite') {
    // Use existing status element or create temporary one
    const statusEl = document.getElementById('status');
    if (statusEl && priority === 'polite') {
        const originalText = statusEl.textContent;
        statusEl.textContent = message;
        // Restore after announcement
        setTimeout(() => {
            if (statusEl.textContent === message) {
                statusEl.textContent = originalText;
            }
        }, 1000);
        return;
    }

    // Create temporary live region for assertive announcements
    const liveRegion = document.createElement('div');
    liveRegion.setAttribute('role', 'alert');
    liveRegion.setAttribute('aria-live', priority);
    liveRegion.setAttribute('aria-atomic', 'true');
    liveRegion.className = 'sr-only';
    liveRegion.style.cssText = 'position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;';
    liveRegion.textContent = message;
    document.body.appendChild(liveRegion);

    // Remove after announcement
    setTimeout(() => liveRegion.remove(), 1000);
}

function showLoginModal() {
    if (ui.loginModal) ui.loginModal.classList.remove('hidden');
}

/**
 * Show upgrade modal when user tries to access a gated feature
 * @param {string} featureName - Display name of the feature
 * @param {string} requiredTier - Required tier (Pro, Team)
 */
function showUpgradeModal(featureName, requiredTier = 'Pro') {
    const modal = document.getElementById('upgradeModal');
    const featureText = document.getElementById('upgradeFeatureName');
    const tierText = document.getElementById('upgradeRequiredTier');

    if (featureText) {
        featureText.textContent = featureName;
    }
    if (tierText) {
        tierText.textContent = requiredTier;
    }
    if (modal) {
        modal.classList.remove('hidden');
    }
}

/**
 * Close the upgrade modal
 */
function closeUpgradeModal() {
    const modal = document.getElementById('upgradeModal');
    if (modal) {
        modal.classList.add('hidden');
    }
}

// Expose showUpgradeModal and closeUpgradeModal globally for feature modules
window.showUpgradeModal = showUpgradeModal;
window.closeUpgradeModal = closeUpgradeModal;

async function activateLicense() {
    if (!ui.licenseKeyInput) return;

    const licenseKey = ui.licenseKeyInput.value.trim();
    if (!licenseKey) {
        setStatus('Please enter a license key', true);
        return;
    }

    try {
        const response = await fetchWithTimeout(
            `${getBackendUrl()}/license/activate`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ key: licenseKey })
            }
        );

        if (!response.ok) {
            throw new Error(await parseErrorResponse(response));
        }

        const data = await response.json();
        saveSettings({
            customerId: data.customerId,
            licenseKey: licenseKey
        });

        if (ui.loginModal) ui.loginModal.classList.add('hidden');
        setStatus('License activated');
        updateCredits();
    } catch (error) {
        setStatus('Activation failed: ' + error.message, true);
    }
}

/**
 * Look up license key by email address
 */
async function lookupLicense() {
    const lookupEmailInput = document.getElementById('lookupEmailInput');
    const licenseKeyInput = document.getElementById('licenseKeyInput');

    if (!lookupEmailInput) return;

    const email = lookupEmailInput.value.trim().toLowerCase();
    if (!email) {
        setStatus('Please enter your email address', true);
        return;
    }

    // Basic email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        setStatus('Please enter a valid email address', true);
        return;
    }

    const lookupBtn = document.getElementById('lookupLicenseBtn');
    if (lookupBtn) {
        lookupBtn.disabled = true;
        lookupBtn.textContent = 'Looking up...';
    }

    try {
        const response = await fetchWithTimeout(
            `${getBackendUrl()}/license/lookup`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email })
            },
            30000
        );

        const result = await response.json();

        // Note: For security, the backend does NOT return the license key directly.
        // It sends the key via email to prevent enumeration attacks.
        if (result.success) {
            setStatus(result.message || 'If a license exists, it has been sent to your email.');
        } else {
            setStatus(result.error || 'Lookup failed. Please try again.', true);
        }
    } catch (error) {
        setStatus('Lookup failed: ' + error.message, true);
    } finally {
        if (lookupBtn) {
            lookupBtn.disabled = false;
            lookupBtn.textContent = 'Lookup';
        }
    }
}

// ============================================================================
// CREDITS
// ============================================================================
function initCredits() {
    updateCredits();
}

async function updateCredits() {
    if (!ui.creditBadge) return;

    const settings = getSettings();
    if (!settings.customerId) {
        ui.creditBadge.className = 'credit-badge login';
        ui.creditBadge.textContent = 'Login';
        ui.creditBadge.style.display = 'flex';
        return;
    }

    try {
        const response = await fetchWithTimeout(
            `${getBackendUrl()}/credits`,
            {
                method: 'GET',
                headers: getAuthHeaders()
            }
        );

        if (response.ok) {
            const data = await response.json();
            // Backend returns hoursRemaining (not remainingMinutes)
            const hours = (data.hoursRemaining || 0).toFixed(1);
            ui.creditBadge.textContent = `${hours}h`;
            // Low warning when less than 1 hour remaining
            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';
            ui.creditBadge.style.display = 'flex';
        } else {
            ui.creditBadge.className = 'credit-badge error';
            ui.creditBadge.textContent = 'Error';
            ui.creditBadge.style.display = 'flex';
        }
    } catch {
        ui.creditBadge.className = 'credit-badge error';
        ui.creditBadge.textContent = 'Offline';
        ui.creditBadge.style.display = 'flex';
    }
}

// ============================================================================
// HELP BUTTON
// ============================================================================
function initHelpButton() {
    const helpBtn = document.getElementById('helpBtn');
    if (helpBtn) {
        helpBtn.addEventListener('click', () => {
            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');
        });
    }
}

// ============================================================================
// DEBUG MODAL
// ============================================================================
function initDebugModal() {
    if (!ui.debugBtn || !ui.debugModal) {
        console.error('[SPLICE] initDebugModal FAILED: Missing elements -',
            !ui.debugBtn ? '#debugBtn' : '',
            !ui.debugModal ? '#debugModal' : '');
        return;
    }

    // Open debug modal
    ui.debugBtn.addEventListener('click', () => {
        ui.debugModal.classList.remove('hidden');
        // Clear previous logs and show placeholder
        if (ui.debugLogs) {
            ui.debugLogs.innerHTML = '<p class="debug-placeholder">Click "Run Diagnostics" to collect diagnostic information.</p>';
        }
        if (ui.debugQuickDiagnosis) {
            ui.debugQuickDiagnosis.textContent = 'Click "Run Diagnostics" to check';
        }
    });

    // Close debug modal
    if (ui.closeDebugBtn) {
        ui.closeDebugBtn.addEventListener('click', () => {
            ui.debugModal.classList.add('hidden');
        });
    }

    // Run diagnostics button
    if (ui.runDiagnosticsBtn) {
        ui.runDiagnosticsBtn.addEventListener('click', async () => {
            await runDiagnostics();
        });
    }

    // Copy diagnostics button
    if (ui.copyDiagnosticsBtn) {
        ui.copyDiagnosticsBtn.addEventListener('click', () => {
            copyDiagnosticsToClipboard();
        });
    }
}

// ============================================================================
// DIAGNOSTICS
// ============================================================================
let diagnosticLogs = [];

async function runDiagnostics() {
    if (!ui.debugLogs || !ui.debugQuickDiagnosis) return;

    diagnosticLogs = [];
    ui.debugLogs.innerHTML = '<p class="debug-running">Running diagnostics... Please wait...</p>';

    try {
        // Test 0: Environment Info (using compatibility module)
        addDiagnosticLog('=== Environment Detection ===');
        if (typeof SpliceCompatibility !== 'undefined') {
            const env = SpliceCompatibility.detectEnvironment();
            addDiagnosticLog('Platform: ' + env.platform.os + ' ' + env.platform.osVersion);
            addDiagnosticLog('Architecture: ' + env.platform.architecture + (env.platform.isAppleSilicon ? ' (Apple Silicon)' : ''));
            if (env.cep.isRunning) {
                addDiagnosticLog('CEP Version: ' + env.cep.version);
                addDiagnosticLog('Host: ' + env.host.name + ' ' + env.host.version);
            }
            addDiagnosticLog('Chromium: ' + (env.browser.chromiumVersion || 'N/A'));
        } else {
            addDiagnosticLog('Compatibility module not loaded');
        }
        addDiagnosticLog('');

        // Test 0.1: Check CEP environment
        addDiagnosticLog('Test 0: Checking CEP environment...');
        if (window.__adobe_cep__) {
            addDiagnosticLog('✓ CEP runtime detected (window.__adobe_cep__ exists)');
        } else {
            addDiagnosticLog('✗ CEP runtime NOT detected - running in browser mode');
        }

        // Test 0.5: Basic ExtendScript test (doesn't require hostScript.jsx)
        addDiagnosticLog('Test 0.5: Testing basic ExtendScript...');
        try {
            const basicResult = await jsx.evalScript('1 + 1');
            addDiagnosticLog('✓ Basic ExtendScript works: 1+1 = ' + basicResult);
        } catch (e) {
            addDiagnosticLog('✗ Basic ExtendScript FAILED: ' + e.message);
            addDiagnosticLog('  → This means Premiere Pro cannot run ANY ExtendScript');
            addDiagnosticLog('  → Make sure CEP debug mode is enabled and Premiere was restarted');
        }

        // Test 0.6: Check if hostScript.jsx functions are loaded
        addDiagnosticLog('Test 0.6: Checking if hostScript.jsx is loaded...');
        try {
            const typeofGetVersion = await jsx.evalScript('typeof getVersion');
            if (typeofGetVersion === 'function') {
                addDiagnosticLog('✓ hostScript.jsx is loaded (getVersion exists)');
            } else {
                addDiagnosticLog('✗ hostScript.jsx NOT loaded (getVersion type: ' + typeofGetVersion + ')');
                addDiagnosticLog('  → The JSX file may not be in the correct location');
            }
        } catch (e) {
            addDiagnosticLog('✗ hostScript check FAILED: ' + e.message);
        }

        // Test 1: JSX Connection
        addDiagnosticLog('Test 1: Checking JSX connection...');
        try {
            const version = await jsx.call('getVersion');
            addDiagnosticLog('✓ JSX connection OK, version: ' + version);
        } catch (e) {
            addDiagnosticLog('✗ JSX connection FAILED: ' + e.message);
        }

        // Test 2: Check for active sequence
        addDiagnosticLog('Test 2: Checking for active sequence...');
        try {
            const hasSequence = await checkSequenceOpen(0, 0); // No retries for diagnostics
            addDiagnosticLog('✓ checkSequenceOpen() returned: ' + hasSequence);
        } catch (e) {
            addDiagnosticLog('✗ checkSequenceOpen() FAILED: ' + e.message);
        }

        // Test 3: Get sequence info
        addDiagnosticLog('Test 3: Getting sequence info...');
        try {
            const seqInfo = await jsx.call('getActiveSequence');
            if (seqInfo && !seqInfo.error) {
                addDiagnosticLog('✓ Sequence found: ' + (seqInfo.name || 'Unknown'));
                addDiagnosticLog('  - Sequence ID: ' + (seqInfo.sequenceID || 'N/A'));
                addDiagnosticLog('  - Duration: ' + (seqInfo.duration || 'N/A'));
                addDiagnosticLog('  - Frame size: ' + (seqInfo.frameSizeHorizontal || 'N/A') + 'x' + (seqInfo.frameSizeVertical || 'N/A'));
            } else {
                addDiagnosticLog('✗ No active sequence found');
            }
        } catch (e) {
            addDiagnosticLog('✗ getActiveSequence() FAILED: ' + e.message);
        }

        // Test 4: Check project sequences
        addDiagnosticLog('Test 4: Checking all project sequences...');
        try {
            const sequences = await jsx.call('getAllSequences');
            if (sequences && sequences.length > 0) {
                addDiagnosticLog('✓ Total sequences in project: ' + sequences.length);
                sequences.forEach((seq, i) => {
                    addDiagnosticLog('  - Sequence ' + i + ': ' + (seq.name || 'Unnamed'));
                });
            } else {
                addDiagnosticLog('✗ No sequences found in project');
            }
        } catch (e) {
            addDiagnosticLog('✗ getAllSequences() FAILED: ' + e.message);
        }

        // Test 5: Check for active sequence via DOM
        addDiagnosticLog('Test 5: Checking app.project.activeSequence...');
        try {
            const result = await jsx.evalScript(`
                (function() {
                    try {
                        if (app && app.project && app.project.activeSequence) {
                            return JSON.stringify({
                                success: true,
                                name: app.project.activeSequence.name,
                                id: app.project.activeSequence.sequenceID
                            });
                        } else {
                            return JSON.stringify({
                                success: false,
                                reason: app ? (app.project ? 'app.project.activeSequence is null' : 'app.project is null') : 'app is null'
                            });
                        }
                    } catch (e) {
                        return JSON.stringify({ success: false, reason: 'Error: ' + e.message });
                    }
                })()
            `);
            const data = JSON.parse(result);
            if (data.success) {
                addDiagnosticLog('✓ app.project.activeSequence found: ' + data.name + ' (ID: ' + data.id + ')');
            } else {
                addDiagnosticLog('✗ app.project.activeSequence NOT found: ' + data.reason);
            }
        } catch (e) {
            addDiagnosticLog('✗ DOM check FAILED: ' + e.message);
        }

        // Test 6: Check QE DOM availability
        addDiagnosticLog('Test 6: Checking QE DOM availability...');
        try {
            const qeResult = await jsx.evalScript(`
                (function() {
                    try {
                        if (typeof qe !== 'undefined' && qe !== null) {
                            return JSON.stringify({ available: true });
                        } else {
                            return JSON.stringify({ available: false });
                        }
                    } catch (e) {
                        return JSON.stringify({ available: false, error: e.message });
                    }
                })()
            `);
            const qeData = JSON.parse(qeResult);
            if (qeData.available) {
                addDiagnosticLog('✓ QE DOM is available');
            } else {
                addDiagnosticLog('✗ QE DOM is NOT available' + (qeData.error ? ': ' + qeData.error : ''));
            }
        } catch (e) {
            addDiagnosticLog('✗ QE DOM check FAILED: ' + e.message);
        }

        // Test 7: Compatibility Check
        addDiagnosticLog('');
        addDiagnosticLog('Test 7: Compatibility check...');
        if (typeof SpliceCompatibility !== 'undefined') {
            const compat = SpliceCompatibility.checkCompatibility();
            if (compat.compatible) {
                addDiagnosticLog('✓ Environment is compatible');
            } else {
                addDiagnosticLog('✗ Environment compatibility issues detected');
            }
            if (compat.errors.length > 0) {
                compat.errors.forEach(err => {
                    addDiagnosticLog('  ERROR: ' + err.message);
                });
            }
            if (compat.warnings.length > 0) {
                compat.warnings.forEach(warn => {
                    addDiagnosticLog('  WARNING: ' + warn.message);
                });
            }
            if (compat.recommendations.length > 0) {
                compat.recommendations.forEach(rec => {
                    addDiagnosticLog('  TIP: ' + rec.message);
                });
            }

            // Feature detection summary
            const features = SpliceCompatibility.detectFeatures();
            addDiagnosticLog('');
            addDiagnosticLog('=== Feature Detection ===');
            addDiagnosticLog('Fetch API: ' + (features.webAPIs.fetch ? 'Yes' : 'No'));
            addDiagnosticLog('Web Crypto: ' + (features.webAPIs.webCrypto ? 'Yes' : 'No'));
            addDiagnosticLog('localStorage: ' + (features.webAPIs.localStorage ? 'Yes' : 'No'));
            addDiagnosticLog('CEP evalScript: ' + (features.cep.evalScript ? 'Yes' : 'No'));
            addDiagnosticLog('CEP Node.js: ' + (features.cep.nodeJS ? 'Yes' : 'No'));
        } else {
            addDiagnosticLog('✗ Compatibility module not available');
        }

        // Display quick diagnosis
        updateQuickDiagnosis();

        // Display all logs
        displayDiagnosticLogs();

    } catch (error) {
        addDiagnosticLog('DIAGNOSTICS ERROR: ' + error.message);
        displayDiagnosticLogs();
    }
}

function addDiagnosticLog(message) {
    diagnosticLogs.push(message);
    console.log('[SPLICE DEBUG] ' + message);
}

function displayDiagnosticLogs() {
    if (!ui.debugLogs) return;

    const html = diagnosticLogs.map(log => {
        return `<div class="debug-log-entry">${escapeHtml(log)}</div>`;
    }).join('');

    ui.debugLogs.innerHTML = html;
}

function updateQuickDiagnosis() {
    if (!ui.debugQuickDiagnosis) return;

    const logs = diagnosticLogs.join(' ');
    let diagnosis = '';
    let solution = '';

    // Analyze logs for common issues
    if (logs.includes('JSX connection FAILED')) {
        diagnosis = '❌ JSX Connection Failed';
        solution = 'The panel cannot communicate with Premiere Pro. Try: 1) Close and reopen the panel, 2) Restart Premiere Pro, 3) Check if plugin is properly installed.';
    } else if (logs.includes('checkSequenceOpen() returned: false') && logs.includes('No active sequence found')) {
        diagnosis = '❌ No Active Sequence';
        solution = 'No sequence is active in the Timeline. Double-click a sequence in the Project panel to open it in the Timeline.';
    } else if (logs.includes('app.project.activeSequence NOT found') && logs.includes('Sequence found')) {
        diagnosis = '❌ Sequence Not Active';
        solution = 'A sequence exists but is not the active sequence. Click on the sequence tab in the Timeline to make it active.';
    } else if (logs.includes('checkSequenceOpen() returned: true') && logs.includes('app.project.activeSequence found')) {
        diagnosis = '✅ Everything Looks Good';
        solution = 'The plugin is working correctly. The sequence is detected and active. Try pressing GO again.';
    } else if (logs.includes('No sequences found in project')) {
        diagnosis = '❌ No Sequences in Project';
        solution = 'Create a sequence in Premiere Pro first (File > New > Sequence), then open it in the Timeline.';
    } else {
        diagnosis = '⚠️ Unknown Issue';
        solution = 'Copy the diagnostic logs below and send them to support for further assistance.';
    }

    ui.debugQuickDiagnosis.innerHTML = `
        <div class="diagnosis-result">
            <div class="diagnosis-title">${diagnosis}</div>
            <div class="diagnosis-solution">${solution}</div>
        </div>
    `;
}

function copyDiagnosticsToClipboard() {
    const text = diagnosticLogs.join('\n');
    navigator.clipboard.writeText(text).then(() => {
        if (ui.copyDiagnosticsBtn) {
            ui.copyDiagnosticsBtn.textContent = 'Copied!';
            setTimeout(() => {
                ui.copyDiagnosticsBtn.textContent = 'Copy to Clipboard';
            }, 2000);
        }
    }).catch(err => {
        setStatus('Failed to copy: ' + err.message, true);
    });
}

// Export for debugging
window.spliceDebug = {
    getState: () => ({
        silences: previewSilences,
        takes: previewTakes,
        chapters: currentChapters,
        zooms: currentZooms,
        selected: Array.from(selectedSilenceIndices)
    }),
    jsx,
    runDetection
};
