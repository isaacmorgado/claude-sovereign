# LOOKSMAXX Forum Implementation Guide

## Executive Summary

This document outlines the complete implementation plan for adding a Reddit-style forum/community feature to the LOOKSMAXX application. The forum will provide persistent, searchable, and quality-ranked content (guides, advice) with categories for **Hairstyle**, **Dating**, and **Skincare**.

**Chosen Approach:** Reddit-style (over Discord-style) because:
- Content persists and is searchable (guides/advice should last)
- Upvotes surface quality content naturally
- Categories map perfectly to topics (Hairstyle, Dating, Skincare)
- Async nature fits advice/Q&A better than real-time chat
- REST API implementation fits existing FastAPI backend

---

## Current Tech Stack

| Layer | Technology |
|-------|------------|
| **Frontend** | Next.js 14 (App Router) + TypeScript + Tailwind CSS |
| **Backend** | FastAPI (Python) + PostgreSQL + SQLAlchemy (async) |
| **Auth** | JWT tokens, existing user model with roles |
| **Styling** | Dark neon theme with cyan (#00f3ff) accents |
| **API Base** | https://api-production-6148.up.railway.app |

---

## 1. Database Schema

### 1.1 SQLAlchemy Models

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/models/forum.py`

```python
"""
Forum database models - Categories, Posts, Comments, Votes, Reports
"""

import uuid
import enum
from datetime import datetime
from sqlalchemy import (
    Column, String, DateTime, ForeignKey, Text, Integer, Boolean, Enum, Index
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship

from app.database import Base


class VoteType(str, enum.Enum):
    UP = "up"
    DOWN = "down"


class TargetType(str, enum.Enum):
    POST = "post"
    COMMENT = "comment"


class ReportStatus(str, enum.Enum):
    PENDING = "pending"
    REVIEWED = "reviewed"
    RESOLVED = "resolved"
    DISMISSED = "dismissed"


class ReportReason(str, enum.Enum):
    SPAM = "spam"
    HARASSMENT = "harassment"
    MISINFORMATION = "misinformation"
    OFF_TOPIC = "off_topic"
    INAPPROPRIATE = "inappropriate"
    OTHER = "other"


class ForumCategory(Base):
    __tablename__ = "forum_categories"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(50), nullable=False, unique=True)
    slug = Column(String(50), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=True)
    icon = Column(String(10), nullable=True)  # Emoji icon
    display_order = Column(Integer, default=0)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    posts = relationship("ForumPost", back_populates="category", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<ForumCategory {self.slug}>"


class ForumPost(Base):
    __tablename__ = "forum_posts"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=False)
    category_id = Column(UUID(as_uuid=True), ForeignKey("forum_categories.id", ondelete="CASCADE"), nullable=False)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)

    # Status flags
    is_pinned = Column(Boolean, default=False)
    is_guide = Column(Boolean, default=False)  # Marks as "Guide" content
    is_approved = Column(Boolean, default=True)  # For moderation workflow
    is_deleted = Column(Boolean, default=False)

    # Denormalized counts for performance
    vote_count = Column(Integer, default=0)  # net score (ups - downs)
    comment_count = Column(Integer, default=0)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    category = relationship("ForumCategory", back_populates="posts")
    author = relationship("User", backref="forum_posts")
    comments = relationship("ForumComment", back_populates="post", cascade="all, delete-orphan")
    votes = relationship("ForumVote", primaryjoin="and_(ForumPost.id==foreign(ForumVote.target_id), ForumVote.target_type=='post')", cascade="all, delete-orphan", viewonly=True)

    # Indexes
    __table_args__ = (
        Index('idx_posts_category_pinned', 'category_id', 'is_pinned', 'created_at'),
        Index('idx_posts_category_votes', 'category_id', 'vote_count'),
        Index('idx_posts_author', 'author_id'),
    )

    def __repr__(self):
        return f"<ForumPost {self.title[:30]}>"


class ForumComment(Base):
    __tablename__ = "forum_comments"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    content = Column(Text, nullable=False)
    post_id = Column(UUID(as_uuid=True), ForeignKey("forum_posts.id", ondelete="CASCADE"), nullable=False)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    parent_id = Column(UUID(as_uuid=True), ForeignKey("forum_comments.id", ondelete="CASCADE"), nullable=True)  # For threading

    # Status
    is_approved = Column(Boolean, default=True)
    is_deleted = Column(Boolean, default=False)

    # Denormalized vote count
    vote_count = Column(Integer, default=0)

    # Depth for limiting nesting (max 5 levels)
    depth = Column(Integer, default=0)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    post = relationship("ForumPost", back_populates="comments")
    author = relationship("User", backref="forum_comments")
    parent = relationship("ForumComment", remote_side=[id], backref="replies")
    votes = relationship("ForumVote", primaryjoin="and_(ForumComment.id==foreign(ForumVote.target_id), ForumVote.target_type=='comment')", cascade="all, delete-orphan", viewonly=True)

    # Indexes
    __table_args__ = (
        Index('idx_comments_post', 'post_id', 'created_at'),
        Index('idx_comments_parent', 'parent_id'),
        Index('idx_comments_author', 'author_id'),
    )

    def __repr__(self):
        return f"<ForumComment {self.id}>"


class ForumVote(Base):
    __tablename__ = "forum_votes"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    target_type = Column(Enum(TargetType), nullable=False)
    target_id = Column(UUID(as_uuid=True), nullable=False)
    vote_type = Column(Enum(VoteType), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    user = relationship("User", backref="forum_votes")

    # Unique constraint: one vote per user per target
    __table_args__ = (
        Index('idx_votes_user_target', 'user_id', 'target_type', 'target_id', unique=True),
        Index('idx_votes_target', 'target_type', 'target_id'),
    )

    def __repr__(self):
        return f"<ForumVote {self.vote_type} on {self.target_type}:{self.target_id}>"


class ForumReport(Base):
    __tablename__ = "forum_reports"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    reporter_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    target_type = Column(Enum(TargetType), nullable=False)
    target_id = Column(UUID(as_uuid=True), nullable=False)
    reason = Column(Enum(ReportReason), nullable=False)
    details = Column(Text, nullable=True)  # Additional context
    status = Column(Enum(ReportStatus), default=ReportStatus.PENDING)
    reviewed_by = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
    reviewed_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    reporter = relationship("User", foreign_keys=[reporter_id], backref="reports_filed")
    reviewer = relationship("User", foreign_keys=[reviewed_by], backref="reports_reviewed")

    # Indexes
    __table_args__ = (
        Index('idx_reports_status', 'status', 'created_at'),
        Index('idx_reports_target', 'target_type', 'target_id'),
    )

    def __repr__(self):
        return f"<ForumReport {self.reason} on {self.target_type}:{self.target_id}>"
```

### 1.2 User Model Update

Add role field to existing User model for moderation:

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/models/user.py`

```python
# Add this enum and column to the User model:

class UserRole(str, enum.Enum):
    USER = "user"
    MODERATOR = "moderator"
    ADMIN = "admin"

# Add to User class:
role = Column(Enum(UserRole), default=UserRole.USER)
```

---

## 2. Database Migration

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-api/migrations/002_add_forum_tables.sql`

```sql
-- Migration: Create forum tables
-- Date: 2025-12-23
-- Description: Reddit-style forum with categories, posts, comments, votes, reports

-- Add role column to users for moderation
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'userrole') THEN
        CREATE TYPE userrole AS ENUM ('user', 'moderator', 'admin');
    END IF;
END $$;

ALTER TABLE users ADD COLUMN IF NOT EXISTS role userrole DEFAULT 'user';

-- Create enum types
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'votetype') THEN
        CREATE TYPE votetype AS ENUM ('up', 'down');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'targettype') THEN
        CREATE TYPE targettype AS ENUM ('post', 'comment');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'reportstatus') THEN
        CREATE TYPE reportstatus AS ENUM ('pending', 'reviewed', 'resolved', 'dismissed');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'reportreason') THEN
        CREATE TYPE reportreason AS ENUM ('spam', 'harassment', 'misinformation', 'off_topic', 'inappropriate', 'other');
    END IF;
END $$;

-- Forum Categories
CREATE TABLE IF NOT EXISTS forum_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL UNIQUE,
    slug VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    icon VARCHAR(10),
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_categories_slug ON forum_categories(slug);
CREATE INDEX IF NOT EXISTS idx_categories_order ON forum_categories(display_order);

-- Insert default categories
INSERT INTO forum_categories (name, slug, description, icon, display_order) VALUES
    ('Hairstyle', 'hairstyle', 'Advice on hairstyles, cuts, and hair care for your face shape', 'ðŸ’‡', 1),
    ('Dating', 'dating', 'Dating advice, social skills, and relationship guidance', 'ðŸ’•', 2),
    ('Skincare', 'skincare', 'Skincare routines, products, and treatments', 'âœ¨', 3)
ON CONFLICT (slug) DO NOTHING;

-- Forum Posts
CREATE TABLE IF NOT EXISTS forum_posts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    category_id UUID NOT NULL REFERENCES forum_categories(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    is_pinned BOOLEAN DEFAULT FALSE,
    is_guide BOOLEAN DEFAULT FALSE,
    is_approved BOOLEAN DEFAULT TRUE,
    is_deleted BOOLEAN DEFAULT FALSE,
    vote_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_posts_category_pinned ON forum_posts(category_id, is_pinned, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_posts_category_votes ON forum_posts(category_id, vote_count DESC);
CREATE INDEX IF NOT EXISTS idx_posts_author ON forum_posts(author_id);
CREATE INDEX IF NOT EXISTS idx_posts_created ON forum_posts(created_at DESC);

-- Forum Comments
CREATE TABLE IF NOT EXISTS forum_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    content TEXT NOT NULL,
    post_id UUID NOT NULL REFERENCES forum_posts(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    parent_id UUID REFERENCES forum_comments(id) ON DELETE CASCADE,
    is_approved BOOLEAN DEFAULT TRUE,
    is_deleted BOOLEAN DEFAULT FALSE,
    vote_count INTEGER DEFAULT 0,
    depth INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_comments_post ON forum_comments(post_id, created_at);
CREATE INDEX IF NOT EXISTS idx_comments_parent ON forum_comments(parent_id);
CREATE INDEX IF NOT EXISTS idx_comments_author ON forum_comments(author_id);

-- Forum Votes
CREATE TABLE IF NOT EXISTS forum_votes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    target_type targettype NOT NULL,
    target_id UUID NOT NULL,
    vote_type votetype NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_votes_user_target ON forum_votes(user_id, target_type, target_id);
CREATE INDEX IF NOT EXISTS idx_votes_target ON forum_votes(target_type, target_id);

-- Forum Reports
CREATE TABLE IF NOT EXISTS forum_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    reporter_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    target_type targettype NOT NULL,
    target_id UUID NOT NULL,
    reason reportreason NOT NULL,
    details TEXT,
    status reportstatus DEFAULT 'pending',
    reviewed_by UUID REFERENCES users(id) ON DELETE SET NULL,
    reviewed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_reports_status ON forum_reports(status, created_at);
CREATE INDEX IF NOT EXISTS idx_reports_target ON forum_reports(target_type, target_id);

-- Function to update post comment count
CREATE OR REPLACE FUNCTION update_post_comment_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE forum_posts SET comment_count = comment_count + 1 WHERE id = NEW.post_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE forum_posts SET comment_count = comment_count - 1 WHERE id = OLD.post_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_comment_count ON forum_comments;
CREATE TRIGGER trigger_comment_count
AFTER INSERT OR DELETE ON forum_comments
FOR EACH ROW EXECUTE FUNCTION update_post_comment_count();

-- Verify migration
SELECT 'forum_categories' as table_name, COUNT(*) as count FROM forum_categories
UNION ALL
SELECT 'forum_posts', COUNT(*) FROM forum_posts
UNION ALL
SELECT 'forum_comments', COUNT(*) FROM forum_comments;
```

---

## 3. API Schemas (Pydantic)

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/schemas/forum.py`

```python
"""
Forum schemas for request/response validation
"""

from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from uuid import UUID
from enum import Enum


# === ENUMS ===

class VoteType(str, Enum):
    UP = "up"
    DOWN = "down"


class TargetType(str, Enum):
    POST = "post"
    COMMENT = "comment"


class ReportReason(str, Enum):
    SPAM = "spam"
    HARASSMENT = "harassment"
    MISINFORMATION = "misinformation"
    OFF_TOPIC = "off_topic"
    INAPPROPRIATE = "inappropriate"
    OTHER = "other"


class SortOrder(str, Enum):
    HOT = "hot"  # vote_count DESC, recent bias
    NEW = "new"  # created_at DESC
    TOP = "top"  # vote_count DESC


# === CATEGORY SCHEMAS ===

class CategoryResponse(BaseModel):
    id: UUID
    name: str
    slug: str
    description: Optional[str]
    icon: Optional[str]
    post_count: int = 0

    class Config:
        from_attributes = True


# === POST SCHEMAS ===

class PostCreate(BaseModel):
    title: str = Field(..., min_length=5, max_length=200)
    content: str = Field(..., min_length=10, max_length=10000)
    category_id: UUID


class PostUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=5, max_length=200)
    content: Optional[str] = Field(None, min_length=10, max_length=10000)


class PostAuthor(BaseModel):
    id: UUID
    username: str

    class Config:
        from_attributes = True


class PostResponse(BaseModel):
    id: UUID
    title: str
    content: str
    category_id: UUID
    category_slug: str
    author: PostAuthor
    is_pinned: bool
    is_guide: bool
    vote_count: int
    comment_count: int
    user_vote: Optional[VoteType] = None  # Current user's vote
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class PostListItem(BaseModel):
    """Lighter version for list views"""
    id: UUID
    title: str
    content_preview: str  # First 200 chars
    category_slug: str
    author: PostAuthor
    is_pinned: bool
    is_guide: bool
    vote_count: int
    comment_count: int
    user_vote: Optional[VoteType] = None
    created_at: datetime

    class Config:
        from_attributes = True


class PostListResponse(BaseModel):
    posts: List[PostListItem]
    total_count: int
    has_more: bool


# === COMMENT SCHEMAS ===

class CommentCreate(BaseModel):
    content: str = Field(..., min_length=1, max_length=5000)
    parent_id: Optional[UUID] = None


class CommentUpdate(BaseModel):
    content: str = Field(..., min_length=1, max_length=5000)


class CommentResponse(BaseModel):
    id: UUID
    content: str
    post_id: UUID
    author: PostAuthor
    parent_id: Optional[UUID]
    vote_count: int
    user_vote: Optional[VoteType] = None
    depth: int
    replies: List["CommentResponse"] = []
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# Needed for self-referential model
CommentResponse.model_rebuild()


# === VOTE SCHEMAS ===

class VoteRequest(BaseModel):
    vote_type: VoteType


class VoteResponse(BaseModel):
    success: bool
    new_vote_count: int
    user_vote: Optional[VoteType]


# === REPORT SCHEMAS ===

class ReportCreate(BaseModel):
    target_type: TargetType
    target_id: UUID
    reason: ReportReason
    details: Optional[str] = Field(None, max_length=1000)


class ReportResponse(BaseModel):
    id: UUID
    target_type: TargetType
    target_id: UUID
    reason: ReportReason
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


# === GUIDE SECTION ===

class GuideSectionResponse(BaseModel):
    """Guides grouped by category for the top section"""
    category: CategoryResponse
    guides: List[PostListItem]
```

---

## 4. API Router

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py`

```python
"""
Forum router - Categories, Posts, Comments, Votes, Reports
"""

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, case, and_, or_, desc
from sqlalchemy.orm import selectinload
from uuid import UUID
from typing import Optional, List
from datetime import datetime, timedelta

from app.database import get_db
from app.models.user import User, UserRole
from app.models.forum import (
    ForumCategory, ForumPost, ForumComment, ForumVote, ForumReport,
    VoteType, TargetType, ReportStatus, ReportReason
)
from app.services.auth import get_current_user, get_current_user_optional
from app.schemas.forum import (
    CategoryResponse, PostCreate, PostUpdate, PostResponse, PostListItem,
    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,
    VoteRequest, VoteResponse, ReportCreate, ReportResponse,
    GuideSectionResponse, SortOrder, PostAuthor
)

router = APIRouter(prefix="/forum", tags=["forum"])

PAGE_SIZE = 20
MAX_COMMENT_DEPTH = 5


# === CATEGORIES ===

@router.get("/categories", response_model=List[CategoryResponse])
async def list_categories(db: AsyncSession = Depends(get_db)):
    """List all active forum categories with post counts."""
    query = (
        select(
            ForumCategory,
            func.count(ForumPost.id).filter(
                ForumPost.is_deleted == False,
                ForumPost.is_approved == True
            ).label("post_count")
        )
        .outerjoin(ForumPost, ForumCategory.id == ForumPost.category_id)
        .where(ForumCategory.is_active == True)
        .group_by(ForumCategory.id)
        .order_by(ForumCategory.display_order)
    )

    result = await db.execute(query)
    rows = result.all()

    return [
        CategoryResponse(
            id=cat.id,
            name=cat.name,
            slug=cat.slug,
            description=cat.description,
            icon=cat.icon,
            post_count=count
        )
        for cat, count in rows
    ]


@router.get("/guides", response_model=List[GuideSectionResponse])
async def get_guides_section(db: AsyncSession = Depends(get_db)):
    """Get pinned guides grouped by category for the top section."""
    # Get categories
    cat_query = select(ForumCategory).where(ForumCategory.is_active == True).order_by(ForumCategory.display_order)
    cat_result = await db.execute(cat_query)
    categories = cat_result.scalars().all()

    response = []
    for cat in categories:
        # Get top 5 guides (pinned or marked as guide) per category
        guide_query = (
            select(ForumPost)
            .options(selectinload(ForumPost.author))
            .where(
                ForumPost.category_id == cat.id,
                ForumPost.is_deleted == False,
                ForumPost.is_approved == True,
                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)
            )
            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())
            .limit(5)
        )
        guide_result = await db.execute(guide_query)
        guides = guide_result.scalars().all()

        response.append(GuideSectionResponse(
            category=CategoryResponse(
                id=cat.id,
                name=cat.name,
                slug=cat.slug,
                description=cat.description,
                icon=cat.icon,
                post_count=0
            ),
            guides=[_post_to_list_item(g, None) for g in guides]
        ))

    return response


# === POSTS ===

@router.get("/categories/{slug}/posts", response_model=PostListResponse)
async def list_category_posts(
    slug: str,
    sort: SortOrder = Query(SortOrder.HOT),
    limit: int = Query(PAGE_SIZE, ge=1, le=50),
    offset: int = Query(0, ge=0),
    current_user: Optional[User] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db),
):
    """List posts in a category with sorting and pagination."""
    # Verify category exists
    cat_result = await db.execute(select(ForumCategory).where(ForumCategory.slug == slug))
    category = cat_result.scalar_one_or_none()
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")

    # Base query
    query = (
        select(ForumPost)
        .options(selectinload(ForumPost.author))
        .where(
            ForumPost.category_id == category.id,
            ForumPost.is_deleted == False,
            ForumPost.is_approved == True
        )
    )

    # Sorting - pinned always first
    if sort == SortOrder.NEW:
        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())
    elif sort == SortOrder.TOP:
        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())
    else:  # HOT - combination of votes and recency
        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())

    # Get total count
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await db.execute(count_query)
    total_count = total_result.scalar()

    # Paginate
    query = query.offset(offset).limit(limit)
    result = await db.execute(query)
    posts = result.scalars().all()

    # Get user votes if authenticated
    user_votes = {}
    if current_user:
        post_ids = [p.id for p in posts]
        votes_query = select(ForumVote).where(
            ForumVote.user_id == current_user.id,
            ForumVote.target_type == TargetType.POST,
            ForumVote.target_id.in_(post_ids)
        )
        votes_result = await db.execute(votes_query)
        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}

    return PostListResponse(
        posts=[_post_to_list_item(p, user_votes.get(p.id)) for p in posts],
        total_count=total_count,
        has_more=offset + limit < total_count
    )


@router.post("/posts", response_model=PostResponse)
async def create_post(
    data: PostCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Create a new post."""
    # Verify category exists
    cat_result = await db.execute(select(ForumCategory).where(ForumCategory.id == data.category_id))
    category = cat_result.scalar_one_or_none()
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")

    post = ForumPost(
        title=data.title,
        content=data.content,
        category_id=data.category_id,
        author_id=current_user.id,
    )

    db.add(post)
    await db.commit()
    await db.refresh(post)

    return _post_to_response(post, category.slug, None)


@router.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(
    post_id: UUID,
    current_user: Optional[User] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db),
):
    """Get a single post with full details."""
    query = (
        select(ForumPost)
        .options(selectinload(ForumPost.author), selectinload(ForumPost.category))
        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)
    )
    result = await db.execute(query)
    post = result.scalar_one_or_none()

    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    # Get user's vote
    user_vote = None
    if current_user:
        vote_result = await db.execute(
            select(ForumVote).where(
                ForumVote.user_id == current_user.id,
                ForumVote.target_type == TargetType.POST,
                ForumVote.target_id == post_id
            )
        )
        vote = vote_result.scalar_one_or_none()
        user_vote = vote.vote_type if vote else None

    return _post_to_response(post, post.category.slug, user_vote)


@router.post("/posts/{post_id}/vote", response_model=VoteResponse)
async def vote_on_post(
    post_id: UUID,
    data: VoteRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it."""
    # Verify post exists
    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False))
    post = post_result.scalar_one_or_none()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    # Check existing vote
    vote_result = await db.execute(
        select(ForumVote).where(
            ForumVote.user_id == current_user.id,
            ForumVote.target_type == TargetType.POST,
            ForumVote.target_id == post_id
        )
    )
    existing_vote = vote_result.scalar_one_or_none()

    new_user_vote = None
    if existing_vote:
        if existing_vote.vote_type == data.vote_type:
            # Same vote - remove it
            await db.delete(existing_vote)
            post.vote_count += -1 if data.vote_type == VoteType.UP else 1
        else:
            # Different vote - switch it
            existing_vote.vote_type = data.vote_type
            # Swing by 2 (remove old, add new)
            post.vote_count += 2 if data.vote_type == VoteType.UP else -2
            new_user_vote = data.vote_type
    else:
        # New vote
        vote = ForumVote(
            user_id=current_user.id,
            target_type=TargetType.POST,
            target_id=post_id,
            vote_type=data.vote_type
        )
        db.add(vote)
        post.vote_count += 1 if data.vote_type == VoteType.UP else -1
        new_user_vote = data.vote_type

    await db.commit()

    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)


# === COMMENTS ===

@router.get("/posts/{post_id}/comments", response_model=List[CommentResponse])
async def get_post_comments(
    post_id: UUID,
    current_user: Optional[User] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db),
):
    """Get all comments for a post in a threaded structure."""
    # Verify post exists
    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))
    if not post_result.scalar_one_or_none():
        raise HTTPException(status_code=404, detail="Post not found")

    # Get all comments for post
    query = (
        select(ForumComment)
        .options(selectinload(ForumComment.author))
        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)
        .order_by(ForumComment.created_at)
    )
    result = await db.execute(query)
    comments = result.scalars().all()

    # Get user votes
    user_votes = {}
    if current_user:
        comment_ids = [c.id for c in comments]
        votes_query = select(ForumVote).where(
            ForumVote.user_id == current_user.id,
            ForumVote.target_type == TargetType.COMMENT,
            ForumVote.target_id.in_(comment_ids)
        )
        votes_result = await db.execute(votes_query)
        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}

    # Build tree structure
    return _build_comment_tree(comments, user_votes)


@router.post("/posts/{post_id}/comments", response_model=CommentResponse)
async def create_comment(
    post_id: UUID,
    data: CommentCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Create a comment on a post."""
    # Verify post exists
    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False))
    post = post_result.scalar_one_or_none()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    depth = 0
    if data.parent_id:
        # Verify parent comment exists
        parent_result = await db.execute(
            select(ForumComment).where(ForumComment.id == data.parent_id, ForumComment.post_id == post_id)
        )
        parent = parent_result.scalar_one_or_none()
        if not parent:
            raise HTTPException(status_code=404, detail="Parent comment not found")
        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)

    comment = ForumComment(
        content=data.content,
        post_id=post_id,
        author_id=current_user.id,
        parent_id=data.parent_id,
        depth=depth,
    )

    db.add(comment)
    await db.commit()
    await db.refresh(comment)

    return _comment_to_response(comment, None)


@router.post("/comments/{comment_id}/vote", response_model=VoteResponse)
async def vote_on_comment(
    comment_id: UUID,
    data: VoteRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Vote on a comment."""
    comment_result = await db.execute(
        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)
    )
    comment = comment_result.scalar_one_or_none()
    if not comment:
        raise HTTPException(status_code=404, detail="Comment not found")

    vote_result = await db.execute(
        select(ForumVote).where(
            ForumVote.user_id == current_user.id,
            ForumVote.target_type == TargetType.COMMENT,
            ForumVote.target_id == comment_id
        )
    )
    existing_vote = vote_result.scalar_one_or_none()

    new_user_vote = None
    if existing_vote:
        if existing_vote.vote_type == data.vote_type:
            await db.delete(existing_vote)
            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1
        else:
            existing_vote.vote_type = data.vote_type
            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2
            new_user_vote = data.vote_type
    else:
        vote = ForumVote(
            user_id=current_user.id,
            target_type=TargetType.COMMENT,
            target_id=comment_id,
            vote_type=data.vote_type
        )
        db.add(vote)
        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1
        new_user_vote = data.vote_type

    await db.commit()

    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)


# === REPORTS ===

@router.post("/reports", response_model=ReportResponse)
async def create_report(
    data: ReportCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Report a post or comment."""
    # Verify target exists
    if data.target_type == TargetType.POST:
        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))
    else:
        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))

    if not target_result.scalar_one_or_none():
        raise HTTPException(status_code=404, detail="Target not found")

    # Check for duplicate report
    existing = await db.execute(
        select(ForumReport).where(
            ForumReport.reporter_id == current_user.id,
            ForumReport.target_type == data.target_type,
            ForumReport.target_id == data.target_id,
            ForumReport.status == ReportStatus.PENDING
        )
    )
    if existing.scalar_one_or_none():
        raise HTTPException(status_code=400, detail="You have already reported this content")

    report = ForumReport(
        reporter_id=current_user.id,
        target_type=data.target_type,
        target_id=data.target_id,
        reason=data.reason,
        details=data.details,
    )

    db.add(report)
    await db.commit()
    await db.refresh(report)

    return ReportResponse(
        id=report.id,
        target_type=report.target_type,
        target_id=report.target_id,
        reason=report.reason,
        status=report.status.value,
        created_at=report.created_at
    )


# === MODERATION (Admin/Moderator only) ===

@router.post("/posts/{post_id}/pin")
async def pin_post(
    post_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Pin/unpin a post (moderator only)."""
    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Moderator access required")

    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))
    post = post_result.scalar_one_or_none()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    post.is_pinned = not post.is_pinned
    await db.commit()

    return {"success": True, "is_pinned": post.is_pinned}


@router.post("/posts/{post_id}/mark-guide")
async def mark_as_guide(
    post_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Mark/unmark a post as a guide (moderator only)."""
    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:
        raise HTTPException(status_code=403, detail="Moderator access required")

    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))
    post = post_result.scalar_one_or_none()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    post.is_guide = not post.is_guide
    await db.commit()

    return {"success": True, "is_guide": post.is_guide}


@router.delete("/posts/{post_id}")
async def delete_post(
    post_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
):
    """Delete a post (author or moderator)."""
    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))
    post = post_result.scalar_one_or_none()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    is_author = post.author_id == current_user.id
    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]

    if not is_author and not is_mod:
        raise HTTPException(status_code=403, detail="Not authorized")

    post.is_deleted = True
    await db.commit()

    return {"success": True}


# === HELPER FUNCTIONS ===

def _post_to_list_item(post: ForumPost, user_vote: Optional[VoteType]) -> PostListItem:
    return PostListItem(
        id=post.id,
        title=post.title,
        content_preview=post.content[:200] + "..." if len(post.content) > 200 else post.content,
        category_slug=post.category.slug if post.category else "",
        author=PostAuthor(id=post.author.id, username=post.author.username),
        is_pinned=post.is_pinned,
        is_guide=post.is_guide,
        vote_count=post.vote_count,
        comment_count=post.comment_count,
        user_vote=user_vote,
        created_at=post.created_at,
    )


def _post_to_response(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostResponse:
    return PostResponse(
        id=post.id,
        title=post.title,
        content=post.content,
        category_id=post.category_id,
        category_slug=category_slug,
        author=PostAuthor(id=post.author.id, username=post.author.username),
        is_pinned=post.is_pinned,
        is_guide=post.is_guide,
        vote_count=post.vote_count,
        comment_count=post.comment_count,
        user_vote=user_vote,
        created_at=post.created_at,
        updated_at=post.updated_at,
    )


def _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:
    return CommentResponse(
        id=comment.id,
        content=comment.content,
        post_id=comment.post_id,
        author=PostAuthor(id=comment.author.id, username=comment.author.username),
        parent_id=comment.parent_id,
        vote_count=comment.vote_count,
        user_vote=user_vote,
        depth=comment.depth,
        replies=[],
        created_at=comment.created_at,
        updated_at=comment.updated_at,
    )


def _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:
    """Build a tree structure from flat comment list."""
    comment_map = {}
    roots = []

    # First pass: create all response objects
    for c in comments:
        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))

    # Second pass: build tree
    for c in comments:
        response = comment_map[c.id]
        if c.parent_id and c.parent_id in comment_map:
            comment_map[c.parent_id].replies.append(response)
        else:
            roots.append(response)

    return roots
```

### 4.1 Register Router

Add to `/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/main.py`:

```python
from app.routers import forum

app.include_router(forum.router)
```

---

## 5. Frontend Types

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/types/forum.ts`

```typescript
/**
 * Forum Types
 */

export type VoteType = 'up' | 'down';
export type TargetType = 'post' | 'comment';
export type SortOrder = 'hot' | 'new' | 'top';

export type ReportReason =
  | 'spam'
  | 'harassment'
  | 'misinformation'
  | 'off_topic'
  | 'inappropriate'
  | 'other';

export interface ForumCategory {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  icon: string | null;
  postCount: number;
}

export interface PostAuthor {
  id: string;
  username: string;
}

export interface PostListItem {
  id: string;
  title: string;
  contentPreview: string;
  categorySlug: string;
  author: PostAuthor;
  isPinned: boolean;
  isGuide: boolean;
  voteCount: number;
  commentCount: number;
  userVote: VoteType | null;
  createdAt: string;
}

export interface Post extends Omit<PostListItem, 'contentPreview'> {
  content: string;
  categoryId: string;
  updatedAt: string;
}

export interface Comment {
  id: string;
  content: string;
  postId: string;
  author: PostAuthor;
  parentId: string | null;
  voteCount: number;
  userVote: VoteType | null;
  depth: number;
  replies: Comment[];
  createdAt: string;
  updatedAt: string;
}

export interface GuideSection {
  category: ForumCategory;
  guides: PostListItem[];
}

export interface PostListResponse {
  posts: PostListItem[];
  totalCount: number;
  hasMore: boolean;
}

export interface VoteResponse {
  success: boolean;
  newVoteCount: number;
  userVote: VoteType | null;
}
```

---

## 6. API Client Extensions

**Add to:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/api.ts`

```typescript
// === FORUM API METHODS ===

// Forum Categories
async getForumCategories(): Promise<ForumCategory[]> {
  return this.request('/forum/categories');
}

async getGuidesSection(): Promise<GuideSection[]> {
  const response = await this.request<GuideSectionApiResponse[]>('/forum/guides');
  return response.map(transformGuideSection);
}

// Forum Posts
async getCategoryPosts(
  slug: string,
  options?: { sort?: SortOrder; limit?: number; offset?: number }
): Promise<PostListResponse> {
  const params = new URLSearchParams();
  if (options?.sort) params.set('sort', options.sort);
  if (options?.limit) params.set('limit', String(options.limit));
  if (options?.offset) params.set('offset', String(options.offset));
  const query = params.toString() ? `?${params}` : '';
  const response = await this.request<PostListApiResponse>(`/forum/categories/${slug}/posts${query}`);
  return transformPostList(response);
}

async createPost(data: { title: string; content: string; categoryId: string }): Promise<Post> {
  const response = await this.request<PostApiResponse>('/forum/posts', {
    method: 'POST',
    body: { title: data.title, content: data.content, category_id: data.categoryId },
  });
  return transformPost(response);
}

async getPost(postId: string): Promise<Post> {
  const response = await this.request<PostApiResponse>(`/forum/posts/${postId}`);
  return transformPost(response);
}

async voteOnPost(postId: string, voteType: VoteType): Promise<VoteResponse> {
  return this.request(`/forum/posts/${postId}/vote`, {
    method: 'POST',
    body: { vote_type: voteType },
  });
}

async deletePost(postId: string): Promise<void> {
  return this.request(`/forum/posts/${postId}`, { method: 'DELETE' });
}

// Forum Comments
async getPostComments(postId: string): Promise<Comment[]> {
  const response = await this.request<CommentApiResponse[]>(`/forum/posts/${postId}/comments`);
  return response.map(transformComment);
}

async createComment(postId: string, data: { content: string; parentId?: string }): Promise<Comment> {
  const response = await this.request<CommentApiResponse>(`/forum/posts/${postId}/comments`, {
    method: 'POST',
    body: { content: data.content, parent_id: data.parentId },
  });
  return transformComment(response);
}

async voteOnComment(commentId: string, voteType: VoteType): Promise<VoteResponse> {
  return this.request(`/forum/comments/${commentId}/vote`, {
    method: 'POST',
    body: { vote_type: voteType },
  });
}

// Reports
async reportContent(data: {
  targetType: TargetType;
  targetId: string;
  reason: ReportReason;
  details?: string;
}): Promise<void> {
  return this.request('/forum/reports', {
    method: 'POST',
    body: {
      target_type: data.targetType,
      target_id: data.targetId,
      reason: data.reason,
      details: data.details,
    },
  });
}

// Moderation (for mods/admins)
async pinPost(postId: string): Promise<{ success: boolean; isPinned: boolean }> {
  return this.request(`/forum/posts/${postId}/pin`, { method: 'POST' });
}

async markPostAsGuide(postId: string): Promise<{ success: boolean; isGuide: boolean }> {
  return this.request(`/forum/posts/${postId}/mark-guide`, { method: 'POST' });
}
```

---

## 7. Frontend Context

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/contexts/ForumContext.tsx`

```tsx
'use client';

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import { api } from '@/lib/api';
import type {
  ForumCategory,
  PostListItem,
  Post,
  Comment,
  GuideSection,
  SortOrder,
  VoteType,
} from '@/types/forum';

interface ForumContextType {
  // Categories
  categories: ForumCategory[];
  fetchCategories: () => Promise<void>;

  // Guides
  guideSections: GuideSection[];
  fetchGuideSections: () => Promise<void>;

  // Posts
  posts: PostListItem[];
  totalCount: number;
  hasMore: boolean;
  currentSort: SortOrder;
  isLoading: boolean;
  error: string | null;

  fetchPosts: (categorySlug: string, sort?: SortOrder, reset?: boolean) => Promise<void>;
  loadMorePosts: (categorySlug: string) => Promise<void>;
  setSort: (sort: SortOrder) => void;

  // Current post
  currentPost: Post | null;
  comments: Comment[];
  fetchPost: (postId: string) => Promise<void>;
  fetchComments: (postId: string) => Promise<void>;

  // Actions
  createPost: (title: string, content: string, categoryId: string) => Promise<Post>;
  voteOnPost: (postId: string, voteType: VoteType) => Promise<void>;
  createComment: (postId: string, content: string, parentId?: string) => Promise<Comment>;
  voteOnComment: (commentId: string, voteType: VoteType) => Promise<void>;
}

const ForumContext = createContext<ForumContextType | null>(null);

export function useForumContext(): ForumContextType {
  const context = useContext(ForumContext);
  if (!context) {
    throw new Error('useForumContext must be used within a ForumProvider');
  }
  return context;
}

const PAGE_SIZE = 20;

export function ForumProvider({ children }: { children: ReactNode }) {
  // State
  const [categories, setCategories] = useState<ForumCategory[]>([]);
  const [guideSections, setGuideSections] = useState<GuideSection[]>([]);
  const [posts, setPosts] = useState<PostListItem[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [currentSort, setCurrentSort] = useState<SortOrder>('hot');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentPost, setCurrentPost] = useState<Post | null>(null);
  const [comments, setComments] = useState<Comment[]>([]);

  // Category fetching
  const fetchCategories = useCallback(async () => {
    try {
      const data = await api.getForumCategories();
      setCategories(data);
    } catch (err) {
      console.error('[Forum] Failed to fetch categories:', err);
    }
  }, []);

  const fetchGuideSections = useCallback(async () => {
    try {
      const data = await api.getGuidesSection();
      setGuideSections(data);
    } catch (err) {
      console.error('[Forum] Failed to fetch guides:', err);
    }
  }, []);

  // Post fetching
  const fetchPosts = useCallback(async (categorySlug: string, sort?: SortOrder, reset = true) => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await api.getCategoryPosts(categorySlug, {
        sort: sort || currentSort,
        limit: PAGE_SIZE,
        offset: reset ? 0 : posts.length,
      });

      setPosts(reset ? data.posts : [...posts, ...data.posts]);
      setTotalCount(data.totalCount);
      setHasMore(data.hasMore);
      if (sort) setCurrentSort(sort);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch posts');
    } finally {
      setIsLoading(false);
    }
  }, [currentSort, posts]);

  const loadMorePosts = useCallback(async (categorySlug: string) => {
    if (!hasMore || isLoading) return;
    await fetchPosts(categorySlug, currentSort, false);
  }, [fetchPosts, hasMore, isLoading, currentSort]);

  const setSort = useCallback((sort: SortOrder) => {
    setCurrentSort(sort);
  }, []);

  // Single post
  const fetchPost = useCallback(async (postId: string) => {
    try {
      const data = await api.getPost(postId);
      setCurrentPost(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch post');
    }
  }, []);

  const fetchComments = useCallback(async (postId: string) => {
    try {
      const data = await api.getPostComments(postId);
      setComments(data);
    } catch (err) {
      console.error('[Forum] Failed to fetch comments:', err);
    }
  }, []);

  // Actions with optimistic updates
  const createPost = useCallback(async (title: string, content: string, categoryId: string) => {
    const post = await api.createPost({ title, content, categoryId });
    return post;
  }, []);

  const voteOnPost = useCallback(async (postId: string, voteType: VoteType) => {
    // Optimistic update
    setPosts(prev => prev.map(p => {
      if (p.id !== postId) return p;
      const oldVote = p.userVote;
      let newCount = p.voteCount;
      let newVote: VoteType | null = voteType;

      if (oldVote === voteType) {
        newCount += voteType === 'up' ? -1 : 1;
        newVote = null;
      } else if (oldVote) {
        newCount += voteType === 'up' ? 2 : -2;
      } else {
        newCount += voteType === 'up' ? 1 : -1;
      }

      return { ...p, voteCount: newCount, userVote: newVote };
    }));

    if (currentPost?.id === postId) {
      setCurrentPost(prev => {
        if (!prev) return prev;
        const oldVote = prev.userVote;
        let newCount = prev.voteCount;
        let newVote: VoteType | null = voteType;

        if (oldVote === voteType) {
          newCount += voteType === 'up' ? -1 : 1;
          newVote = null;
        } else if (oldVote) {
          newCount += voteType === 'up' ? 2 : -2;
        } else {
          newCount += voteType === 'up' ? 1 : -1;
        }

        return { ...prev, voteCount: newCount, userVote: newVote };
      });
    }

    try {
      await api.voteOnPost(postId, voteType);
    } catch (err) {
      console.error('[Forum] Vote failed:', err);
      // Could rollback here
    }
  }, [currentPost]);

  const createComment = useCallback(async (postId: string, content: string, parentId?: string) => {
    const comment = await api.createComment(postId, { content, parentId });

    // Add to comments tree
    if (!parentId) {
      setComments(prev => [...prev, comment]);
    } else {
      setComments(prev => {
        const addReply = (comments: Comment[]): Comment[] => {
          return comments.map(c => {
            if (c.id === parentId) {
              return { ...c, replies: [...c.replies, comment] };
            }
            if (c.replies.length > 0) {
              return { ...c, replies: addReply(c.replies) };
            }
            return c;
          });
        };
        return addReply(prev);
      });
    }

    return comment;
  }, []);

  const voteOnComment = useCallback(async (commentId: string, voteType: VoteType) => {
    // Optimistic update for comments tree
    const updateVote = (comments: Comment[]): Comment[] => {
      return comments.map(c => {
        if (c.id === commentId) {
          const oldVote = c.userVote;
          let newCount = c.voteCount;
          let newVote: VoteType | null = voteType;

          if (oldVote === voteType) {
            newCount += voteType === 'up' ? -1 : 1;
            newVote = null;
          } else if (oldVote) {
            newCount += voteType === 'up' ? 2 : -2;
          } else {
            newCount += voteType === 'up' ? 1 : -1;
          }

          return { ...c, voteCount: newCount, userVote: newVote };
        }
        if (c.replies.length > 0) {
          return { ...c, replies: updateVote(c.replies) };
        }
        return c;
      });
    };

    setComments(prev => updateVote(prev));

    try {
      await api.voteOnComment(commentId, voteType);
    } catch (err) {
      console.error('[Forum] Comment vote failed:', err);
    }
  }, []);

  return (
    <ForumContext.Provider
      value={{
        categories,
        fetchCategories,
        guideSections,
        fetchGuideSections,
        posts,
        totalCount,
        hasMore,
        currentSort,
        isLoading,
        error,
        fetchPosts,
        loadMorePosts,
        setSort,
        currentPost,
        comments,
        fetchPost,
        fetchComments,
        createPost,
        voteOnPost,
        createComment,
        voteOnComment,
      }}
    >
      {children}
    </ForumContext.Provider>
  );
}
```

---

## 8. Frontend Routes

### 8.1 Routing Structure

```
/forum                     - Forum home (category grid + guides section)
/forum/[category]          - Category post list (e.g., /forum/hairstyle)
/forum/post/[id]           - Single post with comments
/forum/new                 - Create new post
```

### 8.2 Forum Home Page

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/app/forum/page.tsx`

```tsx
'use client';

import { useEffect } from 'react';
import { useForumContext } from '@/contexts/ForumContext';
import CategoryGrid from '@/components/forum/CategoryGrid';
import GuidesSection from '@/components/forum/GuidesSection';

export default function ForumPage() {
  const { categories, guideSections, fetchCategories, fetchGuideSections } = useForumContext();

  useEffect(() => {
    fetchCategories();
    fetchGuideSections();
  }, [fetchCategories, fetchGuideSections]);

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-6xl mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold text-foreground mb-2">Community Forum</h1>
        <p className="text-muted-foreground mb-8">
          Get advice, share tips, and connect with others on your looksmax journey
        </p>

        {/* Guides Section - At the TOP */}
        <GuidesSection sections={guideSections} />

        {/* Category Grid */}
        <section className="mt-12">
          <h2 className="text-xl font-semibold text-foreground mb-4">Browse Categories</h2>
          <CategoryGrid categories={categories} />
        </section>
      </div>
    </div>
  );
}
```

### 8.3 Category Posts Page

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/app/forum/[category]/page.tsx`

```tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useForumContext } from '@/contexts/ForumContext';
import PostList from '@/components/forum/PostList';
import SortSelector from '@/components/forum/SortSelector';
import Link from 'next/link';
import { Plus } from 'lucide-react';

export default function CategoryPage() {
  const params = useParams();
  const slug = params.category as string;

  const {
    categories,
    posts,
    hasMore,
    currentSort,
    isLoading,
    fetchCategories,
    fetchPosts,
    loadMorePosts,
    setSort,
  } = useForumContext();

  const category = categories.find(c => c.slug === slug);

  useEffect(() => {
    if (categories.length === 0) {
      fetchCategories();
    }
  }, [categories.length, fetchCategories]);

  useEffect(() => {
    fetchPosts(slug, currentSort, true);
  }, [slug, currentSort, fetchPosts]);

  const handleSortChange = (sort: SortOrder) => {
    setSort(sort);
    fetchPosts(slug, sort, true);
  };

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-4xl mx-auto px-4 py-8">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div>
            <div className="flex items-center gap-2 mb-1">
              <span className="text-2xl">{category?.icon}</span>
              <h1 className="text-2xl font-bold text-foreground">{category?.name}</h1>
            </div>
            <p className="text-muted-foreground">{category?.description}</p>
          </div>
          <Link
            href={`/forum/new?category=${slug}`}
            className="btn-primary flex items-center gap-2"
          >
            <Plus className="w-4 h-4" />
            New Post
          </Link>
        </div>

        {/* Sort */}
        <div className="flex justify-between items-center mb-4">
          <SortSelector value={currentSort} onChange={handleSortChange} />
          <span className="text-sm text-muted-foreground">
            {category?.postCount} posts
          </span>
        </div>

        {/* Posts */}
        <PostList
          posts={posts}
          isLoading={isLoading}
          hasMore={hasMore}
          onLoadMore={() => loadMorePosts(slug)}
        />
      </div>
    </div>
  );
}
```

### 8.4 Post Detail Page

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/app/forum/post/[id]/page.tsx`

```tsx
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { useForumContext } from '@/contexts/ForumContext';
import PostDetail from '@/components/forum/PostDetail';
import CommentTree from '@/components/forum/CommentTree';
import CommentForm from '@/components/forum/CommentForm';

export default function PostPage() {
  const params = useParams();
  const postId = params.id as string;

  const {
    currentPost,
    comments,
    fetchPost,
    fetchComments,
    voteOnPost,
    createComment,
    voteOnComment,
  } = useForumContext();

  useEffect(() => {
    fetchPost(postId);
    fetchComments(postId);
  }, [postId, fetchPost, fetchComments]);

  if (!currentPost) {
    return <div className="min-h-screen bg-background flex items-center justify-center">
      <div className="animate-pulse text-muted-foreground">Loading...</div>
    </div>;
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-4xl mx-auto px-4 py-8">
        <PostDetail post={currentPost} onVote={voteOnPost} />

        <div className="mt-8">
          <h2 className="text-lg font-semibold text-foreground mb-4">
            Comments ({currentPost.commentCount})
          </h2>

          <CommentForm
            postId={postId}
            onSubmit={(content) => createComment(postId, content)}
          />

          <div className="mt-6">
            <CommentTree
              comments={comments}
              onVote={voteOnComment}
              onReply={(parentId, content) => createComment(postId, content, parentId)}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
```

---

## 9. Frontend Components

### 9.1 Component Overview

| Component | Purpose |
|-----------|---------|
| `CategoryGrid` | Display category cards with icons |
| `GuidesSection` | Pinned/featured guides at top |
| `PostList` | List of posts with infinite scroll |
| `PostCard` | Single post card in list |
| `PostDetail` | Full post with content |
| `VoteButtons` | Upvote/downvote buttons |
| `CommentTree` | Recursive threaded comments |
| `CommentItem` | Single comment |
| `CommentForm` | Add comment form |
| `SortSelector` | Hot/New/Top dropdown |
| `ReportModal` | Report content modal |
| `CreatePostForm` | Post creation form |

### 9.2 VoteButtons Component

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/components/forum/VoteButtons.tsx`

```tsx
'use client';

import { ChevronUp, ChevronDown } from 'lucide-react';
import { VoteType } from '@/types/forum';
import { cn } from '@/lib/utils';

interface VoteButtonsProps {
  voteCount: number;
  userVote: VoteType | null;
  onVote: (voteType: VoteType) => void;
  vertical?: boolean;
}

export default function VoteButtons({
  voteCount,
  userVote,
  onVote,
  vertical = true,
}: VoteButtonsProps) {
  return (
    <div className={cn(
      'flex items-center gap-1',
      vertical ? 'flex-col' : 'flex-row'
    )}>
      <button
        onClick={() => onVote('up')}
        className={cn(
          'p-1 rounded hover:bg-white/10 transition-colors',
          userVote === 'up' ? 'text-accent' : 'text-muted-foreground hover:text-foreground'
        )}
        aria-label="Upvote"
      >
        <ChevronUp className="w-5 h-5" />
      </button>

      <span className={cn(
        'text-sm font-medium min-w-[2ch] text-center',
        userVote === 'up' && 'text-accent',
        userVote === 'down' && 'text-red-500',
        !userVote && 'text-foreground'
      )}>
        {voteCount}
      </span>

      <button
        onClick={() => onVote('down')}
        className={cn(
          'p-1 rounded hover:bg-white/10 transition-colors',
          userVote === 'down' ? 'text-red-500' : 'text-muted-foreground hover:text-foreground'
        )}
        aria-label="Downvote"
      >
        <ChevronDown className="w-5 h-5" />
      </button>
    </div>
  );
}
```

### 9.3 PostCard Component

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/components/forum/PostCard.tsx`

```tsx
'use client';

import Link from 'next/link';
import { MessageSquare, Pin, BookOpen } from 'lucide-react';
import { PostListItem, VoteType } from '@/types/forum';
import VoteButtons from './VoteButtons';
import { formatDistanceToNow } from 'date-fns';

interface PostCardProps {
  post: PostListItem;
  onVote: (postId: string, voteType: VoteType) => void;
}

export default function PostCard({ post, onVote }: PostCardProps) {
  return (
    <div className="card flex gap-4 p-4 hover:border-accent/50 transition-colors">
      {/* Vote buttons */}
      <VoteButtons
        voteCount={post.voteCount}
        userVote={post.userVote}
        onVote={(voteType) => onVote(post.id, voteType)}
      />

      {/* Content */}
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2 mb-1">
          {post.isPinned && (
            <span className="flex items-center gap-1 text-xs text-accent">
              <Pin className="w-3 h-3" /> Pinned
            </span>
          )}
          {post.isGuide && (
            <span className="flex items-center gap-1 text-xs text-green-500">
              <BookOpen className="w-3 h-3" /> Guide
            </span>
          )}
        </div>

        <Link href={`/forum/post/${post.id}`}>
          <h3 className="text-lg font-medium text-foreground hover:text-accent transition-colors line-clamp-2">
            {post.title}
          </h3>
        </Link>

        <p className="text-sm text-muted-foreground mt-1 line-clamp-2">
          {post.contentPreview}
        </p>

        <div className="flex items-center gap-4 mt-3 text-xs text-muted-foreground">
          <span>by {post.author.username}</span>
          <span>{formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}</span>
          <span className="flex items-center gap-1">
            <MessageSquare className="w-3 h-3" />
            {post.commentCount} comments
          </span>
        </div>
      </div>
    </div>
  );
}
```

### 9.4 CategoryGrid Component

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/components/forum/CategoryGrid.tsx`

```tsx
'use client';

import Link from 'next/link';
import { ForumCategory } from '@/types/forum';

interface CategoryGridProps {
  categories: ForumCategory[];
}

const CATEGORY_COLORS: Record<string, string> = {
  hairstyle: 'from-pink-500/20 to-rose-500/10 hover:from-pink-500/30',
  dating: 'from-red-500/20 to-pink-500/10 hover:from-red-500/30',
  skincare: 'from-blue-500/20 to-cyan-500/10 hover:from-blue-500/30',
};

export default function CategoryGrid({ categories }: CategoryGridProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      {categories.map((category) => (
        <Link
          key={category.id}
          href={`/forum/${category.slug}`}
          className={`
            p-6 rounded-xl bg-gradient-to-br border border-white/10
            ${CATEGORY_COLORS[category.slug] || 'from-gray-500/20 to-gray-500/10'}
            hover:border-accent/50 hover:scale-[1.02] transition-all duration-200
          `}
        >
          <span className="text-4xl block mb-3">{category.icon}</span>
          <h3 className="text-xl font-semibold text-foreground">{category.name}</h3>
          <p className="text-sm text-muted-foreground mt-1">{category.description}</p>
          <p className="text-xs text-accent mt-3">{category.postCount} posts</p>
        </Link>
      ))}
    </div>
  );
}
```

### 9.5 CommentTree Component

**File:** `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/components/forum/CommentTree.tsx`

```tsx
'use client';

import { useState } from 'react';
import { Comment, VoteType } from '@/types/forum';
import VoteButtons from './VoteButtons';
import CommentForm from './CommentForm';
import { formatDistanceToNow } from 'date-fns';
import { cn } from '@/lib/utils';

interface CommentTreeProps {
  comments: Comment[];
  onVote: (commentId: string, voteType: VoteType) => void;
  onReply: (parentId: string, content: string) => Promise<void>;
}

export default function CommentTree({ comments, onVote, onReply }: CommentTreeProps) {
  return (
    <div className="space-y-4">
      {comments.map((comment) => (
        <CommentItem
          key={comment.id}
          comment={comment}
          onVote={onVote}
          onReply={onReply}
        />
      ))}
    </div>
  );
}

interface CommentItemProps {
  comment: Comment;
  onVote: (commentId: string, voteType: VoteType) => void;
  onReply: (parentId: string, content: string) => Promise<void>;
}

function CommentItem({ comment, onVote, onReply }: CommentItemProps) {
  const [showReplyForm, setShowReplyForm] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleReply = async (content: string) => {
    setIsSubmitting(true);
    try {
      await onReply(comment.id, content);
      setShowReplyForm(false);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className={cn('pl-4 border-l-2 border-white/10', comment.depth > 0 && 'ml-4')}>
      <div className="flex gap-3">
        <VoteButtons
          voteCount={comment.voteCount}
          userVote={comment.userVote}
          onVote={(voteType) => onVote(comment.id, voteType)}
          vertical={false}
        />

        <div className="flex-1">
          <div className="flex items-center gap-2 text-xs text-muted-foreground mb-1">
            <span className="font-medium text-foreground">{comment.author.username}</span>
            <span>â€¢</span>
            <span>{formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true })}</span>
          </div>

          <p className="text-sm text-foreground whitespace-pre-wrap">{comment.content}</p>

          {comment.depth < 5 && (
            <button
              onClick={() => setShowReplyForm(!showReplyForm)}
              className="text-xs text-muted-foreground hover:text-accent mt-2"
            >
              Reply
            </button>
          )}

          {showReplyForm && (
            <div className="mt-2">
              <CommentForm
                postId={comment.postId}
                onSubmit={handleReply}
                onCancel={() => setShowReplyForm(false)}
                placeholder="Write a reply..."
                isSubmitting={isSubmitting}
              />
            </div>
          )}
        </div>
      </div>

      {/* Nested replies */}
      {comment.replies.length > 0 && (
        <div className="mt-4 space-y-4">
          {comment.replies.map((reply) => (
            <CommentItem
              key={reply.id}
              comment={reply}
              onVote={onVote}
              onReply={onReply}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

---

## 10. Implementation Phases

### Phase 1: Backend Foundation
1. Add `UserRole` enum to User model
2. Create `forum.py` models file
3. Create SQL migration file
4. Run migration on Railway
5. Create `forum.py` schemas file
6. Create `forum.py` router file
7. Register router in `main.py`
8. Test endpoints with Postman/curl

### Phase 2: Frontend Foundation
1. Create `types/forum.ts`
2. Add API methods to `lib/api.ts`
3. Create `ForumContext.tsx`
4. Add `ForumProvider` to `Providers.tsx`
5. Create basic page routes

### Phase 3: Core Components
1. `CategoryGrid.tsx` - Category display
2. `GuidesSection.tsx` - Top guides area
3. `PostList.tsx` + `PostCard.tsx` - Post listing
4. `VoteButtons.tsx` - Voting component
5. `SortSelector.tsx` - Sort dropdown

### Phase 4: Post & Comment Features
1. `PostDetail.tsx` - Full post view
2. `CommentTree.tsx` + `CommentItem.tsx` - Threaded comments
3. `CreatePostForm.tsx` - Post creation
4. Wire up all components to pages

### Phase 5: Polish & Moderation
1. `ReportModal.tsx` - Report functionality
2. Moderation UI (pin/mark guide for mods)
3. Error handling and loading states
4. Mobile responsiveness
5. Animation and transitions

### Phase 6: Testing & Deployment
1. End-to-end testing
2. Performance optimization
3. Deploy backend changes
4. Deploy frontend changes

---

## 11. API Endpoints Summary

| Method | Endpoint | Description | Auth |
|--------|----------|-------------|------|
| GET | `/forum/categories` | List all categories | No |
| GET | `/forum/guides` | Get guides by category | No |
| GET | `/forum/categories/{slug}/posts` | List posts in category | Optional |
| POST | `/forum/posts` | Create post | Yes |
| GET | `/forum/posts/{id}` | Get single post | Optional |
| POST | `/forum/posts/{id}/vote` | Vote on post | Yes |
| DELETE | `/forum/posts/{id}` | Delete post | Yes |
| GET | `/forum/posts/{id}/comments` | Get comments | Optional |
| POST | `/forum/posts/{id}/comments` | Create comment | Yes |
| POST | `/forum/comments/{id}/vote` | Vote on comment | Yes |
| POST | `/forum/reports` | Report content | Yes |
| POST | `/forum/posts/{id}/pin` | Pin post | Mod |
| POST | `/forum/posts/{id}/mark-guide` | Mark as guide | Mod |

---

## 12. Future Enhancements (Not in Initial Scope)

### Real-time Notifications
- WebSocket connection for live updates
- New comment notifications
- Vote notifications
- @mentions

### Additional Features
- Search within forum
- User profile pages showing their posts
- Karma system based on votes received
- Category-specific moderators
- Markdown support for posts/comments
- Image uploads in posts
- Post editing history
- User badges/flair

---

## 13. Critical Reference Files

| File | Purpose |
|------|---------|
| `looksmaxx-api/app/models/user.py` | Add UserRole enum |
| `looksmaxx-api/app/routers/leaderboard.py` | Reference for router patterns |
| `looksmaxx-app/src/lib/api.ts` | Extend with forum methods |
| `looksmaxx-app/src/contexts/LeaderboardContext.tsx` | Reference for context patterns |
| `looksmaxx-app/src/components/results/tabs/LeaderboardTab.tsx` | Reference for component styling |
