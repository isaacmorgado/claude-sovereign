#!/usr/bin/env python3
"""
looksmax_engine.py - Comprehensive facial analysis algorithm
Implements Frankfort plane standardization, geometric calculations, and Gaussian scoring.
Supports 66+ metrics matching ranges.json specifications.
"""

import json
import math
import os
import numpy as np
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# Optional matplotlib import for bell curve generation
try:
    import matplotlib.pyplot as plt
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False
    print("[Warning] matplotlib not installed. Bell curve graphs will be disabled.")

# =============================================================================
# LANDMARK MAPPINGS (MediaPipe 478-point indices)
# =============================================================================

LM_MAP = {
    # === CORE FACIAL STRUCTURE ===
    "trichion": 10,              # Hairline / top of forehead
    "glabella": 168,             # Between eyebrows
    "nasion": 6,                 # Bridge of nose (between eyes)
    "pronasale": 1,              # Tip of nose
    "subnasale": 164,            # Base of nose (columella base)
    "labrale_sup": 0,            # Upper lip vermilion border
    "stomion": 13,               # Meeting point of lips
    "labrale_inf": 17,           # Lower lip vermilion border
    "sublabiale": 18,            # Below lower lip
    "pogonion": 152,             # Most anterior point of chin
    "menton": 152,               # Bottom of chin (same as pogonion in 2D)
    "gnathion": 175,             # Lowest point of mandible

    # === FRANKFORT PLANE ===
    "porion": 226,               # Superior margin of ear canal
    "orbitale": 33,              # Lowest point of orbital margin

    # === JAW / MANDIBLE ===
    "gonion": 172,               # Angle of mandible (side view)
    "gonion_l": 172,             # Left jaw angle
    "gonion_r": 397,             # Right jaw angle
    "condyle": 234,              # Condylar process (jaw joint)

    # === CHEEKBONES / ZYGOMA ===
    "zygion_l": 123,             # Left zygomatic arch (cheekbone)
    "zygion_r": 352,             # Right zygomatic arch
    "cheekbone_l": 123,          # Alias for zygion_l
    "cheekbone_r": 352,          # Alias for zygion_r

    # === EYES ===
    "pupil_l": 468,              # Left pupil center
    "pupil_r": 473,              # Right pupil center
    "canthus_in_l": 133,         # Left inner canthus (medial)
    "canthus_out_l": 33,         # Left outer canthus (lateral)
    "canthus_in_r": 362,         # Right inner canthus
    "canthus_out_r": 263,        # Right outer canthus
    "endo_canthus_l": 133,       # Alias - endocanthion left
    "endo_canthus_r": 362,       # Alias - endocanthion right
    "exo_canthus_l": 33,         # Alias - exocanthion left
    "exo_canthus_r": 263,        # Alias - exocanthion right
    "upper_eyelid_l": 159,       # Upper eyelid center left
    "lower_eyelid_l": 145,       # Lower eyelid center left
    "upper_eyelid_r": 386,       # Upper eyelid center right
    "lower_eyelid_r": 374,       # Lower eyelid center right

    # === EYEBROWS ===
    "brow_inner_l": 107,         # Inner brow left
    "brow_outer_l": 70,          # Outer brow left
    "brow_peak_l": 105,          # Brow peak left
    "brow_inner_r": 336,         # Inner brow right
    "brow_outer_r": 300,         # Outer brow right
    "brow_peak_r": 334,          # Brow peak right
    "brow_l": 70,                # Legacy alias
    "brow_r": 300,               # Legacy alias

    # === NOSE ===
    "ala_l": 102,                # Left alar (nostril wing)
    "ala_r": 331,                # Right alar
    "ala_nasi_l": 102,           # Alias
    "ala_nasi_r": 331,           # Alias
    "nose_bridge": 6,            # Alias for nasion
    "columella": 2,              # Columella (between nostrils)

    # === MOUTH / LIPS ===
    "cheilion_l": 61,            # Left mouth corner
    "cheilion_r": 291,           # Right mouth corner
    "upper_lip": 0,              # Upper lip center (vermilion)
    "lower_lip": 17,             # Lower lip center
    "cupid_bow_l": 37,           # Left cupid's bow peak
    "cupid_bow_r": 267,          # Right cupid's bow peak
    "cupid_bow_center": 0,       # Center of cupid's bow
    "philtrum_top": 164,         # Top of philtrum (at subnasale)
    "philtrum_bottom": 0,        # Bottom of philtrum (at upper lip)

    # === TEMPLES / FOREHEAD ===
    "temple_l": 21,              # Left temple
    "temple_r": 251,             # Right temple
    "forehead_top": 10,          # Top of forehead
    "forehead_center": 151,      # Center of forehead

    # === EARS ===
    "ear_l": 234,                # Left ear (tragus area)
    "ear_r": 454,                # Right ear
    "ear_top_l": 127,            # Top of left ear
    "ear_top_r": 356,            # Top of right ear
    "ear_bottom_l": 234,         # Bottom of left ear (lobule)
    "ear_bottom_r": 454,         # Bottom of right ear

    # === NECK ===
    "neck_l": 132,               # Left neck point
    "neck_r": 361,               # Right neck point
    "cervical_point": 152,       # Cervical point (approximated)

    # === CHIN ===
    "chin_tip": 152,             # Tip of chin
    "chin_l": 177,               # Left chin contour
    "chin_r": 401,               # Right chin contour
}

# Legacy mappings for backward compatibility
LANDMARKS_SIDE = {k: v for k, v in LM_MAP.items() if k in [
    "porion", "orbitale", "glabella", "nasion", "pronasale", "subnasale",
    "labrale_sup", "labrale_inf", "pogonion", "menton", "gnathion", "gonion",
    "condyle", "cheilion_l", "sublabiale", "stomion"
]}

LANDMARKS_FRONT = {k: v for k, v in LM_MAP.items() if k in [
    "trichion", "menton", "cheekbone_l", "cheekbone_r", "gonion_l", "gonion_r",
    "pupil_l", "pupil_r", "canthus_in_l", "canthus_out_l", "canthus_in_r", "canthus_out_r",
    "ala_nasi_l", "ala_nasi_r", "cheilion_l", "cheilion_r", "glabella", "upper_lip"
]}

# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass
class MockLandmark:
    """Represents a single facial landmark with x, y, z coordinates."""
    x: float
    y: float
    z: float = 0.0


@dataclass
class Point2D:
    """2D point for geometric calculations."""
    x: float
    y: float

    def __sub__(self, other: 'Point2D') -> 'Point2D':
        return Point2D(self.x - other.x, self.y - other.y)

    def __add__(self, other: 'Point2D') -> 'Point2D':
        return Point2D(self.x + other.x, self.y + other.y)


# =============================================================================
# GEOMETRIC UTILITIES
# =============================================================================

def distance(p1: Point2D, p2: Point2D) -> float:
    """Calculate Euclidean distance between two points."""
    return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2)


def angle_between_points(p1: Point2D, vertex: Point2D, p2: Point2D) -> float:
    """
    Calculate angle at vertex formed by p1-vertex-p2.
    Returns angle in degrees.
    """
    v1 = Point2D(p1.x - vertex.x, p1.y - vertex.y)
    v2 = Point2D(p2.x - vertex.x, p2.y - vertex.y)

    dot = v1.x * v2.x + v1.y * v2.y
    mag1 = math.sqrt(v1.x ** 2 + v1.y ** 2)
    mag2 = math.sqrt(v2.x ** 2 + v2.y ** 2)

    if mag1 == 0 or mag2 == 0:
        return 0.0

    cos_angle = max(-1.0, min(1.0, dot / (mag1 * mag2)))
    return math.degrees(math.acos(cos_angle))


def angle_to_horizontal(p1: Point2D, p2: Point2D) -> float:
    """
    Calculate angle of line p1->p2 relative to horizontal.
    Returns angle in degrees (positive = upward tilt).
    """
    dx = p2.x - p1.x
    dy = p2.y - p1.y

    if dx == 0:
        return 90.0 if dy > 0 else -90.0

    return math.degrees(math.atan2(dy, dx))


def rotate_point(point: Point2D, center: Point2D, angle_rad: float) -> Point2D:
    """Rotate a point around a center by angle (radians)."""
    cos_a = math.cos(angle_rad)
    sin_a = math.sin(angle_rad)

    # Translate to origin
    px = point.x - center.x
    py = point.y - center.y

    # Rotate
    new_x = px * cos_a - py * sin_a
    new_y = px * sin_a + py * cos_a

    # Translate back
    return Point2D(new_x + center.x, new_y + center.y)


# =============================================================================
# FRANKFORT PLANE STANDARDIZATION
# =============================================================================

def apply_frankfort_correction(landmarks: List[MockLandmark]) -> Dict[str, Point2D]:
    """
    Apply Frankfort Plane correction to side profile landmarks.
    """
    porion_idx = LANDMARKS_SIDE["porion"]
    orbitale_idx = LANDMARKS_SIDE["orbitale"]

    porion = Point2D(landmarks[porion_idx].x, landmarks[porion_idx].y)
    orbitale = Point2D(landmarks[orbitale_idx].x, landmarks[orbitale_idx].y)

    current_angle = angle_to_horizontal(porion, orbitale)
    rotation_angle = -math.radians(current_angle)

    corrected = {}
    for name, idx in LANDMARKS_SIDE.items():
        original = Point2D(landmarks[idx].x, landmarks[idx].y)
        corrected[name] = rotate_point(original, porion, rotation_angle)

    return corrected


def get_front_landmarks(landmarks: List[MockLandmark]) -> Dict[str, Point2D]:
    """Extract front profile landmarks as Point2D objects."""
    result = {}
    for name, idx in LANDMARKS_FRONT.items():
        result[name] = Point2D(landmarks[idx].x, landmarks[idx].y)
    return result


# =============================================================================
# GAUSSIAN SCORING SYSTEM
# =============================================================================

def calculate_score(value: float, min_range: float, max_range: float) -> float:
    """
    Calculate a score from 0-10 using Gaussian decay.
    """
    if min_range <= value <= max_range:
        return 10.0

    if value < min_range:
        deviation = min_range - value
        target = min_range
    else:
        deviation = value - max_range
        target = max_range

    if target == 0:
        target = 1.0

    sigma = abs(target) * 0.1
    if sigma == 0:
        sigma = 1.0

    score = 10.0 * math.exp(-0.5 * (deviation / sigma) ** 2)
    return max(0.0, min(10.0, score))


def score_metrics(metrics: Dict[str, float]) -> Dict[str, Tuple[float, float]]:
    """Score all metrics and return (value, score) tuples."""
    results = {}
    for name, value in metrics.items():
        results[name] = (value, None)
    return results


# =============================================================================
# RANGES LOADER
# =============================================================================

def load_ranges(filepath: str = None) -> dict:
    """Load scoring ranges from ranges.json file."""
    if filepath is None:
        script_dir = Path(__file__).parent
        filepath = script_dir / "ranges.json"

    with open(filepath, 'r') as f:
        return json.load(f)


def get_ranges_for_profile(ranges: dict, gender: str = "male", ethnicity: str = "caucasian") -> dict:
    """Get front and side ranges for a specific gender/ethnicity combination."""
    return ranges.get(gender, {}).get(ethnicity, {"front": {}, "side": {}})


# =============================================================================
# FACIAL CALCULATOR CLASS - COMPREHENSIVE 66+ METRICS
# =============================================================================

class FacialCalculator:
    """
    Unified facial metrics calculator that computes all 66+ facial measurements.
    Uses real-world mm scaling based on interpupillary distance (IPD).
    """

    # Class-level IPD constant (can be calibrated)
    REAL_WORLD_IPD_MM = 63.0  # Standard male IPD

    def __init__(self, landmarks: List[MockLandmark]):
        self.landmarks = landmarks
        self.std_landmarks = self._apply_frankfort_correction()

        # Calculate mm_per_unit scaling factor
        pupil_l = self.get_pt("pupil_l")
        pupil_r = self.get_pt("pupil_r")
        eye_dist_units = np.linalg.norm(pupil_l - pupil_r)

        self.mm_per_unit = self.REAL_WORLD_IPD_MM / eye_dist_units if eye_dist_units > 0 else 1.0

    @classmethod
    def calibrate(cls, metric_name: str, known_value: float) -> None:
        """
        Calibrate the IPD constant based on a known measurement.

        Args:
            metric_name: Currently only 'IPD' is supported
            known_value: Known real-world value in mm

        Example:
            FacialCalculator.calibrate('IPD', 65.0)  # Set IPD to 65mm
        """
        if metric_name.upper() == 'IPD':
            cls.REAL_WORLD_IPD_MM = known_value
            print(f"[Calibration] IPD set to {known_value}mm")
        else:
            print(f"[Calibration] Unknown metric: {metric_name}")

    def get_pt(self, name: str, standardized: bool = False) -> np.ndarray:
        """Get a landmark point as numpy array [x, y]."""
        idx = LM_MAP[name]
        pts = self.std_landmarks if standardized else self.landmarks
        pt = pts[idx]
        if isinstance(pt, dict):
            return np.array([pt['x'], pt['y']])
        return np.array([pt.x, pt.y])

    def dist(self, p1_name: str, p2_name: str, standardized: bool = False) -> float:
        """Calculate distance in normalized units."""
        return np.linalg.norm(self.get_pt(p1_name, standardized) - self.get_pt(p2_name, standardized))

    def dist_mm(self, p1_name: str, p2_name: str, standardized: bool = False) -> float:
        """Calculate distance in real-world millimeters."""
        return self.dist(p1_name, p2_name, standardized) * self.mm_per_unit

    def angle_at_vertex(self, p1_name: str, vertex_name: str, p2_name: str, standardized: bool = False) -> float:
        """Calculate angle at vertex formed by p1-vertex-p2 in degrees."""
        p1 = self.get_pt(p1_name, standardized)
        vertex = self.get_pt(vertex_name, standardized)
        p2 = self.get_pt(p2_name, standardized)

        v1 = p1 - vertex
        v2 = p2 - vertex

        dot = np.dot(v1, v2)
        mag1 = np.linalg.norm(v1)
        mag2 = np.linalg.norm(v2)

        if mag1 == 0 or mag2 == 0:
            return 0.0

        cos_angle = np.clip(dot / (mag1 * mag2), -1.0, 1.0)
        return np.degrees(np.arccos(cos_angle))

    def angle_to_horizontal(self, p1_name: str, p2_name: str, standardized: bool = False) -> float:
        """Calculate angle of line p1->p2 relative to horizontal in degrees."""
        p1 = self.get_pt(p1_name, standardized)
        p2 = self.get_pt(p2_name, standardized)

        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]

        if dx == 0:
            return 90.0 if dy > 0 else -90.0

        return np.degrees(np.arctan2(dy, dx))

    def perpendicular_distance(self, point_name: str, line_p1_name: str, line_p2_name: str,
                                standardized: bool = False) -> float:
        """
        Calculate perpendicular distance from a point to a line defined by two points.
        Returns distance in normalized units (multiply by mm_per_unit for mm).
        Positive = point is to the right of line direction, Negative = left.
        """
        point = self.get_pt(point_name, standardized)
        p1 = self.get_pt(line_p1_name, standardized)
        p2 = self.get_pt(line_p2_name, standardized)

        # Line vector
        line_vec = p2 - p1
        line_len = np.linalg.norm(line_vec)

        if line_len == 0:
            return 0.0

        # Vector from p1 to point
        point_vec = point - p1

        # Cross product gives signed area of parallelogram
        # In 2D: cross = v1.x * v2.y - v1.y * v2.x
        cross = line_vec[0] * point_vec[1] - line_vec[1] * point_vec[0]

        # Perpendicular distance = cross / line_length
        return cross / line_len

    def horizontal_distance(self, p1_name: str, p2_name: str, standardized: bool = False) -> float:
        """Calculate horizontal (X-axis) distance between two points. Positive = p2 is right of p1."""
        p1 = self.get_pt(p1_name, standardized)
        p2 = self.get_pt(p2_name, standardized)
        return p2[0] - p1[0]

    def vertical_distance(self, p1_name: str, p2_name: str, standardized: bool = False) -> float:
        """Calculate vertical (Y-axis) distance between two points. Positive = p2 is below p1."""
        p1 = self.get_pt(p1_name, standardized)
        p2 = self.get_pt(p2_name, standardized)
        return p2[1] - p1[1]

    def _apply_frankfort_correction(self) -> List[MockLandmark]:
        """Apply Frankfort Plane correction to all landmarks."""
        porion_idx = LM_MAP["porion"]
        orbitale_idx = LM_MAP["orbitale"]

        porion = np.array([self.landmarks[porion_idx].x, self.landmarks[porion_idx].y])
        orbitale = np.array([self.landmarks[orbitale_idx].x, self.landmarks[orbitale_idx].y])

        dx = orbitale[0] - porion[0]
        dy = orbitale[1] - porion[1]
        current_angle = np.arctan2(dy, dx)

        cos_a = np.cos(-current_angle)
        sin_a = np.sin(-current_angle)

        corrected = []
        for lm in self.landmarks:
            px = lm.x - porion[0]
            py = lm.y - porion[1]

            new_x = px * cos_a - py * sin_a + porion[0]
            new_y = px * sin_a + py * cos_a + porion[1]

            corrected.append(MockLandmark(new_x, new_y, lm.z))

        return corrected

    def calculate_all(self) -> Dict[str, Dict[str, float]]:
        """Calculate all front and side profile metrics."""
        return {
            'front': self.calculate_front_metrics(),
            'side': self.calculate_side_metrics()
        }

    # =========================================================================
    # FRONT PROFILE METRICS (37 total)
    # =========================================================================

    def calculate_front_metrics(self) -> Dict[str, float]:
        """Calculate all front profile metrics matching ranges.json keys."""
        r = {}

        # Get key measurements for ratios
        face_width = self.dist("cheekbone_l", "cheekbone_r")
        jaw_width = self.dist("gonion_l", "gonion_r")

        trichion = self.get_pt("trichion")
        glabella = self.get_pt("glabella")
        nasion = self.get_pt("nasion")
        subnasale = self.get_pt("subnasale")
        upper_lip = self.get_pt("upper_lip")
        menton = self.get_pt("menton")

        # Face height measurements
        face_height_total = np.linalg.norm(trichion - menton)
        upper_third = np.linalg.norm(trichion - glabella)
        middle_third = np.linalg.norm(glabella - subnasale)
        lower_third = np.linalg.norm(subnasale - menton)

        # =====================================================================
        # 1. Face Width to Height Ratio (FWHR)
        # =====================================================================
        midface_height = np.linalg.norm(glabella - upper_lip)
        if midface_height > 0:
            r["Face Width to Height Ratio"] = face_width / midface_height

        # =====================================================================
        # 2. Cheekbone Height
        # =====================================================================
        # (Mean Y of Zygions - Mean Y of Gonions) / (Y of Trichion - Y of Menton) * 100
        zygion_l = self.get_pt("zygion_l")
        zygion_r = self.get_pt("zygion_r")
        gonion_l = self.get_pt("gonion_l")
        gonion_r = self.get_pt("gonion_r")

        mean_zygion_y = (zygion_l[1] + zygion_r[1]) / 2
        mean_gonion_y = (gonion_l[1] + gonion_r[1]) / 2

        if face_height_total > 0:
            cheekbone_height = ((mean_gonion_y - mean_zygion_y) / face_height_total) * 100
            r["Cheekbone Height"] = cheekbone_height

        # =====================================================================
        # 3. Jaw Slope
        # =====================================================================
        # Angle of line from gonion to menton relative to horizontal
        jaw_slope_l = abs(self.angle_to_horizontal("gonion_l", "menton"))
        jaw_slope_r = abs(self.angle_to_horizontal("gonion_r", "menton"))
        r["Jaw Slope"] = (jaw_slope_l + jaw_slope_r) / 2 + 90  # Convert to 90-180 scale

        # =====================================================================
        # 4. Total Facial Width to Height Ratio
        # =====================================================================
        if face_height_total > 0:
            r["Total Facial Width to Height Ratio"] = face_width / face_height_total

        # =====================================================================
        # 5. Nose Bridge to Nose Width
        # =====================================================================
        # Distance between inner canthi / nose width (ala to ala)
        inter_canthal = self.dist("endo_canthus_l", "endo_canthus_r")
        nose_width = self.dist("ala_l", "ala_r")
        if nose_width > 0:
            r["Nose Bridge to Nose Width"] = inter_canthal / nose_width

        # =====================================================================
        # 6. Mouth Width to Nose Width Ratio
        # =====================================================================
        mouth_width = self.dist("cheilion_l", "cheilion_r")
        if nose_width > 0:
            r["Mouth Width to Nose Width Ratio"] = mouth_width / nose_width

        # =====================================================================
        # 7. Midface Ratio
        # =====================================================================
        pupil_l = self.get_pt("pupil_l")
        pupil_r = self.get_pt("pupil_r")
        pupil_center = (pupil_l + pupil_r) / 2

        cheilion_l_pt = self.get_pt("cheilion_l")
        cheilion_r_pt = self.get_pt("cheilion_r")
        mouth_center = (cheilion_l_pt + cheilion_r_pt) / 2

        midface_dist = np.linalg.norm(pupil_center - mouth_center)
        if face_width > 0:
            r["Midface Ratio"] = midface_dist / face_width

        # =====================================================================
        # 8. Lower Third Proportion
        # =====================================================================
        if face_height_total > 0:
            r["Lower Third Proportion"] = (lower_third / face_height_total) * 100

        # =====================================================================
        # 9. Lateral Canthal Tilt
        # =====================================================================
        canthus_in_l = self.get_pt("canthus_in_l")
        canthus_out_l = self.get_pt("canthus_out_l")
        canthus_in_r = self.get_pt("canthus_in_r")
        canthus_out_r = self.get_pt("canthus_out_r")

        left_dx = abs(canthus_out_l[0] - canthus_in_l[0])
        left_dy = canthus_in_l[1] - canthus_out_l[1]
        left_tilt = np.degrees(np.arctan2(left_dy, left_dx))

        right_dx = abs(canthus_out_r[0] - canthus_in_r[0])
        right_dy = canthus_in_r[1] - canthus_out_r[1]
        right_tilt = np.degrees(np.arctan2(right_dy, right_dx))

        r["Lateral Canthal Tilt"] = (left_tilt + right_tilt) / 2

        # =====================================================================
        # 10. Ipsilateral Alar Angle
        # =====================================================================
        # Angle at nose tip between ala points
        r["Ipsilateral Alar Angle"] = self.angle_at_vertex("ala_l", "pronasale", "ala_r")

        # =====================================================================
        # 11. Jaw Frontal Angle
        # =====================================================================
        # Angle between Gonion_L -> Menton -> Gonion_R
        r["Jaw Frontal Angle"] = self.angle_at_vertex("gonion_l", "menton", "gonion_r")

        # =====================================================================
        # 12. Chin to Philtrum Ratio
        # =====================================================================
        # Distance(Labrale_Inf, Menton) / Distance(Subnasale, Labrale_Sup)
        chin_height = self.dist("labrale_inf", "menton")
        philtrum_height = self.dist("subnasale", "labrale_sup")
        if philtrum_height > 0:
            r["Chin to Philtrum Ratio"] = chin_height / philtrum_height

        # =====================================================================
        # 13. Eye Aspect Ratio
        # =====================================================================
        # Eye width / eye height (average of both eyes)
        eye_width_l = self.dist("canthus_in_l", "canthus_out_l")
        eye_height_l = self.dist("upper_eyelid_l", "lower_eyelid_l")
        eye_width_r = self.dist("canthus_in_r", "canthus_out_r")
        eye_height_r = self.dist("upper_eyelid_r", "lower_eyelid_r")

        if eye_height_l > 0 and eye_height_r > 0:
            ear_l = eye_width_l / eye_height_l
            ear_r = eye_width_r / eye_height_r
            r["Eye Aspect Ratio"] = (ear_l + ear_r) / 2

        # =====================================================================
        # 14. Bitemporal Width
        # =====================================================================
        # Distance(Temple L, R) / Distance(Zygion L, R) * 100
        temple_width = self.dist("temple_l", "temple_r")
        if face_width > 0:
            r["Bitemporal Width"] = (temple_width / face_width) * 100

        # =====================================================================
        # 15. Eyebrow Low Setedness
        # =====================================================================
        # Vertical distance from brow to eye relative to eye height
        brow_l = self.get_pt("brow_peak_l")
        brow_r = self.get_pt("brow_peak_r")
        upper_lid_l = self.get_pt("upper_eyelid_l")
        upper_lid_r = self.get_pt("upper_eyelid_r")

        brow_eye_dist_l = upper_lid_l[1] - brow_l[1]  # Positive = brow above eye
        brow_eye_dist_r = upper_lid_r[1] - brow_r[1]

        avg_eye_height = (eye_height_l + eye_height_r) / 2 if (eye_height_l + eye_height_r) > 0 else 1
        r["Eyebrow Low Setedness"] = ((brow_eye_dist_l + brow_eye_dist_r) / 2) / avg_eye_height

        # =====================================================================
        # 16. Eye Separation Ratio
        # =====================================================================
        # Inter-canthal distance / face width * 100
        if face_width > 0:
            r["Eye Separation Ratio"] = (inter_canthal / face_width) * 100

        # =====================================================================
        # 17. Neck Width
        # =====================================================================
        # Distance(Neck L, R) / Distance(Zygion L, R) * 100
        neck_width = self.dist("neck_l", "neck_r")
        if face_width > 0:
            r["Neck Width"] = (neck_width / face_width) * 100

        # =====================================================================
        # 18. Brow Length to Face Width Ratio
        # =====================================================================
        brow_inner_l = self.get_pt("brow_inner_l")
        brow_outer_l = self.get_pt("brow_outer_l")
        brow_inner_r = self.get_pt("brow_inner_r")
        brow_outer_r = self.get_pt("brow_outer_r")

        brow_length_l = np.linalg.norm(brow_outer_l - brow_inner_l)
        brow_length_r = np.linalg.norm(brow_outer_r - brow_inner_r)
        avg_brow_length = (brow_length_l + brow_length_r) / 2

        if face_width > 0:
            r["Brow Length to Face Width Ratio"] = avg_brow_length / face_width

        # =====================================================================
        # 19. Mouth Corner Position
        # =====================================================================
        # Vertical offset of mouth corners from lip center
        lip_center = self.get_pt("upper_lip")
        mouth_corner_y = (cheilion_l_pt[1] + cheilion_r_pt[1]) / 2
        r["Mouth Corner Position"] = (mouth_corner_y - lip_center[1]) * self.mm_per_unit

        # =====================================================================
        # 20. Cupid's Bow Depth
        # =====================================================================
        # Depth of cupid's bow relative to lip line
        cupid_l = self.get_pt("cupid_bow_l")
        cupid_r = self.get_pt("cupid_bow_r")
        cupid_center = self.get_pt("cupid_bow_center")

        cupid_peaks_y = (cupid_l[1] + cupid_r[1]) / 2
        cupid_depth = (cupid_center[1] - cupid_peaks_y) * self.mm_per_unit
        r["Cupid's Bow Depth"] = cupid_depth

        # =====================================================================
        # 21. Bigonial Width
        # =====================================================================
        # Jaw width as percentage of face width
        if face_width > 0:
            r["Bigonial Width"] = (jaw_width / face_width) * 100

        # =====================================================================
        # 22. Lower Lip to Upper Lip Ratio
        # =====================================================================
        upper_lip_height = self.dist("labrale_sup", "stomion")
        lower_lip_height = self.dist("stomion", "labrale_inf")
        if upper_lip_height > 0:
            r["Lower Lip to Upper Lip Ratio"] = lower_lip_height / upper_lip_height

        # =====================================================================
        # 23. Lower Third
        # =====================================================================
        if face_height_total > 0:
            r["Lower Third"] = (lower_third / face_height_total) * 100

        # =====================================================================
        # 24. Interpupillary-Mouth Width Ratio
        # =====================================================================
        ipd = self.dist("pupil_l", "pupil_r")
        if mouth_width > 0:
            r["Interpupillary-Mouth Width Ratio"] = ipd / mouth_width

        # =====================================================================
        # 25. Top Third
        # =====================================================================
        if face_height_total > 0:
            r["Top Third"] = (upper_third / face_height_total) * 100

        # =====================================================================
        # 26. One Eye Apart Test
        # =====================================================================
        # Inter-canthal distance should equal eye width
        avg_eye_width = (eye_width_l + eye_width_r) / 2
        if avg_eye_width > 0:
            r["One Eye Apart Test"] = inter_canthal / avg_eye_width

        # =====================================================================
        # 27. Deviation of IAA & JFA
        # =====================================================================
        # Difference between Ipsilateral Alar Angle and Jaw Frontal Angle
        iaa = r.get("Ipsilateral Alar Angle", 90)
        jfa = r.get("Jaw Frontal Angle", 90)
        r["Deviation of IAA & JFA"] = iaa - jfa

        # =====================================================================
        # 28. Middle Third
        # =====================================================================
        if face_height_total > 0:
            r["Middle Third"] = (middle_third / face_height_total) * 100

        # =====================================================================
        # 29. Eyebrow Tilt
        # =====================================================================
        # Angle of eyebrow from inner to outer
        brow_tilt_l = self.angle_to_horizontal("brow_inner_l", "brow_outer_l")
        brow_tilt_r = -self.angle_to_horizontal("brow_inner_r", "brow_outer_r")  # Mirror
        r["Eyebrow Tilt"] = (brow_tilt_l + brow_tilt_r) / 2

        # =====================================================================
        # 30. Intercanthal-Nasal Width Ratio
        # =====================================================================
        if nose_width > 0:
            r["Intercanthal-Nasal Width Ratio"] = inter_canthal / nose_width

        # =====================================================================
        # 31. Ear Protrusion Angle
        # =====================================================================
        # Angle of ear relative to head (approximated)
        ear_l = self.get_pt("ear_l")
        ear_r = self.get_pt("ear_r")
        cheek_l = self.get_pt("cheekbone_l")
        cheek_r = self.get_pt("cheekbone_r")

        # Calculate how far ears protrude past cheekbones
        ear_protrusion_l = cheek_l[0] - ear_l[0]  # Positive = ear is more lateral
        ear_protrusion_r = ear_r[0] - cheek_r[0]

        # Convert to angle approximation
        head_width = self.dist("ear_l", "ear_r")
        if head_width > 0:
            avg_protrusion = (ear_protrusion_l + ear_protrusion_r) / 2
            r["Ear Protrusion Angle"] = np.degrees(np.arctan2(avg_protrusion, head_width / 10))

        # =====================================================================
        # 32. Ear Protrusion Ratio
        # =====================================================================
        if face_width > 0:
            r["Ear Protrusion Ratio"] = ((ear_protrusion_l + ear_protrusion_r) / 2 / face_width) * 100

        # =====================================================================
        # 33. Nose Tip Position (Front - horizontal offset)
        # =====================================================================
        pronasale = self.get_pt("pronasale")
        nose_center_x = (self.get_pt("ala_l")[0] + self.get_pt("ala_r")[0]) / 2
        r["Nose Tip Position"] = (pronasale[0] - nose_center_x) * self.mm_per_unit

        return r

    # =========================================================================
    # SIDE PROFILE METRICS (33 total)
    # =========================================================================

    def calculate_side_metrics(self) -> Dict[str, float]:
        """Calculate all side profile metrics matching ranges.json keys."""
        r = {}

        # Get key points (all Frankfort-corrected)
        porion = self.get_pt("porion", standardized=True)
        orbitale = self.get_pt("orbitale", standardized=True)
        glabella = self.get_pt("glabella", standardized=True)
        nasion = self.get_pt("nasion", standardized=True)
        pronasale = self.get_pt("pronasale", standardized=True)
        subnasale = self.get_pt("subnasale", standardized=True)
        labrale_sup = self.get_pt("labrale_sup", standardized=True)
        labrale_inf = self.get_pt("labrale_inf", standardized=True)
        sublabiale = self.get_pt("sublabiale", standardized=True)
        pogonion = self.get_pt("pogonion", standardized=True)
        menton = self.get_pt("menton", standardized=True)
        gnathion = self.get_pt("gnathion", standardized=True)
        gonion = self.get_pt("gonion", standardized=True)
        condyle = self.get_pt("condyle", standardized=True)
        trichion = self.get_pt("trichion", standardized=True)

        # Face dimensions
        face_height = np.linalg.norm(trichion - menton)
        face_depth = abs(pogonion[0] - porion[0])

        # =====================================================================
        # 1. Recession Relative to Frankfort Plane
        # =====================================================================
        # Horizontal distance from Nasion to Pogonion (Positive = Chin behind Nasion)
        recession = (nasion[0] - pogonion[0]) * self.mm_per_unit
        r["Recession Relative to Frankfort Plane"] = recession

        # =====================================================================
        # 2. Facial Depth to Height Ratio
        # =====================================================================
        if face_height > 0:
            r["Facial Depth to Height Ratio"] = face_depth / face_height

        # =====================================================================
        # 3. Interior Midface Projection Angle
        # =====================================================================
        # Angle from Nasion to Subnasale to vertical
        midface_angle = self.angle_at_vertex("nasion", "subnasale", "pogonion", standardized=True)
        r["Interior Midface Projection Angle"] = midface_angle

        # =====================================================================
        # 4. Mandibular Plane Angle
        # =====================================================================
        r["Mandibular Plane Angle"] = abs(self.angle_to_horizontal("gonion", "menton", standardized=True))

        # =====================================================================
        # 5. Nasofrontal Angle
        # =====================================================================
        # Angle between Glabella -> Nasion -> Pronasale
        r["Nasofrontal Angle"] = self.angle_at_vertex("glabella", "nasion", "pronasale", standardized=True)

        # =====================================================================
        # 6. Gonion to Mouth Line
        # =====================================================================
        # Vertical distance from gonion to lip line (mm)
        lip_y = (labrale_sup[1] + labrale_inf[1]) / 2
        gonion_to_mouth = (lip_y - gonion[1]) * self.mm_per_unit
        r["Gonion to Mouth Line"] = gonion_to_mouth

        # =====================================================================
        # 7. Lower Lip S-Line Position
        # =====================================================================
        # S-Line: Subnasale to Pogonion
        # Distance from Lower Lip to this line
        s_line_dist = self.perpendicular_distance("labrale_inf", "subnasale", "pogonion", standardized=True)
        r["Lower Lip S-Line Position"] = s_line_dist * self.mm_per_unit

        # =====================================================================
        # 8. Z Angle
        # =====================================================================
        # Angle between Frankfort Plane and line from Pogonion to most protrusive lip
        # Frankfort is horizontal after correction, so measure angle of Pogonion->Labrale_Sup
        z_angle = 90 - abs(self.angle_to_horizontal("pogonion", "labrale_sup", standardized=True))
        r["Z Angle"] = z_angle + 90  # Convert to 0-180 scale

        # =====================================================================
        # 9. Nasomental Angle
        # =====================================================================
        r["Nasomental Angle"] = self.angle_at_vertex("nasion", "pronasale", "pogonion", standardized=True)

        # =====================================================================
        # 10. Submental Cervical Angle
        # =====================================================================
        # Angle at menton between chin line and neck line
        cervical = self.get_pt("cervical_point", standardized=True)
        r["Submental Cervical Angle"] = self.angle_at_vertex("pogonion", "menton", "cervical_point", standardized=True)

        # =====================================================================
        # 11. Nasofacial Angle
        # =====================================================================
        # Angle between nose dorsum and facial plane
        r["Nasofacial Angle"] = self.angle_at_vertex("pronasale", "nasion", "pogonion", standardized=True)

        # =====================================================================
        # 12. Holdaway H-Line
        # =====================================================================
        # H-Line: Labrale_Sup to Pogonion
        # Perpendicular distance from Nasion to this line (mm)
        h_line_dist = self.perpendicular_distance("nasion", "labrale_sup", "pogonion", standardized=True)
        r["Holdaway H Line"] = h_line_dist * self.mm_per_unit

        # =====================================================================
        # 13. Mentolabial Angle
        # =====================================================================
        # Angle between Labrale_Inf -> Sublabiale -> Pogonion
        r["Mentolabial Angle"] = self.angle_at_vertex("labrale_inf", "sublabiale", "pogonion", standardized=True)

        # =====================================================================
        # 14. Anterior Facial Depth
        # =====================================================================
        # Distance from Nasion to Pogonion (mm)
        r["Anterior Facial Depth"] = self.dist_mm("nasion", "pogonion", standardized=True)

        # =====================================================================
        # 15. Lower Lip E-Line Position
        # =====================================================================
        # E-Line: Pronasale to Pogonion
        e_line_lower = self.perpendicular_distance("labrale_inf", "pronasale", "pogonion", standardized=True)
        r["Lower Lip E-Line Position"] = e_line_lower * self.mm_per_unit

        # =====================================================================
        # 16. Gonial Angle
        # =====================================================================
        r["Gonial Angle"] = self.angle_at_vertex("condyle", "gonion", "menton", standardized=True)

        # =====================================================================
        # 17. Lower Lip Burstone Line
        # =====================================================================
        # Burstone Line: Subnasale to Pogonion (same as S-line)
        burstone_lower = self.perpendicular_distance("labrale_inf", "subnasale", "pogonion", standardized=True)
        r["Lower Lip Burstone Line"] = burstone_lower * self.mm_per_unit

        # =====================================================================
        # 18. Nose Tip Rotation Angle
        # =====================================================================
        # Angle of nose tip relative to nose bridge
        columella = self.get_pt("columella", standardized=True)
        nose_rotation = self.angle_at_vertex("nasion", "pronasale", "subnasale", standardized=True)
        r["Nose Tip Rotation Angle"] = nose_rotation - 90  # Normalize

        # =====================================================================
        # 19. Ramus to Mandible Ratio
        # =====================================================================
        ramus_length = self.dist("condyle", "gonion", standardized=True)
        mandible_length = self.dist("gonion", "menton", standardized=True)
        if mandible_length > 0:
            r["Ramus to Mandible Ratio"] = ramus_length / mandible_length

        # =====================================================================
        # 20. Orbital Vector
        # =====================================================================
        # Distance between cheekbone depth and eye depth
        pupil = self.get_pt("pupil_l", standardized=True)
        vector = (orbitale[0] - pupil[0]) * self.mm_per_unit
        r["Orbital Vector"] = vector

        # =====================================================================
        # 21. Facial Convexity (Glabella)
        # =====================================================================
        # Angle: Glabella -> Subnasale -> Pogonion
        r["Facial Convexity (Glabella)"] = self.angle_at_vertex("glabella", "subnasale", "pogonion", standardized=True)

        # =====================================================================
        # 22. Browridge Inclination Angle
        # =====================================================================
        # Angle of browridge relative to Frankfort horizontal
        brow = self.get_pt("brow_peak_l", standardized=True)
        browridge_angle = self.angle_to_horizontal("glabella", "brow_peak_l", standardized=True)
        r["Browridge Inclination Angle"] = abs(browridge_angle)

        # =====================================================================
        # 23. Nasal Tip Angle
        # =====================================================================
        # Angle at pronasale between nasion and subnasale
        r["Nasal Tip Angle"] = self.angle_at_vertex("nasion", "pronasale", "subnasale", standardized=True)

        # =====================================================================
        # 24. Nasal Projection
        # =====================================================================
        # Ratio of nose projection to nose length
        nose_length = self.dist_mm("nasion", "pronasale", standardized=True)
        nose_projection = abs(pronasale[0] - subnasale[0]) * self.mm_per_unit
        if nose_length > 0:
            r["Nasal Projection"] = nose_projection / nose_length

        # =====================================================================
        # 25. Frankfort-tip Angle
        # =====================================================================
        # Angle from Frankfort plane to nose tip
        frankfort_tip = abs(self.angle_to_horizontal("orbitale", "pronasale", standardized=True))
        r["Frankfort-tip Angle"] = frankfort_tip

        # =====================================================================
        # 26. Nasal W to H Ratio
        # =====================================================================
        # Nose width to height ratio (using side profile projection)
        nose_height = self.dist_mm("nasion", "subnasale", standardized=True)
        nose_width_mm = self.dist_mm("ala_l", "ala_r")
        if nose_height > 0:
            r["Nasal W to H Ratio"] = nose_width_mm / nose_height

        # =====================================================================
        # 27. Nasolabial Angle
        # =====================================================================
        columella_pt = (pronasale + subnasale) / 2
        v1 = columella_pt - subnasale
        v2 = labrale_sup - subnasale
        dot = np.dot(v1, v2)
        mag1 = np.linalg.norm(v1)
        mag2 = np.linalg.norm(v2)
        if mag1 > 0 and mag2 > 0:
            cos_angle = np.clip(dot / (mag1 * mag2), -1.0, 1.0)
            r["Nasolabial Angle"] = np.degrees(np.arccos(cos_angle))

        # =====================================================================
        # 28. Facial Convexity (Nasion)
        # =====================================================================
        # Angle: Nasion -> Subnasale -> Pogonion
        r["Facial Convexity (Nasion)"] = self.angle_at_vertex("nasion", "subnasale", "pogonion", standardized=True)

        # =====================================================================
        # 29. Total Facial Convexity
        # =====================================================================
        # Angle: Glabella -> Pronasale -> Pogonion
        r["Total Facial Convexity"] = self.angle_at_vertex("glabella", "pronasale", "pogonion", standardized=True)

        # =====================================================================
        # 30. Upper Lip E-Line Position
        # =====================================================================
        e_line_upper = self.perpendicular_distance("labrale_sup", "pronasale", "pogonion", standardized=True)
        r["Upper Lip E-Line Position"] = e_line_upper * self.mm_per_unit

        # =====================================================================
        # 31. Upper Lip S-Line Position
        # =====================================================================
        s_line_upper = self.perpendicular_distance("labrale_sup", "subnasale", "pogonion", standardized=True)
        r["Upper Lip S-Line Position"] = s_line_upper * self.mm_per_unit

        # =====================================================================
        # 32. Upper Lip Burstone Line
        # =====================================================================
        burstone_upper = self.perpendicular_distance("labrale_sup", "subnasale", "pogonion", standardized=True)
        r["Upper Lip Burstone Line"] = burstone_upper * self.mm_per_unit

        # =====================================================================
        # 33. Upper Forehead Slope
        # =====================================================================
        # Angle of forehead relative to vertical
        forehead_angle = 90 - abs(self.angle_to_horizontal("trichion", "glabella", standardized=True))
        r["Upper Forehead Slope"] = forehead_angle

        return r


# =============================================================================
# MOCK DATA GENERATOR
# =============================================================================

def generate_mock_landmarks() -> List[MockLandmark]:
    """
    Generate 478 mock landmarks roughly shaped like a human face.
    """
    landmarks = []

    for i in range(478):
        t = i / 478.0 * 2 * math.pi
        x = 0.5 + 0.3 * math.cos(t) * (1 + 0.1 * math.sin(3 * t))
        y = 0.5 + 0.4 * math.sin(t) * (1 + 0.1 * math.cos(2 * t))
        landmarks.append(MockLandmark(x, y, 0.0))

    # Override specific landmarks with anatomically correct positions
    # All coordinates are normalized [0, 1] where (0,0) is top-left

    # === HAIRLINE / FOREHEAD ===
    landmarks[10] = MockLandmark(0.5, 0.08, 0.0)    # trichion
    landmarks[151] = MockLandmark(0.5, 0.15, 0.0)   # forehead_center

    # === EYEBROWS ===
    landmarks[107] = MockLandmark(0.40, 0.28, 0.0)  # brow_inner_l
    landmarks[70] = MockLandmark(0.30, 0.26, 0.0)   # brow_outer_l
    landmarks[105] = MockLandmark(0.34, 0.25, 0.0)  # brow_peak_l
    landmarks[336] = MockLandmark(0.60, 0.28, 0.0)  # brow_inner_r
    landmarks[300] = MockLandmark(0.70, 0.26, 0.0)  # brow_outer_r
    landmarks[334] = MockLandmark(0.66, 0.25, 0.0)  # brow_peak_r

    # === EYES - LEFT ===
    landmarks[468] = MockLandmark(0.38, 0.38, 0.0)   # pupil_l
    landmarks[133] = MockLandmark(0.42, 0.385, 0.0)  # canthus_in_l
    landmarks[33] = MockLandmark(0.33, 0.375, 0.0)   # canthus_out_l
    landmarks[159] = MockLandmark(0.38, 0.36, 0.0)   # upper_eyelid_l
    landmarks[145] = MockLandmark(0.38, 0.40, 0.0)   # lower_eyelid_l

    # === EYES - RIGHT ===
    landmarks[473] = MockLandmark(0.62, 0.38, 0.0)   # pupil_r
    landmarks[362] = MockLandmark(0.58, 0.385, 0.0)  # canthus_in_r
    landmarks[263] = MockLandmark(0.67, 0.375, 0.0)  # canthus_out_r
    landmarks[386] = MockLandmark(0.62, 0.36, 0.0)   # upper_eyelid_r
    landmarks[374] = MockLandmark(0.62, 0.40, 0.0)   # lower_eyelid_r

    # === CHEEKBONES ===
    landmarks[123] = MockLandmark(0.22, 0.42, 0.0)   # zygion_l / cheekbone_l
    landmarks[352] = MockLandmark(0.78, 0.42, 0.0)   # zygion_r / cheekbone_r

    # === TEMPLES ===
    landmarks[21] = MockLandmark(0.18, 0.32, 0.0)    # temple_l
    landmarks[251] = MockLandmark(0.82, 0.32, 0.0)   # temple_r

    # === NOSE ===
    landmarks[168] = MockLandmark(0.50, 0.32, 0.0)   # glabella
    landmarks[6] = MockLandmark(0.50, 0.40, 0.0)     # nasion
    landmarks[1] = MockLandmark(0.56, 0.46, -0.08)   # pronasale
    landmarks[164] = MockLandmark(0.54, 0.50, -0.02) # subnasale
    landmarks[2] = MockLandmark(0.50, 0.48, 0.0)     # columella
    landmarks[102] = MockLandmark(0.46, 0.49, 0.0)   # ala_l
    landmarks[331] = MockLandmark(0.54, 0.49, 0.0)   # ala_r

    # === MOUTH / LIPS ===
    landmarks[0] = MockLandmark(0.50, 0.54, 0.0)     # labrale_sup / upper_lip
    landmarks[13] = MockLandmark(0.50, 0.57, 0.0)    # stomion
    landmarks[17] = MockLandmark(0.49, 0.60, 0.0)    # labrale_inf
    landmarks[18] = MockLandmark(0.50, 0.63, 0.0)    # sublabiale
    landmarks[61] = MockLandmark(0.42, 0.57, 0.0)    # cheilion_l
    landmarks[291] = MockLandmark(0.58, 0.57, 0.0)   # cheilion_r
    landmarks[37] = MockLandmark(0.47, 0.54, 0.0)    # cupid_bow_l
    landmarks[267] = MockLandmark(0.53, 0.54, 0.0)   # cupid_bow_r

    # === CHIN / JAW ===
    landmarks[152] = MockLandmark(0.50, 0.78, 0.0)   # pogonion / menton
    landmarks[175] = MockLandmark(0.50, 0.75, 0.0)   # gnathion
    landmarks[172] = MockLandmark(0.28, 0.68, 0.0)   # gonion_l
    landmarks[397] = MockLandmark(0.72, 0.68, 0.0)   # gonion_r
    landmarks[177] = MockLandmark(0.42, 0.76, 0.0)   # chin_l
    landmarks[401] = MockLandmark(0.58, 0.76, 0.0)   # chin_r

    # === EARS ===
    landmarks[234] = MockLandmark(0.12, 0.45, 0.0)   # ear_l
    landmarks[454] = MockLandmark(0.88, 0.45, 0.0)   # ear_r
    landmarks[127] = MockLandmark(0.14, 0.35, 0.0)   # ear_top_l
    landmarks[356] = MockLandmark(0.86, 0.35, 0.0)   # ear_top_r

    # === FRANKFORT PLANE ===
    landmarks[226] = MockLandmark(0.12, 0.40, 0.0)   # porion

    # === NECK ===
    landmarks[132] = MockLandmark(0.35, 0.82, 0.0)   # neck_l
    landmarks[361] = MockLandmark(0.65, 0.82, 0.0)   # neck_r

    return landmarks


# =============================================================================
# TEST HARNESS
# =============================================================================

def print_profile_table(title: str, metrics: Dict[str, float], ranges: Dict[str, List[float]]) -> Tuple[float, int]:
    """Print a formatted table for a profile (front or side)."""
    print(f"\n{'=' * 75}")
    print(f"  {title}")
    print(f"{'=' * 75}")
    print(f"{'Metric':<45} {'Value':>10} {'Range':>12} {'Score':>8}")
    print(f"{'-' * 75}")

    total_score = 0.0
    scored_count = 0
    missing_count = 0

    for metric_name, (min_val, max_val) in sorted(ranges.items()):
        if metric_name in metrics:
            value = metrics[metric_name]
            score = calculate_score(value, min_val, max_val)
            total_score += score
            scored_count += 1

            if abs(value) >= 10:
                value_str = f"{value:.1f}"
            else:
                value_str = f"{value:.2f}"

            if "Angle" in metric_name or "Tilt" in metric_name:
                value_str += ""

            range_str = f"[{min_val:.1f}, {max_val:.1f}]"
            score_str = f"{score:.1f}/10"

            print(f"{metric_name:<45} {value_str:>10} {range_str:>12} {score_str:>8}")
        else:
            missing_count += 1
            range_str = f"[{min_val:.1f}, {max_val:.1f}]"
            print(f"{metric_name:<45} {'N/A':>10} {range_str:>12} {'--':>8}")

    if scored_count > 0:
        avg_score = total_score / scored_count
        print(f"{'-' * 75}")
        print(f"{'AVERAGE SCORE':<45} {'':>10} {'':>12} {avg_score:.2f}/10")
        print(f"{'Metrics Calculated':<45} {scored_count:>10}")
        print(f"{'Metrics Missing':<45} {missing_count:>10}")

    print(f"{'=' * 75}")

    return total_score, scored_count


def main():
    """Main test harness for the looksmax engine."""
    print("\n" + "=" * 75)
    print("  LOOKSMAX ENGINE - Comprehensive Facial Analysis (66+ Metrics)")
    print("  Using ranges.json for ethnicity-specific scoring")
    print("=" * 75)

    # Configuration
    gender = "male"
    ethnicity = "caucasian"

    # [1] Load ranges.json
    print(f"\n[1] Loading ranges.json...")
    try:
        ranges = load_ranges()
        current_ranges = get_ranges_for_profile(ranges, gender, ethnicity)
        print(f"    Loaded ranges for: {gender} / {ethnicity}")
        print(f"    Front metrics defined: {len(current_ranges.get('front', {}))}")
        print(f"    Side metrics defined: {len(current_ranges.get('side', {}))}")
    except FileNotFoundError:
        print("    ERROR: ranges.json not found!")
        return

    # [2] Generate mock landmarks
    print(f"\n[2] Generating mock facial landmarks (478 points)...")
    landmarks = generate_mock_landmarks()
    print(f"    Created {len(landmarks)} landmarks")

    # [3] Calculate metrics using FacialCalculator
    print(f"\n[3] Calculating facial metrics...")
    calculator = FacialCalculator(landmarks)
    all_metrics = calculator.calculate_all()
    print(f"    Front metrics calculated: {len(all_metrics['front'])}")
    print(f"    Side metrics calculated: {len(all_metrics['side'])}")
    print(f"    IPD Scale Factor: {calculator.mm_per_unit:.2f} mm/unit")

    # [4] Print Front Profile Table
    print(f"\n[4] Scoring against {gender}/{ethnicity} ranges...")
    front_total, front_count = print_profile_table(
        "FRONT PROFILE ANALYSIS",
        all_metrics['front'],
        current_ranges.get('front', {})
    )

    # [5] Print Side Profile Table
    side_total, side_count = print_profile_table(
        "SIDE PROFILE ANALYSIS",
        all_metrics['side'],
        current_ranges.get('side', {})
    )

    # [6] Overall Summary
    total_count = front_count + side_count
    total_score = front_total + side_total

    print(f"\n{'=' * 75}")
    print("  OVERALL SUMMARY")
    print(f"{'=' * 75}")
    print(f"  Profile: {gender.upper()} / {ethnicity.upper()}")
    print(f"  Front metrics scored: {front_count}/{len(current_ranges.get('front', {}))}")
    print(f"  Side metrics scored: {side_count}/{len(current_ranges.get('side', {}))}")
    print(f"  Total metrics: {total_count}")
    if total_count > 0:
        overall_avg = total_score / total_count
        overall_pct = (total_score / (total_count * 10)) * 100
        print(f"  Average Score: {overall_avg:.2f} / 10")
        print(f"  Overall Rating: {overall_pct:.1f}%")
    print(f"{'=' * 75}\n")


if __name__ == "__main__":
    main()
