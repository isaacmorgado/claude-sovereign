/**
 * SPLICE Music Module
 * AI-powered music generation for video projects
 */

// ============================================
// STATE
// ============================================
const musicState = {
  jobs: [],
  selectedJob: null,
  isIdentifying: false,
  isGenerating: false,
  identifiedSong: null,
  audioPlayer: null,
  pollInterval: null,
  // Variations state
  variationsJob: null,
  variationsPollingInterval: null,
  selectedVariationIndex: null,
  variationPlayers: [null, null, null],  // Audio players for each variation
  // Scene-aware state
  sceneAwareEnabled: false,
  // Alignment state
  isAligning: false,
  alignmentOptions: null,
  beatAnalysis: null,
  // Timeline state
  isGeneratingTimeline: false,
  timelineOptions: null
};

// ============================================
// CONSTANTS
// ============================================
const MUSIC_POLL_INTERVAL = 5000; // 5 seconds

const MOOD_OPTIONS = [
  { id: 'energetic', name: 'Energetic', description: 'Upbeat, high energy' },
  { id: 'relaxed', name: 'Relaxed', description: 'Calm, peaceful' },
  { id: 'melancholic', name: 'Melancholic', description: 'Sad, emotional' },
  { id: 'intense', name: 'Intense', description: 'Powerful, dramatic' },
  { id: 'happy', name: 'Happy', description: 'Joyful, cheerful' },
  { id: 'mysterious', name: 'Mysterious', description: 'Dark, suspenseful' },
  { id: 'romantic', name: 'Romantic', description: 'Warm, intimate' },
  { id: 'epic', name: 'Epic', description: 'Grand, orchestral' },
  { id: 'chill', name: 'Chill', description: 'Lo-fi, laid-back' },
  { id: 'neutral', name: 'Neutral', description: 'Balanced, versatile' }
];

const INSTRUMENT_OPTIONS = [
  { id: 'acoustic', name: 'Acoustic', description: 'Guitar, piano, strings' },
  { id: 'electronic', name: 'Electronic', description: 'Synths, beats' },
  { id: 'rock', name: 'Rock', description: 'Electric guitars, drums' },
  { id: 'orchestral', name: 'Orchestral', description: 'Strings, brass, woodwinds' },
  { id: 'minimal', name: 'Minimal', description: 'Piano, ambient' },
  { id: 'hiphop', name: 'Hip-Hop', description: '808s, trap drums' }
];

const DURATION_OPTIONS = [
  { value: 30, label: '30 seconds' },
  { value: 60, label: '1 minute' },
  { value: 90, label: '1.5 minutes' },
  { value: 120, label: '2 minutes' },
  { value: 180, label: '3 minutes' }
];

// ============================================
// API FUNCTIONS
// ============================================

/**
 * Identify song from YouTube URL
 * @param {string} youtubeUrl - YouTube URL
 * @returns {Promise<Object>} Identification result
 */
async function identifySong(youtubeUrl) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/identify`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ youtubeUrl })
  }, 90000); // 90 second timeout for identification

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to identify song');
  }

  return response.json();
}

/**
 * Generate music
 * @param {Object} options - Generation options
 * @returns {Promise<Object>} Job info
 */
async function generateMusicRequest(options) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(options)
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start music generation');
  }

  return response.json();
}

/**
 * Get job status
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Job status
 */
async function getJobStatus(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/status/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get job status');
  }

  return response.json();
}

/**
 * Get user's music library
 * @returns {Promise<Object[]>} Array of music items
 */
async function getMusicLibrary() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/library`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to load music library');
  }

  return response.json();
}

/**
 * Get music file with download URL
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Music info with signed URL
 */
async function getMusicFile(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get music file');
  }

  return response.json();
}

/**
 * Delete music from library
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Result
 */
async function deleteMusicFile(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
    method: 'DELETE',
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to delete music');
  }

  return response.json();
}

/**
 * Get music credits balance
 * @returns {Promise<Object>} Credits info
 */
async function getMusicCredits() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/credits`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    return { remaining: 0, total: 0 };
  }

  return response.json();
}

// ============================================
// VARIATIONS API FUNCTIONS
// ============================================

/**
 * Generate 3 music variations
 * @param {Object} options - Generation options
 * @returns {Promise<Object>} Job info
 */
async function generateVariationsRequest(options) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-variations`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(options)
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start variations generation');
  }

  return response.json();
}

/**
 * Get variations job status
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Job status with variations
 */
async function getVariationsStatus(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/variations/status/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get variations status');
  }

  return response.json();
}

/**
 * Select a variation from the generated options
 * @param {string} jobId - Job ID
 * @param {number} variationIndex - Index of variation to select (0-2)
 * @returns {Promise<Object>} Selection result
 */
async function selectVariation(jobId, variationIndex) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/variations/${jobId}/select`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ variationIndex })
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to select variation');
  }

  return response.json();
}

// ============================================
// SCENE-AWARE API FUNCTIONS
// ============================================

/**
 * Generate scene-aware music using transcript analysis
 * @param {Object} options - Generation options
 * @param {Object[]} segments - Transcript segments
 * @returns {Promise<Object>} Job info
 */
async function generateSceneAwareRequest(options, segments) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-scene-aware`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      ...options,
      segments
    })
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start scene-aware music generation');
  }

  return response.json();
}

/**
 * Get transcript segments from the current session
 * @returns {Object[]|null} Transcript segments or null if not available
 */
function getCurrentTranscriptSegments() {
  // Check if transcript is available from main workflow
  if (window.currentTranscript && window.currentTranscript.segments) {
    return window.currentTranscript.segments;
  }
  return null;
}

// ============================================
// ALIGNMENT API FUNCTIONS
// ============================================

/**
 * Align music to video duration with beat-matching
 * @param {string} jobId - Job ID
 * @param {number} targetDuration - Target duration in seconds
 * @param {Object} options - Alignment options
 * @returns {Promise<Object>} Alignment result
 */
async function alignMusicRequest(jobId, targetDuration, options = {}) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/align`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      jobId,
      targetDuration,
      fadeDuration: options.fadeDuration,
      beatAlign: options.beatAlign !== false,
      searchWindow: options.searchWindow
    })
  }, 120000); // 2 minute timeout

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to align music');
  }

  return response.json();
}

/**
 * Analyze beats in music without trimming
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Beat analysis
 */
async function analyzeBeatsRequest(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/analyze-beats`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ jobId })
  }, 60000); // 1 minute timeout

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to analyze beats');
  }

  return response.json();
}

/**
 * Get alignment configuration options
 * @returns {Promise<Object>} Alignment options
 */
async function getAlignmentOptions() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/alignment-options`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    return {
      fadeDuration: { default: 2, min: 0.5, max: 5 },
      searchWindow: { default: 3, min: 0.5, max: 10 },
      minAudioDuration: 5
    };
  }

  return response.json();
}

// ============================================
// TIMELINE API FUNCTIONS
// ============================================

/**
 * Generate timeline music with per-chapter mood matching
 * @param {Object} transcript - Full transcript with segments
 * @param {Object} options - Generation options
 * @returns {Promise<Object>} Timeline generation result
 */
async function generateTimelineRequest(transcript, options = {}) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-timeline`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      transcript,
      maxChapters: options.maxChapters || 10,
      minChapterLength: options.minChapterLength || 60,
      crossfadeDuration: options.crossfadeDuration || 2,
      instruments: options.instruments || [],
      prompt: options.prompt || ''
    })
  }, 600000); // 10 minute timeout for timeline generation

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to generate timeline music');
  }

  return response.json();
}

/**
 * Get timeline generation options
 * @returns {Promise<Object>} Timeline options
 */
async function getTimelineOptions() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/timeline-options`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    return {
      defaults: {
        maxChapters: 10,
        minChapterLength: 60,
        crossfadeDuration: 2
      },
      constraints: {
        minCrossfadeDuration: 0.5,
        maxCrossfadeDuration: 5
      }
    };
  }

  return response.json();
}

/**
 * Estimate timeline generation time
 * @param {Object} transcript - Transcript with duration
 * @param {Object} options - Options
 * @returns {Promise<Object>} Estimate
 */
async function estimateTimelineRequest(transcript, options = {}) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/timeline-estimate`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      transcript,
      maxChapters: options.maxChapters,
      minChapterLength: options.minChapterLength
    })
  });

  if (!response.ok) {
    return {
      estimatedChapters: 3,
      estimatedMinutes: 12,
      estimatedTimeDisplay: '10-15 minutes'
    };
  }

  return response.json();
}

/**
 * Get current transcript from main workflow
 * @returns {Object|null} Full transcript object or null
 */
function getCurrentTranscript() {
  // Check if full transcript is available from main workflow
  if (window.currentTranscript) {
    return window.currentTranscript;
  }
  return null;
}

/**
 * Get current sequence duration from Premiere Pro
 * @returns {Promise<number|null>} Duration in seconds or null
 */
async function getSequenceDuration() {
  try {
    const pproBuilder = require('premierepro').pproBuilder;
    const sequence = await pproBuilder.Sequence.getActiveSequence();
    if (sequence) {
      const duration = await sequence.getOutPoint();
      return duration.seconds || null;
    }
  } catch (error) {
    console.error('Could not get sequence duration:', error);
  }
  return null;
}

// ============================================
// UI FUNCTIONS
// ============================================

/**
 * Initialize music module
 */
function initMusicModule() {
  // Set up event listeners
  setupMusicEventListeners();

  // Populate dropdowns
  populateMoodDropdown();
  populateInstrumentDropdown();
  populateDurationDropdown();

  // Load library on init
  loadMusicLibrary();

  // Update credits display
  updateMusicCreditsDisplay();
}

/**
 * Set up event listeners for music UI
 */
function setupMusicEventListeners() {
  // YouTube URL input
  const urlInput = document.getElementById('musicYoutubeUrl');
  if (urlInput) {
    urlInput.addEventListener('input', debounce(handleYoutubeUrlChange, 500));
  }

  // Identify button
  const identifyBtn = document.getElementById('musicIdentifyBtn');
  if (identifyBtn) {
    identifyBtn.addEventListener('click', handleIdentifySong);
  }

  // Generate button
  const generateBtn = document.getElementById('musicGenerateBtn');
  if (generateBtn) {
    generateBtn.addEventListener('click', handleGenerateMusic);
  }

  // Generate Variations button
  const variationsBtn = document.getElementById('musicGenerateVariationsBtn');
  if (variationsBtn) {
    variationsBtn.addEventListener('click', handleGenerateVariations);
  }

  // Scene-aware toggle
  const sceneAwareToggle = document.getElementById('musicSceneAwareToggle');
  if (sceneAwareToggle) {
    sceneAwareToggle.addEventListener('change', handleSceneAwareToggle);
  }

  // Clear reference button
  const clearRefBtn = document.getElementById('musicClearRefBtn');
  if (clearRefBtn) {
    clearRefBtn.addEventListener('click', handleClearReference);
  }

  // Library refresh
  const refreshBtn = document.getElementById('musicRefreshLibraryBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', loadMusicLibrary);
  }

  // Timeline generation button
  const timelineBtn = document.getElementById('musicGenerateTimelineBtn');
  if (timelineBtn) {
    timelineBtn.addEventListener('click', showTimelineModal);
  }

  // Update scene-aware availability on init
  updateSceneAwareAvailability();

  // Update timeline availability on init
  updateTimelineAvailability();
}

/**
 * Handle scene-aware toggle change
 */
function handleSceneAwareToggle() {
  const toggle = document.getElementById('musicSceneAwareToggle');
  musicState.sceneAwareEnabled = toggle?.checked || false;

  // Show/hide the scene-aware indicator
  const indicator = document.getElementById('sceneAwareIndicator');
  if (indicator) {
    indicator.style.display = musicState.sceneAwareEnabled ? 'block' : 'none';
  }

  // Update status
  if (musicState.sceneAwareEnabled) {
    const segments = getCurrentTranscriptSegments();
    if (segments) {
      setMusicStatus(`Scene-aware enabled: ${segments.length} segments detected`, 'info');
    } else {
      setMusicStatus('Scene-aware enabled: Run transcription first for best results', 'warning');
    }
  }
}

/**
 * Update scene-aware toggle availability based on transcript presence
 */
function updateSceneAwareAvailability() {
  const toggle = document.getElementById('musicSceneAwareToggle');
  const segments = getCurrentTranscriptSegments();

  if (toggle) {
    // Enable toggle if transcript is available
    toggle.disabled = !segments;

    // Update label to show availability
    const label = toggle.closest('label') || toggle.parentElement;
    if (label) {
      const statusSpan = label.querySelector('.scene-aware-status');
      if (statusSpan) {
        statusSpan.textContent = segments
          ? `(${segments.length} segments available)`
          : '(run transcription first)';
      }
    }
  }
}

/**
 * Populate mood dropdown
 */
function populateMoodDropdown() {
  const select = document.getElementById('musicMood');
  if (!select) return;

  select.innerHTML = MOOD_OPTIONS.map(mood =>
    `<option value="${mood.id}" title="${mood.description}">${mood.name}</option>`
  ).join('');
}

/**
 * Populate instrument dropdown
 */
function populateInstrumentDropdown() {
  const select = document.getElementById('musicInstruments');
  if (!select) return;

  select.innerHTML = INSTRUMENT_OPTIONS.map(inst =>
    `<option value="${inst.id}" title="${inst.description}">${inst.name}</option>`
  ).join('');
}

/**
 * Populate duration dropdown
 */
function populateDurationDropdown() {
  const select = document.getElementById('musicDuration');
  if (!select) return;

  select.innerHTML = DURATION_OPTIONS.map(dur =>
    `<option value="${dur.value}">${dur.label}</option>`
  ).join('');

  // Default to 60 seconds
  select.value = '60';
}

/**
 * Handle YouTube URL change
 */
function handleYoutubeUrlChange() {
  const urlInput = document.getElementById('musicYoutubeUrl');
  const identifyBtn = document.getElementById('musicIdentifyBtn');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  const isValidUrl = isValidYouTubeUrl(url);

  identifyBtn.disabled = !isValidUrl;

  // Clear previous identification if URL changed
  if (musicState.identifiedSong) {
    handleClearReference();
  }
}

/**
 * Validate YouTube URL
 * @param {string} url - URL to validate
 * @returns {boolean} Is valid
 */
function isValidYouTubeUrl(url) {
  if (!url) return false;
  const patterns = [
    /youtube\.com\/watch\?v=[\w-]{11}/,
    /youtu\.be\/[\w-]{11}/,
    /youtube\.com\/embed\/[\w-]{11}/
  ];
  return patterns.some(p => p.test(url));
}

/**
 * Handle identify song button click
 */
async function handleIdentifySong() {
  const urlInput = document.getElementById('musicYoutubeUrl');
  const identifyBtn = document.getElementById('musicIdentifyBtn');
  const refDisplay = document.getElementById('musicReferenceDisplay');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  if (!isValidYouTubeUrl(url)) {
    setMusicStatus('Invalid YouTube URL', 'error');
    return;
  }

  try {
    musicState.isIdentifying = true;
    identifyBtn.disabled = true;
    identifyBtn.textContent = 'Identifying...';
    setMusicStatus('Identifying song...', 'info');

    const result = await identifySong(url);

    if (result.identified) {
      musicState.identifiedSong = result;
      displayIdentifiedSong(result);
      setMusicStatus(`Identified: ${result.title} by ${result.artist}`, 'success');
    } else {
      setMusicStatus('Could not identify song. You can still generate music.', 'warning');
    }

  } catch (error) {
    console.error('Identification error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isIdentifying = false;
    identifyBtn.disabled = false;
    identifyBtn.textContent = 'Identify';
  }
}

/**
 * Display identified song info
 * @param {Object} song - Song info
 */
function displayIdentifiedSong(song) {
  const display = document.getElementById('musicReferenceDisplay');
  if (!display) return;

  const details = [];
  if (song.bpm) details.push(`${song.bpm} BPM`);
  if (song.key) details.push(song.key);
  if (song.mood) details.push(song.mood);

  display.innerHTML = `
    <div class="music-reference-card">
      <div class="music-ref-title">${escapeHtml(song.title)}</div>
      <div class="music-ref-artist">${escapeHtml(song.artist)}</div>
      <div class="music-ref-details">${details.join(' â€¢ ')}</div>
      <button id="musicClearRefBtn" class="music-clear-ref-btn" title="Clear reference">Ã—</button>
    </div>
  `;

  display.style.display = 'block';

  // Re-attach clear button listener
  const clearBtn = document.getElementById('musicClearRefBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', handleClearReference);
  }
}

/**
 * Clear reference song
 */
function handleClearReference() {
  musicState.identifiedSong = null;

  const display = document.getElementById('musicReferenceDisplay');
  if (display) {
    display.innerHTML = '';
    display.style.display = 'none';
  }

  const urlInput = document.getElementById('musicYoutubeUrl');
  if (urlInput) {
    urlInput.value = '';
  }

  const identifyBtn = document.getElementById('musicIdentifyBtn');
  if (identifyBtn) {
    identifyBtn.disabled = true;
  }
}

/**
 * Handle generate music button click
 */
async function handleGenerateMusic() {
  const generateBtn = document.getElementById('musicGenerateBtn');
  const moodSelect = document.getElementById('musicMood');
  const instrumentSelect = document.getElementById('musicInstruments');
  const durationSelect = document.getElementById('musicDuration');
  const promptInput = document.getElementById('musicPrompt');

  if (!generateBtn) return;

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';

    const options = {
      mood: moodSelect?.value || 'neutral',
      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
      duration: parseInt(durationSelect?.value) || 60,
      prompt: promptInput?.value || '',
      youtubeUrl: musicState.identifiedSong?.sourceUrl || null,
      referenceSong: musicState.identifiedSong || null
    };

    let result;

    // Check if scene-aware is enabled and transcript is available
    if (musicState.sceneAwareEnabled) {
      const segments = getCurrentTranscriptSegments();
      if (segments && segments.length > 0) {
        setMusicStatus('Analyzing transcript and generating scene-aware music...', 'info');
        result = await generateSceneAwareRequest(options, segments);
        setMusicStatus(`Scene-aware generation started! Job ID: ${result.jobId}`, 'success');
      } else {
        // Fallback to regular generation if no transcript
        setMusicStatus('No transcript available, using regular generation...', 'warning');
        result = await generateMusicRequest(options);
        setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
      }
    } else {
      setMusicStatus('Submitting generation request...', 'info');
      result = await generateMusicRequest(options);
      setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
    }

    // Add to jobs list and start polling
    addJobToList(result.jobId, options, result.isSceneAware);
    startPollingJob(result.jobId);

    // Clear form
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Generation error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate Music';
  }
}

/**
 * Handle generate variations button click
 */
async function handleGenerateVariations() {
  const generateBtn = document.getElementById('musicGenerateVariationsBtn');
  const moodSelect = document.getElementById('musicMood');
  const instrumentSelect = document.getElementById('musicInstruments');
  const durationSelect = document.getElementById('musicDuration');
  const promptInput = document.getElementById('musicPrompt');

  if (!generateBtn) return;

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';
    setMusicStatus('Generating 3 variations... This may take 5-8 minutes.', 'info');

    const options = {
      mood: moodSelect?.value || 'neutral',
      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
      duration: parseInt(durationSelect?.value) || 60,
      prompt: promptInput?.value || '',
      referenceSong: musicState.identifiedSong || null
    };

    const result = await generateVariationsRequest(options);

    setMusicStatus(`Variations generation started! Job ID: ${result.jobId}`, 'success');

    // Store variations job and start polling
    musicState.variationsJob = {
      jobId: result.jobId,
      status: 'pending',
      options
    };

    startPollingVariations(result.jobId);

    // Show variations panel
    showVariationsPanel();

    // Clear form
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Variations error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate 3 Variations';
  }
}

/**
 * Start polling for variations job completion
 * @param {string} jobId - Job ID
 */
function startPollingVariations(jobId) {
  // Clear any existing poll
  if (musicState.variationsPollingInterval) {
    clearInterval(musicState.variationsPollingInterval);
  }

  musicState.variationsPollingInterval = setInterval(async () => {
    try {
      const status = await getVariationsStatus(jobId);

      // Update variations job state
      musicState.variationsJob = {
        ...musicState.variationsJob,
        ...status
      };

      // Update UI
      renderVariationsProgress(status);

      // Check if ready for selection or failed
      if (status.status === 'selecting' || status.status === 'completed') {
        clearInterval(musicState.variationsPollingInterval);
        musicState.variationsPollingInterval = null;

        if (status.variations && status.variations.length > 0) {
          setMusicStatus('Variations ready! Select your favorite.', 'success');
          renderVariationsSelection(status.variations);
        }
      } else if (status.status === 'failed') {
        clearInterval(musicState.variationsPollingInterval);
        musicState.variationsPollingInterval = null;
        setMusicStatus(`Variations failed: ${status.failedReason || 'Unknown error'}`, 'error');
      }

    } catch (error) {
      console.error('Variations polling error:', error);
    }
  }, MUSIC_POLL_INTERVAL);
}

/**
 * Show variations panel
 */
function showVariationsPanel() {
  const panel = document.getElementById('variationsPanel');
  if (panel) {
    panel.style.display = 'block';
    panel.innerHTML = `
      <div class="variations-header">
        <h4>Generating 3 Variations</h4>
        <button id="variationsCancelBtn" class="variations-cancel-btn" title="Cancel">Ã—</button>
      </div>
      <div class="variations-progress">
        <div class="variation-progress-item" data-index="0">
          <span class="variation-name">Version A</span>
          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
          <span class="progress-text">0%</span>
        </div>
        <div class="variation-progress-item" data-index="1">
          <span class="variation-name">Version B</span>
          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
          <span class="progress-text">0%</span>
        </div>
        <div class="variation-progress-item" data-index="2">
          <span class="variation-name">Version C</span>
          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
          <span class="progress-text">0%</span>
        </div>
      </div>
      <div id="variationsSelection" class="variations-selection" style="display: none;"></div>
    `;

    // Add cancel button listener
    const cancelBtn = document.getElementById('variationsCancelBtn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', hideVariationsPanel);
    }
  }
}

/**
 * Hide variations panel
 */
function hideVariationsPanel() {
  const panel = document.getElementById('variationsPanel');
  if (panel) {
    panel.style.display = 'none';
    panel.innerHTML = '';
  }

  // Stop polling
  if (musicState.variationsPollingInterval) {
    clearInterval(musicState.variationsPollingInterval);
    musicState.variationsPollingInterval = null;
  }

  // Stop all variation audio players
  musicState.variationPlayers.forEach(player => {
    if (player) {
      player.pause();
      player.src = '';
    }
  });
  musicState.variationPlayers = [null, null, null];
  musicState.variationsJob = null;
  musicState.selectedVariationIndex = null;
}

/**
 * Render variations progress
 * @param {Object} status - Variations job status
 */
function renderVariationsProgress(status) {
  const progressItems = document.querySelectorAll('.variation-progress-item');
  const variationProgress = status.variationProgress || [0, 0, 0];

  progressItems.forEach((item, index) => {
    const progress = variationProgress[index] || 0;
    const fill = item.querySelector('.progress-fill');
    const text = item.querySelector('.progress-text');

    if (fill) {
      fill.style.width = `${progress}%`;
    }
    if (text) {
      text.textContent = `${progress}%`;
    }

    // Add completed class if done
    if (progress >= 100) {
      item.classList.add('completed');
    }
  });
}

/**
 * Render variations selection UI with 3 audio previews
 * @param {Object[]} variations - Array of variation objects
 */
function renderVariationsSelection(variations) {
  const container = document.getElementById('variationsSelection');
  if (!container) return;

  // Hide progress, show selection
  const progressContainer = document.querySelector('.variations-progress');
  if (progressContainer) {
    progressContainer.style.display = 'none';
  }

  container.style.display = 'block';
  container.innerHTML = `
    <div class="variations-header">
      <h4>Select Your Favorite</h4>
      <p class="variations-subtitle">Preview each variation and choose one to keep</p>
    </div>
    <div class="variations-cards">
      ${variations.map((v, index) => `
        <div class="variation-card ${v.status === 'failed' ? 'failed' : ''}"
             data-index="${index}"
             ${v.status === 'failed' ? 'data-failed="true"' : ''}>
          <div class="variation-card-header">
            <span class="variation-name">${escapeHtml(v.variationName)}</span>
            ${v.status === 'failed' ? '<span class="failed-badge">Failed</span>' : ''}
          </div>
          ${v.promptDescription ? `<div class="variation-description">${escapeHtml(v.promptDescription)}</div>` : ''}
          ${v.status !== 'failed' ? `
            <div class="variation-player" data-index="${index}">
              <button class="play-btn" data-action="play" data-index="${index}" data-url="${v.previewUrl || ''}">
                â–¶
              </button>
              <div class="waveform-placeholder"></div>
              <span class="duration">${v.duration ? `${v.duration}s` : '--'}</span>
            </div>
            <button class="select-variation-btn" data-index="${index}">
              Select This Version
            </button>
          ` : `
            <div class="variation-error">${escapeHtml(v.error || 'Generation failed')}</div>
          `}
        </div>
      `).join('')}
    </div>
  `;

  // Add event listeners for play buttons
  container.querySelectorAll('.play-btn').forEach(btn => {
    btn.addEventListener('click', handleVariationPlay);
  });

  // Add event listeners for select buttons
  container.querySelectorAll('.select-variation-btn').forEach(btn => {
    btn.addEventListener('click', handleVariationSelect);
  });
}

/**
 * Handle variation play button click
 * @param {Event} event - Click event
 */
async function handleVariationPlay(event) {
  const btn = event.target;
  const index = parseInt(btn.dataset.index);
  const url = btn.dataset.url;

  if (!url) {
    setMusicStatus('No preview available', 'warning');
    return;
  }

  // Stop all other variation players
  musicState.variationPlayers.forEach((player, i) => {
    if (player && i !== index) {
      player.pause();
      const otherBtn = document.querySelector(`.play-btn[data-index="${i}"]`);
      if (otherBtn) otherBtn.textContent = 'â–¶';
    }
  });

  // Create or get player for this variation
  if (!musicState.variationPlayers[index]) {
    musicState.variationPlayers[index] = new Audio();
    musicState.variationPlayers[index].addEventListener('ended', () => {
      btn.textContent = 'â–¶';
    });
  }

  const player = musicState.variationPlayers[index];

  if (player.paused || player.src !== url) {
    player.src = url;
    try {
      await player.play();
      btn.textContent = 'â¸';
    } catch (error) {
      console.error('Play error:', error);
      setMusicStatus('Could not play preview', 'error');
    }
  } else {
    player.pause();
    btn.textContent = 'â–¶';
  }
}

/**
 * Handle variation selection
 * @param {Event} event - Click event
 */
async function handleVariationSelect(event) {
  const btn = event.target;
  const index = parseInt(btn.dataset.index);
  const jobId = musicState.variationsJob?.jobId;

  if (!jobId) {
    setMusicStatus('No variations job found', 'error');
    return;
  }

  try {
    // Disable all select buttons
    document.querySelectorAll('.select-variation-btn').forEach(b => {
      b.disabled = true;
    });
    btn.textContent = 'Selecting...';

    setMusicStatus('Finalizing your selection...', 'info');

    const result = await selectVariation(jobId, index);

    setMusicStatus(`Selected ${result.variationName}! Music added to library.`, 'success');

    // Stop all players
    musicState.variationPlayers.forEach(player => {
      if (player) player.pause();
    });

    // Hide panel and refresh library
    hideVariationsPanel();
    loadMusicLibrary();
    updateMusicCreditsDisplay();

  } catch (error) {
    console.error('Selection error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');

    // Re-enable buttons
    document.querySelectorAll('.select-variation-btn').forEach(b => {
      b.disabled = false;
    });
    btn.textContent = 'Select This Version';
  }
}

/**
 * Add job to the jobs list
 * @param {string} jobId - Job ID
 * @param {Object} options - Job options
 * @param {boolean} isSceneAware - Whether this is a scene-aware job
 */
function addJobToList(jobId, options, isSceneAware = false) {
  const job = {
    jobId,
    status: 'pending',
    progress: 0,
    mood: options.mood,
    duration: options.duration,
    isSceneAware,
    createdAt: new Date().toISOString()
  };

  musicState.jobs.unshift(job);
  renderJobsList();
}

/**
 * Start polling for job completion
 * @param {string} jobId - Job ID
 */
function startPollingJob(jobId) {
  // Clear any existing poll
  if (musicState.pollInterval) {
    clearInterval(musicState.pollInterval);
  }

  musicState.pollInterval = setInterval(async () => {
    try {
      const status = await getJobStatus(jobId);

      // Update job in list
      const jobIndex = musicState.jobs.findIndex(j => j.jobId === jobId);
      if (jobIndex !== -1) {
        musicState.jobs[jobIndex] = {
          ...musicState.jobs[jobIndex],
          ...status
        };
        renderJobsList();
      }

      // Check if complete or failed
      if (status.status === 'completed' || status.status === 'failed') {
        clearInterval(musicState.pollInterval);
        musicState.pollInterval = null;

        if (status.status === 'completed') {
          setMusicStatus('Music generation completed!', 'success');
          loadMusicLibrary(); // Refresh library
        } else {
          setMusicStatus(`Generation failed: ${status.failedReason || 'Unknown error'}`, 'error');
        }
      }

    } catch (error) {
      console.error('Polling error:', error);
    }
  }, MUSIC_POLL_INTERVAL);
}

/**
 * Render jobs list UI
 */
function renderJobsList() {
  const container = document.getElementById('musicJobsList');
  if (!container) return;

  if (musicState.jobs.length === 0) {
    container.innerHTML = '<div class="music-empty">No generation jobs yet</div>';
    return;
  }

  container.innerHTML = musicState.jobs.map(job => `
    <div class="music-job-item ${job.status}" data-job-id="${job.jobId}">
      <div class="music-job-status ${job.status}"></div>
      <div class="music-job-info">
        <span class="music-job-mood">${job.mood || 'Music'}${job.isSceneAware ? ' ðŸŽ¬' : ''}</span>
        <span class="music-job-duration">${job.duration}s</span>
      </div>
      <div class="music-job-progress">
        ${job.status === 'completed' ? 'âœ“' : job.status === 'failed' ? 'âœ—' : `${job.progress}%`}
      </div>
    </div>
  `).join('');
}

/**
 * Load and display music library
 */
async function loadMusicLibrary() {
  const container = document.getElementById('musicLibrary');
  if (!container) return;

  try {
    container.innerHTML = '<div class="music-loading">Loading library...</div>';

    const library = await getMusicLibrary();

    if (library.length === 0) {
      container.innerHTML = '<div class="music-empty">Your music library is empty</div>';
      return;
    }

    container.innerHTML = library.map(item => `
      <div class="music-library-item" data-job-id="${item.jobId}">
        <div class="music-item-info">
          <div class="music-item-title">${escapeHtml(item.title || 'Untitled')}</div>
          <div class="music-item-meta">${item.duration}s â€¢ ${item.mood || 'Music'}</div>
        </div>
        <div class="music-item-actions">
          <button class="music-action-btn" data-action="preview" data-job-id="${item.jobId}" title="Preview">â–¶</button>
          <button class="music-action-btn" data-action="align" data-job-id="${item.jobId}" title="Align to Video">âš¡</button>
          <button class="music-action-btn" data-action="import" data-job-id="${item.jobId}" title="Import to Timeline">+</button>
          <button class="music-action-btn danger" data-action="delete" data-job-id="${item.jobId}" title="Delete">Ã—</button>
        </div>
      </div>
    `).join('');

    // Add event listeners
    container.querySelectorAll('.music-action-btn').forEach(btn => {
      btn.addEventListener('click', handleLibraryAction);
    });

  } catch (error) {
    console.error('Library load error:', error);
    container.innerHTML = '<div class="music-error">Failed to load library</div>';
  }
}

/**
 * Handle library action (preview, import, delete)
 * @param {Event} event - Click event
 */
async function handleLibraryAction(event) {
  const btn = event.target;
  const action = btn.dataset.action;
  const jobId = btn.dataset.jobId;

  switch (action) {
    case 'preview':
      await previewMusic(jobId);
      break;
    case 'align':
      await showAlignmentModal(jobId);
      break;
    case 'import':
      await importMusicToTimeline(jobId);
      break;
    case 'delete':
      await confirmDeleteMusic(jobId);
      break;
  }
}

/**
 * Preview music file
 * @param {string} jobId - Job ID
 */
async function previewMusic(jobId) {
  try {
    setMusicStatus('Loading preview...', 'info');

    const music = await getMusicFile(jobId);

    if (!music.previewUrl && !music.downloadUrl) {
      setMusicStatus('No preview available', 'warning');
      return;
    }

    // Create or update audio player
    if (!musicState.audioPlayer) {
      musicState.audioPlayer = new Audio();
      musicState.audioPlayer.addEventListener('ended', () => {
        setMusicStatus('Preview finished', 'info');
      });
    }

    musicState.audioPlayer.src = music.previewUrl || music.downloadUrl;
    musicState.audioPlayer.play();

    setMusicStatus('Playing preview...', 'success');

  } catch (error) {
    console.error('Preview error:', error);
    setMusicStatus(`Preview error: ${error.message}`, 'error');
  }
}

/**
 * Import music to Premiere Pro timeline
 * @param {string} jobId - Job ID
 */
async function importMusicToTimeline(jobId) {
  try {
    setMusicStatus('Downloading music...', 'info');

    const music = await getMusicFile(jobId);

    if (!music.downloadUrl) {
      setMusicStatus('Download URL not available', 'error');
      return;
    }

    setMusicStatus('Importing to timeline...', 'info');

    // Download file
    const response = await fetch(music.downloadUrl);
    const blob = await response.blob();

    // Get temp folder access
    const tempFolder = await getTempFolder();
    if (!tempFolder) {
      setMusicStatus('Could not access temp folder', 'error');
      return;
    }

    // Save to temp file
    const fileName = `splice_music_${jobId}.wav`;
    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
    const arrayBuffer = await blob.arrayBuffer();
    await tempFile.write(arrayBuffer);

    // Import to project
    const pproBuilder = require('premierepro').pproBuilder;
    const project = await pproBuilder.Project.getActiveProject();

    if (!project) {
      setMusicStatus('No active project', 'error');
      return;
    }

    // Import file
    const imported = await project.importFiles([tempFile.nativePath]);

    if (imported && imported.length > 0) {
      setMusicStatus('Music imported to project!', 'success');

      // Optionally insert at playhead
      const sequence = await pproBuilder.Sequence.getActiveSequence();
      if (sequence) {
        // TODO: Insert clip at playhead position
        setMusicStatus('Music imported and ready to use!', 'success');
      }
    } else {
      setMusicStatus('Import failed', 'error');
    }

  } catch (error) {
    console.error('Import error:', error);
    setMusicStatus(`Import error: ${error.message}`, 'error');
  }
}

/**
 * Confirm and delete music
 * @param {string} jobId - Job ID
 */
async function confirmDeleteMusic(jobId) {
  const confirmed = await showConfirmModal(
    'Delete Music',
    'Are you sure you want to delete this music file?'
  );

  if (!confirmed) return;

  try {
    setMusicStatus('Deleting...', 'info');
    await deleteMusicFile(jobId);
    setMusicStatus('Music deleted', 'success');
    loadMusicLibrary();
  } catch (error) {
    console.error('Delete error:', error);
    setMusicStatus(`Delete error: ${error.message}`, 'error');
  }
}

// ============================================
// ALIGNMENT UI FUNCTIONS
// ============================================

/**
 * Show alignment modal for a music item
 * @param {string} jobId - Job ID
 */
async function showAlignmentModal(jobId) {
  try {
    setMusicStatus('Loading alignment options...', 'info');

    // Get alignment options from backend
    const options = await getAlignmentOptions();
    musicState.alignmentOptions = options;

    // Try to get sequence duration
    const sequenceDuration = await getSequenceDuration();

    // Get beat analysis
    setMusicStatus('Analyzing beats...', 'info');
    const beatAnalysis = await analyzeBeatsRequest(jobId);
    musicState.beatAnalysis = beatAnalysis;

    // Show modal
    renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration);
    setMusicStatus('', 'info');

  } catch (error) {
    console.error('Alignment modal error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  }
}

/**
 * Render alignment modal UI
 * @param {string} jobId - Job ID
 * @param {Object} beatAnalysis - Beat analysis data
 * @param {Object} options - Alignment options
 * @param {number|null} sequenceDuration - Sequence duration if available
 */
function renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration) {
  // Create or get modal container
  let modal = document.getElementById('alignmentModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'alignmentModal';
    modal.className = 'modal-overlay';
    document.body.appendChild(modal);
  }

  const defaultDuration = sequenceDuration
    ? Math.round(sequenceDuration)
    : Math.round(beatAnalysis.duration * 0.8);

  modal.innerHTML = `
    <div class="modal-content alignment-modal">
      <div class="modal-header">
        <h3>Align Music to Video</h3>
        <button class="modal-close-btn" id="alignmentCloseBtn">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="alignment-info">
          <div class="alignment-stat">
            <span class="stat-label">Original Duration:</span>
            <span class="stat-value">${formatDuration(beatAnalysis.duration)}</span>
          </div>
          <div class="alignment-stat">
            <span class="stat-label">Detected BPM:</span>
            <span class="stat-value">${beatAnalysis.bpm || 'Unknown'}</span>
          </div>
          <div class="alignment-stat">
            <span class="stat-label">Beat Count:</span>
            <span class="stat-value">${beatAnalysis.beatCount}</span>
          </div>
          ${sequenceDuration ? `
          <div class="alignment-stat highlight">
            <span class="stat-label">Sequence Duration:</span>
            <span class="stat-value">${formatDuration(sequenceDuration)}</span>
          </div>
          ` : ''}
        </div>

        <div class="alignment-form">
          <div class="form-group">
            <label for="alignTargetDuration">Target Duration (seconds)</label>
            <input type="number" id="alignTargetDuration"
                   value="${defaultDuration}"
                   min="${options.minAudioDuration}"
                   max="${Math.ceil(beatAnalysis.duration)}"
                   step="1">
            <span class="form-hint">Music will be trimmed at the nearest beat</span>
          </div>

          <div class="form-group">
            <label for="alignFadeDuration">Fade Out Duration (seconds)</label>
            <input type="number" id="alignFadeDuration"
                   value="${options.fadeDuration.default}"
                   min="${options.fadeDuration.min}"
                   max="${options.fadeDuration.max}"
                   step="0.5">
          </div>

          <div class="form-group checkbox-group">
            <label>
              <input type="checkbox" id="alignBeatAlign" checked>
              Align to nearest beat (recommended)
            </label>
            <span class="form-hint">Ensures clean cut at a musical beat</span>
          </div>

          ${sequenceDuration ? `
          <button type="button" id="alignMatchSequenceBtn" class="btn-secondary">
            Match Sequence Duration (${formatDuration(sequenceDuration)})
          </button>
          ` : ''}
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" id="alignmentCancelBtn" class="btn-secondary">Cancel</button>
        <button type="button" id="alignmentConfirmBtn" class="btn-primary" data-job-id="${jobId}">
          Align Music
        </button>
      </div>
    </div>
  `;

  modal.style.display = 'flex';

  // Event listeners
  document.getElementById('alignmentCloseBtn').addEventListener('click', hideAlignmentModal);
  document.getElementById('alignmentCancelBtn').addEventListener('click', hideAlignmentModal);
  document.getElementById('alignmentConfirmBtn').addEventListener('click', handleAlignmentConfirm);

  if (sequenceDuration) {
    document.getElementById('alignMatchSequenceBtn').addEventListener('click', () => {
      document.getElementById('alignTargetDuration').value = Math.round(sequenceDuration);
    });
  }

  // Close on overlay click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) hideAlignmentModal();
  });
}

/**
 * Hide alignment modal
 */
function hideAlignmentModal() {
  const modal = document.getElementById('alignmentModal');
  if (modal) {
    modal.style.display = 'none';
    modal.innerHTML = '';
  }
  musicState.beatAnalysis = null;
}

/**
 * Handle alignment confirmation
 * @param {Event} event - Click event
 */
async function handleAlignmentConfirm(event) {
  const btn = event.target;
  const jobId = btn.dataset.jobId;

  const targetDuration = parseFloat(document.getElementById('alignTargetDuration').value);
  const fadeDuration = parseFloat(document.getElementById('alignFadeDuration').value);
  const beatAlign = document.getElementById('alignBeatAlign').checked;

  if (!targetDuration || targetDuration < 5) {
    setMusicStatus('Target duration must be at least 5 seconds', 'error');
    return;
  }

  try {
    musicState.isAligning = true;
    btn.disabled = true;
    btn.textContent = 'Aligning...';
    setMusicStatus('Aligning music to video duration...', 'info');

    const result = await alignMusicRequest(jobId, targetDuration, {
      fadeDuration,
      beatAlign
    });

    setMusicStatus(
      `Aligned! Cut at ${formatDuration(result.actualDuration)} (${result.wasAligned ? 'beat-aligned' : 'exact'})`,
      'success'
    );

    // Hide modal
    hideAlignmentModal();

    // Show download option
    showAlignedDownload(result);

  } catch (error) {
    console.error('Alignment error:', error);
    setMusicStatus(`Alignment failed: ${error.message}`, 'error');
    btn.disabled = false;
    btn.textContent = 'Align Music';
  } finally {
    musicState.isAligning = false;
  }
}

/**
 * Show aligned music download/import options
 * @param {Object} result - Alignment result
 */
function showAlignedDownload(result) {
  // Create notification with download option
  const notification = document.createElement('div');
  notification.className = 'alignment-notification';
  notification.innerHTML = `
    <div class="notification-content">
      <span class="notification-icon">âœ“</span>
      <div class="notification-text">
        <strong>Music Aligned!</strong>
        <span>Duration: ${formatDuration(result.actualDuration)}</span>
      </div>
      <div class="notification-actions">
        <button class="btn-small" data-action="import" data-url="${result.downloadUrl}">
          Import to Timeline
        </button>
        <button class="btn-small btn-secondary" data-action="download" data-url="${result.downloadUrl}">
          Download
        </button>
        <button class="btn-close" data-action="close">Ã—</button>
      </div>
    </div>
  `;

  // Add to page
  const container = document.getElementById('musicSection') || document.body;
  container.appendChild(notification);

  // Event handlers
  notification.querySelector('[data-action="import"]').addEventListener('click', async (e) => {
    await importAlignedMusic(e.target.dataset.url, result.jobId);
    notification.remove();
  });

  notification.querySelector('[data-action="download"]').addEventListener('click', (e) => {
    window.open(e.target.dataset.url, '_blank');
    notification.remove();
  });

  notification.querySelector('[data-action="close"]').addEventListener('click', () => {
    notification.remove();
  });

  // Auto-remove after 30 seconds
  setTimeout(() => notification.remove(), 30000);
}

/**
 * Import aligned music to timeline
 * @param {string} downloadUrl - Download URL
 * @param {string} jobId - Job ID
 */
async function importAlignedMusic(downloadUrl, jobId) {
  try {
    setMusicStatus('Importing aligned music...', 'info');

    // Download file
    const response = await fetch(downloadUrl);
    const blob = await response.blob();

    // Get temp folder
    const tempFolder = await getTempFolder();
    if (!tempFolder) {
      setMusicStatus('Could not access temp folder', 'error');
      return;
    }

    // Save to temp file
    const fileName = `splice_aligned_${jobId}.wav`;
    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
    const arrayBuffer = await blob.arrayBuffer();
    await tempFile.write(arrayBuffer);

    // Import to project
    const pproBuilder = require('premierepro').pproBuilder;
    const project = await pproBuilder.Project.getActiveProject();

    if (!project) {
      setMusicStatus('No active project', 'error');
      return;
    }

    const imported = await project.importFiles([tempFile.nativePath]);

    if (imported && imported.length > 0) {
      setMusicStatus('Aligned music imported to project!', 'success');
    } else {
      setMusicStatus('Import failed', 'error');
    }

  } catch (error) {
    console.error('Import error:', error);
    setMusicStatus(`Import error: ${error.message}`, 'error');
  }
}

// ============================================
// TIMELINE UI FUNCTIONS
// ============================================

/**
 * Update timeline button availability
 */
function updateTimelineAvailability() {
  const btn = document.getElementById('musicGenerateTimelineBtn');
  const transcript = getCurrentTranscript();

  if (btn) {
    btn.disabled = !transcript || !transcript.segments || transcript.segments.length === 0;

    // Update tooltip
    if (!transcript) {
      btn.title = 'Run transcription first to enable mood timeline';
    } else if (!transcript.segments || transcript.segments.length === 0) {
      btn.title = 'No transcript segments available';
    } else {
      btn.title = 'Generate per-chapter music with mood matching';
    }
  }
}

/**
 * Show timeline generation modal
 */
async function showTimelineModal() {
  const transcript = getCurrentTranscript();

  if (!transcript) {
    setMusicStatus('Run transcription first to generate mood timeline', 'error');
    return;
  }

  try {
    setMusicStatus('Loading timeline options...', 'info');

    // Get timeline options
    const options = await getTimelineOptions();
    musicState.timelineOptions = options;

    // Get estimate
    const estimate = await estimateTimelineRequest(transcript);

    // Render modal
    renderTimelineModal(transcript, options, estimate);
    setMusicStatus('', 'info');

  } catch (error) {
    console.error('Timeline modal error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  }
}

/**
 * Render timeline generation modal
 * @param {Object} transcript - Transcript object
 * @param {Object} options - Timeline options
 * @param {Object} estimate - Time estimate
 */
function renderTimelineModal(transcript, options, estimate) {
  let modal = document.getElementById('timelineModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'timelineModal';
    modal.className = 'modal-overlay';
    document.body.appendChild(modal);
  }

  const defaults = options.defaults || {};
  const constraints = options.constraints || {};

  modal.innerHTML = `
    <div class="modal-content timeline-modal">
      <div class="modal-header">
        <h3>Generate Mood Timeline</h3>
        <button class="modal-close-btn" id="timelineCloseBtn">Ã—</button>
      </div>
      <div class="modal-body">
        <div class="timeline-info">
          <div class="timeline-stat">
            <span class="stat-label">Video Duration:</span>
            <span class="stat-value">${formatDuration(transcript.duration)}</span>
          </div>
          <div class="timeline-stat">
            <span class="stat-label">Transcript Segments:</span>
            <span class="stat-value">${transcript.segments?.length || 0}</span>
          </div>
          <div class="timeline-stat highlight">
            <span class="stat-label">Estimated Chapters:</span>
            <span class="stat-value">${estimate.estimatedChapters}</span>
          </div>
          <div class="timeline-stat highlight">
            <span class="stat-label">Estimated Time:</span>
            <span class="stat-value">${estimate.estimatedTimeDisplay}</span>
          </div>
        </div>

        <div class="timeline-description">
          <p>This will analyze your video transcript to detect chapters and their emotional tone,
          then generate unique music for each chapter with crossfades between them.</p>
          <p><strong>Cost:</strong> 3 music credits</p>
        </div>

        <div class="timeline-form">
          <div class="form-group">
            <label for="timelineMaxChapters">Maximum Chapters</label>
            <input type="number" id="timelineMaxChapters"
                   value="${defaults.maxChapters || 10}"
                   min="1" max="20" step="1">
            <span class="form-hint">More chapters = more varied music segments</span>
          </div>

          <div class="form-group">
            <label for="timelineMinLength">Minimum Chapter Length (seconds)</label>
            <input type="number" id="timelineMinLength"
                   value="${defaults.minChapterLength || 60}"
                   min="30" max="300" step="10">
            <span class="form-hint">Chapters shorter than this will be merged</span>
          </div>

          <div class="form-group">
            <label for="timelineCrossfade">Crossfade Duration (seconds)</label>
            <input type="number" id="timelineCrossfade"
                   value="${defaults.crossfadeDuration || 2}"
                   min="${constraints.minCrossfadeDuration || 0.5}"
                   max="${constraints.maxCrossfadeDuration || 5}"
                   step="0.5">
            <span class="form-hint">Smooth transition between music segments</span>
          </div>

          <div class="form-group">
            <label for="timelineInstruments">Instrument Style</label>
            <select id="timelineInstruments">
              <option value="">Auto-detect from content</option>
              ${INSTRUMENT_OPTIONS.map(i => `<option value="${i.id}">${i.name} - ${i.description}</option>`).join('')}
            </select>
          </div>

          <div class="form-group">
            <label for="timelinePrompt">Additional Instructions (optional)</label>
            <textarea id="timelinePrompt" rows="2" placeholder="E.g., 'Modern electronic feel' or 'Keep energy consistent'"></textarea>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" id="timelineCancelBtn" class="btn-secondary">Cancel</button>
        <button type="button" id="timelineConfirmBtn" class="btn-primary">
          Generate Timeline Music (3 credits)
        </button>
      </div>
    </div>
  `;

  modal.style.display = 'flex';

  // Event listeners
  document.getElementById('timelineCloseBtn').addEventListener('click', hideTimelineModal);
  document.getElementById('timelineCancelBtn').addEventListener('click', hideTimelineModal);
  document.getElementById('timelineConfirmBtn').addEventListener('click', handleTimelineConfirm);

  // Close on overlay click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) hideTimelineModal();
  });
}

/**
 * Hide timeline modal
 */
function hideTimelineModal() {
  const modal = document.getElementById('timelineModal');
  if (modal) {
    modal.style.display = 'none';
    modal.innerHTML = '';
  }
}

/**
 * Handle timeline generation confirmation
 */
async function handleTimelineConfirm() {
  const transcript = getCurrentTranscript();
  if (!transcript) {
    setMusicStatus('Transcript not available', 'error');
    return;
  }

  const maxChapters = parseInt(document.getElementById('timelineMaxChapters').value) || 10;
  const minChapterLength = parseInt(document.getElementById('timelineMinLength').value) || 60;
  const crossfadeDuration = parseFloat(document.getElementById('timelineCrossfade').value) || 2;
  const instruments = document.getElementById('timelineInstruments').value;
  const prompt = document.getElementById('timelinePrompt').value || '';

  const confirmBtn = document.getElementById('timelineConfirmBtn');

  try {
    musicState.isGeneratingTimeline = true;
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'Generating...';

    setMusicStatus('Generating mood timeline... This may take several minutes.', 'info');

    // Hide modal
    hideTimelineModal();

    // Show progress panel
    showTimelineProgressPanel();

    // Make the request
    const result = await generateTimelineRequest(transcript, {
      maxChapters,
      minChapterLength,
      crossfadeDuration,
      instruments: instruments ? [instruments] : [],
      prompt
    });

    // Show success
    setMusicStatus(`Timeline generated! ${result.chapters?.length || 0} chapters, ${formatDuration(result.duration)}`, 'success');

    // Show download option
    if (result.audioUrl) {
      showTimelineResult(result);
    }

    // Refresh library
    loadMusicLibrary();
    updateMusicCreditsDisplay();

  } catch (error) {
    console.error('Timeline generation error:', error);
    setMusicStatus(`Timeline generation failed: ${error.message}`, 'error');
    hideTimelineProgressPanel();
  } finally {
    musicState.isGeneratingTimeline = false;
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.textContent = 'Generate Timeline Music (3 credits)';
    }
  }
}

/**
 * Show timeline progress panel
 */
function showTimelineProgressPanel() {
  let panel = document.getElementById('timelineProgressPanel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'timelineProgressPanel';
    panel.className = 'timeline-progress-panel';

    const container = document.getElementById('musicSection') || document.body;
    container.insertBefore(panel, container.firstChild);
  }

  panel.innerHTML = `
    <div class="timeline-progress-content">
      <div class="timeline-progress-header">
        <span class="progress-icon">ðŸŽµ</span>
        <span class="progress-title">Generating Mood Timeline</span>
      </div>
      <div class="timeline-progress-steps">
        <div class="progress-step active">Analyzing chapters...</div>
        <div class="progress-step">Detecting moods...</div>
        <div class="progress-step">Generating music...</div>
        <div class="progress-step">Assembling with crossfades...</div>
      </div>
      <div class="timeline-progress-note">
        This may take 10-15 minutes. You can continue using the plugin.
      </div>
    </div>
  `;

  panel.style.display = 'block';
}

/**
 * Hide timeline progress panel
 */
function hideTimelineProgressPanel() {
  const panel = document.getElementById('timelineProgressPanel');
  if (panel) {
    panel.style.display = 'none';
  }
}

/**
 * Show timeline generation result
 * @param {Object} result - Timeline result
 */
function showTimelineResult(result) {
  hideTimelineProgressPanel();

  let resultPanel = document.getElementById('timelineResultPanel');
  if (!resultPanel) {
    resultPanel = document.createElement('div');
    resultPanel.id = 'timelineResultPanel';
    resultPanel.className = 'timeline-result-panel';

    const container = document.getElementById('musicSection') || document.body;
    container.insertBefore(resultPanel, container.firstChild);
  }

  // Build chapter info
  const chapterList = (result.chapters || []).map((ch, i) => `
    <div class="timeline-chapter">
      <span class="chapter-num">${i + 1}</span>
      <span class="chapter-title">${escapeHtml(ch.title)}</span>
      <span class="chapter-mood">${ch.mood || 'neutral'}</span>
      <span class="chapter-status">${ch.musicGenerated ? 'âœ“' : 'âœ—'}</span>
    </div>
  `).join('');

  resultPanel.innerHTML = `
    <div class="timeline-result-content">
      <div class="timeline-result-header">
        <span class="result-icon">âœ“</span>
        <span class="result-title">Mood Timeline Generated!</span>
        <button class="close-btn" data-action="close">Ã—</button>
      </div>

      <div class="timeline-result-stats">
        <div class="result-stat">
          <span class="stat-label">Duration:</span>
          <span class="stat-value">${formatDuration(result.duration)}</span>
        </div>
        <div class="result-stat">
          <span class="stat-label">Chapters:</span>
          <span class="stat-value">${result.chapters?.length || 0}</span>
        </div>
        <div class="result-stat">
          <span class="stat-label">Credits Used:</span>
          <span class="stat-value">${result.creditCost || 3}</span>
        </div>
      </div>

      <div class="timeline-chapters">
        <h4>Chapters</h4>
        ${chapterList}
      </div>

      <div class="timeline-result-actions">
        <button class="btn-primary" data-action="import" data-url="${result.audioUrl}">
          Import to Timeline
        </button>
        <button class="btn-secondary" data-action="download" data-url="${result.audioUrl}">
          Download
        </button>
      </div>
    </div>
  `;

  resultPanel.style.display = 'block';

  // Event listeners
  resultPanel.querySelector('[data-action="close"]').addEventListener('click', () => {
    resultPanel.style.display = 'none';
  });

  resultPanel.querySelector('[data-action="import"]').addEventListener('click', async (e) => {
    await importTimelineMusic(e.target.dataset.url);
    resultPanel.style.display = 'none';
  });

  resultPanel.querySelector('[data-action="download"]').addEventListener('click', (e) => {
    window.open(e.target.dataset.url, '_blank');
  });

  // Auto-hide after 60 seconds
  setTimeout(() => {
    if (resultPanel) resultPanel.style.display = 'none';
  }, 60000);
}

/**
 * Import timeline music to project
 * @param {string} downloadUrl - Download URL
 */
async function importTimelineMusic(downloadUrl) {
  try {
    setMusicStatus('Importing timeline music...', 'info');

    const response = await fetch(downloadUrl);
    const blob = await response.blob();

    const tempFolder = await getTempFolder();
    if (!tempFolder) {
      setMusicStatus('Could not access temp folder', 'error');
      return;
    }

    const fileName = `splice_timeline_${Date.now()}.wav`;
    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
    const arrayBuffer = await blob.arrayBuffer();
    await tempFile.write(arrayBuffer);

    const pproBuilder = require('premierepro').pproBuilder;
    const project = await pproBuilder.Project.getActiveProject();

    if (!project) {
      setMusicStatus('No active project', 'error');
      return;
    }

    const imported = await project.importFiles([tempFile.nativePath]);

    if (imported && imported.length > 0) {
      setMusicStatus('Timeline music imported to project!', 'success');
    } else {
      setMusicStatus('Import failed', 'error');
    }

  } catch (error) {
    console.error('Import error:', error);
    setMusicStatus(`Import error: ${error.message}`, 'error');
  }
}

/**
 * Format duration in mm:ss format
 * @param {number} seconds - Duration in seconds
 * @returns {string} Formatted duration
 */
function formatDuration(seconds) {
  if (!seconds) return '0:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.round(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Update music credits display
 */
async function updateMusicCreditsDisplay() {
  const badge = document.getElementById('musicCreditsBadge');
  if (!badge) return;

  try {
    const credits = await getMusicCredits();
    badge.textContent = `${credits.remaining}/${credits.total} songs`;
    badge.className = 'music-credits-badge';

    if (credits.remaining === 0) {
      badge.classList.add('empty');
    } else if (credits.remaining <= 2) {
      badge.classList.add('low');
    }
  } catch (error) {
    badge.textContent = 'Credits: --';
  }
}

/**
 * Set music status message
 * @param {string} message - Status message
 * @param {string} type - Message type (info, success, warning, error)
 */
function setMusicStatus(message, type = 'info') {
  const status = document.getElementById('musicStatus');
  if (!status) return;

  status.textContent = message;
  status.className = `music-status ${type}`;
  status.style.display = 'block';

  // Auto-hide after delay for non-error messages
  if (type !== 'error') {
    setTimeout(() => {
      status.style.display = 'none';
    }, 5000);
  }
}

/**
 * Get temp folder for file operations
 * @returns {Promise<Folder|null>}
 */
async function getTempFolder() {
  try {
    const uxpFs = require('uxp').storage.localFileSystem;
    return await uxpFs.getTemporaryFolder();
  } catch (error) {
    console.error('Temp folder error:', error);
    return null;
  }
}

/**
 * Escape HTML special characters
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

/**
 * Simple debounce function
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in ms
 * @returns {Function} Debounced function
 */
function debounce(fn, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Export for use in other modules
window.musicModule = {
  init: initMusicModule,
  identifySong,
  generateMusicRequest,
  getMusicLibrary,
  getMusicCredits,
  loadMusicLibrary,
  previewMusic,
  importMusicToTimeline,
  // Variations exports
  generateVariationsRequest,
  getVariationsStatus,
  selectVariation,
  handleGenerateVariations,
  showVariationsPanel,
  hideVariationsPanel,
  // Scene-aware exports
  generateSceneAwareRequest,
  getCurrentTranscriptSegments,
  handleSceneAwareToggle,
  updateSceneAwareAvailability,
  // Alignment exports
  alignMusicRequest,
  analyzeBeatsRequest,
  getAlignmentOptions,
  showAlignmentModal,
  hideAlignmentModal,
  formatDuration,
  getSequenceDuration,
  // Timeline exports
  generateTimelineRequest,
  getTimelineOptions,
  estimateTimelineRequest,
  getCurrentTranscript,
  showTimelineModal,
  hideTimelineModal,
  updateTimelineAvailability,
  importTimelineMusic,
  MOOD_OPTIONS,
  INSTRUMENT_OPTIONS,
  DURATION_OPTIONS
};
