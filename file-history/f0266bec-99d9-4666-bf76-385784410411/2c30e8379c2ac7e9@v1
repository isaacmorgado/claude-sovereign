// Premiere Pro API wrapper

import type {
  PremiereProject,
  PremiereSequence,
  PremiereClip,
  SelectionState,
} from '@/types/premiere'
import type { ClipSelection } from '@/types/plugin'
import { logger } from '../logger'

// Type declarations for UXP Premiere Pro API
declare const app: {
  project: {
    name: string
    path: string
    activeSequence: unknown
    sequences: unknown[]
  }
}

export async function getActiveProject(): Promise<PremiereProject | null> {
  try {
    // Access Premiere Pro's project through UXP API
    const project = app?.project
    if (!project) {
      logger.warn('No active project found')
      return null
    }

    return {
      name: project.name,
      path: project.path,
      sequences: await getSequences(),
      activeSequence: await getActiveSequence(),
    }
  } catch (error) {
    logger.error('Failed to get active project', error)
    return null
  }
}

export async function getActiveSequence(): Promise<PremiereSequence | null> {
  try {
    const sequence = app?.project?.activeSequence
    if (!sequence) {
      logger.debug('No active sequence')
      return null
    }

    // Map the Premiere sequence to our type
    return mapSequence(sequence)
  } catch (error) {
    logger.error('Failed to get active sequence', error)
    return null
  }
}

export async function getSequences(): Promise<PremiereSequence[]> {
  try {
    const sequences = app?.project?.sequences || []
    return sequences.map(mapSequence)
  } catch (error) {
    logger.error('Failed to get sequences', error)
    return []
  }
}

export async function getSelectedClips(): Promise<ClipSelection[]> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return []

    const selectedClips: ClipSelection[] = []

    // Iterate through video tracks
    for (const track of sequence.videoTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'video',
          })
        }
      }
    }

    // Iterate through audio tracks
    for (const track of sequence.audioTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'audio',
          })
        }
      }
    }

    logger.debug('Selected clips retrieved', { count: selectedClips.length })
    return selectedClips
  } catch (error) {
    logger.error('Failed to get selected clips', error)
    return []
  }
}

export async function selectClipsByTimeRange(
  startTime: number,
  endTime: number,
  trackIndices?: number[]
): Promise<boolean> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      logger.warn('No active sequence for selection')
      return false
    }

    // This would use the actual Premiere Pro API to select clips
    // The implementation depends on the specific UXP API available
    logger.info('Selecting clips by time range', { startTime, endTime, trackIndices })

    // Placeholder for actual implementation
    return true
  } catch (error) {
    logger.error('Failed to select clips by time range', error)
    return false
  }
}

export async function selectAllClipsInTrack(
  trackIndex: number,
  trackType: 'video' | 'audio'
): Promise<boolean> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return false

    const tracks = trackType === 'video' ? sequence.videoTracks : sequence.audioTracks
    const track = tracks.find((t) => t.index === trackIndex)

    if (!track) {
      logger.warn('Track not found', { trackIndex, trackType })
      return false
    }

    // Select all clips in the track
    logger.info('Selecting all clips in track', {
      trackIndex,
      trackType,
      clipCount: track.clips.length,
    })
    return true
  } catch (error) {
    logger.error('Failed to select clips in track', error)
    return false
  }
}

export async function getSelectionState(): Promise<SelectionState> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      return { clips: [], markers: [], tracks: [] }
    }

    const selectedClips: PremiereClip[] = []

    for (const track of [...sequence.videoTracks, ...sequence.audioTracks]) {
      selectedClips.push(...track.clips.filter((c) => c.isSelected))
    }

    return {
      clips: selectedClips,
      markers: [], // Would be populated from actual API
      tracks: [],
    }
  } catch (error) {
    logger.error('Failed to get selection state', error)
    return { clips: [], markers: [], tracks: [] }
  }
}

// Helper function to map a single clip from UXP API to our type
function mapClip(clip: unknown, isSelected: boolean): PremiereClip {
  const c = clip as Record<string, unknown>
  const startTime = Number(c.start ?? c.startTime ?? 0)
  const endTime = Number(c.end ?? c.endTime ?? 0)

  return {
    id: String(c.nodeId ?? c.id ?? `clip-${Math.random().toString(36).substr(2, 9)}`),
    name: String(c.name ?? 'Untitled Clip'),
    startTime,
    endTime,
    duration: endTime - startTime,
    inPoint: Number(c.inPoint ?? 0),
    outPoint: Number(c.outPoint ?? endTime - startTime),
    mediaPath: c.projectItem?.getMediaPath?.() ?? String(c.mediaPath ?? ''),
    isSelected,
  }
}

// Helper function to map a track from UXP API to our type
function mapTrack(track: unknown, index: number): PremiereTrack {
  const t = track as Record<string, unknown>
  const clips: PremiereClip[] = []

  // Try to access clips from the track
  // UXP API uses 'clips' property on tracks
  const trackClips = t.clips as unknown[] | undefined

  if (trackClips && Array.isArray(trackClips)) {
    for (let i = 0; i < trackClips.length; i++) {
      try {
        const clip = trackClips[i] as Record<string, unknown>
        // Check if clip is selected - UXP uses isSelected() method or selected property
        const isSelected = typeof clip.isSelected === 'function'
          ? (clip.isSelected as () => boolean)()
          : Boolean(clip.selected ?? clip.isSelected ?? false)

        clips.push(mapClip(clip, isSelected))
      } catch (error) {
        logger.warn('Failed to map clip', { index: i, error })
      }
    }
  }

  return {
    id: String(t.id ?? `track-${index}`),
    name: String(t.name ?? `Track ${index + 1}`),
    index,
    clips,
    muted: Boolean(t.mute ?? t.muted ?? false),
    locked: Boolean(t.locked ?? false),
  }
}

// Helper function to map raw sequence to typed structure
function mapSequence(sequence: unknown): PremiereSequence {
  const seq = sequence as Record<string, unknown>

  // Map video tracks
  const videoTracks: PremiereTrack[] = []
  const rawVideoTracks = seq.videoTracks as unknown[] | undefined

  if (rawVideoTracks && Array.isArray(rawVideoTracks)) {
    for (let i = 0; i < rawVideoTracks.length; i++) {
      try {
        videoTracks.push(mapTrack(rawVideoTracks[i], i))
      } catch (error) {
        logger.warn('Failed to map video track', { index: i, error })
      }
    }
  }

  // Map audio tracks
  const audioTracks: PremiereTrack[] = []
  const rawAudioTracks = seq.audioTracks as unknown[] | undefined

  if (rawAudioTracks && Array.isArray(rawAudioTracks)) {
    for (let i = 0; i < rawAudioTracks.length; i++) {
      try {
        audioTracks.push(mapTrack(rawAudioTracks[i], i))
      } catch (error) {
        logger.warn('Failed to map audio track', { index: i, error })
      }
    }
  }

  // Try to read actual frame rate from sequence settings
  let frameRate = {
    numerator: 24000,
    denominator: 1001,
    value: 23.976,
  }

  try {
    const settings = seq.settings as Record<string, unknown> | undefined
    if (settings?.videoFrameRate) {
      const fr = settings.videoFrameRate as Record<string, unknown>
      frameRate = {
        numerator: Number(fr.numerator ?? 24000),
        denominator: Number(fr.denominator ?? 1001),
        value: Number(fr.numerator ?? 24000) / Number(fr.denominator ?? 1001),
      }
    } else if (typeof seq.getSettings === 'function') {
      // Alternative: UXP API may use getSettings() method
      const settingsObj = (seq.getSettings as () => Record<string, unknown>)()
      if (settingsObj?.videoFrameRate) {
        const fr = settingsObj.videoFrameRate as Record<string, unknown>
        frameRate = {
          numerator: Number(fr.numerator ?? 24000),
          denominator: Number(fr.denominator ?? 1001),
          value: Number(fr.numerator ?? 24000) / Number(fr.denominator ?? 1001),
        }
      }
    }
  } catch (error) {
    logger.debug('Could not read frame rate, using default', error)
  }

  const duration = Number(seq.end ?? 0) - Number(seq.start ?? 0)

  logger.debug('Mapped sequence', {
    name: seq.name,
    videoTrackCount: videoTracks.length,
    audioTrackCount: audioTracks.length,
    totalVideoClips: videoTracks.reduce((sum, t) => sum + t.clips.length, 0),
    totalAudioClips: audioTracks.reduce((sum, t) => sum + t.clips.length, 0),
  })

  return {
    id: String(seq.sequenceID || seq.id || ''),
    name: String(seq.name || 'Untitled'),
    videoTracks,
    audioTracks,
    duration,
    frameRate,
  }
}
