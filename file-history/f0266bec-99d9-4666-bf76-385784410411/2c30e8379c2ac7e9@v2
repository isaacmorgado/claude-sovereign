// Premiere Pro API wrapper

import type {
  PremiereProject,
  PremiereSequence,
  PremiereTrack,
  PremiereClip,
  SelectionState,
} from '@/types/premiere'
import type { ClipSelection } from '@/types/plugin'
import { logger } from '../logger'

// Type declarations for UXP Premiere Pro API
// These are simplified declarations - the actual UXP API may have additional methods
declare const app: {
  project: {
    name: string
    path: string
    activeSequence: {
      sequenceID?: string
      id?: string
      name?: string
      start?: number
      end?: number
      videoTracks?: Array<{
        id?: string
        name?: string
        clips?: Array<{
          nodeId?: string
          id?: string
          name?: string
          start?: number
          end?: number
          startTime?: number
          endTime?: number
          inPoint?: number
          outPoint?: number
          selected?: boolean
          isSelected?: boolean | (() => boolean)
          setSelected?: (selected: boolean) => void
          projectItem?: {
            getMediaPath?: () => string
          }
          mediaPath?: string
        }>
        mute?: boolean
        muted?: boolean
        locked?: boolean
      }>
      audioTracks?: Array<{
        id?: string
        name?: string
        clips?: Array<{
          nodeId?: string
          id?: string
          name?: string
          start?: number
          end?: number
          startTime?: number
          endTime?: number
          inPoint?: number
          outPoint?: number
          selected?: boolean
          isSelected?: boolean | (() => boolean)
          setSelected?: (selected: boolean) => void
          projectItem?: {
            getMediaPath?: () => string
          }
          mediaPath?: string
        }>
        mute?: boolean
        muted?: boolean
        locked?: boolean
      }>
      settings?: {
        videoFrameRate?: {
          numerator?: number
          denominator?: number
        }
      }
      getSettings?: () => {
        videoFrameRate?: {
          numerator?: number
          denominator?: number
        }
      }
    } | null
    sequences: unknown[]
  }
}

export async function getActiveProject(): Promise<PremiereProject | null> {
  try {
    // Access Premiere Pro's project through UXP API
    const project = app?.project
    if (!project) {
      logger.warn('No active project found')
      return null
    }

    return {
      name: project.name,
      path: project.path,
      sequences: await getSequences(),
      activeSequence: await getActiveSequence(),
    }
  } catch (error) {
    logger.error('Failed to get active project', error)
    return null
  }
}

export async function getActiveSequence(): Promise<PremiereSequence | null> {
  try {
    const sequence = app?.project?.activeSequence
    if (!sequence) {
      logger.debug('No active sequence')
      return null
    }

    // Map the Premiere sequence to our type
    return mapSequence(sequence)
  } catch (error) {
    logger.error('Failed to get active sequence', error)
    return null
  }
}

export async function getSequences(): Promise<PremiereSequence[]> {
  try {
    const sequences = app?.project?.sequences || []
    return sequences.map(mapSequence)
  } catch (error) {
    logger.error('Failed to get sequences', error)
    return []
  }
}

export async function getSelectedClips(): Promise<ClipSelection[]> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) return []

    const selectedClips: ClipSelection[] = []

    // Iterate through video tracks
    for (const track of sequence.videoTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'video',
          })
        }
      }
    }

    // Iterate through audio tracks
    for (const track of sequence.audioTracks) {
      for (const clip of track.clips) {
        if (clip.isSelected) {
          selectedClips.push({
            id: clip.id,
            name: clip.name,
            startTime: clip.startTime,
            endTime: clip.endTime,
            trackIndex: track.index,
            type: 'audio',
          })
        }
      }
    }

    logger.debug('Selected clips retrieved', { count: selectedClips.length })
    return selectedClips
  } catch (error) {
    logger.error('Failed to get selected clips', error)
    return []
  }
}

export async function selectClipsByTimeRange(
  startTime: number,
  endTime: number,
  trackIndices?: number[]
): Promise<boolean> {
  try {
    const sequence = app?.project?.activeSequence
    if (!sequence) {
      logger.warn('No active sequence for selection')
      return false
    }

    logger.info('Selecting clips by time range', { startTime, endTime, trackIndices })

    let selectedCount = 0

    // Helper to check if clip overlaps with time range
    const clipOverlapsRange = (clip: { start?: number; end?: number; startTime?: number; endTime?: number }) => {
      const clipStart = clip.start ?? clip.startTime ?? 0
      const clipEnd = clip.end ?? clip.endTime ?? 0
      // Clip overlaps if it's not completely before or after the range
      return clipEnd > startTime && clipStart < endTime
    }

    // Process video tracks
    if (sequence.videoTracks) {
      for (let trackIdx = 0; trackIdx < sequence.videoTracks.length; trackIdx++) {
        // Skip if trackIndices specified and this track isn't included
        if (trackIndices && !trackIndices.includes(trackIdx)) continue

        const track = sequence.videoTracks[trackIdx]
        if (track.clips) {
          for (const clip of track.clips) {
            if (clipOverlapsRange(clip)) {
              // Try to select the clip using UXP API
              if (typeof clip.setSelected === 'function') {
                clip.setSelected(true)
                selectedCount++
              } else if ('selected' in clip) {
                // Direct property assignment fallback
                ;(clip as { selected: boolean }).selected = true
                selectedCount++
              }
            }
          }
        }
      }
    }

    // Process audio tracks
    if (sequence.audioTracks) {
      for (let trackIdx = 0; trackIdx < sequence.audioTracks.length; trackIdx++) {
        // Skip if trackIndices specified and this track isn't included
        if (trackIndices && !trackIndices.includes(trackIdx)) continue

        const track = sequence.audioTracks[trackIdx]
        if (track.clips) {
          for (const clip of track.clips) {
            if (clipOverlapsRange(clip)) {
              if (typeof clip.setSelected === 'function') {
                clip.setSelected(true)
                selectedCount++
              } else if ('selected' in clip) {
                ;(clip as { selected: boolean }).selected = true
                selectedCount++
              }
            }
          }
        }
      }
    }

    logger.info('Selected clips by time range', { selectedCount })
    return selectedCount > 0
  } catch (error) {
    logger.error('Failed to select clips by time range', error)
    return false
  }
}

export async function selectAllClipsInTrack(
  trackIndex: number,
  trackType: 'video' | 'audio'
): Promise<boolean> {
  try {
    const sequence = app?.project?.activeSequence
    if (!sequence) {
      logger.warn('No active sequence for track selection')
      return false
    }

    const tracks = trackType === 'video' ? sequence.videoTracks : sequence.audioTracks
    if (!tracks || trackIndex >= tracks.length) {
      logger.warn('Track not found', { trackIndex, trackType, availableTracks: tracks?.length ?? 0 })
      return false
    }

    const track = tracks[trackIndex]
    if (!track.clips || track.clips.length === 0) {
      logger.warn('No clips in track', { trackIndex, trackType })
      return false
    }

    let selectedCount = 0

    // Select all clips in the track
    for (const clip of track.clips) {
      try {
        if (typeof clip.setSelected === 'function') {
          clip.setSelected(true)
          selectedCount++
        } else if ('selected' in clip) {
          ;(clip as { selected: boolean }).selected = true
          selectedCount++
        }
      } catch (clipError) {
        logger.warn('Failed to select clip', clipError)
      }
    }

    logger.info('Selected all clips in track', {
      trackIndex,
      trackType,
      clipCount: track.clips.length,
      selectedCount,
    })

    return selectedCount > 0
  } catch (error) {
    logger.error('Failed to select clips in track', error)
    return false
  }
}

export async function getSelectionState(): Promise<SelectionState> {
  try {
    const sequence = await getActiveSequence()
    if (!sequence) {
      return { clips: [], markers: [], tracks: [] }
    }

    const selectedClips: PremiereClip[] = []

    for (const track of [...sequence.videoTracks, ...sequence.audioTracks]) {
      selectedClips.push(...track.clips.filter((c) => c.isSelected))
    }

    return {
      clips: selectedClips,
      markers: [], // Would be populated from actual API
      tracks: [],
    }
  } catch (error) {
    logger.error('Failed to get selection state', error)
    return { clips: [], markers: [], tracks: [] }
  }
}

// Helper function to map a single clip from UXP API to our type
function mapClip(clip: unknown, isSelected: boolean): PremiereClip {
  const c = clip as Record<string, unknown>
  const startTime = Number(c.start ?? c.startTime ?? 0)
  const endTime = Number(c.end ?? c.endTime ?? 0)

  // Try to get media path from projectItem if available
  let mediaPath = ''
  try {
    const projectItem = c.projectItem as { getMediaPath?: () => string } | undefined
    if (projectItem?.getMediaPath) {
      mediaPath = projectItem.getMediaPath()
    } else if (c.mediaPath) {
      mediaPath = String(c.mediaPath)
    }
  } catch {
    // Ignore errors getting media path
  }

  return {
    id: String(c.nodeId ?? c.id ?? `clip-${Math.random().toString(36).substr(2, 9)}`),
    name: String(c.name ?? 'Untitled Clip'),
    startTime,
    endTime,
    duration: endTime - startTime,
    inPoint: Number(c.inPoint ?? 0),
    outPoint: Number(c.outPoint ?? endTime - startTime),
    mediaPath,
    isSelected,
  }
}

// Helper function to map a track from UXP API to our type
function mapTrack(track: unknown, index: number): PremiereTrack {
  const t = track as Record<string, unknown>
  const clips: PremiereClip[] = []

  // Try to access clips from the track
  // UXP API uses 'clips' property on tracks
  const trackClips = t.clips as unknown[] | undefined

  if (trackClips && Array.isArray(trackClips)) {
    for (let i = 0; i < trackClips.length; i++) {
      try {
        const clip = trackClips[i] as Record<string, unknown>
        // Check if clip is selected - UXP uses isSelected() method or selected property
        const isSelected = typeof clip.isSelected === 'function'
          ? (clip.isSelected as () => boolean)()
          : Boolean(clip.selected ?? clip.isSelected ?? false)

        clips.push(mapClip(clip, isSelected))
      } catch (error) {
        logger.warn('Failed to map clip', { index: i, error })
      }
    }
  }

  return {
    id: String(t.id ?? `track-${index}`),
    name: String(t.name ?? `Track ${index + 1}`),
    index,
    clips,
    muted: Boolean(t.mute ?? t.muted ?? false),
    locked: Boolean(t.locked ?? false),
  }
}

// Helper function to map raw sequence to typed structure
function mapSequence(sequence: unknown): PremiereSequence {
  const seq = sequence as Record<string, unknown>

  // Map video tracks
  const videoTracks: PremiereTrack[] = []
  const rawVideoTracks = seq.videoTracks as unknown[] | undefined

  if (rawVideoTracks && Array.isArray(rawVideoTracks)) {
    for (let i = 0; i < rawVideoTracks.length; i++) {
      try {
        videoTracks.push(mapTrack(rawVideoTracks[i], i))
      } catch (error) {
        logger.warn('Failed to map video track', { index: i, error })
      }
    }
  }

  // Map audio tracks
  const audioTracks: PremiereTrack[] = []
  const rawAudioTracks = seq.audioTracks as unknown[] | undefined

  if (rawAudioTracks && Array.isArray(rawAudioTracks)) {
    for (let i = 0; i < rawAudioTracks.length; i++) {
      try {
        audioTracks.push(mapTrack(rawAudioTracks[i], i))
      } catch (error) {
        logger.warn('Failed to map audio track', { index: i, error })
      }
    }
  }

  // Try to read actual frame rate from sequence settings
  let frameRate = {
    numerator: 24000,
    denominator: 1001,
    value: 23.976,
  }

  try {
    const settings = seq.settings as Record<string, unknown> | undefined
    if (settings?.videoFrameRate) {
      const fr = settings.videoFrameRate as Record<string, unknown>
      frameRate = {
        numerator: Number(fr.numerator ?? 24000),
        denominator: Number(fr.denominator ?? 1001),
        value: Number(fr.numerator ?? 24000) / Number(fr.denominator ?? 1001),
      }
    } else if (typeof seq.getSettings === 'function') {
      // Alternative: UXP API may use getSettings() method
      const settingsObj = (seq.getSettings as () => Record<string, unknown>)()
      if (settingsObj?.videoFrameRate) {
        const fr = settingsObj.videoFrameRate as Record<string, unknown>
        frameRate = {
          numerator: Number(fr.numerator ?? 24000),
          denominator: Number(fr.denominator ?? 1001),
          value: Number(fr.numerator ?? 24000) / Number(fr.denominator ?? 1001),
        }
      }
    }
  } catch (error) {
    logger.debug('Could not read frame rate, using default', error)
  }

  const duration = Number(seq.end ?? 0) - Number(seq.start ?? 0)

  logger.debug('Mapped sequence', {
    name: seq.name,
    videoTrackCount: videoTracks.length,
    audioTrackCount: audioTracks.length,
    totalVideoClips: videoTracks.reduce((sum, t) => sum + t.clips.length, 0),
    totalAudioClips: audioTracks.reduce((sum, t) => sum + t.clips.length, 0),
  })

  return {
    id: String(seq.sequenceID || seq.id || ''),
    name: String(seq.name || 'Untitled'),
    videoTracks,
    audioTracks,
    duration,
    frameRate,
  }
}
