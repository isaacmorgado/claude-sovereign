"""
Supplement Service
Business logic for supplement recommendations and daily stack generation
"""

from typing import Dict, List, Optional, Tuple
from app.data.supplements import (
    SUPPLEMENTS,
    PRODUCTS,
    METRIC_TO_PRODUCTS,
    CATEGORY_TO_PRODUCTS,
    get_supplement_by_id,
    get_product_by_id,
    get_product_by_supplement_id,
    get_base_stack_products,
)


class SupplementService:
    """Service for supplement recommendations"""

    def get_all_supplements(self, category: Optional[str] = None) -> List[Dict]:
        """Get all supplements, optionally filtered by category"""
        if category:
            return [s for s in SUPPLEMENTS if s["category"] == category]
        return SUPPLEMENTS

    def get_all_products(self, category: Optional[str] = None) -> List[Dict]:
        """Get all products, optionally filtered by category"""
        if category:
            return [p for p in PRODUCTS if p["category"] == category]
        return PRODUCTS

    def generate_daily_stack(
        self,
        gender: str,
        age: Optional[int] = None
    ) -> Dict:
        """
        Generate universal daily stack for a user.

        Args:
            gender: 'male' or 'female'
            age: Optional user age for age-specific additions

        Returns:
            DailyStack with products, timing, cost, and rationale
        """
        # Get base 6 products that everyone needs
        stack_products = get_base_stack_products()

        # Add gender-specific boosters (male gets Ashwagandha)
        if gender == "male":
            ashwagandha = get_product_by_id("ashwagandha_now")
            if ashwagandha:
                stack_products.append(ashwagandha)

        # Add age-specific boosters (30+ gets NMN)
        if age and age >= 30:
            nmn = get_product_by_id("nmn_prohealth")
            if nmn:
                stack_products.append(nmn)

        # Calculate total cost
        total_cost_min = 0
        total_cost_max = 0
        for product in stack_products:
            supplement = get_supplement_by_id(product["supplementId"])
            if supplement:
                total_cost_min += supplement["costPerMonth"]["min"]
                total_cost_max += supplement["costPerMonth"]["max"]

        # Organize by timing
        morning_ids = [
            "vitamin_c_now", "d3_k2_sports_research", "creatine_optimum",
            "ashwagandha_now", "nmn_prohealth"
        ]
        evening_ids = ["magnesium_doctors_best", "omega3_nordic"]

        timing = {
            "morning": [p for p in stack_products if p["id"] in morning_ids],
            "evening": [p for p in stack_products if p["id"] in evening_ids],
            "anytime": [p for p in stack_products if p["id"] not in morning_ids + evening_ids],
        }

        # Rationale message
        if gender == "male":
            rationale = (
                "This foundation stack supports skin elasticity, bone structure, "
                "hormonal balance, and inflammation control - the pillars of facial "
                "aesthetics and long-term appearance preservation."
            )
        else:
            rationale = (
                "This foundation stack supports collagen production, bone density, "
                "skin health, and hormonal balance - essential for maintaining facial "
                "aesthetics and preventing age-related changes."
            )

        return {
            "products": stack_products,
            "totalCostPerMonth": {
                "min": round(total_cost_min),
                "max": round(total_cost_max),
            },
            "timing": timing,
            "rationale": rationale,
        }

    def get_product_recommendations(
        self,
        metrics_dict: Dict[str, float],
        severity_dict: Dict[str, str],
        gender: str,
        ethnicity: Optional[str] = None
    ) -> Tuple[List[Dict], int, int]:
        """
        Generate product recommendations based on user metrics.

        Args:
            metrics_dict: Metric name -> value
            severity_dict: Metric name -> severity level
            gender: 'male' or 'female'
            ethnicity: Optional ethnicity for customization

        Returns:
            Tuple of (recommendations list, flaw_count, ideal_count)
        """
        recommendations: List[Dict] = []
        seen_products: set = set()
        flaw_count = 0
        ideal_count = 0

        # Iterate through all metrics
        for metric_name, metric_value in metrics_dict.items():
            severity = severity_dict.get(metric_name)
            if not severity:
                continue

            # Determine state and urgency
            state: str
            urgency: str
            message_template: str

            if severity in ("severe", "extremely_severe"):
                state = "flaw"
                urgency = "high"
                message_template = "Your {metric} is WEAK (bottom 10%). Use {product} to IMPROVE it."
                flaw_count += 1
            elif severity in ("moderate", "major"):
                state = "flaw"
                urgency = "medium"
                message_template = "Your {metric} needs improvement. Use {product} to optimize it."
                flaw_count += 1
            elif severity in ("optimal", "ideal"):
                state = "ideal"
                urgency = "low"
                message_template = "Your {metric} is ELITE (top 10%). Use {product} to MAINTAIN and PROTECT this strength."
                ideal_count += 1
            else:
                # Skip "minor" or "good" - not compelling enough
                continue

            # Find products for this metric
            product_ids = METRIC_TO_PRODUCTS.get(metric_name)

            # If no direct mapping, try category fallback
            if not product_ids:
                metric_lower = metric_name.lower()
                if "skin" in metric_lower or "texture" in metric_lower:
                    product_ids = CATEGORY_TO_PRODUCTS["skin"]
                elif "jaw" in metric_lower or "chin" in metric_lower or "bone" in metric_lower:
                    product_ids = CATEGORY_TO_PRODUCTS["bone"]
                elif "hair" in metric_lower:
                    product_ids = CATEGORY_TO_PRODUCTS["hair"]
                else:
                    product_ids = CATEGORY_TO_PRODUCTS["general"]

            # Create recommendations for each product (max 2 per metric)
            for supplement_id in product_ids[:2]:
                # Find product by supplement ID
                product = get_product_by_supplement_id(supplement_id)
                if not product:
                    continue

                # Skip if already recommended
                if product["id"] in seen_products:
                    # Just add this metric to existing recommendation
                    for rec in recommendations:
                        if rec["product"]["id"] == product["id"]:
                            if metric_name not in rec["matchedMetrics"]:
                                rec["matchedMetrics"].append(metric_name)
                            break
                    continue

                # Get supplement details
                supplement = get_supplement_by_id(supplement_id)
                product_display_name = supplement["name"] if supplement else product["name"]

                # Create personalized message
                message = message_template.replace("{metric}", metric_name).replace("{product}", product_display_name)

                recommendations.append({
                    "product": product,
                    "state": state,
                    "targetMetric": metric_name,
                    "message": message,
                    "urgency": urgency,
                    "matchedMetrics": [metric_name],
                    "supplement": supplement,
                })

                seen_products.add(product["id"])

        # Sort recommendations:
        # 1. High urgency flaws first
        # 2. Then medium urgency flaws
        # 3. Then ideal maintenance products
        urgency_order = {"high": 3, "medium": 2, "low": 1}
        recommendations.sort(
            key=lambda r: (
                urgency_order.get(r["urgency"], 0),
                r["product"]["priority"]
            ),
            reverse=True
        )

        # Return top 15 recommendations
        return recommendations[:15], flaw_count, ideal_count

    def get_combined_recommendations(
        self,
        metrics_dict: Dict[str, float],
        severity_dict: Dict[str, str],
        gender: str,
        age: Optional[int] = None,
        ethnicity: Optional[str] = None
    ) -> Dict:
        """
        Get both product recommendations and daily stack.

        Returns complete recommendation response.
        """
        # Get targeted recommendations
        recommendations, flaw_count, ideal_count = self.get_product_recommendations(
            metrics_dict=metrics_dict,
            severity_dict=severity_dict,
            gender=gender,
            ethnicity=ethnicity
        )

        # Get daily stack
        daily_stack = self.generate_daily_stack(gender=gender, age=age)

        return {
            "recommendations": recommendations,
            "dailyStack": daily_stack,
            "flawCount": flaw_count,
            "idealCount": ideal_count,
        }


# Singleton instance
supplement_service = SupplementService()
