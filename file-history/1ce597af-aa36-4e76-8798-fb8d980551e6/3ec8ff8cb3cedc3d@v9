/**
 * Slice 7: Apply Takes to Timeline
 *
 * Timeline manipulation functions:
 * - Label clips with take information
 * - Delete non-best takes
 */

/**
 * Initialize the Label Clips on Timeline button
 */
function initLabelTimeline() {
  document.getElementById('labelTimelineBtn').addEventListener('click', async () => {
    const btn = document.getElementById('labelTimelineBtn');
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
      setStatus('No takes to label');
      return;
    }

    btn.disabled = true;
    setStatus('Labeling clips on timeline...');

    try {
      const context = await getActiveSequence();
      if (!context) {
        setStatus('No project or sequence open');
        btn.disabled = false;
        return;
      }

      const { sequence } = context;

      // Find clips and rename them based on which take they fall into
      // Note: razorAllTracksAtTime not available in UXP - label existing clips
      const videoTrackCount = await sequence.getVideoTrackCount();
      let labeledCount = 0;

      for (let i = 0; i < videoTrackCount; i++) {
        const track = await sequence.getVideoTrack(i);
        if (!track) continue;

        const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
        if (!clips) continue;

        for (let j = 0; j < clips.length; j++) {
          const clip = clips[j];
          if (!clip) continue;

          const clipStartObj = await clip.getStartTime();
          // TickTime is an object - extract the ticks value
          const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
          const clipStartSec = clipStart / TICKS_PER_SECOND;

          // Find which take this clip belongs to
          for (const take of takes) {
            if (clipStartSec >= take.start && clipStartSec < take.end) {
              // Short label: "★ Best Take 1" or "Take 2"
              const prefix = take.isBest ? '★ Best ' : '';
              const label = `${prefix}Take ${take.takeNumber}`;

              // UXP action pattern: action must be created INSIDE executeTransaction
              const project = await ppro.Project.getActiveProject();
              const clipRef = clip;
              const labelRef = label;

              project.lockedAccess(() => {
                project.executeTransaction((compoundAction) => {
                  const setNameAction = clipRef.createSetNameAction(labelRef);
                  compoundAction.addAction(setNameAction);
                }, 'SPLICE: Label Clip');
              });
              labeledCount++;
              break;
            }
          }
        }
      }

      setStatus(`Labeled ${labeledCount} clip(s) on timeline`);

    } catch (err) {
      setStatus(`Label error: ${err.message}`);
      console.error('SPLICE label error:', err);
    }

    btn.disabled = false;
  });
}

/**
 * Initialize the Keep Best Takes Only button
 */
function initApplyTakes() {
  document.getElementById('applyTakesBtn').addEventListener('click', async () => {
    const btn = document.getElementById('applyTakesBtn');
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
      setStatus('No takes to apply');
      return;
    }

    btn.disabled = true;
    setStatus('Applying takes to timeline...');

    try {
      const context = await getActiveSequence();
      if (!context) {
        setStatus('No project or sequence open');
        btn.disabled = false;
        return;
      }

      const { sequence } = context;

      // Sort takes by start time (descending) - work from end to avoid time shifts
      const sortedTakes = [...takes].sort((a, b) => b.start - a.start);

      let deletedCount = 0;

      for (const take of sortedTakes) {
        if (take.isBest) {
          continue; // Keep best takes
        }

        // Convert seconds to ticks
        const startTicks = Math.floor(take.start * TICKS_PER_SECOND);
        const endTicks = Math.floor(take.end * TICKS_PER_SECOND);

        // Note: razorAllTracksAtTime not available in UXP
        // Delete clips that fall within non-best take range
        // Process both video and audio tracks
        const videoTrackCount = await sequence.getVideoTrackCount();
        const audioTrackCount = await sequence.getAudioTrackCount();

        // Process video tracks
        for (let i = 0; i < videoTrackCount; i++) {
          const track = await sequence.getVideoTrack(i);
          if (!track) continue;

          const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
          if (!clips) continue;

          for (let j = clips.length - 1; j >= 0; j--) {
            const clip = clips[j];
            if (!clip) continue;

            const clipStartObj = await clip.getStartTime();
            const clipEndObj = await clip.getEndTime();
            const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
            const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

            // Check if clip is within the non-best take range
            if (clipStart >= startTicks && clipEnd <= endTicks) {
              // No createRemoveAction in UXP - disable clips instead
              const project = await ppro.Project.getActiveProject();
              const clipRef = clip;

              project.lockedAccess(() => {
                project.executeTransaction((compoundAction) => {
                  const disableAction = clipRef.createSetDisabledAction(true);
                  compoundAction.addAction(disableAction);
                }, 'SPLICE: Disable Non-Best Take');
              });
              deletedCount++;
            }
          }
        }

        // Process audio tracks
        for (let i = 0; i < audioTrackCount; i++) {
          const track = await sequence.getAudioTrack(i);
          if (!track) continue;

          const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
          if (!clips) continue;

          for (let j = clips.length - 1; j >= 0; j--) {
            const clip = clips[j];
            if (!clip) continue;

            const clipStartObj = await clip.getStartTime();
            const clipEndObj = await clip.getEndTime();
            const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
            const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

            // Check if clip is within the non-best take range
            if (clipStart >= startTicks && clipEnd <= endTicks) {
              // No createRemoveAction in UXP - disable clips instead
              const project = await ppro.Project.getActiveProject();
              const clipRef = clip;

              project.lockedAccess(() => {
                project.executeTransaction((compoundAction) => {
                  const disableAction = clipRef.createSetDisabledAction(true);
                  compoundAction.addAction(disableAction);
                }, 'SPLICE: Disable Non-Best Take');
              });
              deletedCount++;
            }
          }
        }
      }

      const keptTakes = takes.filter(t => t.isBest).length;
      setStatus(`Applied: kept ${keptTakes} best take(s), disabled ${deletedCount} clip(s)`);

    } catch (err) {
      setStatus(`Apply error: ${err.message}`);
      console.error('SPLICE apply error:', err);
    }

    btn.disabled = false;
  });
}
