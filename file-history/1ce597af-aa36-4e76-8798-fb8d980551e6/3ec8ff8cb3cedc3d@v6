/**
 * Slice 7: Apply Takes to Timeline
 *
 * Timeline manipulation functions:
 * - Label clips with take information
 * - Delete non-best takes
 */

/**
 * Initialize the Label Clips on Timeline button
 */
function initLabelTimeline() {
  document.getElementById('labelTimelineBtn').addEventListener('click', async () => {
    const btn = document.getElementById('labelTimelineBtn');
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
      setStatus('No takes to label');
      return;
    }

    btn.disabled = true;
    setStatus('Labeling clips on timeline...');

    try {
      const context = await getActiveSequence();
      if (!context) {
        setStatus('No project or sequence open');
        btn.disabled = false;
        return;
      }

      const { sequence } = context;

      // Find clips and rename them based on which take they fall into
      // Note: razorAllTracksAtTime not available in UXP - label existing clips
      const videoTrackCount = await sequence.getVideoTrackCount();
      let labeledCount = 0;

      // DEBUG: Log take ranges
      console.log('SPLICE DEBUG: Take ranges (in seconds):');
      for (const take of takes) {
        console.log(`  Take ${take.takeNumber}: ${take.start.toFixed(2)}s - ${take.end.toFixed(2)}s`);
      }

      for (let i = 0; i < videoTrackCount; i++) {
        const track = await sequence.getVideoTrack(i);
        if (!track) continue;

        const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
        if (!clips) continue;

        console.log(`SPLICE DEBUG: Track ${i} has ${clips.length} clip(s)`);

        for (let j = 0; j < clips.length; j++) {
          const clip = clips[j];
          if (!clip) continue;

          const clipStartObj = await clip.getStartTime();
          // TickTime is an object - extract the ticks value
          const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
          const clipStartSec = clipStart / TICKS_PER_SECOND;

          console.log(`SPLICE DEBUG: Clip ${j} starts at ${clipStartSec.toFixed(2)}s (ticks=${clipStart}, raw=${JSON.stringify(clipStartObj)})`);

          // Find which take this clip belongs to
          for (const take of takes) {
            if (clipStartSec >= take.start && clipStartSec < take.end) {
              // Build label: "Take N - [first words]" with star if best
              const prefix = take.isBest ? 'â˜… ' : '';
              const shortDesc = take.description.substring(0, 30);
              const label = `${prefix}Take ${take.takeNumber} - ${shortDesc}`;

              // UXP action pattern: lockedAccess + executeTransaction
              try {
                const setNameAction = await clip.createSetNameAction(label);
                await ppro.app.project.lockedAccess(async (lockedProject) => {
                  const compoundAction = await lockedProject.createCompoundAction('Set Clip Name');
                  await compoundAction.addAction(setNameAction);
                  await lockedProject.executeTransaction(compoundAction);
                });
                console.log(`SPLICE DEBUG: Labeled clip as "${label}"`);
              } catch (nameErr) {
                console.log(`SPLICE DEBUG: Name set failed: ${nameErr.message}`);
              }
              labeledCount++;
              break;
            }
          }
        }
      }

      setStatus(`Labeled ${labeledCount} clip(s) on timeline`);

    } catch (err) {
      setStatus(`Label error: ${err.message}`);
      console.error('SPLICE label error:', err);
    }

    btn.disabled = false;
  });
}

/**
 * Initialize the Keep Best Takes Only button
 */
function initApplyTakes() {
  document.getElementById('applyTakesBtn').addEventListener('click', async () => {
    const btn = document.getElementById('applyTakesBtn');
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
      setStatus('No takes to apply');
      return;
    }

    btn.disabled = true;
    setStatus('Applying takes to timeline...');

    try {
      const context = await getActiveSequence();
      if (!context) {
        setStatus('No project or sequence open');
        btn.disabled = false;
        return;
      }

      const { sequence } = context;

      // Sort takes by start time (descending) - work from end to avoid time shifts
      const sortedTakes = [...takes].sort((a, b) => b.start - a.start);

      let deletedCount = 0;

      for (const take of sortedTakes) {
        if (take.isBest) {
          continue; // Keep best takes
        }

        // Convert seconds to ticks
        const startTicks = Math.floor(take.start * TICKS_PER_SECOND);
        const endTicks = Math.floor(take.end * TICKS_PER_SECOND);

        // Note: razorAllTracksAtTime not available in UXP
        // Delete clips that fall within non-best take range
        // Process both video and audio tracks
        const videoTrackCount = await sequence.getVideoTrackCount();
        const audioTrackCount = await sequence.getAudioTrackCount();

        // Process video tracks
        for (let i = 0; i < videoTrackCount; i++) {
          const track = await sequence.getVideoTrack(i);
          if (!track) continue;

          const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
          if (!clips) continue;

          for (let j = clips.length - 1; j >= 0; j--) {
            const clip = clips[j];
            if (!clip) continue;

            const clipStartObj = await clip.getStartTime();
            const clipEndObj = await clip.getEndTime();
            const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
            const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

            // Check if clip is within the non-best take range
            if (clipStart >= startTicks && clipEnd <= endTicks) {
              const removeAction = await clip.createRemoveAction ? await clip.createRemoveAction() : null;
              if (removeAction) {
                await removeAction.execute();
              } else {
                await clip.remove();
              }
              deletedCount++;
            }
          }
        }

        // Process audio tracks
        for (let i = 0; i < audioTrackCount; i++) {
          const track = await sequence.getAudioTrack(i);
          if (!track) continue;

          const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
          if (!clips) continue;

          for (let j = clips.length - 1; j >= 0; j--) {
            const clip = clips[j];
            if (!clip) continue;

            const clipStartObj = await clip.getStartTime();
            const clipEndObj = await clip.getEndTime();
            const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
            const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

            // Check if clip is within the non-best take range
            if (clipStart >= startTicks && clipEnd <= endTicks) {
              const removeAction = await clip.createRemoveAction ? await clip.createRemoveAction() : null;
              if (removeAction) {
                await removeAction.execute();
              } else {
                await clip.remove();
              }
              deletedCount++;
            }
          }
        }
      }

      const keptTakes = takes.filter(t => t.isBest).length;
      setStatus(`Applied: kept ${keptTakes} best take(s), removed ${deletedCount} clip segment(s)`);

    } catch (err) {
      setStatus(`Apply error: ${err.message}`);
      console.error('SPLICE apply error:', err);
    }

    btn.disabled = false;
  });
}
