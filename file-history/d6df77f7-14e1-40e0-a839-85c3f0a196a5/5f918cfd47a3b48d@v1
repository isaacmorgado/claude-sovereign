/**
 * SPLICE Chapter Detection Service
 *
 * Analyzes transcripts to identify natural chapter/topic boundaries.
 * Uses GPT-4o-mini for intelligent topic segmentation.
 *
 * Features:
 * - Automatic chapter boundary detection
 * - YouTube timestamp format generation
 * - Timeline marker data for Premiere Pro
 * - Configurable chapter count and minimum length
 */

const OpenAI = require('openai');

// Lazy-load OpenAI client to avoid errors when API key is not set
let openai = null;
function getOpenAI() {
  if (!openai) {
    openai = new OpenAI();
  }
  return openai;
}

/**
 * Detect chapters in a transcript using AI
 * @param {Object} transcript - Transcript with text and/or segments
 * @param {Object} settings - Detection settings
 * @returns {Promise<Object>} Detected chapters, timestamps, and markers
 */
async function detectChapters(transcript, settings = {}) {
  const {
    maxChapters = 10,
    minChapterLength = 60, // seconds
    // language = 'en', // reserved for future i18n
    titleStyle = 'standard' // 'standard', 'youtube', 'shorts'
  } = settings;

  // Get full text from transcript
  const text = extractText(transcript);

  if (!text || text.length < 100) {
    console.log('[SPLICE Chapters] Transcript too short for chapter detection');
    return {
      chapters: [],
      youtubeTimestamps: '',
      markers: [],
      metadata: {
        chapterCount: 0,
        reason: 'transcript_too_short'
      }
    };
  }

  // Get duration
  const duration = transcript.duration ||
    (transcript.segments?.length > 0 ? transcript.segments[transcript.segments.length - 1].end : 0);

  if (duration < minChapterLength * 2) {
    console.log('[SPLICE Chapters] Content too short for multiple chapters');
    return {
      chapters: [{
        startTime: 0,
        title: 'Full Video',
        description: 'Video content'
      }],
      youtubeTimestamps: '0:00 Full Video',
      markers: [{
        time: 0,
        name: 'Full Video',
        comment: 'Video content'
      }],
      metadata: {
        chapterCount: 1,
        reason: 'single_chapter'
      }
    };
  }

  console.log(`[SPLICE Chapters] Analyzing transcript (${text.length} chars, ${Math.floor(duration)}s)`);

  try {
    const prompt = buildChapterPrompt(text, maxChapters, minChapterLength, duration, titleStyle);

    const response = await getOpenAI().chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `You are a video chapter detection expert. Analyze transcripts to identify natural topic changes and chapter boundaries. Return structured JSON with accurate timestamps.`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 1000,
      response_format: { type: 'json_object' }
    });

    const content = response.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No response from AI service');
    }
    const result = JSON.parse(content);
    const chapters = result.chapters || result || [];

    // Validate and clean chapters
    const validChapters = validateChapters(chapters, duration, minChapterLength);

    // Generate YouTube timestamps
    const youtubeTimestamps = formatYouTubeTimestamps(validChapters);

    // Generate marker data
    const markers = validChapters.map(ch => ({
      time: ch.startTime,
      name: ch.title,
      comment: ch.description || '',
      keywords: ch.keywords || []
    }));

    console.log(`[SPLICE Chapters] Detected ${validChapters.length} chapters`);

    return {
      chapters: validChapters,
      youtubeTimestamps,
      markers,
      metadata: {
        chapterCount: validChapters.length,
        duration,
        model: 'gpt-4o-mini',
        titleStyle
      }
    };

  } catch (err) {
    console.error('[SPLICE Chapters] Detection error:', err);
    throw new Error(`Chapter detection failed: ${err.message}`);
  }
}

/**
 * Extract plain text from transcript
 * @param {Object} transcript - Transcript object
 * @returns {string} Plain text
 */
function extractText(transcript) {
  if (typeof transcript === 'string') {
    return transcript;
  }

  if (transcript.text) {
    return transcript.text;
  }

  if (transcript.segments) {
    return transcript.segments
      .map(s => s.text || s.content || '')
      .join(' ')
      .trim();
  }

  if (transcript.words) {
    return transcript.words
      .map(w => w.word || w.text || '')
      .join(' ')
      .trim();
  }

  return '';
}

/**
 * Build the prompt for chapter detection
 * @param {string} text - Transcript text
 * @param {number} maxChapters - Maximum chapters
 * @param {number} minLength - Minimum chapter length
 * @param {number} duration - Total duration
 * @param {string} titleStyle - Title style: 'standard', 'youtube', 'shorts'
 * @returns {string} Formatted prompt
 */
function buildChapterPrompt(text, maxChapters, minLength, duration, titleStyle = 'standard') {
  // Truncate text if too long (keep first 15000 chars)
  const truncatedText = text.length > 15000 ? text.substring(0, 15000) + '...' : text;

  // Get title style rules based on format
  let titleRules = '';
  switch (titleStyle) {
    case 'youtube':
      titleRules = `TITLE STYLE (YouTube Long-Form):
- Create engaging, SEO-optimized titles (5-8 words max)
- Use keywords that viewers might search for
- Make titles compelling and clickable
- Include relevant topic keywords
- Avoid clickbait but be interesting
- Example: "Setting Up Your Development Environment"`;
      break;
    case 'shorts':
      titleRules = `TITLE STYLE (YouTube Shorts/TikTok):
- Create punchy, hook-style titles (3-5 words max)
- Use action words and emotional triggers
- Make it scroll-stopping and urgent
- Keep it ultra-concise for mobile
- Example: "This Changes Everything" or "Wait For It..."`;
      break;
    default:
      titleRules = `TITLE STYLE:
- Create short, descriptive titles (3-5 words max)
- Focus on the main topic of each section
- Be clear and informative`;
  }

  return `Analyze this transcript and identify natural chapter breaks.

RULES:
- Maximum ${maxChapters} chapters
- Minimum ${minLength} seconds between chapters
- First chapter MUST start at 0 seconds
- Total video duration is ${Math.floor(duration)} seconds
- Identify topic/subject changes

${titleRules}

TRANSCRIPT:
${truncatedText}

Return JSON in this exact format:
{
  "chapters": [
    {
      "startTime": 0,
      "title": "Introduction",
      "description": "Brief description of this chapter",
      "keywords": ["keyword1", "keyword2"]
    },
    {
      "startTime": 120,
      "title": "Main Topic",
      "description": "Description of what happens",
      "keywords": ["topic", "subject"]
    }
  ]
}

IMPORTANT:
- startTime values must be in SECONDS as numbers, not strings.
- Include 2-3 relevant keywords for each chapter for SEO.`;
}

/**
 * Validate and clean detected chapters
 * @param {Array} chapters - Raw chapters from AI
 * @param {number} duration - Total duration
 * @param {number} minLength - Minimum chapter length
 * @returns {Array} Validated chapters
 */
function validateChapters(chapters, duration, minLength) {
  if (!Array.isArray(chapters)) {
    return [{
      startTime: 0,
      title: 'Video',
      description: 'Full video content'
    }];
  }

  const validChapters = [];
  let lastTime = -minLength;

  // Sort by start time
  const sorted = [...chapters].sort((a, b) => {
    const aTime = parseFloat(a.startTime) || 0;
    const bTime = parseFloat(b.startTime) || 0;
    return aTime - bTime;
  });

  for (const chapter of sorted) {
    const startTime = parseFloat(chapter.startTime) || 0;

    // Skip if too close to last chapter
    if (startTime - lastTime < minLength && validChapters.length > 0) {
      continue;
    }

    // Skip if past duration
    if (startTime >= duration) {
      continue;
    }

    // Ensure title exists
    const title = (chapter.title || 'Chapter ' + (validChapters.length + 1)).substring(0, 50);
    const description = (chapter.description || '').substring(0, 200);

    // Preserve keywords if provided by AI
    const keywords = Array.isArray(chapter.keywords) ? chapter.keywords.slice(0, 5) : [];

    validChapters.push({
      startTime: parseFloat(startTime.toFixed(2)),
      title,
      description,
      keywords
    });

    lastTime = startTime;
  }

  // Ensure first chapter starts at 0
  if (validChapters.length > 0 && validChapters[0].startTime > 0) {
    validChapters.unshift({
      startTime: 0,
      title: 'Introduction',
      description: 'Video introduction'
    });
  }

  // Ensure at least one chapter
  if (validChapters.length === 0) {
    validChapters.push({
      startTime: 0,
      title: 'Video',
      description: 'Full video content'
    });
  }

  return validChapters;
}

/**
 * Format chapters as YouTube timestamps
 * @param {Array} chapters - Array of chapter objects
 * @returns {string} YouTube-formatted timestamp string
 */
function formatYouTubeTimestamps(chapters) {
  return chapters.map(ch => {
    const totalSeconds = Math.floor(ch.startTime);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    let time;
    if (hours > 0) {
      time = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
      time = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    return `${time} ${ch.title}`;
  }).join('\n');
}

/**
 * Detect chapters from segments (fallback without AI)
 * Uses silence gaps and segment boundaries
 * @param {Object} transcript - Transcript with segments
 * @param {Object} settings - Detection settings
 * @returns {Object} Detected chapters
 */
function detectChaptersFallback(transcript, settings = {}) {
  const {
    minChapterLength = 120,
    gapThreshold = 3 // seconds of silence to consider chapter break
  } = settings;

  const segments = transcript.segments || [];
  if (segments.length === 0) {
    return {
      chapters: [{ startTime: 0, title: 'Video', description: '' }],
      youtubeTimestamps: '0:00 Video',
      markers: [{ time: 0, name: 'Video', comment: '' }],
      metadata: { chapterCount: 1, method: 'fallback' }
    };
  }

  const chapters = [{ startTime: 0, title: 'Chapter 1', description: '' }];
  let chapterNum = 2;
  let lastEnd = 0;
  let lastChapterTime = 0;

  for (const segment of segments) {
    const gap = segment.start - lastEnd;

    // Large gap indicates potential chapter break
    if (gap >= gapThreshold && segment.start - lastChapterTime >= minChapterLength) {
      chapters.push({
        startTime: parseFloat(segment.start.toFixed(2)),
        title: `Chapter ${chapterNum}`,
        description: ''
      });
      chapterNum++;
      lastChapterTime = segment.start;
    }

    lastEnd = segment.end;
  }

  return {
    chapters,
    youtubeTimestamps: formatYouTubeTimestamps(chapters),
    markers: chapters.map(ch => ({
      time: ch.startTime,
      name: ch.title,
      comment: ch.description
    })),
    metadata: {
      chapterCount: chapters.length,
      method: 'fallback'
    }
  };
}

/**
 * Generate chapter divider data for timeline insertion
 * Creates divider clips with text, colors, and animation data
 * @param {Array} chapters - Array of chapter objects
 * @param {Object} settings - Divider settings
 * @returns {Object} Divider data for builder insertion
 */
function generateChapterDividers(chapters, settings = {}) {
  const {
    duration = 3, // seconds per divider
    style = 'gradient', // 'gradient', 'solid', 'minimal'
    colorScheme = 'blue', // 'blue', 'purple', 'green', 'orange', 'custom'
    fadeIn = 0.5,
    fadeOut = 0.5,
    fontSize = 72,
    fontFamily = 'Arial',
    position = 'center', // 'center', 'lower-third', 'top'
    includeChapterNumber = true,
    customColors = null
  } = settings;

  // Color schemes for gradients
  const colorSchemes = {
    blue: { start: '#1e3a8a', end: '#3b82f6', text: '#ffffff' },
    purple: { start: '#581c87', end: '#a855f7', text: '#ffffff' },
    green: { start: '#14532d', end: '#22c55e', text: '#ffffff' },
    orange: { start: '#7c2d12', end: '#f97316', text: '#ffffff' },
    red: { start: '#7f1d1d', end: '#ef4444', text: '#ffffff' },
    custom: customColors || { start: '#000000', end: '#333333', text: '#ffffff' }
  };

  const colors = colorSchemes[colorScheme] || colorSchemes.blue;

  // Position presets (as percentages)
  const positions = {
    'center': { x: 50, y: 50 },
    'lower-third': { x: 50, y: 80 },
    'top': { x: 50, y: 20 }
  };

  const pos = positions[position] || positions.center;

  const dividers = chapters.map((chapter, index) => {
    const chapterNum = index + 1;
    const displayTitle = includeChapterNumber
      ? `Chapter ${chapterNum}: ${chapter.title}`
      : chapter.title;

    return {
      // Timing
      insertTime: chapter.startTime,
      duration: duration,
      fadeIn: fadeIn,
      fadeOut: fadeOut,

      // Content
      chapterNumber: chapterNum,
      title: chapter.title,
      displayTitle: displayTitle,
      description: chapter.description || '',
      keywords: chapter.keywords || [],

      // Styling
      style: style,
      colors: {
        background: colors.start,
        backgroundEnd: colors.end,
        text: colors.text
      },

      // Text properties
      font: {
        family: fontFamily,
        size: fontSize,
        weight: 'bold'
      },

      // Position (percentages)
      position: {
        x: pos.x,
        y: pos.y
      },

      // Animation
      animation: {
        type: 'fade',
        easeIn: 'ease-out',
        easeOut: 'ease-in'
      },

      // Marker for Premiere Pro
      markerData: {
        time: chapter.startTime,
        name: `SPLICE: ${displayTitle}`,
        comment: `Chapter divider - ${chapter.description || 'No description'}`,
        colorIndex: 5 // Cerulean
      }
    };
  });

  return {
    dividers,
    settings: {
      duration,
      style,
      colorScheme,
      position,
      fadeIn,
      fadeOut
    },
    metadata: {
      count: dividers.length,
      totalDuration: dividers.length * duration
    }
  };
}

/**
 * Get available divider styles and color schemes
 * @returns {Object} Available options
 */
function getDividerPresets() {
  return {
    styles: [
      { id: 'gradient', name: 'Gradient', description: 'Smooth color gradient background' },
      { id: 'solid', name: 'Solid', description: 'Single color background' },
      { id: 'minimal', name: 'Minimal', description: 'Text only with subtle shadow' }
    ],
    colorSchemes: [
      { id: 'blue', name: 'Blue', colors: { start: '#1e3a8a', end: '#3b82f6' } },
      { id: 'purple', name: 'Purple', colors: { start: '#581c87', end: '#a855f7' } },
      { id: 'green', name: 'Green', colors: { start: '#14532d', end: '#22c55e' } },
      { id: 'orange', name: 'Orange', colors: { start: '#7c2d12', end: '#f97316' } },
      { id: 'red', name: 'Red', colors: { start: '#7f1d1d', end: '#ef4444' } }
    ],
    positions: [
      { id: 'center', name: 'Center', y: 50 },
      { id: 'lower-third', name: 'Lower Third', y: 80 },
      { id: 'top', name: 'Top', y: 20 }
    ],
    defaults: {
      duration: 3,
      fadeIn: 0.5,
      fadeOut: 0.5,
      fontSize: 72,
      style: 'gradient',
      colorScheme: 'blue',
      position: 'center'
    }
  };
}

module.exports = {
  detectChapters,
  detectChaptersFallback,
  formatYouTubeTimestamps,
  extractText,
  validateChapters,
  generateChapterDividers,
  getDividerPresets
};
