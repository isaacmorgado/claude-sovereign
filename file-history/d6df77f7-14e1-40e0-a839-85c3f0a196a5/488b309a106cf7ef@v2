/**
 * SPLICE Animated Captions Service
 *
 * Generates word-by-word animated captions with popular styles.
 * Supports keyword highlighting, emoji insertion, and multiple export formats.
 */

const OpenAI = require('openai');

// Lazy-load OpenAI client
let openai = null;
function getOpenAI() {
  if (!openai) {
    openai = new OpenAI();
  }
  return openai;
}

// ============================================================================
// TEMPLATE DEFINITIONS
// ============================================================================

const TEMPLATES = {
  mrbeast: {
    id: 'mrbeast',
    name: 'MrBeast',
    description: 'Bold, uppercase, colorful with shake animation',
    style: {
      fontFamily: 'Impact',
      fontSize: 72,
      fontWeight: 'bold',
      textTransform: 'uppercase',
      color: '#FFFFFF',
      strokeColor: '#000000',
      strokeWidth: 4,
      shadowColor: 'rgba(0,0,0,0.8)',
      shadowBlur: 8,
      position: 'bottom-center',
      padding: 20
    },
    animation: {
      type: 'shake-scale',
      duration: 0.15,
      scale: 1.2,
      shake: 3,
      easing: 'ease-out'
    },
    highlight: {
      enabled: true,
      color: '#FFFF00',
      keywords: ['amazing', 'insane', 'crazy', 'million', 'thousand', 'win', 'lose', 'money', 'challenge']
    }
  },

  hormozi: {
    id: 'hormozi',
    name: 'Hormozi',
    description: 'Clean, yellow highlight bar, professional',
    style: {
      fontFamily: 'Arial Black',
      fontSize: 64,
      fontWeight: 'bold',
      textTransform: 'none',
      color: '#FFFFFF',
      strokeColor: '#000000',
      strokeWidth: 2,
      backgroundColor: 'rgba(0,0,0,0.7)',
      position: 'bottom-center',
      padding: 16
    },
    animation: {
      type: 'slide-in',
      duration: 0.2,
      direction: 'left',
      easing: 'ease-out'
    },
    highlight: {
      enabled: true,
      color: '#FFD700',
      backgroundColor: '#FFD700',
      textColor: '#000000',
      keywords: ['money', 'business', 'million', 'profit', 'revenue', 'growth', 'scale']
    }
  },

  gaming: {
    id: 'gaming',
    name: 'Gaming',
    description: 'Neon glow, glitch effects, fast transitions',
    style: {
      fontFamily: 'Orbitron',
      fontSize: 56,
      fontWeight: 'bold',
      textTransform: 'uppercase',
      color: '#00FF00',
      strokeColor: '#000000',
      strokeWidth: 2,
      glowColor: '#00FF00',
      glowBlur: 15,
      position: 'bottom-center',
      padding: 12
    },
    animation: {
      type: 'glitch',
      duration: 0.1,
      glitchIntensity: 5,
      chromatic: true,
      easing: 'linear'
    },
    highlight: {
      enabled: true,
      color: '#FF00FF',
      glowColor: '#FF00FF',
      keywords: ['kill', 'win', 'gg', 'clutch', 'epic', 'legendary', 'headshot', 'victory']
    }
  },

  corporate: {
    id: 'corporate',
    name: 'Corporate',
    description: 'Subtle, professional, clean fade animations',
    style: {
      fontFamily: 'Helvetica Neue',
      fontSize: 48,
      fontWeight: '500',
      textTransform: 'none',
      color: '#FFFFFF',
      strokeColor: 'transparent',
      strokeWidth: 0,
      backgroundColor: 'rgba(0,0,0,0.6)',
      borderRadius: 8,
      position: 'bottom-center',
      padding: 20
    },
    animation: {
      type: 'fade',
      duration: 0.3,
      easing: 'ease-in-out'
    },
    highlight: {
      enabled: false,
      color: '#3B82F6',
      keywords: []
    }
  },

  karaoke: {
    id: 'karaoke',
    name: 'Karaoke',
    description: 'Word-by-word highlight bar, progressive fill',
    style: {
      fontFamily: 'Arial',
      fontSize: 60,
      fontWeight: 'bold',
      textTransform: 'none',
      color: '#FFFFFF',
      highlightColor: '#FFD700',
      strokeColor: '#000000',
      strokeWidth: 3,
      position: 'bottom-center',
      padding: 16
    },
    animation: {
      type: 'progressive-fill',
      duration: 'word-timed',
      fillDirection: 'left-to-right',
      easing: 'linear'
    },
    highlight: {
      enabled: true,
      mode: 'progressive',
      color: '#FFD700',
      keywords: []
    }
  }
};

// ============================================================================
// EMOJI MAPPINGS
// ============================================================================

const EMOJI_MAPPINGS = {
  // Emotions
  happy: 'üòä', excited: 'üéâ', sad: 'üò¢', angry: 'üò†', love: '‚ù§Ô∏è', laugh: 'üòÇ',
  surprise: 'üòÆ', think: 'ü§î', cool: 'üòé', fire: 'üî•', hot: 'üî•',

  // Actions
  win: 'üèÜ', lose: 'üòû', money: 'üí∞', work: 'üíº', sleep: 'üò¥', eat: 'üçΩÔ∏è',
  drink: 'üç∫', play: 'üéÆ', music: 'üéµ', video: 'üé¨', phone: 'üì±',

  // Objects
  car: 'üöó', house: 'üè†', computer: 'üíª', camera: 'üì∑', book: 'üìö',

  // Emphasis
  important: '‚ö†Ô∏è', question: '‚ùì', check: '‚úÖ', cross: '‚ùå', star: '‚≠ê',
  rocket: 'üöÄ', target: 'üéØ', idea: 'üí°', time: '‚è∞', point: 'üëâ'
};

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Generate animated captions from transcript
 * @param {Object} transcript - Transcript with words array (word, start, end)
 * @param {string} templateId - Template to apply
 * @param {Object} settings - Custom settings
 * @returns {Promise<Object>} Animated caption data
 */
async function generateAnimatedCaptions(transcript, templateId = 'mrbeast', settings = {}) {
  const {
    maxWordsPerLine = 4,
    highlightKeywords = true,
    insertEmojis = false,
    emojiFrequency = 'medium', // low, medium, high
    customKeywords = []
    // language = 'en' - reserved for future i18n
  } = settings;

  // Get template
  const template = TEMPLATES[templateId] || TEMPLATES.mrbeast;

  // Extract words from transcript
  const words = extractWords(transcript);

  if (!words || words.length === 0) {
    return {
      success: false,
      error: 'No words found in transcript',
      captions: []
    };
  }

  console.log(`[SPLICE Captions] Generating ${templateId} captions for ${words.length} words`);

  // Group words into caption lines
  const lines = groupWordsIntoLines(words, maxWordsPerLine);

  // Detect keywords if enabled
  let keywords = [];
  if (highlightKeywords) {
    keywords = await detectKeywords(transcript, {
      customKeywords,
      templateKeywords: template.highlight.keywords || []
    });
  }

  // Generate caption data for each line
  const captions = lines.map((line, index) => {
    const lineWords = line.words.map(word => {
      const isKeyword = keywords.some(kw =>
        word.word.toLowerCase().includes(kw.toLowerCase())
      );

      return {
        word: word.word,
        start: word.start,
        end: word.end,
        isKeyword,
        emoji: insertEmojis ? getEmojiForWord(word.word, emojiFrequency) : null
      };
    });

    return {
      id: `caption_${index}`,
      lineNumber: index + 1,
      text: line.text,
      words: lineWords,
      start: line.start,
      end: line.end,
      duration: line.end - line.start,
      template: templateId,
      style: { ...template.style },
      animation: { ...template.animation }
    };
  });

  // Insert emojis if enabled
  let finalCaptions = captions;
  if (insertEmojis) {
    finalCaptions = addEmojisToCaption(captions, emojiFrequency);
  }

  return {
    success: true,
    template: templateId,
    templateInfo: {
      name: template.name,
      description: template.description
    },
    totalCaptions: finalCaptions.length,
    totalWords: words.length,
    duration: words[words.length - 1]?.end || 0,
    captions: finalCaptions,
    keywords: keywords,
    metadata: {
      maxWordsPerLine,
      highlightKeywords,
      insertEmojis,
      emojiFrequency
    }
  };
}

/**
 * Detect keywords using AI
 * @param {Object} transcript - Transcript data
 * @param {Object} options - Detection options
 * @returns {Promise<string[]>} Array of keywords
 */
async function detectKeywords(transcript, options = {}) {
  const {
    customKeywords = [],
    templateKeywords = [],
    maxKeywords = 20,
    useAI = true
  } = options;

  // Start with template and custom keywords
  let keywords = [...new Set([...templateKeywords, ...customKeywords])];

  if (!useAI) {
    return keywords.slice(0, maxKeywords);
  }

  // Extract text
  const text = extractText(transcript);
  if (!text || text.length < 50) {
    return keywords.slice(0, maxKeywords);
  }

  try {
    console.log('[SPLICE Captions] Detecting keywords with AI...');

    const response = await getOpenAI().chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are a keyword extraction expert. Extract impactful words that should be highlighted in video captions for emphasis and engagement.'
        },
        {
          role: 'user',
          content: `Extract ${maxKeywords} keywords from this transcript that would be impactful to highlight in animated captions. Focus on: numbers, emotional words, action words, important nouns, and phrases that viewers would want emphasized.

TRANSCRIPT:
${text.substring(0, 3000)}

Return JSON: { "keywords": ["word1", "word2", ...] }`
        }
      ],
      temperature: 0.5,
      max_tokens: 200,
      response_format: { type: 'json_object' }
    });

    const content = response.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No response from AI service');
    }
    const result = JSON.parse(content);
    const aiKeywords = result.keywords || [];

    // Merge with existing keywords
    keywords = [...new Set([...keywords, ...aiKeywords])];

    console.log(`[SPLICE Captions] Detected ${aiKeywords.length} AI keywords`);

  } catch (err) {
    console.error('[SPLICE Captions] Keyword detection error:', err.message);
    // Continue with template/custom keywords only
  }

  return keywords.slice(0, maxKeywords);
}

/**
 * Insert emojis into transcript based on context
 * @param {Object} transcript - Transcript data
 * @param {Object} options - Emoji options
 * @returns {Promise<Object>} Transcript with emoji suggestions
 */
async function insertEmojis(transcript, options = {}) {
  const {
    frequency = 'medium', // low (~1 per 30 words), medium (~1 per 15 words), high (~1 per 8 words)
    // position = 'after', // before, after, replace - reserved for future use
    useAI = true
  } = options;

  const frequencyMap = { low: 30, medium: 15, high: 8 };
  const interval = frequencyMap[frequency] || 15;

  const words = extractWords(transcript);
  if (!words || words.length === 0) {
    return { success: false, error: 'No words found', emojis: [] };
  }

  const emojis = [];

  if (useAI) {
    // Use AI to suggest contextual emojis
    try {
      const text = extractText(transcript);
      const response = await getOpenAI().chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'You suggest contextually appropriate emojis for video captions. Return relevant emojis that match the tone and content.'
          },
          {
            role: 'user',
            content: `Suggest emojis to insert into this transcript at approximately every ${interval} words. Return the word index and emoji.

TRANSCRIPT (${words.length} words):
${text.substring(0, 2000)}

Return JSON: { "emojis": [{ "afterWordIndex": 5, "emoji": "üî•" }, ...] }`
          }
        ],
        temperature: 0.7,
        max_tokens: 300,
        response_format: { type: 'json_object' }
      });

      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error('No response from AI service');
      }
      const result = JSON.parse(content);
      emojis.push(...(result.emojis || []));

    } catch (err) {
      console.error('[SPLICE Captions] Emoji insertion error:', err.message);
      // Fall back to rule-based
    }
  }

  // Rule-based fallback/supplement
  if (emojis.length === 0) {
    words.forEach((word, index) => {
      if (index % interval === 0 && index > 0) {
        const emoji = getEmojiForWord(word.word, frequency);
        if (emoji) {
          emojis.push({ afterWordIndex: index, emoji, word: word.word });
        }
      }
    });
  }

  return {
    success: true,
    totalEmojis: emojis.length,
    frequency,
    emojis
  };
}

/**
 * Apply template to caption data
 * @param {Object} captionData - Existing caption data
 * @param {string} templateId - Template to apply
 * @returns {Object} Caption data with new template applied
 */
function applyTemplate(captionData, templateId) {
  const template = TEMPLATES[templateId];
  if (!template) {
    return {
      success: false,
      error: `Template '${templateId}' not found`,
      availableTemplates: Object.keys(TEMPLATES)
    };
  }

  const updatedCaptions = captionData.captions.map(caption => ({
    ...caption,
    template: templateId,
    style: { ...template.style },
    animation: { ...template.animation }
  }));

  return {
    success: true,
    template: templateId,
    templateInfo: {
      name: template.name,
      description: template.description
    },
    captions: updatedCaptions
  };
}

/**
 * Generate MOGRT-compatible data for After Effects/Premiere
 * @param {Array} captions - Caption data array
 * @param {Object} settings - MOGRT settings
 * @returns {Object} MOGRT-compatible JSON
 */
function generateMOGRTData(captions, settings = {}) {
  const {
    frameRate = 30,
    width = 1920,
    height = 1080,
    outputFormat = 'json'
  } = settings;

  const mogrtData = {
    version: '1.0',
    type: 'animated_captions',
    composition: {
      width,
      height,
      frameRate,
      duration: captions.length > 0 ? captions[captions.length - 1].end : 0
    },
    layers: captions.map((caption, index) => ({
      id: `text_layer_${index}`,
      type: 'text',
      name: `Caption ${index + 1}`,
      inPoint: Math.round(caption.start * frameRate),
      outPoint: Math.round(caption.end * frameRate),
      inPointSeconds: caption.start,
      outPointSeconds: caption.end,
      content: {
        text: caption.text,
        words: caption.words.map(w => ({
          text: w.word,
          inFrame: Math.round(w.start * frameRate),
          outFrame: Math.round(w.end * frameRate),
          isKeyword: w.isKeyword || false,
          emoji: w.emoji || null
        }))
      },
      style: caption.style,
      animation: {
        ...caption.animation,
        keyframes: generateKeyframes(caption, frameRate)
      }
    })),
    metadata: {
      totalLayers: captions.length,
      generatedAt: new Date().toISOString(),
      generator: 'SPLICE Animated Captions'
    }
  };

  return {
    success: true,
    format: outputFormat,
    data: mogrtData
  };
}

/**
 * Export captions burned into video (requires FFmpeg)
 * @param {string} videoPath - Source video path
 * @param {Array} captions - Caption data
 * @param {string} outputPath - Output video path
 * @returns {Promise<Object>} Export result
 */
async function exportBurnedInCaptions(videoPath, captions, outputPath) {
  // This would require FFmpeg integration
  // For now, return ASS subtitle format that can be burned in

  const assContent = generateASSSubtitles(captions);

  return {
    success: true,
    format: 'ass',
    subtitleContent: assContent,
    ffmpegCommand: `ffmpeg -i "${videoPath}" -vf "ass=captions.ass" -c:a copy "${outputPath}"`,
    instructions: 'Save subtitleContent to captions.ass and run the ffmpegCommand'
  };
}

/**
 * Get all available templates
 * @returns {Object} Templates with metadata
 */
function getTemplates() {
  return {
    templates: Object.values(TEMPLATES).map(t => ({
      id: t.id,
      name: t.name,
      description: t.description,
      previewStyle: {
        fontFamily: t.style.fontFamily,
        color: t.style.color,
        animation: t.animation.type
      }
    })),
    count: Object.keys(TEMPLATES).length
  };
}

/**
 * Get template by ID
 * @param {string} templateId - Template ID
 * @returns {Object|null} Template or null
 */
function getTemplateById(templateId) {
  return TEMPLATES[templateId] || null;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Extract words array from transcript
 */
function extractWords(transcript) {
  if (!transcript) return [];

  // Direct words array
  if (Array.isArray(transcript.words)) {
    return transcript.words.map(w => ({
      word: w.word || w.text || '',
      start: w.start || 0,
      end: w.end || 0
    }));
  }

  // Words in segments
  if (Array.isArray(transcript.segments)) {
    const words = [];
    transcript.segments.forEach(seg => {
      if (Array.isArray(seg.words)) {
        seg.words.forEach(w => {
          words.push({
            word: w.word || w.text || '',
            start: w.start || 0,
            end: w.end || 0
          });
        });
      }
    });
    return words;
  }

  return [];
}

/**
 * Extract plain text from transcript
 */
function extractText(transcript) {
  if (typeof transcript === 'string') return transcript;
  if (transcript.text) return transcript.text;

  const words = extractWords(transcript);
  return words.map(w => w.word).join(' ');
}

/**
 * Group words into caption lines
 */
function groupWordsIntoLines(words, maxWordsPerLine = 4) {
  const lines = [];
  let currentLine = { words: [], text: '', start: 0, end: 0 };

  words.forEach((word, index) => {
    if (currentLine.words.length === 0) {
      currentLine.start = word.start;
    }

    currentLine.words.push(word);
    currentLine.end = word.end;

    // Check if we should start a new line
    const shouldBreak =
      currentLine.words.length >= maxWordsPerLine ||
      (word.word.endsWith('.') || word.word.endsWith('!') || word.word.endsWith('?'));

    if (shouldBreak || index === words.length - 1) {
      currentLine.text = currentLine.words.map(w => w.word).join(' ');
      lines.push({ ...currentLine });
      currentLine = { words: [], text: '', start: 0, end: 0 };
    }
  });

  return lines;
}

/**
 * Get emoji for a word based on mappings
 */
function getEmojiForWord(word, frequency = 'medium') {
  const lowerWord = word.toLowerCase().replace(/[^a-z]/g, '');

  // Direct mapping
  if (EMOJI_MAPPINGS[lowerWord]) {
    return EMOJI_MAPPINGS[lowerWord];
  }

  // Partial matches for high frequency
  if (frequency === 'high') {
    for (const [key, emoji] of Object.entries(EMOJI_MAPPINGS)) {
      if (lowerWord.includes(key) || key.includes(lowerWord)) {
        return emoji;
      }
    }
  }

  return null;
}

/**
 * Add emojis to captions
 */
function addEmojisToCaption(captions, frequency) {
  const frequencyMap = { low: 3, medium: 2, high: 1 };
  const interval = frequencyMap[frequency] || 2;

  return captions.map((caption, index) => {
    if (index % interval === 0) {
      // Try to find an emoji for any word in the caption
      for (const word of caption.words) {
        const emoji = getEmojiForWord(word.word, frequency);
        if (emoji) {
          return {
            ...caption,
            emoji,
            text: `${caption.text} ${emoji}`
          };
        }
      }
    }
    return caption;
  });
}

/**
 * Generate animation keyframes
 */
function generateKeyframes(caption, frameRate) {
  const { animation, start, end } = caption;
  const startFrame = Math.round(start * frameRate);
  const endFrame = Math.round(end * frameRate);
  const duration = animation.duration === 'word-timed' ?
    (end - start) / caption.words.length :
    animation.duration;
  const durationFrames = Math.round(duration * frameRate);

  const keyframes = [];

  switch (animation.type) {
    case 'shake-scale':
      keyframes.push(
        { frame: startFrame, scale: 1, x: 0, y: 0, opacity: 0 },
        { frame: startFrame + 2, scale: animation.scale || 1.2, x: 0, y: 0, opacity: 1 },
        { frame: startFrame + 4, scale: 1, x: animation.shake || 3, y: 0, opacity: 1 },
        { frame: startFrame + 6, scale: 1, x: -(animation.shake || 3), y: 0, opacity: 1 },
        { frame: startFrame + 8, scale: 1, x: 0, y: 0, opacity: 1 },
        { frame: endFrame - 2, scale: 1, x: 0, y: 0, opacity: 1 },
        { frame: endFrame, scale: 0.8, x: 0, y: 0, opacity: 0 }
      );
      break;

    case 'slide-in': {
      const direction = animation.direction || 'left';
      const offset = direction === 'left' ? -100 : 100;
      keyframes.push(
        { frame: startFrame, x: offset, opacity: 0 },
        { frame: startFrame + durationFrames, x: 0, opacity: 1 },
        { frame: endFrame - durationFrames, x: 0, opacity: 1 },
        { frame: endFrame, x: -offset, opacity: 0 }
      );
      break;
    }

    case 'glitch':
      keyframes.push(
        { frame: startFrame, opacity: 0, glitch: 0 },
        { frame: startFrame + 1, opacity: 1, glitch: animation.glitchIntensity || 5 },
        { frame: startFrame + 2, opacity: 1, glitch: 0 },
        { frame: startFrame + 3, opacity: 0.5, glitch: animation.glitchIntensity || 5 },
        { frame: startFrame + 4, opacity: 1, glitch: 0 },
        { frame: endFrame, opacity: 0, glitch: 0 }
      );
      break;

    case 'fade':
      keyframes.push(
        { frame: startFrame, opacity: 0 },
        { frame: startFrame + durationFrames, opacity: 1 },
        { frame: endFrame - durationFrames, opacity: 1 },
        { frame: endFrame, opacity: 0 }
      );
      break;

    case 'progressive-fill':
      // For karaoke-style, generate keyframe per word
      caption.words.forEach((word, i) => {
        const wordStart = Math.round(word.start * frameRate);
        // wordEnd could be used for duration-based animations
        keyframes.push({
          frame: wordStart,
          wordIndex: i,
          fillProgress: i / caption.words.length,
          highlighted: true
        });
      });
      break;

    default:
      keyframes.push(
        { frame: startFrame, opacity: 1 },
        { frame: endFrame, opacity: 1 }
      );
  }

  return keyframes;
}

/**
 * Generate ASS subtitle format
 */
function generateASSSubtitles(captions) {
  const template = captions[0]?.style || TEMPLATES.mrbeast.style;

  let ass = `[Script Info]
Title: SPLICE Animated Captions
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${template.fontFamily || 'Arial'},${template.fontSize || 64},&H00FFFFFF,&H000000FF,&H00000000,&H80000000,1,0,0,0,100,100,0,0,1,3,2,2,10,10,50,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  captions.forEach(caption => {
    const start = formatASSTime(caption.start);
    const end = formatASSTime(caption.end);
    // Escape special characters and add styling
    const text = caption.text.replace(/\\/g, '\\\\').replace(/\n/g, '\\N');
    ass += `Dialogue: 0,${start},${end},Default,,0,0,0,,${text}\n`;
  });

  return ass;
}

/**
 * Format time for ASS subtitles
 */
function formatASSTime(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  const cs = Math.floor((seconds % 1) * 100);
  return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports = {
  generateAnimatedCaptions,
  detectKeywords,
  insertEmojis,
  applyTemplate,
  generateMOGRTData,
  exportBurnedInCaptions,
  getTemplates,
  getTemplateById,
  // Helpers exposed for testing
  extractWords,
  extractText,
  groupWordsIntoLines,
  getEmojiForWord,
  TEMPLATES,
  EMOJI_MAPPINGS
};
