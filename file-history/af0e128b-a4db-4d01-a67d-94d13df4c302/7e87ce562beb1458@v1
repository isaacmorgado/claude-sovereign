/**
 * Advanced Multitrack Balancing E2E Test
 *
 * Tests Feature 7: GA-optimized multitrack balancing with constraints
 */

const assert = require('assert');
const fs = require('fs');
const path = require('path');

let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`  ✓ ${name}`);
    passed++;
  } catch (err) {
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${err.message}`);
    failed++;
  }
}

// Load files
const serverJs = fs.readFileSync(path.join(__dirname, '../server.js'), 'utf8');
const multitrackJs = fs.readFileSync(path.join(__dirname, '../services/multitrackAnalysis.js'), 'utf8');

console.log('\n=== Advanced Multitrack Balancing E2E Tests ===\n');

// === 1. Service Functions ===
console.log('=== 1. Service Functions ===');

test('advancedBalanceMultitrack function exists', () => {
  assert.ok(multitrackJs.includes('async function advancedBalanceMultitrack'),
    'advancedBalanceMultitrack function should exist');
});

test('Function accepts maxConsecutiveSeconds parameter', () => {
  assert.ok(multitrackJs.includes('maxConsecutiveSeconds = 30'),
    'Should accept maxConsecutiveSeconds with default 30');
});

test('Function accepts momentumFactor parameter', () => {
  assert.ok(multitrackJs.includes('momentumFactor = 0.7'),
    'Should accept momentumFactor with default 0.7');
});

test('Function accepts populationSize parameter', () => {
  assert.ok(multitrackJs.includes('populationSize = 20'),
    'Should accept populationSize with default 20');
});

test('Function accepts generations parameter', () => {
  assert.ok(multitrackJs.includes('generations = 10'),
    'Should accept generations with default 10');
});

test('Function accepts mutationRate parameter', () => {
  assert.ok(multitrackJs.includes('mutationRate = 0.1'),
    'Should accept mutationRate with default 0.1');
});

test('Function accepts targetDistribution parameter', () => {
  assert.ok(multitrackJs.includes('targetDistribution = null'),
    'Should accept targetDistribution parameter');
});

// === 2. Genetic Algorithm Components ===
console.log('\n=== 2. Genetic Algorithm Components ===');

test('generatePopulation function exists', () => {
  assert.ok(multitrackJs.includes('function generatePopulation(speakerNames, size)'),
    'generatePopulation function should exist');
});

test('generatePopulation creates baseline individual', () => {
  assert.ok(multitrackJs.includes('Always include baseline'),
    'Should include baseline with no boosts');
});

test('evaluateFitness calculates distribution error', () => {
  assert.ok(multitrackJs.includes('Distribution error'),
    'Should calculate distribution error');
});

test('evaluateFitness penalizes consecutive speaker', () => {
  assert.ok(multitrackJs.includes('Consecutive speaker penalty'),
    'Should penalize consecutive speaker duration');
  assert.ok(multitrackJs.includes('currentDuration > maxConsecutiveSeconds'),
    'Should check against maxConsecutiveSeconds');
});

test('Implements selection (survival of fittest)', () => {
  assert.ok(multitrackJs.includes('keep top 50%') || multitrackJs.includes('Selection'),
    'Should implement selection');
});

test('Implements crossover', () => {
  assert.ok(multitrackJs.includes('Crossover'),
    'Should implement crossover');
  assert.ok(multitrackJs.includes('parent1') && multitrackJs.includes('parent2'),
    'Should select two parents');
});

test('Implements mutation', () => {
  assert.ok(multitrackJs.includes('Mutation'),
    'Should implement mutation');
  assert.ok(multitrackJs.includes('Math.random() < mutationRate'),
    'Should use mutation rate');
});

// === 3. Momentum Feature ===
console.log('\n=== 3. Momentum Feature ===');

test('applyMomentum function exists', () => {
  assert.ok(multitrackJs.includes('function applyMomentum(result, momentumFactor, maxConsecutive)'),
    'applyMomentum function should exist');
});

test('applyMomentum calculates switch probability', () => {
  assert.ok(multitrackJs.includes('switchProbability = 1 - momentumFactor'),
    'Should calculate switch probability from momentum factor');
});

test('applyMomentum forces switch when max consecutive exceeded', () => {
  assert.ok(multitrackJs.includes('forcedSwitch = currentDuration >= maxConsecutive'),
    'Should force switch when max consecutive exceeded');
});

test('applyMomentum merges decisions when momentum prevents switch', () => {
  assert.ok(multitrackJs.includes('Momentum prevents switch'),
    'Should handle momentum preventing switch');
});

test('applyMomentum recalculates speaker percentages', () => {
  assert.ok(multitrackJs.includes('Recalculate speaker percentages'),
    'Should recalculate speaker percentages after adjustment');
});

// === 4. Module Exports ===
console.log('\n=== 4. Module Exports ===');

test('advancedBalanceMultitrack is exported', () => {
  assert.ok(multitrackJs.includes('advancedBalanceMultitrack,'),
    'advancedBalanceMultitrack should be exported');
});

test('generatePopulation is exported', () => {
  assert.ok(multitrackJs.includes('generatePopulation,'),
    'generatePopulation should be exported');
});

test('applyMomentum is exported', () => {
  assert.ok(multitrackJs.includes('applyMomentum,'),
    'applyMomentum should be exported');
});

// === 5. Server Endpoint ===
console.log('\n=== 5. Server Endpoint ===');

test('POST /multitrack/advanced-balance endpoint exists', () => {
  assert.ok(serverJs.includes("app.post('/multitrack/advanced-balance'"),
    'POST /multitrack/advanced-balance endpoint should exist');
});

test('Endpoint requires credits', () => {
  assert.ok(serverJs.includes("requireCredits({ endpoint: 'multitrack-advanced' })"),
    'Endpoint should require credits');
});

test('Endpoint accepts advanced parameters', () => {
  assert.ok(serverJs.includes('maxConsecutiveSeconds = 30'),
    'Should accept maxConsecutiveSeconds');
  assert.ok(serverJs.includes('momentumFactor = 0.7'),
    'Should accept momentumFactor');
  assert.ok(serverJs.includes('populationSize = 20'),
    'Should accept populationSize');
  assert.ok(serverJs.includes('generations = 10'),
    'Should accept generations');
});

test('Endpoint validates constraint ranges', () => {
  assert.ok(serverJs.includes('maxConsecutiveSeconds < 5 || maxConsecutiveSeconds > 120'),
    'Should validate maxConsecutiveSeconds range');
  assert.ok(serverJs.includes('momentumFactor < 0 || momentumFactor > 1'),
    'Should validate momentumFactor range');
});

test('Endpoint calls advancedBalanceMultitrack', () => {
  assert.ok(serverJs.includes('await advancedBalanceMultitrack(audioPaths'),
    'Should call advancedBalanceMultitrack');
});

test('Endpoint is documented in API list', () => {
  assert.ok(serverJs.includes("'POST /multitrack/advanced-balance':"),
    'Endpoint should be in API documentation');
});

test('Server imports advancedBalanceMultitrack', () => {
  assert.ok(serverJs.includes('advancedBalanceMultitrack'),
    'Should import advancedBalanceMultitrack from multitrackAnalysis');
});

// === 6. Response Format ===
console.log('\n=== 6. Response Format ===');

test('Returns advanced flag', () => {
  assert.ok(multitrackJs.includes('advanced: true'),
    'Should return advanced: true flag');
});

test('Returns constraints object', () => {
  assert.ok(multitrackJs.includes('constraints: {'),
    'Should return constraints object');
});

test('Returns speakerBoosts', () => {
  assert.ok(multitrackJs.includes('speakerBoosts: bestIndividual'),
    'Should return optimized speakerBoosts');
});

test('Returns finalError', () => {
  assert.ok(multitrackJs.includes('finalError: bestFitness'),
    'Should return final fitness error');
});

test('Returns momentumApplied flag in metadata', () => {
  assert.ok(multitrackJs.includes('momentumApplied: true'),
    'Should return momentumApplied flag when momentum is applied');
});

// === Summary ===
console.log('\n=== Summary ===');
console.log(`Passed: ${passed}`);
console.log(`Failed: ${failed}`);
console.log(`Total:  ${passed + failed}`);

if (failed === 0) {
  console.log('\n✓ All tests passed!');
} else {
  console.log('\n✗ Some tests failed');
}

process.exit(failed > 0 ? 1 : 0);
