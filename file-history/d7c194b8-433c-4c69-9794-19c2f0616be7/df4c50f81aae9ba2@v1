/**
 * SPLICE CEP Panel - Animated Captions Module
 * Word-by-word animated captions with template gallery and preview
 * v4.0.0 - CEP Migration
 */

// ============================================================================
// STATE
// ============================================================================
const animatedCaptionsState = {
    templates: [],
    selectedTemplate: 'mrbeast',
    captions: null,
    keywords: [],
    settings: {
        maxWordsPerLine: 4,
        highlightKeywords: true,
        insertEmojis: false,
        emojiFrequency: 'medium'
    },
    isGenerating: false,
    lastTranscript: null
};

// ============================================================================
// DOM ELEMENT CACHE
// ============================================================================
const captionsUI = {};

function cacheCaptionElements() {
    captionsUI.section = document.getElementById('captionsSection');
    captionsUI.toggle = document.getElementById('captionsToggle');
    captionsUI.panel = document.getElementById('captionsPanel');
    captionsUI.templateGallery = document.getElementById('captionTemplateGallery');
    captionsUI.previewContainer = document.getElementById('captionPreviewContainer');
    captionsUI.stats = document.getElementById('captionStats');
    captionsUI.status = document.getElementById('captionStatus');

    // Settings
    captionsUI.wordsPerLine = document.getElementById('captionWordsPerLine');
    captionsUI.highlightKeywords = document.getElementById('captionHighlightKeywords');
    captionsUI.insertEmojis = document.getElementById('captionInsertEmojis');
    captionsUI.emojiFrequency = document.getElementById('captionEmojiFrequency');

    // Buttons
    captionsUI.generateBtn = document.getElementById('generateCaptionsBtn');
    captionsUI.exportSrtBtn = document.getElementById('exportCaptionsSrtBtn');
    captionsUI.exportMogrtBtn = document.getElementById('exportCaptionsMogrtBtn');
    captionsUI.applyBtn = document.getElementById('applyCaptionsBtn');
    captionsUI.copyBtn = document.getElementById('copyCaptionsBtn');
}

// ============================================================================
// INITIALIZATION
// ============================================================================
async function initAnimatedCaptions() {
    console.log('[SPLICE Captions] Initializing animated captions module');

    cacheCaptionElements();

    if (!captionsUI.section) {
        console.warn('[SPLICE Captions] Captions section not found in DOM');
        return;
    }

    // Toggle section expand/collapse
    if (captionsUI.toggle) {
        captionsUI.toggle.addEventListener('click', toggleCaptionsSection);
    }

    // Load templates
    await loadCaptionTemplates();

    // Setup event listeners
    setupCaptionEventListeners();

    // Render template gallery
    renderTemplateGallery();

    console.log('[SPLICE Captions] Module initialized');
}

// ============================================================================
// SECTION TOGGLE
// ============================================================================
function toggleCaptionsSection() {
    if (!captionsUI.panel || !captionsUI.toggle) return;

    // Check state BEFORE toggling
    const wasCollapsed = captionsUI.panel.classList.contains('collapsed');
    captionsUI.panel.classList.toggle('collapsed');
    const icon = captionsUI.toggle.querySelector('.toggle-icon');

    if (icon) {
        // If it was collapsed, it's now expanded (show -)
        icon.textContent = wasCollapsed ? '-' : '+';
    }
}

// ============================================================================
// LOAD TEMPLATES
// ============================================================================
async function loadCaptionTemplates() {
    try {
        const apiUrl = getBackendUrl();
        const response = await fetchWithTimeout(`${apiUrl}/captions/templates`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
        }, 30000);

        if (response.ok) {
            const data = await response.json();
            animatedCaptionsState.templates = data.templates || [];
            console.log(`[SPLICE Captions] Loaded ${animatedCaptionsState.templates.length} templates`);
        }
    } catch (err) {
        console.error('[SPLICE Captions] Failed to load templates:', err);
        // Use fallback templates
        animatedCaptionsState.templates = [
            { id: 'mrbeast', name: 'MrBeast', description: 'Bold, uppercase, colorful' },
            { id: 'hormozi', name: 'Hormozi', description: 'Clean, yellow highlight' },
            { id: 'gaming', name: 'Gaming', description: 'Neon glow, glitch effects' },
            { id: 'corporate', name: 'Corporate', description: 'Subtle, professional' },
            { id: 'karaoke', name: 'Karaoke', description: 'Word-by-word highlight' }
        ];
    }
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================
function setupCaptionEventListeners() {
    // Template gallery delegation
    if (captionsUI.templateGallery) {
        captionsUI.templateGallery.addEventListener('click', (e) => {
            const card = e.target.closest('.caption-template-card');
            if (card) {
                selectCaptionTemplate(card.dataset.templateId);
            }
        });
    }

    // Generate button
    if (captionsUI.generateBtn) {
        captionsUI.generateBtn.addEventListener('click', generateCaptions);
    }

    // Export buttons
    if (captionsUI.exportSrtBtn) {
        captionsUI.exportSrtBtn.addEventListener('click', () => exportCaptions('srt'));
    }
    if (captionsUI.exportMogrtBtn) {
        captionsUI.exportMogrtBtn.addEventListener('click', () => exportCaptions('mogrt'));
    }

    // Apply to timeline button
    if (captionsUI.applyBtn) {
        captionsUI.applyBtn.addEventListener('click', applyCaptionsToTimeline);
    }

    // Copy button
    if (captionsUI.copyBtn) {
        captionsUI.copyBtn.addEventListener('click', copyCaptionsToClipboard);
    }

    // Settings changes
    if (captionsUI.wordsPerLine) {
        captionsUI.wordsPerLine.addEventListener('change', (e) => {
            animatedCaptionsState.settings.maxWordsPerLine = parseInt(e.target.value) || 4;
        });
    }
    if (captionsUI.highlightKeywords) {
        captionsUI.highlightKeywords.addEventListener('change', (e) => {
            animatedCaptionsState.settings.highlightKeywords = e.target.checked;
        });
    }
    if (captionsUI.insertEmojis) {
        captionsUI.insertEmojis.addEventListener('change', (e) => {
            animatedCaptionsState.settings.insertEmojis = e.target.checked;
            // Toggle emoji frequency group visibility
            const emojiFrequencyGroup = document.getElementById('emojiFrequencyGroup');
            if (emojiFrequencyGroup) {
                emojiFrequencyGroup.style.display = e.target.checked ? 'block' : 'none';
            }
        });
    }
    if (captionsUI.emojiFrequency) {
        captionsUI.emojiFrequency.addEventListener('change', (e) => {
            animatedCaptionsState.settings.emojiFrequency = e.target.value;
        });
    }
}

// ============================================================================
// TEMPLATE GALLERY
// ============================================================================
function renderTemplateGallery() {
    if (!captionsUI.templateGallery) return;

    const fragment = document.createDocumentFragment();

    animatedCaptionsState.templates.forEach(template => {
        const card = document.createElement('div');
        card.className = `caption-template-card ${animatedCaptionsState.selectedTemplate === template.id ? 'selected' : ''}`;
        card.dataset.templateId = template.id;
        card.setAttribute('role', 'button');
        card.setAttribute('tabindex', '0');
        card.setAttribute('aria-label', `Select ${escapeHtmlCaptions(template.name)} template`);

        // SECURITY: Escape template data to prevent XSS (even though it comes from backend/fallback)
        const safeId = escapeHtmlCaptions(template.id);
        const safeName = escapeHtmlCaptions(template.name);
        const safeDesc = escapeHtmlCaptions(template.description);

        card.innerHTML = `
            <div class="template-preview template-preview-${safeId}">
                <span class="template-preview-text">Hello World</span>
            </div>
            <div class="template-info">
                <span class="template-name">${safeName}</span>
                <span class="template-desc">${safeDesc}</span>
            </div>
        `;

        fragment.appendChild(card);
    });

    captionsUI.templateGallery.innerHTML = '';
    captionsUI.templateGallery.appendChild(fragment);
}

function selectCaptionTemplate(templateId) {
    animatedCaptionsState.selectedTemplate = templateId;

    // Update UI
    document.querySelectorAll('.caption-template-card').forEach(card => {
        card.classList.toggle('selected', card.dataset.templateId === templateId);
    });

    console.log(`[SPLICE Captions] Selected template: ${templateId}`);

    // Re-apply template if we have captions
    if (animatedCaptionsState.captions) {
        applyTemplateToExisting(templateId);
    }
}

async function applyTemplateToExisting(templateId) {
    if (!animatedCaptionsState.captions) return;

    try {
        const apiUrl = getBackendUrl();
        const response = await fetchWithTimeout(`${apiUrl}/captions/apply-template`, {
            method: 'POST',
            headers: getAuthHeaders(),
            body: JSON.stringify({
                captionData: { captions: animatedCaptionsState.captions },
                templateId
            })
        }, 30000);

        if (response.ok) {
            const data = await response.json();
            animatedCaptionsState.captions = data.captions;
            renderCaptionPreview();
        }
    } catch (err) {
        console.error('[SPLICE Captions] Failed to apply template:', err);
    }
}

// ============================================================================
// CAPTION GENERATION
// ============================================================================
async function generateCaptions() {
    const transcript = getLastTranscript();
    if (!transcript) {
        showCaptionStatus('No transcript available. Run transcription first.', 'error');
        return;
    }

    // Check online status
    if (typeof isOnline === 'function' && !isOnline()) {
        showCaptionStatus('Offline - Check your connection', 'error');
        return;
    }

    animatedCaptionsState.isGenerating = true;
    updateGenerateButton(true);
    showCaptionStatus('Generating animated captions...', 'info');

    try {
        const apiUrl = getBackendUrl();
        const response = await fetchWithTimeout(`${apiUrl}/captions/animate`, {
            method: 'POST',
            headers: getAuthHeaders(),
            body: JSON.stringify({
                transcript,
                template: animatedCaptionsState.selectedTemplate,
                settings: animatedCaptionsState.settings
            })
        }, 120000);

        if (!response.ok) {
            const errorMsg = await parseErrorResponse(response);
            throw new Error(errorMsg);
        }

        const data = await response.json();
        animatedCaptionsState.captions = data.captions;
        animatedCaptionsState.keywords = data.keywords || [];

        // Update UI
        renderCaptionPreview();
        updateCaptionStats(data);
        showCaptionExportActions(true);
        showCaptionStatus(`Generated ${data.totalCaptions} caption lines`, 'success');

    } catch (err) {
        console.error('[SPLICE Captions] Generation error:', err);
        showCaptionStatus(err.message, 'error');
    } finally {
        animatedCaptionsState.isGenerating = false;
        updateGenerateButton(false);
    }
}

function getLastTranscript() {
    // Try main module state
    if (window.spliceState?.lastTranscript) {
        return window.spliceState.lastTranscript;
    }
    // Try local state
    if (animatedCaptionsState.lastTranscript) {
        return animatedCaptionsState.lastTranscript;
    }
    return null;
}

function setCaptionTranscript(transcript) {
    animatedCaptionsState.lastTranscript = transcript;
}

// ============================================================================
// CAPTION PREVIEW
// ============================================================================
function renderCaptionPreview() {
    if (!captionsUI.previewContainer || !animatedCaptionsState.captions) return;

    const captions = animatedCaptionsState.captions.slice(0, 10);
    const fragment = document.createDocumentFragment();

    const list = document.createElement('div');
    list.className = 'caption-preview-list';

    captions.forEach((caption, i) => {
        const item = document.createElement('div');
        item.className = 'caption-preview-item';
        item.dataset.index = i;

        const hasKeywords = caption.words?.some(w => w.isKeyword);
        item.innerHTML = `
            <span class="caption-time">${formatCaptionTime(caption.start)}</span>
            <span class="caption-text ${hasKeywords ? 'has-keywords' : ''}">${formatCaptionText(caption)}</span>
        `;

        list.appendChild(item);
    });

    if (animatedCaptionsState.captions.length > 10) {
        const more = document.createElement('div');
        more.className = 'caption-preview-more';
        more.textContent = `+ ${animatedCaptionsState.captions.length - 10} more captions`;
        list.appendChild(more);
    }

    fragment.appendChild(list);

    captionsUI.previewContainer.innerHTML = '';
    captionsUI.previewContainer.appendChild(fragment);
}

// SECURITY: Escape HTML to prevent XSS
function escapeHtmlCaptions(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

function formatCaptionText(caption) {
    if (!caption.words) return escapeHtmlCaptions(caption.text);

    // SECURITY: Escape user-provided word content to prevent XSS
    return caption.words.map(word => {
        const safeWord = escapeHtmlCaptions(word.word);
        if (word.isKeyword) {
            return `<span class="caption-keyword">${safeWord}</span>`;
        }
        if (word.emoji) {
            const safeEmoji = escapeHtmlCaptions(word.emoji);
            return `${safeWord} ${safeEmoji}`;
        }
        return safeWord;
    }).join(' ');
}

function formatCaptionTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function updateCaptionStats(data) {
    if (!captionsUI.stats) return;

    captionsUI.stats.innerHTML = `
        <span class="stat-item">${data.totalCaptions} lines</span>
        <span class="stat-item">${data.totalWords} words</span>
        <span class="stat-item">${data.keywords?.length || 0} keywords</span>
        <span class="stat-item">${formatCaptionTime(data.duration)}</span>
    `;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================
async function exportCaptions(format) {
    if (!animatedCaptionsState.captions) {
        showCaptionStatus('No captions to export. Generate captions first.', 'error');
        return;
    }

    showCaptionStatus(`Exporting ${format.toUpperCase()}...`, 'info');

    try {
        const apiUrl = getBackendUrl();
        let endpoint, body;

        if (format === 'mogrt') {
            endpoint = '/captions/export/mogrt';
            body = {
                captions: animatedCaptionsState.captions,
                settings: { frameRate: 30, width: 1920, height: 1080 }
            };
        } else {
            endpoint = '/export/captions';
            body = {
                transcript: { words: flattenCaptionWords() },
                format
            };
        }

        const response = await fetchWithTimeout(`${apiUrl}${endpoint}`, {
            method: 'POST',
            headers: getAuthHeaders(),
            body: JSON.stringify(body)
        }, 60000);

        if (!response.ok) {
            const errorMsg = await parseErrorResponse(response);
            throw new Error(errorMsg);
        }

        const data = await response.json();

        if (format === 'mogrt') {
            downloadJSON(data.data, 'animated-captions-mogrt.json');
            showCaptionStatus('MOGRT data exported', 'success');
        } else {
            downloadText(data.content, `captions.${format}`);
            showCaptionStatus(`${format.toUpperCase()} exported`, 'success');
        }

    } catch (err) {
        console.error('[SPLICE Captions] Export error:', err);
        showCaptionStatus(err.message, 'error');
    }
}

function flattenCaptionWords() {
    if (!animatedCaptionsState.captions) return [];

    const words = [];
    animatedCaptionsState.captions.forEach(caption => {
        if (caption.words) {
            caption.words.forEach(w => words.push(w));
        }
    });
    return words;
}

async function copyCaptionsToClipboard() {
    if (!animatedCaptionsState.captions) {
        showCaptionStatus('No captions to copy', 'error');
        return;
    }

    const text = animatedCaptionsState.captions
        .map(c => `[${formatCaptionTime(c.start)}] ${c.text}`)
        .join('\n');

    try {
        await navigator.clipboard.writeText(text);
        showCaptionStatus('Captions copied to clipboard', 'success');
    } catch (err) {
        console.error('[SPLICE Captions] Copy failed:', err);
        showCaptionStatus('Failed to copy', 'error');
    }
}

// ============================================================================
// TIMELINE INTEGRATION
// ============================================================================
async function applyCaptionsToTimeline() {
    if (!animatedCaptionsState.captions) {
        showCaptionStatus('No captions to apply', 'error');
        return;
    }

    // FIX: CEP-CRIT-008 - Animated Captions Timeline Loop
    // Batch process markers (10 at a time) to prevent 15s UI freeze
    const BATCH_SIZE = 10;
    const totalCaptions = animatedCaptionsState.captions.length;
    let processed = 0;

    showCaptionStatus(`Applying ${totalCaptions} caption markers...`, 'info');

    try {
        // Process in batches
        for (let i = 0; i < totalCaptions; i += BATCH_SIZE) {
            const batch = animatedCaptionsState.captions.slice(i, i + BATCH_SIZE);

            // Process current batch
            await Promise.all(batch.map(caption => {
                const duration = caption.end - caption.start;
                return jsx.call('createMarker', caption.start, caption.text, duration, null, 5); // CERULEAN color
            }));

            processed += batch.length;

            // Update progress
            const percent = Math.round((processed / totalCaptions) * 100);
            showCaptionStatus(`Applying caption markers... ${processed}/${totalCaptions} (${percent}%)`, 'info');

            // Brief pause to prevent UI blocking
            if (processed < totalCaptions) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        showCaptionStatus(`Added ${totalCaptions} caption markers`, 'success');
    } catch (err) {
        console.error('[SPLICE Captions] Apply error:', err);
        showCaptionStatus(err.message, 'error');
    }
}

// ============================================================================
// UI HELPERS
// ============================================================================
function showCaptionExportActions(show) {
    const exportActions = document.getElementById('captionExportActions');
    if (exportActions) {
        exportActions.classList.toggle('hidden', !show);
    }
}

function showCaptionStatus(message, type = 'info') {
    if (!captionsUI.status) return;

    captionsUI.status.textContent = message;
    captionsUI.status.className = `caption-status caption-status-${type}`;

    // Auto-clear after 5 seconds for success/info
    if (type !== 'error') {
        setTimeout(() => {
            captionsUI.status.textContent = '';
            captionsUI.status.className = 'caption-status';
        }, 5000);
    }
}

function updateGenerateButton(isGenerating) {
    if (!captionsUI.generateBtn) return;

    captionsUI.generateBtn.disabled = isGenerating;
    captionsUI.generateBtn.textContent = isGenerating ? 'Generating...' : 'Generate Captions';
}

function downloadJSON(data, filename) {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

function downloadText(content, filename) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

// ============================================================================
// EXPORTS
// ============================================================================
if (typeof window !== 'undefined') {
    window.initAnimatedCaptions = initAnimatedCaptions;
    window.spliceAnimatedCaptions = {
        init: initAnimatedCaptions,
        generate: generateCaptions,
        setTranscript: setCaptionTranscript,
        selectTemplate: selectCaptionTemplate,
        export: exportCaptions,
        applyToTimeline: applyCaptionsToTimeline,
        getState: () => animatedCaptionsState
    };
}
