import { z } from 'zod';
import * as userRepository from '../db/repositories/user-repository.js';
import { hashPassword, verifyPassword } from '../utils/password.js';
import {
  generateTokenPair,
  verifyRefreshToken,
  revokeRefreshToken,
  revokeAllUserTokens,
} from '../utils/jwt.js';
import type { TokenPair } from '../types/auth.js';
import type { UserPublic } from '../types/user.js';

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number'),
  name: z.string().min(1).max(100).optional(),
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

export const refreshSchema = z.object({
  refreshToken: z.string().min(1, 'Refresh token is required'),
});

export interface AuthResult {
  user: UserPublic;
  tokens: TokenPair;
}

export class AuthError extends Error {
  constructor(
    message: string,
    public statusCode: number = 401
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export async function register(
  email: string,
  password: string,
  name?: string
): Promise<AuthResult> {
  const existingUser = await userRepository.findByEmail(email);
  if (existingUser) {
    throw new AuthError('Email already registered', 409);
  }

  const passwordHash = await hashPassword(password);
  const user = await userRepository.create({ email, password, name }, passwordHash);
  const publicUser = userRepository.toPublicUser(user);
  const tokens = await generateTokenPair(publicUser);

  return { user: publicUser, tokens };
}

export async function login(email: string, password: string): Promise<AuthResult> {
  const user = await userRepository.findByEmail(email);
  if (!user) {
    throw new AuthError('Invalid email or password');
  }

  const isValid = await verifyPassword(password, user.password_hash);
  if (!isValid) {
    throw new AuthError('Invalid email or password');
  }

  const publicUser = userRepository.toPublicUser(user);
  const tokens = await generateTokenPair(publicUser);

  return { user: publicUser, tokens };
}

export async function refresh(refreshToken: string): Promise<TokenPair> {
  const { userId, tokenId } = await verifyRefreshToken(refreshToken);

  const user = await userRepository.findById(userId);
  if (!user) {
    throw new AuthError('User not found');
  }

  await revokeRefreshToken(tokenId);

  const publicUser = userRepository.toPublicUser(user);
  return generateTokenPair(publicUser);
}

export async function logout(refreshToken: string): Promise<void> {
  try {
    const { tokenId } = await verifyRefreshToken(refreshToken);
    await revokeRefreshToken(tokenId);
  } catch {
    // Token already invalid, nothing to do
  }
}

export async function logoutAll(userId: string): Promise<void> {
  await revokeAllUserTokens(userId);
}
