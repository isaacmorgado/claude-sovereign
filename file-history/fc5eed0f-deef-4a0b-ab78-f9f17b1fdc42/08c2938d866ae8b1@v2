#!/usr/bin/env bun

/**
 * Komplete Kontrol CLI
 * Ultimate AI coding assistant integrating Roo Code, /auto, and advanced autonomous features
 */

import { Command } from 'commander';
import chalk from 'chalk';
import { createLLMClient } from './core/llm';
import type { CommandContext } from './cli/types';
import {
  AutoCommand,
  SPARCCommand,
  SwarmCommand,
  ReflectCommand,
  ResearchCommand,
  RootCauseCommand
} from './cli/commands';

const program = new Command();

program
  .name('komplete')
  .description('Ultimate AI coding assistant with autonomous capabilities')
  .version('1.0.0');

/**
 * Initialize command context
 */
async function initializeContext(): Promise<CommandContext> {
  const llmClient = await createLLMClient();

  return {
    llmRouter: llmClient.router,
    llmRegistry: llmClient.registry,
    workDir: process.cwd(),
    autonomousMode: false,
    verbose: false
  };
}

/**
 * /auto - Autonomous mode
 */
program
  .command('auto')
  .description('Enter autonomous mode with ReAct + Reflexion loop')
  .argument('<goal>', 'Goal to achieve autonomously')
  .option('-m, --model <model>', 'Model to use. Supports provider/model syntax (e.g., "glm/glm-4.7", "dolphin-3"). Default: auto-routed')
  .option('-i, --iterations <number>', 'Max iterations (default: 50)', '50')
  .option('-c, --checkpoint <number>', 'Checkpoint every N iterations (default: 10)', '10')
  .option('-v, --verbose', 'Verbose output', false)
  .action(async (goal: string, options: any) => {
    try {
      const context = await initializeContext();
      context.verbose = options.verbose;
      context.autonomousMode = true;

      const autoCommand = new AutoCommand();
      const result = await autoCommand.execute(context, {
        goal,
        model: options.model,
        maxIterations: parseInt(options.iterations, 10),
        checkpointThreshold: parseInt(options.checkpoint, 10),
        verbose: options.verbose
      });

      if (!result.success) {
        console.error(chalk.red('\nError:'), result.message);
        process.exit(1);
      }
    } catch (error) {
      const err = error as Error;
      console.error(chalk.red('\nFatal error:'), err.message);
      process.exit(1);
    }
  });

/**
 * /init - Initialize project
 */
program
  .command('init')
  .description('Initialize komplete in current project')
  .action(() => {
    console.log(chalk.green('✅ Komplete initialized'));
    console.log(chalk.gray('Created .komplete/ directory with configuration'));
  });

/**
 * /sparc - SPARC methodology
 */
program
  .command('sparc')
  .description('Execute SPARC methodology (Specification → Pseudocode → Architecture → Refinement → Completion)')
  .argument('<task>', 'Task description')
  .option('-r, --requirements <items...>', 'Requirements list')
  .option('-c, --constraints <items...>', 'Constraints list')
  .option('-v, --verbose', 'Verbose output', false)
  .action(async (task: string, options: any) => {
    try {
      const context = await initializeContext();
      context.verbose = options.verbose;

      const sparcCommand = new SPARCCommand();
      const result = await sparcCommand.execute(context, {
        task,
        requirements: options.requirements,
        constraints: options.constraints,
        verbose: options.verbose
      });

      if (!result.success) {
        console.error(chalk.red('\nError:'), result.message);
        process.exit(1);
      }
    } catch (error) {
      const err = error as Error;
      console.error(chalk.red('\nFatal error:'), err.message);
      process.exit(1);
    }
  });

/**
 * /swarm - Distributed agent swarms
 */
program
  .command('swarm')
  .description('Spawn and manage distributed agent swarms for parallel execution')
  .argument('<action>', 'Action: spawn, status, collect, clear')
  .argument('[task]', 'Task description (required for spawn)')
  .option('-n, --count <number>', 'Number of agents (for spawn)', '5')
  .option('-id, --swarm-id <id>', 'Swarm ID (for status/collect)')
  .option('-d, --dir <directory>', 'Working directory')
  .option('-v, --verbose', 'Verbose output', false)
  .action(async (action: string, task: string | undefined, options: any) => {
    try {
      const context = await initializeContext();
      context.verbose = options.verbose;

      const swarmCommand = new SwarmCommand();
      const result = await swarmCommand.execute(context, {
        action: action as 'spawn' | 'status' | 'collect' | 'clear',
        task,
        agentCount: parseInt(options.count, 10),
        swarmId: options.swarmId,
        workDir: options.dir,
        verbose: options.verbose
      });

      if (!result.success) {
        console.error(chalk.red('\nError:'), result.message);
        process.exit(1);
      }
    } catch (error) {
      const err = error as Error;
      console.error(chalk.red('\nFatal error:'), err.message);
      process.exit(1);
    }
  });

/**
 * /reflect - ReAct + Reflexion loop
 */
program
  .command('reflect')
  .description('Run ReAct + Reflexion loop (Think → Act → Observe → Reflect)')
  .argument('<goal>', 'Goal to achieve')
  .option('-i, --iterations <number>', 'Number of reflexion cycles (default: 3)', '3')
  .option('-v, --verbose', 'Verbose output', false)
  .action(async (goal: string, options: any) => {
    try {
      const context = await initializeContext();
      context.verbose = options.verbose;

      const reflectCommand = new ReflectCommand();
      const result = await reflectCommand.execute(context, {
        goal,
        iterations: parseInt(options.iterations, 10),
        verbose: options.verbose
      });

      if (!result.success) {
        console.error(chalk.red('\nError:'), result.message);
        process.exit(1);
      }
    } catch (error) {
      const err = error as Error;
      console.error(chalk.red('\nFatal error:'), err.message);
      process.exit(1);
    }
  });

/**
 * /research - Research code patterns and solutions
 */
program
  .command('research')
  .description('Research code patterns, solutions, and best practices')
  .argument('<query>', 'Research query')
  .option('-s, --sources <sources...>', 'Sources: github, memory, web (default: all)', ['github', 'memory'])
  .option('-l, --limit <number>', 'Result limit (default: 10)', '10')
  .option('--lang <languages...>', 'Filter by programming languages')
  .option('-v, --verbose', 'Verbose output', false)
  .action(async (query: string, options: any) => {
    try {
      const context = await initializeContext();
      context.verbose = options.verbose;

      const researchCommand = new ResearchCommand();
      const result = await researchCommand.execute(context, {
        query,
        sources: options.sources as ('github' | 'memory' | 'web')[],
        limit: parseInt(options.limit, 10),
        language: options.lang,
        verbose: options.verbose
      });

      if (!result.success) {
        console.error(chalk.red('\nError:'), result.message);
        process.exit(1);
      }
    } catch (error) {
      const err = error as Error;
      console.error(chalk.red('\nFatal error:'), err.message);
      process.exit(1);
    }
  });

/**
 * /rootcause - Root cause analysis
 */
program
  .command('rootcause')
  .description('Perform root cause analysis with regression detection')
  .argument('<action>', 'Action: analyze, verify')
  .option('-b, --bug <description>', 'Bug description (for analyze)')
  .option('-t, --type <type>', 'Bug type (for analyze)')
  .option('--test <command>', 'Test command (for verify)')
  .option('--snapshot <id>', 'Before snapshot ID (for verify)')
  .option('-f, --fix <description>', 'Fix description (for verify)')
  .option('-v, --verbose', 'Verbose output', false)
  .action(async (action: string, options: any) => {
    try {
      const context = await initializeContext();
      context.verbose = options.verbose;

      const rootcauseCommand = new RootCauseCommand();
      const result = await rootcauseCommand.execute(context, {
        action: action as 'analyze' | 'verify',
        bugDescription: options.bug,
        bugType: options.type,
        testCommand: options.test,
        beforeSnapshotId: options.snapshot,
        fixDescription: options.fix,
        verbose: options.verbose
      });

      if (!result.success) {
        console.error(chalk.red('\nError:'), result.message);
        process.exit(1);
      }
    } catch (error) {
      const err = error as Error;
      console.error(chalk.red('\nFatal error:'), err.message);
      process.exit(1);
    }
  });

// Error handling
program.exitOverride((err) => {
  // Help-related errors should exit cleanly
  if (err.code === 'commander.help' || err.code === 'outputHelp' ||
      err.message?.includes('outputHelp') || err.message?.includes('help')) {
    process.exit(0);
  }
  console.error(chalk.red('Error:'), err.message);
  process.exit(1);
});

program.parse();
