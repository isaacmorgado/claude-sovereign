/**
 * SPLICE CEP Panel - Builder Module
 * Handles sequence building, cut list processing, and Premiere Pro integration
 * v4.0.0 - CEP Migration
 */

// ============================================================================
// COLOR MAPPING
// ============================================================================
const SPLICE_COLORS = {
    NONE: 0,
    VIOLET: 1,
    IRIS: 2,
    CARIBBEAN: 3,
    LAVENDER: 4,
    CERULEAN: 5,
    FOREST: 6,
    ROSE: 7,
    MANGO: 8,
    PURPLE: 9,
    BLUE: 10,
    TEAL: 11,
    MAGENTA: 12,
    TAN: 13,
    GREEN: 14,
    BROWN: 15,
    YELLOW: 16
};

const SEGMENT_COLORS = {
    speech: SPLICE_COLORS.FOREST,
    take: SPLICE_COLORS.LAVENDER,
    best_take: SPLICE_COLORS.CERULEAN,
    silence: SPLICE_COLORS.VIOLET,
    wide_shot: SPLICE_COLORS.YELLOW,
    speaker_a: SPLICE_COLORS.MANGO,
    speaker_b: SPLICE_COLORS.CARIBBEAN
};

const COLOR_HINT_MAP = {
    cerulean: SPLICE_COLORS.CERULEAN,
    lavender: SPLICE_COLORS.LAVENDER,
    forest: SPLICE_COLORS.FOREST,
    mango: SPLICE_COLORS.MANGO,
    caribbean: SPLICE_COLORS.CARIBBEAN,
    yellow: SPLICE_COLORS.YELLOW,
    violet: SPLICE_COLORS.VIOLET,
    rose: SPLICE_COLORS.ROSE,
    blue: SPLICE_COLORS.BLUE,
    green: SPLICE_COLORS.GREEN
};

// ============================================================================
// PROJECT ITEM CACHE
// ============================================================================
const projectItemCache = {
    byName: new Map(),
    byPath: new Map(),
    projectId: null
};

/**
 * Build the project item cache for O(1) lookups
 */
async function buildProjectItemCache() {
    try {
        const items = await jsx.call('getAllProjectItems');

        projectItemCache.byName.clear();
        projectItemCache.byPath.clear();

        if (Array.isArray(items)) {
            items.forEach(item => {
                if (item.name) {
                    projectItemCache.byName.set(item.name, item);
                }
                if (item.mediaPath) {
                    projectItemCache.byPath.set(item.mediaPath, item);
                }
                if (item.treePath) {
                    projectItemCache.byPath.set(item.treePath, item);
                }
            });
        }

        console.log(`[Builder] Cached ${projectItemCache.byName.size} project items`);
        return true;
    } catch (e) {
        console.warn('[Builder] Failed to build cache:', e);
        return false;
    }
}

/**
 * Clear the project item cache
 */
function clearProjectItemCache() {
    projectItemCache.byName.clear();
    projectItemCache.byPath.clear();
    projectItemCache.projectId = null;
}

/**
 * Find a project item by name (uses cache)
 */
function findProjectItemByName(name) {
    return projectItemCache.byName.get(name) || null;
}

/**
 * Find a project item by path (uses cache)
 */
function findProjectItemByPath(path) {
    return projectItemCache.byPath.get(path) || null;
}

// ============================================================================
// SEQUENCE BUILDING
// ============================================================================

/**
 * Build a new sequence from a cut list
 * @param {Object} cutList - The cut list from the backend
 * @param {Object} options - Build options
 * @returns {Promise<Object>} Build result
 */
async function buildSequenceFromCutList(cutList, options = {}) {
    console.log('[Builder] Starting sequence build...');

    try {
        // Validate cut list
        if (!cutList || !cutList.segments || cutList.segments.length === 0) {
            throw new Error('Invalid cut list: no segments');
        }

        // Build cache if needed
        await buildProjectItemCache();

        // Call JSX to build the sequence
        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));

        if (result.error) {
            throw new Error(result.error);
        }

        console.log('[Builder] Sequence built successfully:', result.sequenceName);
        return {
            success: true,
            sequenceName: result.sequenceName,
            stats: result.stats
        };
    } catch (e) {
        console.error('[Builder] Build failed:', e);
        return {
            success: false,
            error: e.message
        };
    }
}

/**
 * Process a cut list and add color labels
 * @param {Object} cutList - The cut list from the backend
 * @returns {Object} Processed cut list with color indices
 */
function processCutList(cutList) {
    if (!cutList || !cutList.segments) return cutList;

    cutList.segments = cutList.segments.map(segment => {
        // Determine color index
        let colorIndex = null;

        if (segment.colorHint && COLOR_HINT_MAP[segment.colorHint] !== undefined) {
            colorIndex = COLOR_HINT_MAP[segment.colorHint];
        } else if (segment.type && SEGMENT_COLORS[segment.type] !== undefined) {
            colorIndex = SEGMENT_COLORS[segment.type];
        }

        return {
            ...segment,
            colorIndex
        };
    });

    return cutList;
}

// ============================================================================
// MARKER OPERATIONS
// ============================================================================

/**
 * Add markers to the timeline from silence data
 * @param {Array} silences - Array of silence objects
 * @param {Object} options - Marker options
 */
async function addSilenceMarkers(silences, options = {}) {
    const { colorIndex = SPLICE_COLORS.VIOLET, prefix = 'SPLICE: Silence' } = options;
    let added = 0;

    for (const silence of silences) {
        try {
            const duration = silence.end - silence.start;
            await jsx.call('createMarker', silence.start, prefix, duration, null, colorIndex);
            added++;
        } catch (e) {
            console.warn('[Builder] Failed to add silence marker:', e);
        }
    }

    return { added };
}

/**
 * Add markers to the timeline from take data
 * @param {Array} takes - Array of take objects
 * @param {Object} options - Marker options
 */
async function addTakeMarkers(takes, options = {}) {
    const { colorIndex = SPLICE_COLORS.CERULEAN } = options;
    let added = 0;

    for (const take of takes) {
        try {
            const name = take.label || `Take ${take.takeNumber || added + 1}`;
            const duration = take.end - take.start;
            await jsx.call('createMarker', take.start, name, duration, null, colorIndex);
            added++;
        } catch (e) {
            console.warn('[Builder] Failed to add take marker:', e);
        }
    }

    return { added };
}

/**
 * Add chapter markers to the timeline
 * @param {Array} chapters - Array of chapter objects
 */
async function addChapterMarkers(chapters) {
    let added = 0;

    for (const chapter of chapters) {
        try {
            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);
            added++;
        } catch (e) {
            console.warn('[Builder] Failed to add chapter marker:', e);
        }
    }

    return { added };
}

/**
 * Add zoom markers to the timeline
 * @param {Array} zoomPoints - Array of zoom point objects
 */
async function addZoomMarkers(zoomPoints) {
    let added = 0;

    for (const zoom of zoomPoints) {
        try {
            await jsx.call('addZoomMarker', zoom.startTime, zoom.scale, zoom.duration, zoom.easing);
            added++;
        } catch (e) {
            console.warn('[Builder] Failed to add zoom marker:', e);
        }
    }

    return { added };
}

/**
 * Clear all SPLICE markers from the timeline
 */
async function clearSpliceMarkers() {
    try {
        const result = await jsx.call('deleteMarkersByName', 'SPLICE');
        return { deleted: result.deleted || 0 };
    } catch (e) {
        console.warn('[Builder] Failed to clear markers:', e);
        return { deleted: 0 };
    }
}

// ============================================================================
// RAZOR OPERATIONS
// ============================================================================

/**
 * Apply razor cuts at silence boundaries
 * @param {Array} silences - Array of silence objects
 * @param {Object} options - Razor options
 */
async function razorAtSilences(silences, options = {}) {
    const { trackType = 'all', trackIndex = -1 } = options;

    // Convert silences to frame-aligned cut points
    const cutPoints = [];
    const frameRate = await jsx.call('getVideoFrameRateInSeconds');

    for (const silence of silences) {
        // Align to frame boundaries
        const startFrame = Math.round(silence.start / frameRate);
        const endFrame = Math.round(silence.end / frameRate);

        cutPoints.push([startFrame, endFrame]);
    }

    // Batch the cuts
    if (cutPoints.length > 0) {
        try {
            await jsx.call('razorSequenceAtFramesArray', JSON.stringify(cutPoints));
            return { cuts: cutPoints.length * 2 };
        } catch (e) {
            console.error('[Builder] Razor failed:', e);
            return { cuts: 0, error: e.message };
        }
    }

    return { cuts: 0 };
}

/**
 * Delete clips at silence points
 * @param {Array} silences - Array of silence objects
 * @param {Object} options - Delete options
 */
async function deleteClipsAtSilences(silences, options = {}) {
    const { trackType = 'video', trackIndex = 0 } = options;

    try {
        const result = await jsx.call(
            'deleteClipsAtSilencePointsInTrack',
            JSON.stringify(silences.map(s => [s.start, s.end])),
            trackType,
            trackIndex
        );

        return { deleted: result.deleted || 0 };
    } catch (e) {
        console.error('[Builder] Delete failed:', e);
        return { deleted: 0, error: e.message };
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Get color index for a segment type
 */
function getColorForSegment(type, colorHint) {
    if (colorHint && COLOR_HINT_MAP[colorHint] !== undefined) {
        return COLOR_HINT_MAP[colorHint];
    }
    if (type && SEGMENT_COLORS[type] !== undefined) {
        return SEGMENT_COLORS[type];
    }
    return null;
}

/**
 * Get the active sequence info
 */
async function getActiveSequence() {
    try {
        return await jsx.call('getActiveSequence');
    } catch (e) {
        console.warn('[Builder] Failed to get active sequence:', e);
        return null;
    }
}

/**
 * Check if a sequence is open in the Timeline
 * Enhanced with logging for debugging
 */
async function checkSequenceOpen() {
    try {
        const result = await jsx.call('checkSequenceOpen');
        console.log('[Builder] checkSequenceOpen result:', result, 'type:', typeof result);
        return result === true || result === 'true';
    } catch (error) {
        console.error('[Builder] checkSequenceOpen failed:', error.message);
        return false;
    }
}

/**
 * Clone the current sequence
 * @param {string} newName - Name for the cloned sequence
 */
async function cloneSequence(newName) {
    try {
        return await jsx.call('cloneSequence', newName);
    } catch (e) {
        console.error('[Builder] Clone failed:', e);
        return { error: e.message };
    }
}

/**
 * Undo the last operation
 */
async function undo() {
    try {
        await jsx.call('undo');
        return { success: true };
    } catch (e) {
        console.warn('[Builder] Undo failed:', e);
        return { success: false, error: e.message };
    }
}

// ============================================================================
// EXPORTS
// ============================================================================

window.spliceBuilder = {
    // Constants
    SPLICE_COLORS,
    SEGMENT_COLORS,
    COLOR_HINT_MAP,

    // Cache
    buildProjectItemCache,
    clearProjectItemCache,
    findProjectItemByName,
    findProjectItemByPath,

    // Sequence building
    buildSequenceFromCutList,
    processCutList,

    // Markers
    addSilenceMarkers,
    addTakeMarkers,
    addChapterMarkers,
    addZoomMarkers,
    clearSpliceMarkers,

    // Razor
    razorAtSilences,
    deleteClipsAtSilences,

    // Utilities
    getColorForSegment,
    getActiveSequence,
    checkSequenceOpen,
    cloneSequence,
    undo
};
