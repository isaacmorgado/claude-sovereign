/**
 * SPLICE CEP Social Reframe Module
 *
 * Auto-crops video to vertical/square formats for social media.
 * Supports TikTok, Instagram Reels, YouTube Shorts with face tracking.
 */

// ============================================================================
// STATE
// ============================================================================

const socialReframeState = {
  platforms: [],
  aspectRatios: [],
  selectedPlatform: 'tiktok',
  selectedAspectRatio: 'portrait',
  analysis: null,
  exportQueue: [],
  isAnalyzing: false,
  isExporting: false,
  currentVideoPath: null,
  safeZones: null,
  showSafeZones: false
};

// ============================================================================
// DOM ELEMENT CACHE
// ============================================================================

const reframeElements = {
  panel: null,
  platformSelector: null,
  aspectSelector: null,
  analysisResults: null,
  previewCanvas: null,
  exportResults: null,
  status: null,
  analyzeBtn: null,
  exportBtn: null,
  exportAllBtn: null,
  toggleSafeZonesBtn: null,
  smoothingSlider: null,
  smoothingDisplay: null
};

/**
 * Cache DOM elements for social reframe
 */
function cacheReframeElements() {
  reframeElements.panel = document.getElementById('social-reframe-panel');
  reframeElements.platformSelector = document.getElementById('reframe-platform-selector');
  reframeElements.aspectSelector = document.getElementById('reframe-aspect-selector');
  reframeElements.analysisResults = document.getElementById('reframe-analysis-results');
  reframeElements.previewCanvas = document.getElementById('reframe-preview-canvas');
  reframeElements.exportResults = document.getElementById('reframe-export-results');
  reframeElements.status = document.getElementById('reframe-status');
  reframeElements.analyzeBtn = document.getElementById('analyze-reframe-btn');
  reframeElements.exportBtn = document.getElementById('export-reframe-btn');
  reframeElements.exportAllBtn = document.getElementById('export-all-formats-btn');
  reframeElements.toggleSafeZonesBtn = document.getElementById('toggle-safe-zones-btn');
  reframeElements.smoothingSlider = document.getElementById('motion-smoothing-slider');
  reframeElements.smoothingDisplay = document.getElementById('smoothing-value-display');
}

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize social reframe module
 */
async function initSocialReframe() {
  console.log('[SPLICE] Initializing social reframe module');

  // Cache DOM elements
  cacheReframeElements();

  // Load platforms and aspect ratios
  await loadPlatformPresets();

  // Setup event listeners
  setupReframeEventListeners();

  // Render platform buttons
  renderPlatformSelector();

  console.log('[SPLICE] Social reframe module initialized');
}

/**
 * Load platform presets from backend
 */
async function loadPlatformPresets() {
  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const response = await fetchFn(`${backendUrl}/reframe/platforms`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });

    if (response.ok) {
      const data = await response.json();
      socialReframeState.platforms = data.platforms || [];
      socialReframeState.aspectRatios = data.aspectRatios || [];
      console.log(`[SPLICE] Loaded ${socialReframeState.platforms.length} platforms`);
    }
  } catch (err) {
    console.error('[SPLICE] Failed to load platform presets:', err);
    // Use fallback presets
    socialReframeState.platforms = [
      { id: 'tiktok', name: 'TikTok', aspectRatio: 'portrait', maxDuration: 180 },
      { id: 'reels', name: 'Instagram Reels', aspectRatio: 'portrait', maxDuration: 90 },
      { id: 'shorts', name: 'YouTube Shorts', aspectRatio: 'portrait', maxDuration: 60 },
      { id: 'instagram_feed', name: 'Instagram Feed', aspectRatio: 'square', maxDuration: 60 }
    ];
    socialReframeState.aspectRatios = [
      { id: 'portrait', name: 'Portrait (9:16)', ratio: 0.5625 },
      { id: 'square', name: 'Square (1:1)', ratio: 1 },
      { id: 'portrait_4_5', name: 'Portrait (4:5)', ratio: 0.8 }
    ];
  }
}

/**
 * Setup event listeners
 */
function setupReframeEventListeners() {
  document.addEventListener('click', (e) => {
    // Platform selection
    if (e.target.closest('.reframe-platform-btn')) {
      const btn = e.target.closest('.reframe-platform-btn');
      const platformId = btn.dataset.platformId;
      selectPlatform(platformId);
    }

    // Aspect ratio selection
    if (e.target.closest('.reframe-aspect-btn')) {
      const btn = e.target.closest('.reframe-aspect-btn');
      const aspectId = btn.dataset.aspectId;
      selectAspectRatio(aspectId);
    }

    // Analyze button
    if (e.target.id === 'analyze-reframe-btn') {
      analyzeForReframe();
    }

    // Export buttons
    if (e.target.id === 'export-reframe-btn') {
      exportReframe();
    }
    if (e.target.id === 'export-all-formats-btn') {
      exportAllFormats();
    }

    // Preview toggle
    if (e.target.id === 'toggle-safe-zones-btn') {
      toggleSafeZones();
    }

    // Toggle panel collapse
    if (e.target.closest('.reframe-header')) {
      const panel = document.getElementById('social-reframe-panel');
      if (panel) {
        const isCollapsed = panel.classList.toggle('collapsed');
        const icon = e.target.closest('.section-toggle')?.querySelector('.toggle-icon');
        if (icon) {
          icon.textContent = isCollapsed ? '+' : '-';
        }
      }
    }
  });

  // Motion smoothing slider
  document.addEventListener('input', (e) => {
    if (e.target.id === 'motion-smoothing-slider') {
      updateSmoothingValue(e.target.value);
    }
  });
}

// ============================================================================
// PLATFORM & ASPECT RATIO SELECTION
// ============================================================================

/**
 * Render platform selector buttons
 */
function renderPlatformSelector() {
  const container = reframeElements.platformSelector || document.getElementById('reframe-platform-selector');
  if (!container) return;

  const html = socialReframeState.platforms.map(platform => `
    <button class="reframe-platform-btn ${socialReframeState.selectedPlatform === platform.id ? 'selected' : ''}"
            data-platform-id="${platform.id}"
            aria-label="Select ${platform.name}">
      <span class="platform-icon platform-icon-${platform.id}"></span>
      <span class="platform-name">${platform.name}</span>
    </button>
  `).join('');

  container.innerHTML = html;

  // Also render aspect ratio buttons
  renderAspectRatioSelector();
}

/**
 * Render aspect ratio selector
 */
function renderAspectRatioSelector() {
  const container = reframeElements.aspectSelector || document.getElementById('reframe-aspect-selector');
  if (!container) return;

  const html = socialReframeState.aspectRatios.map(aspect => `
    <button class="reframe-aspect-btn ${socialReframeState.selectedAspectRatio === aspect.id ? 'selected' : ''}"
            data-aspect-id="${aspect.id}"
            aria-label="Select ${aspect.name}">
      <span class="aspect-preview aspect-preview-${aspect.id}"></span>
      <span class="aspect-name">${aspect.name}</span>
    </button>
  `).join('');

  container.innerHTML = html;
}

/**
 * Select platform
 */
function selectPlatform(platformId) {
  const platform = socialReframeState.platforms.find(p => p.id === platformId);
  if (!platform) return;

  socialReframeState.selectedPlatform = platformId;
  socialReframeState.selectedAspectRatio = platform.aspectRatio;

  // Update UI
  document.querySelectorAll('.reframe-platform-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.platformId === platformId);
  });

  renderAspectRatioSelector();
  loadSafeZones(platformId);

  console.log(`[SPLICE] Selected platform: ${platform.name}`);
}

/**
 * Select aspect ratio
 */
function selectAspectRatio(aspectId) {
  socialReframeState.selectedAspectRatio = aspectId;

  document.querySelectorAll('.reframe-aspect-btn').forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.aspectId === aspectId);
  });

  // Update preview if available
  if (socialReframeState.analysis) {
    updateCropPreview();
  }

  console.log(`[SPLICE] Selected aspect ratio: ${aspectId}`);
}

/**
 * Load safe zones for platform
 */
async function loadSafeZones(platformId) {
  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const response = await fetchFn(`${backendUrl}/reframe/safe-zones/${platformId}`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });

    if (response.ok) {
      const data = await response.json();
      socialReframeState.safeZones = data;
      renderSafeZoneOverlay();
    }
  } catch (err) {
    console.error('[SPLICE] Failed to load safe zones:', err);
  }
}

// ============================================================================
// ANALYSIS
// ============================================================================

/**
 * Analyze current video for reframe
 */
async function analyzeForReframe() {
  const videoPath = getCurrentVideoPath();
  if (!videoPath) {
    showReframeStatus('No video selected', 'error');
    return;
  }

  socialReframeState.isAnalyzing = true;
  updateAnalyzeButton(true);
  showReframeStatus('Analyzing video for face tracking...', 'info');

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const slider = reframeElements.smoothingSlider || document.getElementById('motion-smoothing-slider');
    const smoothing = slider?.value || 0.3;

    const response = await fetchFn(`${backendUrl}/reframe/analyze`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        videoPath,
        options: {
          sampleRate: 0.5,
          smoothing: parseFloat(smoothing)
        }
      })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Analysis failed');
    }

    const data = await response.json();
    socialReframeState.analysis = data;
    socialReframeState.currentVideoPath = videoPath;

    // Update UI
    renderAnalysisResults(data);
    updateCropPreview();
    showReframeStatus(`Found ${data.faceTracking.tracksFound} face(s)`, 'success');

  } catch (err) {
    console.error('[SPLICE] Reframe analysis error:', err);
    showReframeStatus(err.message, 'error');
  } finally {
    socialReframeState.isAnalyzing = false;
    updateAnalyzeButton(false);
  }
}

/**
 * Get current video path from main module or JSX
 */
function getCurrentVideoPath() {
  // Try to get from main module state
  if (window.spliceState?.currentVideoPath) {
    return window.spliceState.currentVideoPath;
  }

  // Try from active sequence
  if (window.spliceState?.activeSequence?.projectItem?.treePath) {
    return window.spliceState.activeSequence.projectItem.treePath;
  }

  return socialReframeState.currentVideoPath;
}

/**
 * Set video path for reframe
 */
function setVideoPath(videoPath) {
  socialReframeState.currentVideoPath = videoPath;
}

/**
 * Render analysis results
 */
function renderAnalysisResults(analysis) {
  const container = reframeElements.analysisResults || document.getElementById('reframe-analysis-results');
  if (!container) return;

  const html = `
    <div class="analysis-summary">
      <div class="analysis-stat">
        <span class="stat-label">Faces Found</span>
        <span class="stat-value">${analysis.faceTracking.tracksFound}</span>
      </div>
      <div class="analysis-stat">
        <span class="stat-label">Video Duration</span>
        <span class="stat-value">${formatDuration(analysis.videoInfo.duration)}</span>
      </div>
      <div class="analysis-stat">
        <span class="stat-label">Resolution</span>
        <span class="stat-value">${analysis.videoInfo.width}x${analysis.videoInfo.height}</span>
      </div>
    </div>
    <div class="analysis-formats">
      ${Object.entries(analysis.suggestions).map(([key, suggestion]) => `
        <div class="format-suggestion" data-format="${key}">
          <span class="format-name">${getAspectRatioName(key)}</span>
          <span class="format-method">${suggestion.method}</span>
          <span class="format-keyframes">${suggestion.totalKeyframes || 0} keyframes</span>
        </div>
      `).join('')}
    </div>
  `;

  container.innerHTML = html;
}

/**
 * Get aspect ratio name
 */
function getAspectRatioName(id) {
  const aspect = socialReframeState.aspectRatios.find(a => a.id === id);
  return aspect?.name || id;
}

// ============================================================================
// PREVIEW
// ============================================================================

/**
 * Update crop preview canvas
 */
function updateCropPreview() {
  const canvas = reframeElements.previewCanvas || document.getElementById('reframe-preview-canvas');
  if (!canvas || !socialReframeState.analysis) return;

  const ctx = canvas.getContext('2d');
  const { videoInfo, suggestions } = socialReframeState.analysis;
  const aspectId = socialReframeState.selectedAspectRatio;
  const suggestion = suggestions[aspectId];

  if (!suggestion) return;

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw video frame representation
  const scale = Math.min(canvas.width / videoInfo.width, canvas.height / videoInfo.height);
  const videoW = videoInfo.width * scale;
  const videoH = videoInfo.height * scale;
  const videoX = (canvas.width - videoW) / 2;
  const videoY = (canvas.height - videoH) / 2;

  // Draw video background
  ctx.fillStyle = '#333';
  ctx.fillRect(videoX, videoY, videoW, videoH);

  // Draw crop region
  const crop = suggestion.static ? suggestion.crop : suggestion.keyframes[0]?.crop;
  if (crop) {
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      videoX + crop.x * videoW,
      videoY + crop.y * videoH,
      crop.width * videoW,
      crop.height * videoH
    );

    // Draw face indicator
    if (socialReframeState.analysis.faceTracking.tracks[0]) {
      const face = socialReframeState.analysis.faceTracking.tracks[0].positions[0];
      if (face) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.fillRect(
          videoX + face.x * videoW,
          videoY + face.y * videoH,
          face.width * videoW,
          face.height * videoH
        );
      }
    }
  }

  // Draw safe zones if enabled
  if (socialReframeState.showSafeZones && socialReframeState.safeZones) {
    renderSafeZoneOnCanvas(ctx, videoX, videoY, videoW, videoH);
  }
}

/**
 * Render safe zone overlay on canvas
 */
function renderSafeZoneOnCanvas(ctx, x, y, width, height) {
  const sz = socialReframeState.safeZones.safeZone;
  if (!sz) return;

  ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';

  // Top safe zone
  ctx.fillRect(x, y, width, height * sz.top);

  // Bottom safe zone
  ctx.fillRect(x, y + height * (1 - sz.bottom), width, height * sz.bottom);

  // Left safe zone
  ctx.fillRect(x, y, width * sz.left, height);

  // Right safe zone
  ctx.fillRect(x + width * (1 - sz.right), y, width * sz.right, height);
}

/**
 * Render safe zone overlay
 */
function renderSafeZoneOverlay() {
  updateCropPreview();
}

/**
 * Toggle safe zones visibility
 */
function toggleSafeZones() {
  socialReframeState.showSafeZones = !socialReframeState.showSafeZones;
  updateCropPreview();

  const btn = reframeElements.toggleSafeZonesBtn || document.getElementById('toggle-safe-zones-btn');
  if (btn) {
    btn.classList.toggle('active', socialReframeState.showSafeZones);
  }
}

// ============================================================================
// EXPORT
// ============================================================================

/**
 * Export for selected format
 */
async function exportReframe() {
  if (!socialReframeState.analysis) {
    showReframeStatus('Analyze video first', 'error');
    return;
  }

  socialReframeState.isExporting = true;
  updateExportButton(true);
  showReframeStatus('Generating export data...', 'info');

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const slider = reframeElements.smoothingSlider || document.getElementById('motion-smoothing-slider');
    const smoothing = slider?.value || 0.3;

    const response = await fetchFn(`${backendUrl}/reframe/export`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        videoPath: socialReframeState.currentVideoPath,
        formats: [socialReframeState.selectedAspectRatio],
        settings: {
          quality: 'high',
          motionSmoothing: parseFloat(smoothing)
        }
      })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Export failed');
    }

    const data = await response.json();
    renderExportResults(data);
    showReframeStatus('Export data generated', 'success');

  } catch (err) {
    console.error('[SPLICE] Reframe export error:', err);
    showReframeStatus(err.message, 'error');
  } finally {
    socialReframeState.isExporting = false;
    updateExportButton(false);
  }
}

/**
 * Export all formats at once
 */
async function exportAllFormats() {
  if (!socialReframeState.analysis) {
    showReframeStatus('Analyze video first', 'error');
    return;
  }

  const allFormats = socialReframeState.aspectRatios.map(a => a.id);

  socialReframeState.isExporting = true;
  updateExportButton(true);
  showReframeStatus('Generating all formats...', 'info');

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const response = await fetchFn(`${backendUrl}/reframe/export`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        videoPath: socialReframeState.currentVideoPath,
        formats: allFormats,
        settings: { quality: 'high' }
      })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Export failed');
    }

    const data = await response.json();
    renderExportResults(data);
    showReframeStatus(`Generated ${data.totalFormats} formats`, 'success');

  } catch (err) {
    console.error('[SPLICE] Reframe batch export error:', err);
    showReframeStatus(err.message, 'error');
  } finally {
    socialReframeState.isExporting = false;
    updateExportButton(false);
  }
}

/**
 * Render export results
 */
function renderExportResults(data) {
  const container = reframeElements.exportResults || document.getElementById('reframe-export-results');
  if (!container) return;

  const html = `
    <div class="export-summary">
      <span class="export-count">${data.totalFormats} format(s) ready</span>
    </div>
    <div class="export-list">
      ${data.exports.map(exp => `
        <div class="export-item">
          <span class="export-format">${exp.name}</span>
          <span class="export-dims">${exp.dimensions.width}x${exp.dimensions.height}</span>
          <button class="copy-ffmpeg-btn btn btn-small" data-filter="${encodeURIComponent(exp.ffmpegFilter)}">
            Copy FFmpeg
          </button>
        </div>
      `).join('')}
    </div>
  `;

  container.innerHTML = html;

  // Add copy handlers
  container.querySelectorAll('.copy-ffmpeg-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const filter = decodeURIComponent(btn.dataset.filter);
      navigator.clipboard.writeText(filter).then(() => {
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy FFmpeg', 2000);
      });
    });
  });
}

// ============================================================================
// UI HELPERS
// ============================================================================

/**
 * Show status message
 */
function showReframeStatus(message, type = 'info') {
  const statusEl = reframeElements.status || document.getElementById('reframe-status');
  if (!statusEl) return;

  statusEl.textContent = message;
  statusEl.className = `reframe-status reframe-status-${type}`;

  if (type !== 'error') {
    setTimeout(() => {
      statusEl.textContent = '';
      statusEl.className = 'reframe-status';
    }, 5000);
  }
}

/**
 * Update analyze button state
 */
function updateAnalyzeButton(isAnalyzing) {
  const btn = reframeElements.analyzeBtn || document.getElementById('analyze-reframe-btn');
  if (!btn) return;

  btn.disabled = isAnalyzing;
  btn.textContent = isAnalyzing ? 'Analyzing...' : 'Analyze Video';
}

/**
 * Update export button state
 */
function updateExportButton(isExporting) {
  const btn = reframeElements.exportBtn || document.getElementById('export-reframe-btn');
  if (!btn) return;

  btn.disabled = isExporting;
  btn.textContent = isExporting ? 'Exporting...' : 'Export';
}

/**
 * Update smoothing value display
 */
function updateSmoothingValue(value) {
  const display = reframeElements.smoothingDisplay || document.getElementById('smoothing-value-display');
  if (display) {
    display.textContent = parseFloat(value).toFixed(2);
  }
}

/**
 * Format duration for display
 */
function formatDuration(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ============================================================================
// EXPORTS
// ============================================================================

// Export for global access
window.spliceSocialReframe = {
  init: initSocialReframe,
  analyze: analyzeForReframe,
  setVideoPath: setVideoPath,
  selectPlatform: selectPlatform,
  selectAspectRatio: selectAspectRatio,
  export: exportReframe,
  exportAll: exportAllFormats,
  toggleSafeZones: toggleSafeZones,
  getState: () => ({ ...socialReframeState })
};

// Also expose individual functions for direct access
window.initSocialReframe = initSocialReframe;
