/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The /agents slash command for managing and viewing available agents.
 * Provides list, info, and reload subcommands for agent management.
 */

import {
  type CommandContext,
  type SlashCommand,
  CommandKind,
} from './types.js';
import { MessageType, type HistoryItemMarkdown } from '../types.js';

/**
 * Lists all registered agents with their descriptions and sources.
 */
async function listAgents(context: CommandContext): Promise<void> {
  const agentRegistry = context.services.config?.getAgentRegistry?.();

  if (!agentRegistry) {
    context.ui.addItem(
      {
        type: MessageType.ERROR,
        text: 'Agents are not enabled. Enable them in settings with `experimental.enableAgents: true`.',
      },
      Date.now(),
    );
    return;
  }

  const agents = agentRegistry.getAllDefinitions();

  if (agents.length === 0) {
    context.ui.addItem(
      {
        type: MessageType.ASSISTANT,
        markdown:
          '## No Agents Available\n\nNo agents are currently registered. You can create agents by adding `.toml` or `.md` files to:\n\n- `~/.gemini/agents/` (user-level)\n- `.gemini/agents/` (project-level)',
      } as HistoryItemMarkdown,
      Date.now(),
    );
    return;
  }

  // Group agents by source
  const bySource: Record<string, typeof agents> = {};
  for (const agent of agents) {
    const source = agent.source || 'unknown';
    if (!bySource[source]) {
      bySource[source] = [];
    }
    bySource[source].push(agent);
  }

  let markdown = '## Available Agents\n\n';

  const sourceOrder = ['builtin', 'user', 'project', 'cli', 'remote', 'unknown'];
  for (const source of sourceOrder) {
    const sourceAgents = bySource[source];
    if (!sourceAgents || sourceAgents.length === 0) continue;

    markdown += `### ${source.charAt(0).toUpperCase() + source.slice(1)} Agents\n\n`;
    for (const agent of sourceAgents) {
      const displayName = agent.displayName || agent.name;
      markdown += `- **${displayName}** (\`${agent.name}\`): ${agent.description}\n`;
    }
    markdown += '\n';
  }

  markdown += `\n_Use \`/agents info <name>\` to see details about a specific agent._`;

  context.ui.addItem(
    {
      type: MessageType.ASSISTANT,
      markdown,
    } as HistoryItemMarkdown,
    Date.now(),
  );
}

/**
 * Shows detailed information about a specific agent.
 */
async function showAgentInfo(
  context: CommandContext,
  agentName: string,
): Promise<void> {
  const agentRegistry = context.services.config?.getAgentRegistry?.();

  if (!agentRegistry) {
    context.ui.addItem(
      {
        type: MessageType.ERROR,
        text: 'Agents are not enabled.',
      },
      Date.now(),
    );
    return;
  }

  const agent = agentRegistry.getDefinition(agentName);

  if (!agent) {
    context.ui.addItem(
      {
        type: MessageType.ERROR,
        text: `Agent '${agentName}' not found. Use \`/agents\` to list available agents.`,
      },
      Date.now(),
    );
    return;
  }

  let markdown = `## Agent: ${agent.displayName || agent.name}\n\n`;
  markdown += `**Name:** \`${agent.name}\`\n`;
  markdown += `**Description:** ${agent.description}\n`;
  markdown += `**Source:** ${agent.source || 'unknown'}\n`;
  markdown += `**Kind:** ${agent.kind}\n\n`;

  if (agent.kind === 'local') {
    const localAgent = agent;

    markdown += '### Configuration\n\n';
    markdown += `- **Model:** ${localAgent.modelConfig.model}\n`;
    markdown += `- **Temperature:** ${localAgent.modelConfig.temp}\n`;
    markdown += `- **Max Time:** ${localAgent.runConfig.max_time_minutes} minutes\n`;
    if (localAgent.runConfig.max_turns) {
      markdown += `- **Max Turns:** ${localAgent.runConfig.max_turns}\n`;
    }

    if (localAgent.toolConfig?.tools) {
      const toolNames = localAgent.toolConfig.tools
        .map((t) => (typeof t === 'string' ? t : t.name))
        .join(', ');
      markdown += `\n### Available Tools\n\n\`${toolNames}\`\n`;
    }

    if (localAgent.inputConfig?.inputs) {
      markdown += '\n### Input Parameters\n\n';
      for (const [name, config] of Object.entries(localAgent.inputConfig.inputs)) {
        const required = config.required ? ' (required)' : ' (optional)';
        markdown += `- **${name}**${required}: ${config.description} (${config.type})\n`;
      }
    }

    if (localAgent.promptConfig?.systemPrompt) {
      const preview = localAgent.promptConfig.systemPrompt.slice(0, 200);
      const ellipsis = localAgent.promptConfig.systemPrompt.length > 200 ? '...' : '';
      markdown += `\n### System Prompt Preview\n\n\`\`\`\n${preview}${ellipsis}\n\`\`\`\n`;
    }
  } else if (agent.kind === 'remote') {
    markdown += `\n### Remote Agent\n\n`;
    markdown += `**Agent Card URL:** ${agent.agentCardUrl}\n`;
  }

  markdown += `\n_To use this agent, the parent agent can call \`delegate_to_agent\` with \`agent_name: "${agent.name}"\`._`;

  context.ui.addItem(
    {
      type: MessageType.ASSISTANT,
      markdown,
    } as HistoryItemMarkdown,
    Date.now(),
  );
}

/**
 * Reloads agents from the filesystem.
 */
async function reloadAgents(context: CommandContext): Promise<void> {
  const agentRegistry = context.services.config?.getAgentRegistry?.();

  if (!agentRegistry) {
    context.ui.addItem(
      {
        type: MessageType.ERROR,
        text: 'Agents are not enabled.',
      },
      Date.now(),
    );
    return;
  }

  try {
    // Re-initialize the registry to reload agents
    await agentRegistry.initialize();

    const agents = agentRegistry.getAllDefinitions();
    context.ui.addItem(
      {
        type: MessageType.ASSISTANT,
        markdown: `Agents reloaded successfully. **${agents.length}** agent(s) available.`,
      } as HistoryItemMarkdown,
      Date.now(),
    );
  } catch (error) {
    context.ui.addItem(
      {
        type: MessageType.ERROR,
        text: `Failed to reload agents: ${(error as Error).message}`,
      },
      Date.now(),
    );
  }
}

/**
 * Provides completion suggestions for agent names.
 */
function agentNameCompletion(
  context: CommandContext,
  partialArg: string,
): string[] {
  const agentRegistry = context.services.config?.getAgentRegistry?.();
  if (!agentRegistry) return [];

  const allNames = agentRegistry.getAllAgentNames();
  if (!partialArg) return allNames;

  const lower = partialArg.toLowerCase();
  return allNames.filter((name) => name.toLowerCase().startsWith(lower));
}

/**
 * The /agents slash command for managing available agents.
 */
export const agentsCommand: SlashCommand = {
  name: 'agents',
  description: 'List and manage available agents. Usage: /agents [list|info|reload]',
  kind: CommandKind.BUILT_IN,
  autoExecute: false,
  action: async (context: CommandContext, args?: string): Promise<void> => {
    const trimmedArgs = args?.trim() || '';
    const parts = trimmedArgs.split(/\s+/);
    const subCommand = parts[0]?.toLowerCase();
    const subArgs = parts.slice(1).join(' ');

    switch (subCommand) {
      case '':
      case 'list':
        await listAgents(context);
        break;
      case 'info':
        if (!subArgs) {
          context.ui.addItem(
            {
              type: MessageType.ERROR,
              text: 'Usage: /agents info <agent_name>',
            },
            Date.now(),
          );
          return;
        }
        await showAgentInfo(context, subArgs);
        break;
      case 'reload':
        await reloadAgents(context);
        break;
      default:
        // Try to interpret as agent name for info
        await showAgentInfo(context, subCommand);
    }
  },
  subCommands: [
    {
      name: 'list',
      description: 'List all available agents',
      kind: CommandKind.BUILT_IN,
      autoExecute: true,
      action: async (context: CommandContext): Promise<void> => {
        await listAgents(context);
      },
    },
    {
      name: 'info',
      description: 'Show details about a specific agent. Usage: /agents info <name>',
      kind: CommandKind.BUILT_IN,
      autoExecute: false,
      completion: agentNameCompletion,
      action: async (context: CommandContext, args?: string): Promise<void> => {
        const agentName = args?.trim();
        if (!agentName) {
          context.ui.addItem(
            {
              type: MessageType.ERROR,
              text: 'Usage: /agents info <agent_name>',
            },
            Date.now(),
          );
          return;
        }
        await showAgentInfo(context, agentName);
      },
    },
    {
      name: 'reload',
      description: 'Reload agents from filesystem',
      kind: CommandKind.BUILT_IN,
      autoExecute: true,
      action: async (context: CommandContext): Promise<void> => {
        await reloadAgents(context);
      },
    },
  ],
};
