import { Worker, Job } from 'bullmq'
import { redis } from '../config/redis.js'
import { env } from '../config/env.js'
import * as audioService from '../services/audio-service.js'
import type { AudioJobQueueData, VocalIsolationResult } from '../types/audio.js'

const QUEUE_NAME = audioService.QUEUE_NAMES.vocal_isolation

async function processVocalIsolationJob(job: Job<AudioJobQueueData>): Promise<void> {
  const { jobId, audioUrl } = job.data

  console.log(`Processing vocal isolation job ${jobId}`)

  await audioService.markJobProcessing(jobId)
  await audioService.updateJobProgress(jobId, 10)

  try {
    const result = await isolateVocals(audioUrl, jobId)

    await audioService.markJobCompleted(
      jobId,
      result.vocalsUrl,
      result as unknown as Record<string, unknown>
    )

    console.log(`Vocal isolation job ${jobId} completed successfully`)
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    console.error(`Vocal isolation job ${jobId} failed:`, errorMessage)
    throw error
  }
}

async function isolateVocals(audioUrl: string, jobId: string): Promise<VocalIsolationResult> {
  if (env.DOLBY_API_KEY) {
    return isolateWithDolby(audioUrl, env.DOLBY_API_KEY, jobId)
  }

  if (env.DEMUCS_API_URL) {
    return isolateWithDemucs(audioUrl, env.DEMUCS_API_URL, jobId)
  }

  throw new Error('No vocal isolation service configured. Set DOLBY_API_KEY or DEMUCS_API_URL.')
}

async function isolateWithDolby(
  audioUrl: string,
  apiKey: string,
  jobId: string
): Promise<VocalIsolationResult> {
  await audioService.updateJobProgress(jobId, 20)

  const startResponse = await fetch('https://api.dolby.com/media/enhance', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      input: audioUrl,
      output: 'dlb://out/vocals.wav',
      content: {
        type: 'voice_recording',
      },
    }),
  })

  if (!startResponse.ok) {
    const errorText = await startResponse.text()
    throw new Error(`Dolby API error: ${String(startResponse.status)} - ${errorText}`)
  }

  const startData = (await startResponse.json()) as DolbyStartResponse
  const dolbyJobId = startData.job_id

  await audioService.updateJobProgress(jobId, 30)

  let result: DolbyStatusResponse | null = null
  const maxAttempts = 60
  let attempts = 0

  while (attempts < maxAttempts) {
    await sleep(5000)

    const statusResponse = await fetch(`https://api.dolby.com/media/enhance?job_id=${dolbyJobId}`, {
      headers: {
        Authorization: `Bearer ${apiKey}`,
      },
    })

    if (!statusResponse.ok) {
      const errorText = await statusResponse.text()
      throw new Error(`Dolby status check error: ${String(statusResponse.status)} - ${errorText}`)
    }

    result = (await statusResponse.json()) as DolbyStatusResponse

    if (result.status === 'Success') {
      break
    }

    if (result.status === 'Failed') {
      throw new Error(`Dolby processing failed: ${result.error?.message ?? 'Unknown error'}`)
    }

    // Update progress based on poll iteration (30% to 85%)
    const progress = 30 + Math.min(55, Math.floor((attempts / maxAttempts) * 55))
    await audioService.updateJobProgress(jobId, progress)

    attempts++
  }

  if (!result || result.status !== 'Success') {
    throw new Error('Dolby processing timed out')
  }

  await audioService.updateJobProgress(jobId, 90)

  return {
    vocalsUrl: result.output ?? '',
    instrumentalUrl: '',
  }
}

async function isolateWithDemucs(
  audioUrl: string,
  apiUrl: string,
  jobId: string
): Promise<VocalIsolationResult> {
  await audioService.updateJobProgress(jobId, 30)

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ audio_url: audioUrl }),
  })

  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(`Demucs API error: ${String(response.status)} - ${errorText}`)
  }

  const data = (await response.json()) as DemucsResponse

  await audioService.updateJobProgress(jobId, 90)

  return {
    vocalsUrl: data.vocals_url,
    instrumentalUrl: data.instrumental_url ?? data.accompaniment_url ?? '',
  }
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

interface DolbyStartResponse {
  job_id: string
}

interface DolbyStatusResponse {
  status: 'Pending' | 'Running' | 'Success' | 'Failed'
  output?: string
  error?: {
    message: string
  }
}

interface DemucsResponse {
  vocals_url: string
  instrumental_url?: string
  accompaniment_url?: string
}

export function startVocalIsolationWorker(): Worker<AudioJobQueueData> {
  const worker = new Worker<AudioJobQueueData>(QUEUE_NAME, processVocalIsolationJob, {
    connection: redis,
    concurrency: 2,
  })

  worker.on('completed', (job) => {
    console.log(`Job ${String(job.id)} completed`)
  })

  worker.on('failed', (job, err) => {
    if (job) {
      console.error(`Job ${String(job.id)} failed with error: ${err.message}`)
      audioService.markJobFailed(job.data.jobId, err.message).catch((e: unknown) => {
        console.error('Failed to mark job as failed:', e)
      })
    }
  })

  worker.on('error', (err) => {
    console.error('Worker error:', err)
  })

  console.log(`Vocal isolation worker started, listening on queue: ${QUEUE_NAME}`)

  return worker
}
