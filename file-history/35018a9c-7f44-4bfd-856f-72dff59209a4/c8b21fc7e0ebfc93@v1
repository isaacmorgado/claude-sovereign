import { query } from '../../config/database.js'
import type {
  AudioJob,
  AudioJobPublic,
  AudioJobStatus,
  CreateAudioJobInput,
} from '../../types/audio.js'

export function toPublicJob(job: AudioJob): AudioJobPublic {
  return {
    id: job.id,
    jobType: job.job_type,
    status: job.status,
    audioDurationMinutes: job.audio_duration_minutes,
    progress: job.progress,
    resultUrl: job.result_url,
    resultData: job.result_data,
    errorMessage: job.error_message,
    createdAt: job.created_at,
    completedAt: job.completed_at,
  }
}

export async function create(input: CreateAudioJobInput): Promise<AudioJob> {
  const result = await query<AudioJob>(
    `INSERT INTO audio_jobs (user_id, job_type, status, audio_url, audio_duration_minutes)
     VALUES ($1, $2::audio_job_type, 'pending'::audio_job_status, $3, $4)
     RETURNING *`,
    [input.userId, input.jobType, input.audioUrl, input.audioDurationMinutes]
  )
  const job = result.rows[0]
  if (!job) {
    throw new Error('Failed to create audio job')
  }
  return job
}

export async function findById(id: string): Promise<AudioJob | null> {
  const result = await query<AudioJob>('SELECT * FROM audio_jobs WHERE id = $1', [id])
  return result.rows[0] ?? null
}

export async function findByIdAndUser(id: string, userId: string): Promise<AudioJob | null> {
  const result = await query<AudioJob>('SELECT * FROM audio_jobs WHERE id = $1 AND user_id = $2', [
    id,
    userId,
  ])
  return result.rows[0] ?? null
}

export async function findByUser(
  userId: string,
  limit: number = 20,
  offset: number = 0
): Promise<AudioJob[]> {
  const result = await query<AudioJob>(
    `SELECT * FROM audio_jobs
     WHERE user_id = $1
     ORDER BY created_at DESC
     LIMIT $2 OFFSET $3`,
    [userId, limit, offset]
  )
  return result.rows
}

export async function updateStatus(
  id: string,
  status: AudioJobStatus,
  errorMessage?: string
): Promise<AudioJob | null> {
  const shouldComplete = status === 'completed' || status === 'failed'
  const result = await query<AudioJob>(
    `UPDATE audio_jobs
     SET status = $2::audio_job_status,
         error_message = $3,
         completed_at = CASE WHEN $4 THEN NOW() ELSE NULL END,
         updated_at = NOW()
     WHERE id = $1
     RETURNING *`,
    [id, status, errorMessage ?? null, shouldComplete]
  )
  return result.rows[0] ?? null
}

export async function updateResult(
  id: string,
  resultUrl: string | null,
  resultData: Record<string, unknown> | null
): Promise<AudioJob | null> {
  const result = await query<AudioJob>(
    `UPDATE audio_jobs
     SET status = 'completed',
         result_url = $2,
         result_data = $3,
         completed_at = NOW(),
         updated_at = NOW()
     WHERE id = $1
     RETURNING *`,
    [id, resultUrl, resultData ? JSON.stringify(resultData) : null]
  )
  return result.rows[0] ?? null
}

export async function countPendingByUser(userId: string): Promise<number> {
  const result = await query<{ count: string }>(
    `SELECT COUNT(*) as count FROM audio_jobs
     WHERE user_id = $1 AND status IN ('pending', 'processing')`,
    [userId]
  )
  return parseInt(result.rows[0]?.count ?? '0', 10)
}
