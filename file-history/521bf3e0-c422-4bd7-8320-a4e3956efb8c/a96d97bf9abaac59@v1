/**
 * Phase 2: Code Quality & Consistency E2E Tests
 *
 * Tests for:
 * - 2.1: Centralized URL configuration
 * - 2.2: No duplicate function definitions
 * - 2.3: Fetch timeout support
 * - 2.4: Standardized error response parsing
 */

const fs = require('fs');
const path = require('path');
const assert = require('assert');

// Test helpers
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`  âœ“ ${name}`);
    passed++;
  } catch (err) {
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    failed++;
  }
}

async function asyncTest(name, fn) {
  try {
    await fn();
    console.log(`  âœ“ ${name}`);
    passed++;
  } catch (err) {
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    failed++;
  }
}

// Read plugin files
const pluginDir = path.join(__dirname, '../../splice-plugin/js');
const configJs = fs.readFileSync(path.join(pluginDir, 'config.js'), 'utf8');
const mainJs = fs.readFileSync(path.join(pluginDir, 'main.js'), 'utf8');
const creditsJs = fs.readFileSync(path.join(pluginDir, 'credits.js'), 'utf8');
const settingsJs = fs.readFileSync(path.join(pluginDir, 'settings.js'), 'utf8');
const utilsJs = fs.readFileSync(path.join(pluginDir, 'utils.js'), 'utf8');
const slice8Js = fs.readFileSync(path.join(pluginDir, 'slice8-silence.js'), 'utf8');
const slice9Js = fs.readFileSync(path.join(pluginDir, 'slice9-razor.js'), 'utf8');

// ============================================================================
// 2.1: Centralized URL Configuration Tests
// ============================================================================
console.log('\nðŸ“¦ Feature 2.1: Centralized URL Configuration\n');

test('config.js exports getBackendUrl() function', () => {
  assert(configJs.includes('function getBackendUrl()'), 'getBackendUrl function not found');
});

test('config.js defines BACKEND_URL_DEV constant', () => {
  assert(configJs.includes("BACKEND_URL_DEV = 'https://127.0.0.1:3847'"), 'BACKEND_URL_DEV not found');
});

test('config.js uses 127.0.0.1 not localhost', () => {
  assert(!configJs.includes('localhost:3847'), 'Should use 127.0.0.1, not localhost');
  assert(configJs.includes('127.0.0.1:3847'), 'Should use 127.0.0.1');
});

test('credits.js uses getBackendUrl() not hardcoded fallback', () => {
  assert(!creditsJs.includes("'https://127.0.0.1:3847'"), 'Should not have hardcoded fallback');
  assert(creditsJs.includes('getBackendUrl()'), 'Should use getBackendUrl()');
});

test('credits.js removed getCreditsBackendUrl() duplicate', () => {
  assert(!creditsJs.includes('function getCreditsBackendUrl'), 'Duplicate function should be removed');
});

test('settings.js uses getBackendUrl() for license activation', () => {
  assert(settingsJs.includes('getBackendUrl()/license/activate'), 'Should use getBackendUrl()');
  assert(!settingsJs.includes("const baseUrl = typeof BACKEND_URL"), 'Should not have hardcoded fallback pattern');
});

test('main.js uses getBackendUrl() not BACKEND_URL directly', () => {
  // Count uses of getBackendUrl() - should be 5+ (isolate, silences, analyze, batch, batch-status)
  const getBackendUrlCount = (mainJs.match(/getBackendUrl\(\)/g) || []).length;
  assert(getBackendUrlCount >= 5, `Expected 5+ getBackendUrl() uses, found ${getBackendUrlCount}`);
});

// ============================================================================
// 2.2: Duplicate Function Definitions Tests
// ============================================================================
console.log('\nðŸ“¦ Feature 2.2: Remove Duplicate Function Definitions\n');

test('utils.js has formatTime with NaN check', () => {
  assert(utilsJs.includes("isNaN(seconds)"), 'formatTime should check for NaN');
  assert(utilsJs.includes("return '0:00'"), 'formatTime should return 0:00 for invalid input');
});

test('main.js references formatTime from utils.js (not duplicate)', () => {
  // main.js should have a comment about formatTime being in utils.js
  assert(mainJs.includes('formatTime is defined in utils.js'), 'Should reference utils.js formatTime');
});

test('utils.js has setStatus with null check', () => {
  assert(utilsJs.includes("if (statusEl)"), 'setStatus should have null check');
});

test('slice8-silence.js references showRazorSection from slice9', () => {
  assert(slice8Js.includes('showRazorSection is defined in slice9-razor.js'),
    'Should reference slice9 for showRazorSection');
});

test('slice9-razor.js defines showRazorSection', () => {
  assert(slice9Js.includes('function showRazorSection()'), 'showRazorSection should be in slice9');
});

// Count function definitions to ensure no duplicates
test('formatTime is defined exactly once across files', () => {
  const formatTimeInUtils = (utilsJs.match(/function formatTime\(/g) || []).length;
  const formatTimeInMain = (mainJs.match(/function formatTime\(/g) || []).length;
  assert(formatTimeInUtils === 1, `Expected 1 in utils.js, found ${formatTimeInUtils}`);
  assert(formatTimeInMain === 0, `Expected 0 in main.js, found ${formatTimeInMain}`);
});

// ============================================================================
// 2.3: Fetch Timeout Support Tests
// ============================================================================
console.log('\nðŸ“¦ Feature 2.3: Fetch Timeout Support\n');

test('config.js exports fetchWithTimeout function', () => {
  assert(configJs.includes('async function fetchWithTimeout'), 'fetchWithTimeout function not found');
});

test('config.js defines timeout constants', () => {
  assert(configJs.includes('FETCH_TIMEOUT_DEFAULT'), 'FETCH_TIMEOUT_DEFAULT not found');
  assert(configJs.includes('FETCH_TIMEOUT_HEALTH'), 'FETCH_TIMEOUT_HEALTH not found');
  assert(configJs.includes('FETCH_TIMEOUT_PROCESSING'), 'FETCH_TIMEOUT_PROCESSING not found');
});

test('fetchWithTimeout uses AbortController', () => {
  assert(configJs.includes('AbortController'), 'Should use AbortController');
  assert(configJs.includes('controller.abort()'), 'Should call abort on timeout');
});

test('fetchWithTimeout throws "Request timed out" on abort', () => {
  assert(configJs.includes("throw new Error('Request timed out')"), 'Should throw timeout error');
});

test('main.js uses fetchWithTimeout for API calls', () => {
  const fetchWithTimeoutCount = (mainJs.match(/fetchWithTimeout\(/g) || []).length;
  assert(fetchWithTimeoutCount >= 6, `Expected 6+ fetchWithTimeout uses, found ${fetchWithTimeoutCount}`);
});

test('credits.js uses fetchWithTimeout', () => {
  assert(creditsJs.includes('fetchWithTimeout('), 'credits.js should use fetchWithTimeout');
});

test('settings.js uses fetchWithTimeout for license activation', () => {
  assert(settingsJs.includes('fetchWithTimeout('), 'settings.js should use fetchWithTimeout');
});

test('slice9-razor.js uses fetchWithTimeout', () => {
  assert(slice9Js.includes('fetchWithTimeout('), 'slice9 should use fetchWithTimeout');
});

test('health check uses FETCH_TIMEOUT_HEALTH (shorter timeout)', () => {
  assert(slice9Js.includes('FETCH_TIMEOUT_HEALTH'), 'FFprobe check should use short timeout');
});

test('processing endpoints use FETCH_TIMEOUT_PROCESSING (longer timeout)', () => {
  const processingTimeoutCount = (mainJs.match(/FETCH_TIMEOUT_PROCESSING/g) || []).length;
  assert(processingTimeoutCount >= 5, `Expected 5+ FETCH_TIMEOUT_PROCESSING uses, found ${processingTimeoutCount}`);
});

// ============================================================================
// 2.4: Standardized Error Response Parsing Tests
// ============================================================================
console.log('\nðŸ“¦ Feature 2.4: Standardized Error Response Parsing\n');

test('config.js exports parseErrorResponse function', () => {
  assert(configJs.includes('async function parseErrorResponse'), 'parseErrorResponse function not found');
});

test('parseErrorResponse handles error field', () => {
  assert(configJs.includes('data.error'), 'Should check data.error');
});

test('parseErrorResponse handles message field', () => {
  assert(configJs.includes('data.message'), 'Should check data.message');
});

test('parseErrorResponse handles JSON parse failure', () => {
  assert(configJs.includes('catch'), 'Should catch JSON parse errors');
  assert(configJs.includes('response.status'), 'Should fall back to status code');
});

test('main.js uses parseErrorResponse', () => {
  const parseErrorCount = (mainJs.match(/parseErrorResponse\(/g) || []).length;
  assert(parseErrorCount >= 5, `Expected 5+ parseErrorResponse uses, found ${parseErrorCount}`);
});

test('credits.js uses parseErrorResponse', () => {
  assert(creditsJs.includes('parseErrorResponse('), 'credits.js should use parseErrorResponse');
});

test('slice9-razor.js uses parseErrorResponse', () => {
  assert(slice9Js.includes('parseErrorResponse('), 'slice9 should use parseErrorResponse');
});

// ============================================================================
// Integration Tests - Simulated fetchWithTimeout behavior
// ============================================================================
console.log('\nðŸ“¦ Integration Tests: Fetch Timeout Behavior\n');

// Simulate the fetchWithTimeout function
async function simulateFetchWithTimeout(url, options = {}, timeout = 1000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    // Simulate a slow response
    await new Promise((resolve, reject) => {
      const timer = setTimeout(resolve, 500); // Fast response
      controller.signal.addEventListener('abort', () => {
        clearTimeout(timer);
        reject(new Error('AbortError'));
      });
    });
    clearTimeout(timeoutId);
    return { ok: true, status: 200 };
  } catch (err) {
    clearTimeout(timeoutId);
    if (err.message === 'AbortError') {
      throw new Error('Request timed out');
    }
    throw err;
  }
}

asyncTest('fetchWithTimeout completes before timeout', async () => {
  const response = await simulateFetchWithTimeout('http://test', {}, 1000);
  assert(response.ok === true, 'Should complete successfully');
});

asyncTest('fetchWithTimeout throws on timeout', async () => {
  try {
    await simulateFetchWithTimeout('http://test', {}, 1); // 1ms timeout
    await new Promise(r => setTimeout(r, 100)); // Wait for abort
    assert(false, 'Should have thrown');
  } catch (err) {
    assert(err.message === 'Request timed out', 'Should throw timeout error');
  }
});

// Simulate parseErrorResponse
async function simulateParseErrorResponse(response) {
  try {
    const data = response.json ? await response.json() : {};
    return data.error || data.message || `Error ${response.status}`;
  } catch {
    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
  }
}

asyncTest('parseErrorResponse extracts error field', async () => {
  const response = { status: 400, json: async () => ({ error: 'Bad request' }) };
  const msg = await simulateParseErrorResponse(response);
  assert(msg === 'Bad request', 'Should extract error field');
});

asyncTest('parseErrorResponse extracts message field', async () => {
  const response = { status: 401, json: async () => ({ message: 'Unauthorized' }) };
  const msg = await simulateParseErrorResponse(response);
  assert(msg === 'Unauthorized', 'Should extract message field');
});

asyncTest('parseErrorResponse handles JSON parse failure', async () => {
  const response = {
    status: 500,
    statusText: 'Internal Server Error',
    json: async () => { throw new Error('Invalid JSON'); }
  };
  const msg = await simulateParseErrorResponse(response);
  assert(msg.includes('500'), 'Should include status code');
});

asyncTest('parseErrorResponse handles empty body', async () => {
  const response = {
    status: 502,
    statusText: 'Bad Gateway',
    json: async () => ({})
  };
  const msg = await simulateParseErrorResponse(response);
  assert(msg.includes('502'), 'Should fall back to status code');
});

// ============================================================================
// Summary
// ============================================================================
console.log('\n' + '='.repeat(60));
console.log(`Phase 2 Tests: ${passed} passed, ${failed} failed`);
console.log('='.repeat(60) + '\n');

if (failed > 0) {
  process.exit(1);
}
