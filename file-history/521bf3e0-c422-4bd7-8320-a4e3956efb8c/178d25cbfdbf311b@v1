/**
 * Phase 2: Runtime E2E Tests
 *
 * Actually exercises the implemented features at runtime:
 * - fetchWithTimeout with real network calls
 * - parseErrorResponse with actual responses
 * - API calls using the new patterns
 */

const https = require('https');
const http = require('http');

// Test helpers
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`  âœ“ ${name}`);
    passed++;
  } catch (err) {
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    failed++;
  }
}

async function asyncTest(name, fn) {
  try {
    await fn();
    console.log(`  âœ“ ${name}`);
    passed++;
  } catch (err) {
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    failed++;
  }
}

// ============================================================================
// Implement the functions exactly as they are in config.js
// ============================================================================

const BACKEND_URL_DEV = 'https://127.0.0.1:3847';
const FETCH_TIMEOUT_DEFAULT = 30000;
const FETCH_TIMEOUT_HEALTH = 5000;
const FETCH_TIMEOUT_PROCESSING = 120000;

function getBackendUrl() {
  return BACKEND_URL_DEV;
}

async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT_DEFAULT) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (err) {
    clearTimeout(timeoutId);
    if (err.name === 'AbortError') {
      throw new Error('Request timed out');
    }
    throw err;
  }
}

async function parseErrorResponse(response) {
  try {
    const data = await response.json();
    return data.error || data.message || `Error ${response.status}`;
  } catch {
    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
  }
}

// Custom fetch for Node.js with self-signed cert support
const agent = new https.Agent({ rejectUnauthorized: false });

async function nodeFetch(url, options = {}) {
  return fetch(url, { ...options, agent });
}

async function nodeFetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT_DEFAULT) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
      agent
    });
    clearTimeout(timeoutId);
    return response;
  } catch (err) {
    clearTimeout(timeoutId);
    if (err.name === 'AbortError') {
      throw new Error('Request timed out');
    }
    throw err;
  }
}

// ============================================================================
// Feature 2.1: Centralized URL Configuration - Runtime Tests
// ============================================================================
console.log('\nðŸ”Œ Feature 2.1: Centralized URL Runtime Tests\n');

test('getBackendUrl returns correct dev URL', () => {
  const url = getBackendUrl();
  if (url !== 'https://127.0.0.1:3847') {
    throw new Error(`Expected https://127.0.0.1:3847, got ${url}`);
  }
});

asyncTest('Backend health check responds at configured URL', async () => {
  const url = `${getBackendUrl()}/health`;
  const response = await nodeFetch(url);
  if (!response.ok) {
    throw new Error(`Health check failed with status ${response.status}`);
  }
  const data = await response.json();
  if (data.status !== 'ok') {
    throw new Error(`Expected status "ok", got "${data.status}"`);
  }
});

// ============================================================================
// Feature 2.3: Fetch Timeout - Runtime Tests
// ============================================================================
console.log('\nâ±ï¸ Feature 2.3: Fetch Timeout Runtime Tests\n');

asyncTest('fetchWithTimeout completes fast requests successfully', async () => {
  const response = await nodeFetchWithTimeout(`${getBackendUrl()}/health`, {}, 5000);
  if (!response.ok) {
    throw new Error(`Request failed with status ${response.status}`);
  }
});

asyncTest('fetchWithTimeout throws on very short timeout', async () => {
  try {
    // Use a 1ms timeout - request cannot complete this fast
    await nodeFetchWithTimeout(`${getBackendUrl()}/health`, {}, 1);
    throw new Error('Should have timed out');
  } catch (err) {
    if (!err.message.includes('timed out') && err.name !== 'AbortError') {
      throw new Error(`Expected timeout error, got: ${err.message}`);
    }
  }
});

asyncTest('Health endpoint responds within FETCH_TIMEOUT_HEALTH (5s)', async () => {
  const start = Date.now();
  const response = await nodeFetchWithTimeout(`${getBackendUrl()}/health`, {}, FETCH_TIMEOUT_HEALTH);
  const elapsed = Date.now() - start;

  if (!response.ok) {
    throw new Error(`Health check failed with status ${response.status}`);
  }
  if (elapsed > FETCH_TIMEOUT_HEALTH) {
    throw new Error(`Request took ${elapsed}ms, exceeds ${FETCH_TIMEOUT_HEALTH}ms timeout`);
  }
});

// ============================================================================
// Feature 2.4: Error Response Parsing - Runtime Tests
// ============================================================================
console.log('\nðŸ”´ Feature 2.4: Error Parsing Runtime Tests\n');

asyncTest('parseErrorResponse handles 404 with error field', async () => {
  // Call an endpoint that doesn't exist
  const response = await nodeFetch(`${getBackendUrl()}/nonexistent-endpoint-xyz`);
  if (response.ok) {
    throw new Error('Expected 404, got success');
  }

  const errorMsg = await parseErrorResponse(response);
  // Should contain "404" or an error message
  if (!errorMsg && response.status !== 404) {
    throw new Error(`Expected error message, got empty`);
  }
});

asyncTest('parseErrorResponse handles missing auth header (401/403)', async () => {
  // Call credits endpoint without auth header
  const response = await nodeFetch(`${getBackendUrl()}/credits`);

  // Clone response to read body twice
  const clonedResponse = response.clone();

  if (response.status === 401 || response.status === 403 || response.status === 400) {
    const errorMsg = await parseErrorResponse(clonedResponse);
    if (!errorMsg) {
      throw new Error('Expected error message for auth failure');
    }
  }
});

asyncTest('parseErrorResponse handles invalid JSON gracefully', async () => {
  // Create a mock response with invalid JSON
  const mockResponse = {
    status: 500,
    statusText: 'Internal Server Error',
    json: async () => { throw new SyntaxError('Invalid JSON'); }
  };

  const errorMsg = await parseErrorResponse(mockResponse);
  if (!errorMsg.includes('500')) {
    throw new Error(`Expected status code in message, got: ${errorMsg}`);
  }
});

// ============================================================================
// Integration Tests: Full API Calls with New Patterns
// ============================================================================
console.log('\nðŸ”— Integration Tests: Full API Patterns\n');

asyncTest('Credits endpoint with proper headers returns data or auth error', async () => {
  const response = await nodeFetchWithTimeout(`${getBackendUrl()}/credits`, {
    method: 'GET',
    headers: {
      'x-stripe-customer-id': 'cus_test_nonexistent'
    }
  }, FETCH_TIMEOUT_DEFAULT);

  // Either success with data or proper error response
  if (response.ok) {
    const data = await response.json();
    // Should have expected fields
    if (typeof data.hoursRemaining === 'undefined') {
      throw new Error('Missing hoursRemaining in response');
    }
  } else {
    // Should return parseable error
    const errorMsg = await parseErrorResponse(response);
    if (!errorMsg) {
      throw new Error('Expected error message for failed request');
    }
  }
});

asyncTest('FFprobe check endpoint works with timeout', async () => {
  const response = await nodeFetchWithTimeout(
    `${getBackendUrl()}/ffprobe-check`,
    {},
    FETCH_TIMEOUT_HEALTH
  );

  if (!response.ok) {
    throw new Error(`FFprobe check failed: ${response.status}`);
  }

  const data = await response.json();
  // Should have installed field
  if (typeof data.installed !== 'boolean') {
    throw new Error('Missing installed field in ffprobe-check response');
  }
});

asyncTest('API metadata endpoint returns version info', async () => {
  const response = await nodeFetchWithTimeout(
    `${getBackendUrl()}/`,
    {},
    FETCH_TIMEOUT_DEFAULT
  );

  if (!response.ok) {
    throw new Error(`API metadata failed: ${response.status}`);
  }

  const data = await response.json();
  if (!data.name || !data.version) {
    throw new Error('Missing name or version in API metadata');
  }
});

asyncTest('Silences endpoint requires auth (returns proper error)', async () => {
  const response = await nodeFetchWithTimeout(
    `${getBackendUrl()}/silences-audio`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ wavPath: '/tmp/test.wav' })
    },
    FETCH_TIMEOUT_DEFAULT
  );

  // Should return auth error, not crash
  if (response.ok) {
    // Might succeed if no auth required in dev mode
    console.log('    (Note: endpoint succeeded without auth - dev mode?)');
  } else {
    const errorMsg = await parseErrorResponse(response);
    if (!errorMsg) {
      throw new Error('Expected parseable error response');
    }
  }
});

// ============================================================================
// Concurrent Request Tests
// ============================================================================
console.log('\nâš¡ Concurrent Request Tests\n');

asyncTest('Multiple concurrent requests complete successfully', async () => {
  const urls = [
    `${getBackendUrl()}/health`,
    `${getBackendUrl()}/`,
    `${getBackendUrl()}/ffprobe-check`
  ];

  const promises = urls.map(url =>
    nodeFetchWithTimeout(url, {}, FETCH_TIMEOUT_DEFAULT)
  );

  const responses = await Promise.all(promises);

  for (let i = 0; i < responses.length; i++) {
    if (!responses[i].ok) {
      throw new Error(`Request ${i} failed: ${responses[i].status}`);
    }
  }
});

asyncTest('Rapid sequential requests work correctly', async () => {
  for (let i = 0; i < 5; i++) {
    const response = await nodeFetchWithTimeout(
      `${getBackendUrl()}/health`,
      {},
      FETCH_TIMEOUT_HEALTH
    );
    if (!response.ok) {
      throw new Error(`Request ${i + 1}/5 failed`);
    }
  }
});

// ============================================================================
// Summary
// ============================================================================
console.log('\n' + '='.repeat(60));
console.log(`Phase 2 Runtime Tests: ${passed} passed, ${failed} failed`);
console.log('='.repeat(60) + '\n');

if (failed > 0) {
  process.exit(1);
}
