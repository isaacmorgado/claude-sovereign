/**
 * Slice 8: Silence Detection Utilities
 *
 * Provides core functionality for silence detection and removal.
 * UI workflow is now handled by main.js.
 */

// Store detected silences
let currentSilences = [];

/**
 * Get current silences
 */
function getCurrentSilences() {
  return currentSilences;
}

/**
 * Set current silences (used by main.js)
 */
function setCurrentSilences(silences) {
  currentSilences = silences;
}

/**
 * Maps 0-100 sensitivity slider to detection parameters
 * Lower = keep more pauses, Higher = remove more aggressively
 */
function mapSensitivity(value) {
  const t = value / 100;
  return {
    dbThreshold: Math.round(-50 + (30 * t)),                    // -50dB → -20dB
    minDuration: parseFloat((2.0 - (1.7 * t)).toFixed(2)),      // 2.0s → 0.3s
    padding: parseFloat((0.2 - (0.15 * t)).toFixed(2))          // 0.2s → 0.05s
  };
}

/**
 * Remove silences from timeline by disabling clips
 * Returns count of disabled clips
 */
async function removeSilencesFromTimeline() {
  if (!currentSilences || currentSilences.length === 0) {
    return 0;
  }

  const context = await getActiveSequence();
  if (!context) {
    throw new Error('No project or sequence open');
  }

  const { sequence } = context;

  // Sort silences by start time DESCENDING (work from end to avoid time shifts)
  const sortedSilences = [...currentSilences].sort((a, b) => b.start - a.start);

  let removedCount = 0;
  const videoTrackCount = await sequence.getVideoTrackCount();
  const audioTrackCount = await sequence.getAudioTrackCount();

  for (const silence of sortedSilences) {
    const startTicks = Math.floor(silence.start * TICKS_PER_SECOND);
    const endTicks = Math.floor(silence.end * TICKS_PER_SECOND);

    // Process video tracks
    for (let i = 0; i < videoTrackCount; i++) {
      const track = await sequence.getVideoTrack(i);
      if (!track) continue;

      const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      if (!clips) continue;

      for (let j = clips.length - 1; j >= 0; j--) {
        const clip = clips[j];
        if (!clip) continue;

        const clipStartObj = await clip.getStartTime();
        const clipEndObj = await clip.getEndTime();
        const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
        const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

        // Check if clip is FULLY CONTAINED within silence region
        if (clipStart >= startTicks && clipEnd <= endTicks) {
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;

          await project.lockedAccess(async () => {
            await project.executeTransaction((compoundAction) => {
              const disableAction = clipRef.createSetDisabledAction(true);
              compoundAction.addAction(disableAction);
            }, 'SPLICE: Remove Silence');
          });
          removedCount++;
        }
      }
    }

    // Process audio tracks
    for (let i = 0; i < audioTrackCount; i++) {
      const track = await sequence.getAudioTrack(i);
      if (!track) continue;

      const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      if (!clips) continue;

      for (let j = clips.length - 1; j >= 0; j--) {
        const clip = clips[j];
        if (!clip) continue;

        const clipStartObj = await clip.getStartTime();
        const clipEndObj = await clip.getEndTime();
        const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
        const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

        // Check if clip is FULLY CONTAINED within silence region
        if (clipStart >= startTicks && clipEnd <= endTicks) {
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;

          await project.lockedAccess(async () => {
            await project.executeTransaction((compoundAction) => {
              const disableAction = clipRef.createSetDisabledAction(true);
              compoundAction.addAction(disableAction);
            }, 'SPLICE: Remove Silence');
          });
          removedCount++;
        }
      }
    }
  }

  return removedCount;
}

// showRazorSection is defined in slice9-razor.js - using centralized version

// Legacy function name for compatibility
function showSilenceSection() {
  // No longer needed in new UI
}

// Legacy init function - no longer needed
function initDetectRemove() {
  // Workflow is now handled by main.js initSilenceWorkflow()
}
