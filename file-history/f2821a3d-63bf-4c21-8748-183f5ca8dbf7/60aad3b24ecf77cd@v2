/**
 * End-to-End Tests for Word-Level Transcription
 *
 * Tests the transcribeWithWords function and endpoint integration.
 * Uses mocked OpenAI responses to test without API calls.
 */

const { detectProfanity } = require('../services/profanityDetection');
const { detectStutters, detectAllRepetitions } = require('../services/repetitionDetection');

// Mock transcript with word-level timestamps (simulating Whisper output)
const mockTranscriptWithWords = {
  text: "Hello I I I think we we we need to check for stutters. The damn quick brown fox jumps over the lazy dog.",
  words: [
    { word: "Hello", start: 0.0, end: 0.5 },
    { word: "I", start: 0.6, end: 0.7 },
    { word: "I", start: 0.75, end: 0.85 },
    { word: "I", start: 0.9, end: 1.0 },
    { word: "think", start: 1.1, end: 1.4 },
    { word: "we", start: 1.5, end: 1.6 },
    { word: "we", start: 1.65, end: 1.75 },
    { word: "we", start: 1.8, end: 1.9 },
    { word: "need", start: 2.0, end: 2.3 },
    { word: "to", start: 2.4, end: 2.5 },
    { word: "check", start: 2.6, end: 2.9 },
    { word: "for", start: 3.0, end: 3.1 },
    { word: "stutters", start: 3.2, end: 3.6 },
    { word: "The", start: 3.8, end: 4.0 },
    { word: "damn", start: 4.1, end: 4.4 },
    { word: "quick", start: 4.5, end: 4.8 },
    { word: "brown", start: 4.9, end: 5.2 },
    { word: "fox", start: 5.3, end: 5.5 },
    { word: "jumps", start: 5.6, end: 5.9 },
    { word: "over", start: 6.0, end: 6.2 },
    { word: "the", start: 6.3, end: 6.4 },
    { word: "lazy", start: 6.5, end: 6.8 },
    { word: "dog", start: 6.9, end: 7.1 }
  ],
  language: "en",
  duration: 7.5
};

// Test stutter detection
function testStutterDetection() {
  console.log('\n=== Test: Stutter Detection ===');

  const startTime = Date.now();
  const result = detectStutters(mockTranscriptWithWords, {
    minRepeats: 2,
    maxGapMs: 500,
    ignoreFillers: true,
    minWordLength: 1  // Allow single-char words like "I"
  });
  const duration = Date.now() - startTime;

  console.log(`Duration: ${duration}ms`);
  console.log(`Stutters found: ${result.stutters.length}`);

  // Should find "I I I" and "we we we"
  if (result.stutters.length !== 2) {
    console.error(`FAIL: Expected 2 stutters, got ${result.stutters.length}`);
    return false;
  }

  // Verify "I" stutter (single char word)
  const iStutter = result.stutters.find(s => s.word === 'i');
  if (!iStutter) {
    console.error('FAIL: "I" stutter not detected (single char word issue!)');
    return false;
  }
  console.log(`✓ "I" stutter detected: ${iStutter.occurrences} occurrences`);

  // Verify "we" stutter
  const weStutter = result.stutters.find(s => s.word === 'we');
  if (!weStutter) {
    console.error('FAIL: "we" stutter not detected');
    return false;
  }
  console.log(`✓ "we" stutter detected: ${weStutter.occurrences} occurrences`);

  console.log('✓ PASS: Stutter detection working correctly');
  return true;
}

// Test profanity detection
function testProfanityDetection() {
  console.log('\n=== Test: Profanity Detection ===');

  const startTime = Date.now();
  const result = detectProfanity(mockTranscriptWithWords, {
    language: 'en',
    customBlocklist: [],
    customAllowlist: [],
    frameRate: 30
  });
  const duration = Date.now() - startTime;

  console.log(`Duration: ${duration}ms`);
  console.log(`Profanity found: ${result.metadata?.profanityCount || 0}`);
  console.log(`Words checked: ${result.metadata?.totalWords || 'N/A'}`);

  // Should find "damn"
  if (!result.metadata?.profanityCount || result.metadata.profanityCount < 1) {
    console.error('FAIL: Expected at least 1 profanity word (damn)');
    return false;
  }

  const damnWord = result.words?.find(w => w.text?.toLowerCase() === 'damn' && w.isProfanity);
  if (damnWord) {
    console.log(`✓ "damn" detected at ${damnWord.start}s - ${damnWord.end}s`);
  }

  console.log('✓ PASS: Profanity detection working correctly');
  return true;
}

// Test repetition detection
async function testRepetitionDetection() {
  console.log('\n=== Test: Repetition Detection ===');

  const startTime = Date.now();
  const result = await detectAllRepetitions(mockTranscriptWithWords, {
    phraseSize: 3,
    tolerance: 0.7,
    searchRadius: 50,
    useOpenAI: false
  });
  const duration = Date.now() - startTime;

  console.log(`Duration: ${duration}ms`);
  console.log(`Phrase repetitions: ${result.repetitions?.length || 0}`);
  console.log(`Stutters: ${result.stutters?.length || 0}`);
  console.log(`Removal segments: ${result.removalSegments?.length || 0}`);

  console.log('✓ PASS: Repetition detection completed');
  return true;
}

// Performance test with larger dataset
async function testPerformance() {
  console.log('\n=== Test: Performance with Large Dataset ===');

  // Create a large transcript (1000 words)
  const largeTranscript = {
    text: '',
    words: [],
    language: 'en',
    duration: 600
  };

  const sampleWords = ['hello', 'world', 'test', 'check', 'word', 'think', 'need', 'want'];
  let time = 0;

  for (let i = 0; i < 1000; i++) {
    const word = sampleWords[i % sampleWords.length];
    largeTranscript.words.push({
      word,
      start: time,
      end: time + 0.3
    });
    time += 0.35;
  }

  // Add some stutters
  largeTranscript.words.splice(100, 0,
    { word: 'I', start: 35, end: 35.1 },
    { word: 'I', start: 35.15, end: 35.25 },
    { word: 'I', start: 35.3, end: 35.4 }
  );

  console.log(`Dataset size: ${largeTranscript.words.length} words`);

  // Measure stutter detection
  let start = Date.now();
  const stutterResult = detectStutters(largeTranscript, { minRepeats: 2, minWordLength: 1 });
  const stutterTime = Date.now() - start;
  console.log(`Stutter detection: ${stutterTime}ms (${stutterResult.stutters.length} found)`);

  // Measure profanity detection
  start = Date.now();
  const profanityResult = detectProfanity(largeTranscript, { language: 'en' });
  const profanityTime = Date.now() - start;
  console.log(`Profanity detection: ${profanityTime}ms`);

  // Measure full repetition detection (can be slower due to phrase comparison)
  start = Date.now();
  const repResult = await detectAllRepetitions(largeTranscript, {
    phraseSize: 3,
    tolerance: 0.7,
    searchRadius: 50
  });
  const repTime = Date.now() - start;
  console.log(`Full repetition detection: ${repTime}ms`);

  // Performance thresholds
  const maxAcceptableTime = 1000; // 1 second
  if (stutterTime > maxAcceptableTime) {
    console.warn(`⚠ WARNING: Stutter detection took ${stutterTime}ms (>1s)`);
  }
  if (repTime > maxAcceptableTime) {
    console.warn(`⚠ WARNING: Repetition detection took ${repTime}ms (>1s)`);
  }

  console.log('✓ Performance test completed');
  return true;
}

// Test cache key uniqueness
function testCacheKeys() {
  console.log('\n=== Test: Cache Key Design ===');

  // Simulate cache behavior
  const cache = new Map();

  const path1 = '/tmp/test.wav';
  const path2 = '/tmp/test.wav';

  // Standard cache
  cache.set(path1, { type: 'segment' });
  cache.set(`words:${path2}`, { type: 'words' });

  console.log(`Cache entries: ${cache.size}`);
  console.log(`Segment cache: ${cache.get(path1)?.type}`);
  console.log(`Words cache: ${cache.get(`words:${path2}`)?.type}`);

  if (cache.size !== 2) {
    console.error('FAIL: Cache keys should be unique for segment vs word caches');
    return false;
  }

  console.log('✓ PASS: Cache keys are correctly separated');
  return true;
}

// Run all tests
async function runAllTests() {
  console.log('='.repeat(60));
  console.log('SPLICE Word-Level Transcription E2E Tests');
  console.log('='.repeat(60));

  const results = [];

  try {
    results.push({ name: 'Stutter Detection', pass: testStutterDetection() });
    results.push({ name: 'Profanity Detection', pass: testProfanityDetection() });
    results.push({ name: 'Repetition Detection', pass: await testRepetitionDetection() });
    results.push({ name: 'Performance', pass: await testPerformance() });
    results.push({ name: 'Cache Keys', pass: testCacheKeys() });
  } catch (err) {
    console.error('\n❌ Test error:', err.message);
    console.error(err.stack);
  }

  console.log('\n' + '='.repeat(60));
  console.log('SUMMARY');
  console.log('='.repeat(60));

  let passed = 0;
  let failed = 0;

  for (const r of results) {
    const status = r.pass ? '✓ PASS' : '✗ FAIL';
    console.log(`${status}: ${r.name}`);
    if (r.pass) passed++; else failed++;
  }

  console.log(`\nTotal: ${passed} passed, ${failed} failed`);

  process.exit(failed > 0 ? 1 : 0);
}

runAllTests();
