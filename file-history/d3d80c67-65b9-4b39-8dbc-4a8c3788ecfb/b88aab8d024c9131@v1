/**
 * Vocal Isolation Service
 *
 * Uses Replicate's Demucs model to separate vocals from audio.
 * Cost: ~$0.015/min
 *
 * Workflow:
 * 1. Upload audio to temporary URL (or use file path)
 * 2. Call Replicate Demucs API
 * 3. Download isolated vocals track
 * 4. Return path to clean vocals file
 */

const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');

// Replicate API configuration
const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;
const DEMUCS_MODEL = 'cjwbw/demucs:25a173108cff36ef9f80f854c162d01df9e6528be175794b81571f6c6c8a9c68';

/**
 * Isolate vocals from an audio file using Demucs via Replicate
 *
 * @param {string} audioPath - Path to input audio file
 * @param {Object} options - Configuration options
 * @param {string} options.outputDir - Directory for output (default: same as input)
 * @param {string} options.stem - Which stem to extract: 'vocals', 'drums', 'bass', 'other' (default: 'vocals')
 * @returns {Promise<Object>} Result with path to isolated vocals
 */
async function isolateVocals(audioPath, options = {}) {
  const { outputDir = path.dirname(audioPath), stem = 'vocals' } = options;

  if (!REPLICATE_API_TOKEN) {
    throw new Error('REPLICATE_API_TOKEN environment variable is required');
  }

  if (!fs.existsSync(audioPath)) {
    throw new Error(`Audio file not found: ${audioPath}`);
  }

  console.log(`[VocalIsolation] Starting isolation for: ${audioPath}`);
  const startTime = Date.now();

  // Read audio file and convert to base64 data URI
  const audioBuffer = fs.readFileSync(audioPath);
  const base64Audio = audioBuffer.toString('base64');
  const mimeType = getMimeType(audioPath);
  const dataUri = `data:${mimeType};base64,${base64Audio}`;

  // Create prediction on Replicate
  const prediction = await createPrediction(dataUri);
  console.log(`[VocalIsolation] Prediction created: ${prediction.id}`);

  // Poll for completion
  const result = await pollPrediction(prediction.id);

  if (result.status === 'failed') {
    throw new Error(`Vocal isolation failed: ${result.error || 'Unknown error'}`);
  }

  // Download the requested stem
  const stemUrl = result.output[stem];
  if (!stemUrl) {
    throw new Error(`Stem '${stem}' not found in output. Available: ${Object.keys(result.output).join(', ')}`);
  }

  // Generate output filename
  const inputBasename = path.basename(audioPath, path.extname(audioPath));
  const outputFilename = `${inputBasename}_${stem}.wav`;
  const outputPath = path.join(outputDir, outputFilename);

  // Download the isolated track
  await downloadFile(stemUrl, outputPath);

  const duration = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`[VocalIsolation] Complete in ${duration}s: ${outputPath}`);

  return {
    success: true,
    inputPath: audioPath,
    outputPath,
    stem,
    processingTime: parseFloat(duration),
    allStems: Object.keys(result.output)
  };
}

/**
 * Create a prediction on Replicate
 */
async function createPrediction(audioDataUri) {
  const requestBody = JSON.stringify({
    version: DEMUCS_MODEL.split(':')[1],
    input: {
      audio: audioDataUri,
      output_format: 'wav'
    }
  });

  return new Promise((resolve, reject) => {
    const req = https.request({
      hostname: 'api.replicate.com',
      path: '/v1/predictions',
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${REPLICATE_API_TOKEN}`,
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(requestBody)
      }
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          if (res.statusCode >= 400) {
            reject(new Error(`Replicate API error: ${parsed.detail || data}`));
          } else {
            resolve(parsed);
          }
        } catch (e) {
          reject(new Error(`Failed to parse Replicate response: ${data}`));
        }
      });
    });

    req.on('error', reject);
    req.write(requestBody);
    req.end();
  });
}

/**
 * Poll prediction status until complete
 */
async function pollPrediction(predictionId, maxWaitMs = 300000) {
  const startTime = Date.now();
  const pollInterval = 2000; // 2 seconds

  while (Date.now() - startTime < maxWaitMs) {
    const prediction = await getPrediction(predictionId);

    if (prediction.status === 'succeeded') {
      return prediction;
    }

    if (prediction.status === 'failed' || prediction.status === 'canceled') {
      return prediction;
    }

    console.log(`[VocalIsolation] Status: ${prediction.status}...`);
    await sleep(pollInterval);
  }

  throw new Error(`Prediction timed out after ${maxWaitMs / 1000}s`);
}

/**
 * Get prediction status from Replicate
 */
async function getPrediction(predictionId) {
  return new Promise((resolve, reject) => {
    const req = https.request({
      hostname: 'api.replicate.com',
      path: `/v1/predictions/${predictionId}`,
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${REPLICATE_API_TOKEN}`
      }
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          reject(new Error(`Failed to parse prediction status: ${data}`));
        }
      });
    });

    req.on('error', reject);
    req.end();
  });
}

/**
 * Download a file from URL to local path
 */
async function downloadFile(url, outputPath) {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(outputPath);
    const protocol = url.startsWith('https') ? https : http;

    protocol.get(url, (response) => {
      // Handle redirects
      if (response.statusCode === 301 || response.statusCode === 302) {
        file.close();
        fs.unlinkSync(outputPath);
        return downloadFile(response.headers.location, outputPath)
          .then(resolve)
          .catch(reject);
      }

      if (response.statusCode !== 200) {
        file.close();
        fs.unlinkSync(outputPath);
        reject(new Error(`Failed to download: HTTP ${response.statusCode}`));
        return;
      }

      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      file.close();
      fs.unlink(outputPath, () => {}); // Clean up partial file
      reject(err);
    });
  });
}

/**
 * Get MIME type from file extension
 */
function getMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  const mimeTypes = {
    '.wav': 'audio/wav',
    '.mp3': 'audio/mpeg',
    '.m4a': 'audio/mp4',
    '.flac': 'audio/flac',
    '.ogg': 'audio/ogg',
    '.aac': 'audio/aac'
  };
  return mimeTypes[ext] || 'audio/wav';
}

/**
 * Sleep utility
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Check if Replicate API token is configured
 */
function isReplicateConfigured() {
  return !!REPLICATE_API_TOKEN;
}

module.exports = {
  isolateVocals,
  isReplicateConfigured
};
