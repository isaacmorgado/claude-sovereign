import * as vscode from "vscode"
import * as path from "path"
import * as fs from "fs/promises"
import type {
	OrchestrationConfig,
	OrchestrationTask,
	OrchestrationSubtask,
	ProjectDependencies,
	WorkspaceContext,
} from "@multi-agent/types"
import { WorkspaceManager } from "./WorkspaceManager"

/**
 * Simple glob pattern matcher supporting * and ** wildcards
 */
function matchGlobPattern(pattern: string, filePath: string): boolean {
	// Normalize paths to use forward slashes
	const normalizedPath = filePath.replace(/\\/g, "/")
	const normalizedPattern = pattern.replace(/\\/g, "/")

	// Convert glob pattern to regex
	const regexPattern = normalizedPattern
		.replace(/\./g, "\\.") // Escape dots
		.replace(/\*\*/g, "___DOUBLE_STAR___") // Placeholder for **
		.replace(/\*/g, "[^/]*") // * matches anything except /
		.replace(/___DOUBLE_STAR___/g, ".*") // ** matches anything including /
		.replace(/\?/g, ".") // ? matches single char

	const regex = new RegExp(`^${regexPattern}$`)
	return regex.test(normalizedPath)
}

export interface OrchestratorOptions {
	workspaceManager: WorkspaceManager
	outputChannel: vscode.OutputChannel
}

export interface SharedContextFile {
	workspacePath: string
	relativePath: string
	absolutePath: string
	content: string
}

export interface ExecutionPlan {
	phases: ExecutionPhase[]
	totalSubtasks: number
}

export interface ExecutionPhase {
	phaseIndex: number
	subtasks: OrchestrationSubtask[]
}

/**
 * CrossProjectOrchestrator coordinates tasks across multiple workspaces
 * with dependency ordering and shared context propagation.
 */
export class CrossProjectOrchestrator implements vscode.Disposable {
	private readonly workspaceManager: WorkspaceManager
	private readonly outputChannel: vscode.OutputChannel
	private readonly disposables: vscode.Disposable[] = []

	// Active orchestration tasks
	private readonly activeTasks: Map<string, OrchestrationTask> = new Map()

	// Shared context cache
	private sharedContextCache: Map<string, SharedContextFile[]> = new Map()

	// Events
	private readonly _onTaskStarted = new vscode.EventEmitter<OrchestrationTask>()
	private readonly _onTaskCompleted = new vscode.EventEmitter<OrchestrationTask>()
	private readonly _onSubtaskUpdated = new vscode.EventEmitter<OrchestrationSubtask>()
	private readonly _onContextPropagated = new vscode.EventEmitter<SharedContextFile[]>()

	public readonly onTaskStarted = this._onTaskStarted.event
	public readonly onTaskCompleted = this._onTaskCompleted.event
	public readonly onSubtaskUpdated = this._onSubtaskUpdated.event
	public readonly onContextPropagated = this._onContextPropagated.event

	constructor(options: OrchestratorOptions) {
		this.workspaceManager = options.workspaceManager
		this.outputChannel = options.outputChannel
	}

	/**
	 * Create an orchestration task from a prompt targeting multiple workspaces
	 */
	createTask(
		name: string,
		prompt: string,
		targetWorkspaces: string[],
		dependencies?: ProjectDependencies,
	): OrchestrationTask {
		const taskId = `orch-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`

		// Get configured dependencies or use provided ones
		const projectDeps = dependencies || this.getConfiguredDependencies()

		// Create subtasks for each target workspace
		const subtasks = this.createSubtasks(taskId, prompt, targetWorkspaces, projectDeps)

		const task: OrchestrationTask = {
			id: taskId,
			name,
			prompt,
			targetWorkspaces,
			dependencies: projectDeps,
			status: "pending",
			subtasks,
		}

		this.activeTasks.set(taskId, task)
		this.log(`Created orchestration task: ${taskId} with ${subtasks.length} subtasks`)

		return task
	}

	/**
	 * Create subtasks with proper dependency relationships
	 */
	private createSubtasks(
		taskId: string,
		prompt: string,
		targetWorkspaces: string[],
		dependencies: ProjectDependencies,
	): OrchestrationSubtask[] {
		const subtasks: OrchestrationSubtask[] = []
		const workspaceToSubtaskId: Map<string, string> = new Map()

		// First pass: create subtask IDs
		for (const workspacePath of targetWorkspaces) {
			const subtaskId = `${taskId}-${path.basename(workspacePath)}`
			workspaceToSubtaskId.set(workspacePath, subtaskId)
		}

		// Second pass: create subtasks with dependency references
		for (const workspacePath of targetWorkspaces) {
			const subtaskId = workspaceToSubtaskId.get(workspacePath)!
			const workspaceDeps = dependencies[workspacePath] || []

			// Map workspace dependencies to subtask IDs
			const dependsOn = workspaceDeps
				.filter((dep) => targetWorkspaces.includes(dep))
				.map((dep) => workspaceToSubtaskId.get(dep))
				.filter((id): id is string => !!id)

			subtasks.push({
				id: subtaskId,
				workspacePath,
				prompt,
				status: dependsOn.length > 0 ? "waiting_dependency" : "pending",
				dependsOn,
			})
		}

		return subtasks
	}

	/**
	 * Get configured project dependencies from workspace config
	 */
	private getConfiguredDependencies(): ProjectDependencies {
		return this.workspaceManager.getProjectDependencies()
	}

	/**
	 * Compute execution plan using topological sort
	 */
	computeExecutionPlan(task: OrchestrationTask): ExecutionPlan {
		const sorted = this.topologicalSort(task.subtasks)
		const phases = this.groupIntoPhases(sorted)

		return {
			phases,
			totalSubtasks: task.subtasks.length,
		}
	}

	/**
	 * Topological sort of subtasks based on dependencies
	 * Returns subtasks in dependency order (dependencies first)
	 */
	topologicalSort(subtasks: OrchestrationSubtask[]): OrchestrationSubtask[] {
		const subtaskMap = new Map<string, OrchestrationSubtask>()
		for (const subtask of subtasks) {
			subtaskMap.set(subtask.id, subtask)
		}

		const visited = new Set<string>()
		const temp = new Set<string>()
		const result: OrchestrationSubtask[] = []

		const visit = (id: string): void => {
			if (visited.has(id)) {
				return
			}

			if (temp.has(id)) {
				throw new Error(`Circular dependency detected involving subtask: ${id}`)
			}

			const subtask = subtaskMap.get(id)
			if (!subtask) {
				return
			}

			temp.add(id)

			// Visit dependencies first
			for (const depId of subtask.dependsOn) {
				visit(depId)
			}

			temp.delete(id)
			visited.add(id)
			result.push(subtask)
		}

		// Visit all subtasks
		for (const subtask of subtasks) {
			visit(subtask.id)
		}

		return result
	}

	/**
	 * Group sorted subtasks into execution phases
	 * Subtasks in the same phase can run in parallel
	 */
	private groupIntoPhases(sortedSubtasks: OrchestrationSubtask[]): ExecutionPhase[] {
		const phases: ExecutionPhase[] = []
		const completedIds = new Set<string>()

		let remaining = [...sortedSubtasks]
		let phaseIndex = 0

		while (remaining.length > 0) {
			const phase: OrchestrationSubtask[] = []
			const toRemove: OrchestrationSubtask[] = []

			for (const subtask of remaining) {
				// Check if all dependencies are completed
				const allDepsCompleted = subtask.dependsOn.every((dep) => completedIds.has(dep))

				if (allDepsCompleted) {
					phase.push(subtask)
					toRemove.push(subtask)
				}
			}

			if (phase.length === 0 && remaining.length > 0) {
				// Should not happen with valid topological sort
				throw new Error("Unable to create execution phase - possible circular dependency")
			}

			// Mark phase subtasks as "completed" for next iteration
			for (const subtask of phase) {
				completedIds.add(subtask.id)
			}

			phases.push({
				phaseIndex,
				subtasks: phase,
			})

			remaining = remaining.filter((s) => !toRemove.includes(s))
			phaseIndex++
		}

		return phases
	}

	/**
	 * Execute an orchestration task
	 */
	async executeTask(
		task: OrchestrationTask,
		executeSubtask: (subtask: OrchestrationSubtask, context: WorkspaceContext) => Promise<string>,
	): Promise<void> {
		task.status = "running"
		task.startTime = Date.now()
		this._onTaskStarted.fire(task)

		this.log(`Starting orchestration task: ${task.id}`)

		try {
			const plan = this.computeExecutionPlan(task)

			for (const phase of plan.phases) {
				this.log(`Executing phase ${phase.phaseIndex + 1}/${plan.phases.length}`)

				// Execute all subtasks in this phase in parallel
				await Promise.all(
					phase.subtasks.map(async (subtask) => {
						await this.executeSubtask(subtask, task, executeSubtask)
					}),
				)

				// Check if any subtask in this phase failed
				const failedSubtask = phase.subtasks.find((s) => s.status === "failed")
				if (failedSubtask) {
					throw new Error(`Subtask ${failedSubtask.id} failed in phase ${phase.phaseIndex}`)
				}

				// Propagate shared context after each phase
				await this.propagateSharedContext(task.targetWorkspaces)
			}

			task.status = "completed"
			task.endTime = Date.now()
			this.log(`Orchestration task completed: ${task.id}`)
		} catch (error) {
			task.status = "failed"
			task.endTime = Date.now()
			this.log(`Orchestration task failed: ${task.id} - ${error}`)
			throw error
		} finally {
			this._onTaskCompleted.fire(task)
		}
	}

	/**
	 * Execute a single subtask
	 */
	private async executeSubtask(
		subtask: OrchestrationSubtask,
		task: OrchestrationTask,
		executeSubtask: (subtask: OrchestrationSubtask, context: WorkspaceContext) => Promise<string>,
	): Promise<void> {
		subtask.status = "running"
		this._onSubtaskUpdated.fire(subtask)

		this.log(`Executing subtask: ${subtask.id} for workspace ${subtask.workspacePath}`)

		try {
			// Get workspace context
			const context = this.workspaceManager.getWorkspaceContext(subtask.workspacePath)
			if (!context) {
				throw new Error(`No context available for workspace: ${subtask.workspacePath}`)
			}

			// Add shared context from dependencies to the context
			const sharedContext = await this.gatherSharedContext(
				subtask.dependsOn.map((depId) => {
					const depSubtask = task.subtasks.find((s) => s.id === depId)
					return depSubtask?.workspacePath
				}).filter((p): p is string => !!p),
			)

			// Execute the subtask
			const result = await executeSubtask(subtask, {
				...context,
				relatedWorkspaces: task.targetWorkspaces.filter((w) => w !== subtask.workspacePath),
			})

			subtask.result = result
			subtask.status = "completed"
			this.log(`Subtask completed: ${subtask.id}`)
		} catch (error) {
			subtask.status = "failed"
			subtask.result = error instanceof Error ? error.message : String(error)
			this.log(`Subtask failed: ${subtask.id} - ${subtask.result}`)
			throw error
		} finally {
			this._onSubtaskUpdated.fire(subtask)
		}
	}

	/**
	 * Gather shared context files from specified workspaces
	 */
	async gatherSharedContext(workspacePaths: string[]): Promise<SharedContextFile[]> {
		const sharedPatterns = this.getSharedContextPatterns()
		if (sharedPatterns.length === 0) {
			return []
		}

		const contextFiles: SharedContextFile[] = []

		for (const workspacePath of workspacePaths) {
			const files = await this.findMatchingFiles(workspacePath, sharedPatterns)
			contextFiles.push(...files)
		}

		return contextFiles
	}

	/**
	 * Get shared context file patterns from configuration
	 */
	private getSharedContextPatterns(): string[] {
		const configuredPatterns = this.workspaceManager.getSharedContextPatterns()
		if (configuredPatterns.length > 0) {
			return configuredPatterns
		}
		// Default patterns for shared context
		return ["**/*.d.ts", "**/package.json", "**/tsconfig.json"]
	}

	/**
	 * Find files matching patterns in a workspace
	 */
	private async findMatchingFiles(workspacePath: string, patterns: string[]): Promise<SharedContextFile[]> {
		const cacheKey = `${workspacePath}:${patterns.join(",")}`

		// Check cache
		if (this.sharedContextCache.has(cacheKey)) {
			return this.sharedContextCache.get(cacheKey)!
		}

		const files: SharedContextFile[] = []

		try {
			const allFiles = await this.walkDirectory(workspacePath)

			for (const absolutePath of allFiles) {
				const relativePath = path.relative(workspacePath, absolutePath)

				// Check if file matches any pattern
				const matches = patterns.some((pattern) => matchGlobPattern(pattern, relativePath))

				if (matches) {
					try {
						const content = await fs.readFile(absolutePath, "utf-8")
						files.push({
							workspacePath,
							relativePath,
							absolutePath,
							content,
						})
					} catch {
						// Skip files that can't be read
					}
				}
			}
		} catch {
			// Handle directory access errors
		}

		// Cache results
		this.sharedContextCache.set(cacheKey, files)

		return files
	}

	/**
	 * Walk directory and return all file paths
	 */
	private async walkDirectory(dir: string, maxDepth: number = 5): Promise<string[]> {
		const files: string[] = []

		const walk = async (currentDir: string, depth: number): Promise<void> => {
			if (depth > maxDepth) {
				return
			}

			try {
				const entries = await fs.readdir(currentDir, { withFileTypes: true })

				for (const entry of entries) {
					const fullPath = path.join(currentDir, entry.name)

					// Skip common non-project directories
					if (entry.isDirectory()) {
						if (["node_modules", ".git", "dist", "build", ".next", "coverage"].includes(entry.name)) {
							continue
						}
						await walk(fullPath, depth + 1)
					} else if (entry.isFile()) {
						files.push(fullPath)
					}
				}
			} catch {
				// Handle permission errors
			}
		}

		await walk(dir, 0)
		return files
	}

	/**
	 * Propagate shared context between workspaces after task completion
	 */
	async propagateSharedContext(workspacePaths: string[]): Promise<void> {
		const patterns = this.getSharedContextPatterns()
		if (patterns.length === 0) {
			return
		}

		// Invalidate cache to get fresh content
		this.sharedContextCache.clear()

		// Gather all shared context
		const allContext = await this.gatherSharedContext(workspacePaths)

		if (allContext.length > 0) {
			this.log(`Propagating ${allContext.length} shared context files`)
			this._onContextPropagated.fire(allContext)
		}
	}

	/**
	 * Get the status of all subtasks for a task
	 */
	getTaskStatus(taskId: string): OrchestrationTask | undefined {
		return this.activeTasks.get(taskId)
	}

	/**
	 * Get all active orchestration tasks
	 */
	getActiveTasks(): OrchestrationTask[] {
		return Array.from(this.activeTasks.values())
	}

	/**
	 * Cancel an orchestration task
	 */
	cancelTask(taskId: string): boolean {
		const task = this.activeTasks.get(taskId)
		if (!task || task.status === "completed" || task.status === "failed") {
			return false
		}

		task.status = "failed"
		task.endTime = Date.now()

		// Mark pending/waiting subtasks as failed
		for (const subtask of task.subtasks) {
			if (subtask.status === "pending" || subtask.status === "waiting_dependency") {
				subtask.status = "failed"
				subtask.result = "Task cancelled"
			}
		}

		this._onTaskCompleted.fire(task)
		this.log(`Orchestration task cancelled: ${taskId}`)

		return true
	}

	/**
	 * Clear shared context cache
	 */
	clearContextCache(): void {
		this.sharedContextCache.clear()
	}

	/**
	 * Remove completed task from active tasks
	 */
	removeTask(taskId: string): boolean {
		return this.activeTasks.delete(taskId)
	}

	/**
	 * Log a message
	 */
	private log(message: string): void {
		this.outputChannel.appendLine(`[CrossProjectOrchestrator] ${message}`)
	}

	/**
	 * Dispose the orchestrator
	 */
	dispose(): void {
		this.log("Disposing CrossProjectOrchestrator")

		for (const disposable of this.disposables) {
			disposable.dispose()
		}
		this.disposables.length = 0

		this._onTaskStarted.dispose()
		this._onTaskCompleted.dispose()
		this._onSubtaskUpdated.dispose()
		this._onContextPropagated.dispose()

		this.activeTasks.clear()
		this.sharedContextCache.clear()
	}
}
