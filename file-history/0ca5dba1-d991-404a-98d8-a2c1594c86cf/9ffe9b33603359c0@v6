<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SPLICE</title>
  <style>
    body {
      font-family: Adobe Clean, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #323232;
      color: #e1e1e1;
      margin: 0;
      padding: 16px;
    }
    h1 {
      font-size: 18px;
      font-weight: 500;
      margin: 0 0 16px 0;
    }
    #status {
      padding: 8px;
      background: #1e1e1e;
      border-radius: 4px;
      font-size: 14px;
      margin-bottom: 16px;
    }
    button {
      background: #0d6efd;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 100%;
      margin-bottom: 16px;
    }
    button:hover {
      background: #0b5ed7;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    #clips {
      background: #1e1e1e;
      border-radius: 4px;
      padding: 8px;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
    }
    .clip-item {
      padding: 4px 0;
      border-bottom: 1px solid #444;
    }
    .clip-item:last-child {
      border-bottom: none;
    }
    .no-clips {
      color: #888;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>SPLICE</h1>
  <p id="status">Plugin loaded!</p>
  <button id="readClipsBtn">Read Timeline Clips</button>
  <div id="clips"></div>

  <script>
    const ppro = require('premierepro');

    async function log(clipsEl, msg) {
      clipsEl.innerHTML += `<div class="clip-item">${msg}</div>`;
      console.log('SPLICE:', msg);
    }

    document.getElementById('readClipsBtn').addEventListener('click', async () => {
      const statusEl = document.getElementById('status');
      const clipsEl = document.getElementById('clips');
      const btn = document.getElementById('readClipsBtn');

      btn.disabled = true;
      statusEl.textContent = 'Reading clips...';
      clipsEl.innerHTML = '';

      try {
        // Get the active project
        const project = await ppro.Project.getActiveProject();
        await log(clipsEl, `Project: ${project ? 'found' : 'null'}`);

        if (!project) {
          statusEl.textContent = 'No project open';
          btn.disabled = false;
          return;
        }

        // Try to get active sequence - method should exist on project
        let sequence = null;

        // Method 1: project.getActiveSequence()
        if (typeof project.getActiveSequence === 'function') {
          sequence = await project.getActiveSequence();
          await log(clipsEl, `getActiveSequence(): ${sequence ? 'found' : 'null'}`);
        }

        // Method 2: Try Sequence class directly
        if (!sequence && ppro.Sequence && ppro.Sequence.getActiveSequence) {
          sequence = await ppro.Sequence.getActiveSequence();
          await log(clipsEl, `Sequence.getActiveSequence(): ${sequence ? 'found' : 'null'}`);
        }

        // Method 3: Try SequenceUtils
        if (!sequence && ppro.SequenceUtils) {
          const utilMethods = Object.getOwnPropertyNames(ppro.SequenceUtils);
          await log(clipsEl, `SequenceUtils methods: ${utilMethods.join(', ')}`);
          if (ppro.SequenceUtils.getActiveSequence) {
            sequence = await ppro.SequenceUtils.getActiveSequence();
          }
        }

        if (!sequence) {
          // Show all project methods for debugging
          const proto = Object.getPrototypeOf(project);
          const methods = Object.getOwnPropertyNames(proto).filter(k => typeof project[k] === 'function');
          await log(clipsEl, `Project methods: ${methods.join(', ')}`);
          statusEl.textContent = 'No active sequence found';
          btn.disabled = false;
          return;
        }

        const seqName = sequence.name;
        await log(clipsEl, `Sequence: ${seqName}`);

        // Get video track count and iterate
        const numTracks = await sequence.getVideoTrackCount();
        await log(clipsEl, `Video tracks: ${numTracks}`);

        const clipNames = [];
        for (let i = 0; i < numTracks; i++) {
          const track = await sequence.getVideoTrack(i);
          if (!track) continue;

          // Debug: show track methods on first track
          if (i === 0) {
            const trackProto = Object.getPrototypeOf(track);
            const trackMethods = Object.getOwnPropertyNames(trackProto).filter(m => !m.startsWith('_'));
            await log(clipsEl, `Track methods: ${trackMethods.join(', ')}`);
          }

          // Try to get clips/track items - may need parameters
          let clips = null;
          try {
            // Try with no params first
            clips = await track.getTrackItems();
          } catch (e1) {
            await log(clipsEl, `getTrackItems() error: ${e1.message}`);
            try {
              // Try with trackItemType parameter (0 = all, 1 = video, 2 = audio)
              clips = await track.getTrackItems(0);
            } catch (e2) {
              await log(clipsEl, `getTrackItems(0) error: ${e2.message}`);
              try {
                // Try with true/false
                clips = await track.getTrackItems(true);
              } catch (e3) {
                await log(clipsEl, `getTrackItems(true) error: ${e3.message}`);
                // Try getting all items via selection
                try {
                  clips = await track.getTrackItems(ppro.Constants?.TrackItemType?.ALL);
                } catch (e4) {
                  await log(clipsEl, `All attempts failed for track ${i}`);
                }
              }
            }
          }

          if (!clips) {
            continue;
          }

          await log(clipsEl, `Track ${i} clips type: ${typeof clips}, isArray: ${Array.isArray(clips)}, length: ${clips?.length}`);

          // Handle array or collection
          const numClips = Array.isArray(clips) ? clips.length : (clips.length ?? 0);
          for (let j = 0; j < numClips; j++) {
            const clip = Array.isArray(clips) ? clips[j] : (clips[j] || await clips.getItem?.(j));
            if (!clip) continue;

            // Debug first clip
            if (clipNames.length === 0) {
              const clipProto = Object.getPrototypeOf(clip);
              const clipMethods = Object.getOwnPropertyNames(clipProto).filter(m => !m.startsWith('_'));
              await log(clipsEl, `Clip props: ${clipMethods.slice(0, 15).join(', ')}`);
            }

            const name = clip.name ?? clip.getName?.() ?? `Clip ${i}-${j}`;
            clipNames.push(name);
          }
        }

        clipsEl.innerHTML = '';
        if (clipNames.length === 0) {
          clipsEl.innerHTML = '<div class="no-clips">No clips in timeline</div>';
          statusEl.textContent = 'No clips found';
        } else {
          clipsEl.innerHTML = clipNames
            .map(name => `<div class="clip-item">${name}</div>`)
            .join('');
          statusEl.textContent = `Found ${clipNames.length} clip(s)`;
        }
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
        await log(clipsEl, `Error: ${err.message}`);
        console.error('SPLICE error:', err);
      }

      btn.disabled = false;
    });
  </script>
</body>
</html>
