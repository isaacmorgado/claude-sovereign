/**
 * SPLICE Plugin Configuration
 *
 * Constants and configuration values used across all slices.
 */

// Backend API configuration
const BACKEND_URL_DEV = 'https://127.0.0.1:3847';
const BACKEND_URL_PROD = 'https://splice-api-production.up.railway.app';

// Default to dev URL - production detection handled by getBackendUrl()
const BACKEND_URL = BACKEND_URL_DEV;

/**
 * Get the backend URL with consistent fallback logic.
 * Used across all plugin modules for API calls.
 * @returns {string} Backend API base URL
 */
function getBackendUrl() {
  // Check if explicitly defined
  if (typeof BACKEND_URL !== 'undefined' && BACKEND_URL) {
    return BACKEND_URL;
  }
  // Fallback to dev URL (use 127.0.0.1, not localhost - UXP requirement)
  return BACKEND_URL_DEV;
}

// File paths - initialized dynamically for cross-platform support
// These are populated by initPaths() on plugin load
let WAV_PATH = null;
let XML_PATH = null;
let WAV_PRESET_PATH = null;

// Cache for initialized paths
let _pathsInitialized = false;

/**
 * Initialize file paths using UXP localFileSystem API.
 * Must be called once on plugin load before using file operations.
 * Cross-platform: works on macOS and Windows.
 * @returns {Promise<{wavPath: string, xmlPath: string, presetPath: string|null}>}
 */
async function initPaths() {
  if (_pathsInitialized && WAV_PATH && XML_PATH) {
    return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
  }

  try {
    const { localFileSystem } = require('uxp').storage;

    // Get UXP temp folder (cross-platform)
    const tempFolder = await localFileSystem.getTemporaryFolder();

    // Create temp files in UXP temp directory
    const wavFile = await tempFolder.createFile('splice_audio_export.wav', { overwrite: true });
    const xmlFile = await tempFolder.createFile('splice_export.xml', { overwrite: true });

    WAV_PATH = wavFile.nativePath;
    XML_PATH = xmlFile.nativePath;

    // Detect Premiere Pro preset path dynamically
    WAV_PRESET_PATH = await detectPresetPath();

    _pathsInitialized = true;
    console.log('[SPLICE Config] Paths initialized:', { WAV_PATH, XML_PATH, WAV_PRESET_PATH });

    return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
  } catch (err) {
    console.error('[SPLICE Config] Failed to initialize paths:', err);

    // Fallback to platform-specific temp paths
    const isMac = navigator.platform.toLowerCase().includes('mac');
    const tempDir = isMac ? '/tmp' : (process.env.TEMP || process.env.TMP || 'C:\\Windows\\Temp');

    WAV_PATH = `${tempDir}/splice_audio_export.wav`;
    XML_PATH = `${tempDir}/splice_export.xml`;
    WAV_PRESET_PATH = await detectPresetPath();

    _pathsInitialized = true;
    console.log('[SPLICE Config] Using fallback paths:', { WAV_PATH, XML_PATH, WAV_PRESET_PATH });

    return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
  }
}

/**
 * Detect Premiere Pro encoder preset path dynamically.
 * Searches multiple possible locations for different versions.
 * @returns {Promise<string|null>} Preset path or null if not found
 */
async function detectPresetPath() {
  const isMac = navigator.platform.toLowerCase().includes('mac');

  // Possible Premiere Pro installation paths
  const possiblePaths = isMac ? [
    // macOS paths - try multiple versions
    '/Applications/Adobe Premiere Pro 2025/Adobe Premiere Pro 2025.app/Contents/Settings/EncoderPresets/Wave48mono16.epr',
    '/Applications/Adobe Premiere Pro (Beta)/Adobe Premiere Pro (Beta).app/Contents/Settings/EncoderPresets/Wave48mono16.epr',
    '/Applications/Adobe Premiere Pro 2024/Adobe Premiere Pro 2024.app/Contents/Settings/EncoderPresets/Wave48mono16.epr',
    '/Applications/Adobe Premiere Pro/Adobe Premiere Pro.app/Contents/Settings/EncoderPresets/Wave48mono16.epr'
  ] : [
    // Windows paths
    'C:\\Program Files\\Adobe\\Adobe Premiere Pro 2025\\Settings\\EncoderPresets\\Wave48mono16.epr',
    'C:\\Program Files\\Adobe\\Adobe Premiere Pro (Beta)\\Settings\\EncoderPresets\\Wave48mono16.epr',
    'C:\\Program Files\\Adobe\\Adobe Premiere Pro 2024\\Settings\\EncoderPresets\\Wave48mono16.epr',
    'C:\\Program Files\\Adobe\\Adobe Premiere Pro\\Settings\\EncoderPresets\\Wave48mono16.epr'
  ];

  // Try to find existing preset file
  try {
    const { localFileSystem } = require('uxp').storage;

    for (const path of possiblePaths) {
      try {
        // Use UXP entry API to check if file exists
        const entry = await localFileSystem.getEntryWithUrl('file://' + encodeURI(path));
        if (entry) {
          console.log('[SPLICE Config] Found preset at:', path);
          return path;
        }
      } catch (e) {
        // File doesn't exist at this path, continue checking
      }
    }
  } catch (err) {
    console.warn('[SPLICE Config] Could not check preset paths:', err);
  }

  // Return first path as fallback (user can manually configure if needed)
  console.warn('[SPLICE Config] Preset path not found, using default');
  return possiblePaths[0];
}

/**
 * Get initialized paths (async getter).
 * Ensures paths are initialized before returning.
 * @returns {Promise<{wavPath: string, xmlPath: string, presetPath: string|null}>}
 */
async function getPaths() {
  if (!_pathsInitialized) {
    return await initPaths();
  }
  return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
}

/**
 * Check if a path exists and is accessible.
 * @param {string} path - File path to check
 * @returns {Promise<boolean>} True if path exists
 */
async function pathExists(path) {
  if (!path) return false;

  try {
    const { localFileSystem } = require('uxp').storage;
    const entry = await localFileSystem.getEntryWithUrl('file://' + encodeURI(path));
    return entry !== null;
  } catch {
    return false;
  }
}

// Premiere Pro timebase (ticks per second)
const TICKS_PER_SECOND = 254016000000;

// Fetch timeout configuration (milliseconds)
const FETCH_TIMEOUT_DEFAULT = 30000;      // 30 seconds for most requests
const FETCH_TIMEOUT_HEALTH = 5000;        // 5 seconds for health checks
const FETCH_TIMEOUT_PROCESSING = 120000;  // 2 minutes for processing endpoints

/**
 * Fetch with timeout support (AbortController-based).
 * Prevents UI from freezing if server hangs.
 * @param {string} url - URL to fetch
 * @param {Object} options - Fetch options
 * @param {number} [timeout] - Timeout in milliseconds (default: FETCH_TIMEOUT_DEFAULT)
 * @returns {Promise<Response>} Fetch response
 * @throws {Error} 'Request timed out' if timeout exceeded
 */
async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT_DEFAULT) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (err) {
    clearTimeout(timeoutId);
    if (err.name === 'AbortError') {
      throw new Error('Request timed out');
    }
    throw err;
  }
}

/**
 * Parse error response from API with consistent fallback.
 * Handles various error response formats gracefully.
 * @param {Response} response - Fetch response object
 * @returns {Promise<string>} Error message string
 */
async function parseErrorResponse(response) {
  try {
    const data = await response.json();
    return data.error || data.message || `Error ${response.status}`;
  } catch {
    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
  }
}
