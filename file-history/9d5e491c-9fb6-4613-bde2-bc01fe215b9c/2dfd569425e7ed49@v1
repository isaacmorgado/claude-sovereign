/**
 * Phase 4: Architecture Improvements Tests
 *
 * Tests for:
 * - 4.1 Dynamic File Paths (cross-platform support)
 * - 4.2 ARIA Labels (accessibility)
 * - 4.3 ProjectItemType Constant Fallback
 */

const assert = require('assert');
const fs = require('fs');
const path = require('path');

// Test helpers
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`✅ ${name}`);
    passed++;
  } catch (err) {
    console.log(`❌ ${name}`);
    console.log(`   Error: ${err.message}`);
    failed++;
  }
}

// =============================================================================
// 4.1 Dynamic File Paths Tests
// =============================================================================

console.log('\n=== 4.1 Dynamic File Paths (Cross-Platform) ===\n');

const configPath = path.join(__dirname, '../../splice-plugin/js/config.js');
const configSource = fs.readFileSync(configPath, 'utf-8');

test('config: paths are not hardcoded constants', () => {
  // Should use 'let' (mutable) not 'const' for paths
  const usesLetWavPath = configSource.includes('let WAV_PATH');
  const usesLetXmlPath = configSource.includes('let XML_PATH');
  const usesLetPresetPath = configSource.includes('let WAV_PRESET_PATH');

  console.log(`   WAV_PATH uses 'let': ${usesLetWavPath}`);
  console.log(`   XML_PATH uses 'let': ${usesLetXmlPath}`);
  console.log(`   WAV_PRESET_PATH uses 'let': ${usesLetPresetPath}`);

  assert(usesLetWavPath, 'WAV_PATH should use let (mutable)');
  assert(usesLetXmlPath, 'XML_PATH should use let (mutable)');
  assert(usesLetPresetPath, 'WAV_PRESET_PATH should use let (mutable)');
});

test('config: has initPaths() function', () => {
  const hasInitPaths = configSource.includes('async function initPaths()');
  const usesLocalFileSystem = configSource.includes('localFileSystem');
  const usesGetTemporaryFolder = configSource.includes('getTemporaryFolder');

  console.log(`   initPaths function exists: ${hasInitPaths}`);
  console.log(`   Uses UXP localFileSystem: ${usesLocalFileSystem}`);
  console.log(`   Uses getTemporaryFolder: ${usesGetTemporaryFolder}`);

  assert(hasInitPaths, 'Should have initPaths() function');
  assert(usesLocalFileSystem, 'Should use UXP localFileSystem API');
  assert(usesGetTemporaryFolder, 'Should use getTemporaryFolder for cross-platform temp dir');
});

test('config: has getPaths() async getter', () => {
  const hasGetPaths = configSource.includes('async function getPaths()');
  console.log(`   getPaths function exists: ${hasGetPaths}`);
  assert(hasGetPaths, 'Should have async getPaths() getter');
});

test('config: has detectPresetPath() for multiple Premiere versions', () => {
  const hasDetectPresetPath = configSource.includes('async function detectPresetPath()');
  const hasMacOSPaths = configSource.includes('/Applications/Adobe Premiere Pro');
  const hasWindowsPaths = configSource.includes('C:\\\\Program Files\\\\Adobe');
  const has2025Version = configSource.includes('2025');
  const has2024Version = configSource.includes('2024');

  console.log(`   detectPresetPath function exists: ${hasDetectPresetPath}`);
  console.log(`   Has macOS paths: ${hasMacOSPaths}`);
  console.log(`   Has Windows paths: ${hasWindowsPaths}`);
  console.log(`   Has 2025 version: ${has2025Version}`);
  console.log(`   Has 2024 version: ${has2024Version}`);

  assert(hasDetectPresetPath, 'Should have detectPresetPath() function');
  assert(hasMacOSPaths, 'Should include macOS application paths');
  assert(hasWindowsPaths, 'Should include Windows application paths');
});

test('config: has platform detection for fallback paths', () => {
  const hasPlatformCheck = configSource.includes('navigator.platform');
  const hasMacCheck = configSource.includes('mac');
  const hasTempFallback = configSource.includes('process.env.TEMP') || configSource.includes('/tmp');

  console.log(`   Platform detection: ${hasPlatformCheck}`);
  console.log(`   macOS check: ${hasMacCheck}`);
  console.log(`   Temp fallback: ${hasTempFallback}`);

  assert(hasPlatformCheck, 'Should detect platform via navigator.platform');
  assert(hasTempFallback, 'Should have fallback temp paths');
});

test('config: has pathExists() utility', () => {
  const hasPathExists = configSource.includes('async function pathExists(');
  console.log(`   pathExists function exists: ${hasPathExists}`);
  assert(hasPathExists, 'Should have pathExists() utility function');
});

// Test main.js integration
const mainPath = path.join(__dirname, '../../splice-plugin/js/main.js');
const mainSource = fs.readFileSync(mainPath, 'utf-8');

test('main.js: calls initPaths() on load', () => {
  const callsInitPaths = mainSource.includes('await initPaths()');
  console.log(`   main.js calls initPaths(): ${callsInitPaths}`);
  assert(callsInitPaths, 'main.js should call initPaths() on load');
});

test('main.js: exportAudioInternal uses getPaths()', () => {
  // Find exportAudioInternal function and check it uses getPaths
  const fnMatch = mainSource.match(/async function exportAudioInternal[\s\S]*?^}/m);
  assert(fnMatch, 'exportAudioInternal function not found');

  const usesGetPaths = fnMatch[0].includes('await getPaths()');
  const usesPathsWavPath = fnMatch[0].includes('paths.wavPath');

  console.log(`   Uses getPaths(): ${usesGetPaths}`);
  console.log(`   Uses paths.wavPath: ${usesPathsWavPath}`);

  assert(usesGetPaths, 'exportAudioInternal should call getPaths()');
  assert(usesPathsWavPath, 'exportAudioInternal should use paths.wavPath');
});

test('main.js: no hardcoded WAV_PATH references', () => {
  // Check that WAV_PATH is not used directly (should use paths.wavPath)
  // Exclude comments and the paths object access
  const lines = mainSource.split('\n');
  let hardcodedCount = 0;

  for (const line of lines) {
    // Skip comments
    if (line.trim().startsWith('//') || line.trim().startsWith('*')) continue;
    // Check for direct WAV_PATH usage (not paths.wavPath)
    if (line.includes('WAV_PATH') && !line.includes('paths.wavPath') && !line.includes('// ')) {
      // Exclude the paths object initialization
      if (!line.includes('paths = ') && !line.includes('const paths')) {
        hardcodedCount++;
      }
    }
  }

  console.log(`   Hardcoded WAV_PATH references: ${hardcodedCount}`);
  assert(hardcodedCount === 0, `Found ${hardcodedCount} hardcoded WAV_PATH references`);
});

// =============================================================================
// 4.2 ARIA Labels Tests
// =============================================================================

console.log('\n=== 4.2 ARIA Labels (Accessibility) ===\n');

const htmlPath = path.join(__dirname, '../../splice-plugin/index.html');
const htmlSource = fs.readFileSync(htmlPath, 'utf-8');

test('HTML: status bar has aria-live', () => {
  const hasAriaLive = htmlSource.includes('id="status"') && htmlSource.includes('aria-live="polite"');
  const hasAriaAtomic = htmlSource.includes('aria-atomic="true"');
  const hasRoleStatus = htmlSource.includes('role="status"');

  console.log(`   Status bar aria-live: ${hasAriaLive}`);
  console.log(`   Status bar aria-atomic: ${hasAriaAtomic}`);
  console.log(`   Status bar role: ${hasRoleStatus}`);

  assert(hasAriaLive, 'Status bar should have aria-live="polite"');
});

test('HTML: icon buttons have aria-labels', () => {
  // Check help button
  const helpBtnMatch = htmlSource.match(/id="helpBtn"[^>]*>/);
  const hasHelpAriaLabel = helpBtnMatch && helpBtnMatch[0].includes('aria-label=');

  // Check settings button
  const settingsBtnMatch = htmlSource.match(/id="settingsBtn"[^>]*>/);
  const hasSettingsAriaLabel = settingsBtnMatch && settingsBtnMatch[0].includes('aria-label=');

  console.log(`   Help button aria-label: ${hasHelpAriaLabel}`);
  console.log(`   Settings button aria-label: ${hasSettingsAriaLabel}`);

  assert(hasHelpAriaLabel, 'Help button should have aria-label');
  assert(hasSettingsAriaLabel, 'Settings button should have aria-label');
});

test('HTML: modals have proper dialog roles', () => {
  // Check login modal
  const loginModalMatch = htmlSource.match(/id="loginModal"[^>]*>/);
  const loginHasRole = loginModalMatch && loginModalMatch[0].includes('role="dialog"');
  const loginHasAriaModal = loginModalMatch && loginModalMatch[0].includes('aria-modal="true"');
  const loginHasLabelledBy = loginModalMatch && loginModalMatch[0].includes('aria-labelledby=');

  // Check settings modal
  const settingsModalMatch = htmlSource.match(/id="settingsModal"[^>]*>/);
  const settingsHasRole = settingsModalMatch && settingsModalMatch[0].includes('role="dialog"');

  // Check preset modal
  const presetModalMatch = htmlSource.match(/id="presetModal"[^>]*>/);
  const presetHasRole = presetModalMatch && presetModalMatch[0].includes('role="dialog"');

  // Check manage presets modal
  const managePresetsModalMatch = htmlSource.match(/id="managePresetsModal"[^>]*>/);
  const managePresetsHasRole = managePresetsModalMatch && managePresetsModalMatch[0].includes('role="dialog"');

  // Check confirm modal
  const confirmModalMatch = htmlSource.match(/id="confirmModal"[^>]*>/);
  const confirmHasRole = confirmModalMatch && confirmModalMatch[0].includes('role="dialog"');

  console.log(`   Login modal role="dialog": ${loginHasRole}`);
  console.log(`   Login modal aria-modal="true": ${loginHasAriaModal}`);
  console.log(`   Login modal aria-labelledby: ${loginHasLabelledBy}`);
  console.log(`   Settings modal role="dialog": ${settingsHasRole}`);
  console.log(`   Preset modal role="dialog": ${presetHasRole}`);
  console.log(`   Manage presets modal role="dialog": ${managePresetsHasRole}`);
  console.log(`   Confirm modal role="dialog": ${confirmHasRole}`);

  assert(loginHasRole, 'Login modal should have role="dialog"');
  assert(loginHasAriaModal, 'Login modal should have aria-modal="true"');
  assert(settingsHasRole, 'Settings modal should have role="dialog"');
  assert(presetHasRole, 'Preset modal should have role="dialog"');
  assert(managePresetsHasRole, 'Manage presets modal should have role="dialog"');
  assert(confirmHasRole, 'Confirm modal should have role="dialog"');
});

test('HTML: filter buttons have aria-labels', () => {
  // Check filter buttons group
  const hasFilterGroup = htmlSource.includes('class="preview-filters"') && htmlSource.includes('role="group"');
  const hasFilterAriaLabel = htmlSource.includes('aria-label="Filter silences');

  // Check individual filter buttons
  const lessThanHalfSecMatch = htmlSource.match(/data-min="0"[^>]*>/);
  const lessThanHalfSecAriaLabel = lessThanHalfSecMatch && lessThanHalfSecMatch[0].includes('aria-label=');

  console.log(`   Filter group has role: ${hasFilterGroup}`);
  console.log(`   Filter group has aria-label: ${hasFilterAriaLabel}`);
  console.log(`   Filter button has aria-label: ${lessThanHalfSecAriaLabel}`);

  assert(hasFilterGroup, 'Filter buttons should be in a group with role="group"');
  assert(lessThanHalfSecAriaLabel, 'Filter buttons should have aria-labels');
});

test('HTML: preview list has proper role', () => {
  const previewListMatch = htmlSource.match(/id="previewList"[^>]*>/);
  const hasRoleList = previewListMatch && previewListMatch[0].includes('role="list"');
  const hasAriaLabel = previewListMatch && previewListMatch[0].includes('aria-label=');

  console.log(`   Preview list role="list": ${hasRoleList}`);
  console.log(`   Preview list aria-label: ${hasAriaLabel}`);

  assert(hasRoleList, 'Preview list should have role="list"');
  assert(hasAriaLabel, 'Preview list should have aria-label');
});

test('HTML: modal close buttons have aria-labels', () => {
  // Check login close button
  const loginCloseMatch = htmlSource.match(/id="closeLoginBtn"[^>]*>/);
  const loginCloseAriaLabel = loginCloseMatch && loginCloseMatch[0].includes('aria-label=');

  // Check settings close button
  const settingsCloseMatch = htmlSource.match(/id="closeSettingsBtn"[^>]*>/);
  const settingsCloseAriaLabel = settingsCloseMatch && settingsCloseMatch[0].includes('aria-label=');

  // Check preset close button
  const presetCloseMatch = htmlSource.match(/id="closePresetModalBtn"[^>]*>/);
  const presetCloseAriaLabel = presetCloseMatch && presetCloseMatch[0].includes('aria-label=');

  console.log(`   Login close aria-label: ${loginCloseAriaLabel}`);
  console.log(`   Settings close aria-label: ${settingsCloseAriaLabel}`);
  console.log(`   Preset close aria-label: ${presetCloseAriaLabel}`);

  assert(loginCloseAriaLabel, 'Login close button should have aria-label');
  assert(settingsCloseAriaLabel, 'Settings close button should have aria-label');
  assert(presetCloseAriaLabel, 'Preset close button should have aria-label');
});

test('HTML: action buttons have aria-labels', () => {
  // Check apply button
  const applyBtnMatch = htmlSource.match(/id="applyPreviewBtn"[^>]*>/);
  const applyAriaLabel = applyBtnMatch && applyBtnMatch[0].includes('aria-label=');

  // Check cancel button
  const cancelBtnMatch = htmlSource.match(/id="cancelPreviewBtn"[^>]*>/);
  const cancelAriaLabel = cancelBtnMatch && cancelBtnMatch[0].includes('aria-label=');

  // Check build sequence button
  const buildBtnMatch = htmlSource.match(/id="buildSequenceBtn"[^>]*>/);
  const buildAriaLabel = buildBtnMatch && buildBtnMatch[0].includes('aria-label=');

  console.log(`   Apply button aria-label: ${applyAriaLabel}`);
  console.log(`   Cancel button aria-label: ${cancelAriaLabel}`);
  console.log(`   Build sequence button aria-label: ${buildAriaLabel}`);

  assert(applyAriaLabel, 'Apply button should have aria-label');
  assert(cancelAriaLabel, 'Cancel button should have aria-label');
  assert(buildAriaLabel, 'Build sequence button should have aria-label');
});

test('HTML: export/import preset buttons have aria-labels', () => {
  const exportBtnMatch = htmlSource.match(/id="exportPresetsBtn"[^>]*>/);
  const exportAriaLabel = exportBtnMatch && exportBtnMatch[0].includes('aria-label=');

  const importBtnMatch = htmlSource.match(/id="importPresetsBtn"[^>]*>/);
  const importAriaLabel = importBtnMatch && importBtnMatch[0].includes('aria-label=');

  console.log(`   Export button aria-label: ${exportAriaLabel}`);
  console.log(`   Import button aria-label: ${importAriaLabel}`);

  assert(exportAriaLabel, 'Export presets button should have aria-label');
  assert(importAriaLabel, 'Import presets button should have aria-label');
});

// =============================================================================
// 4.3 ProjectItemType Constant Fallback Tests
// =============================================================================

console.log('\n=== 4.3 ProjectItemType Constant Fallback ===\n');

const builderPath = path.join(__dirname, '../../splice-plugin/js/builder.js');
const builderSource = fs.readFileSync(builderPath, 'utf-8');

test('builder.js: has ProjectItemType fallback', () => {
  const hasProjectItemType = builderSource.includes('const ProjectItemType =');
  const hasOptionalChaining = builderSource.includes('pproBuilder?.Constants?.ProjectItemType');
  const hasFallbackObject = builderSource.includes('CLIP: 1') && builderSource.includes('BIN: 2');

  console.log(`   ProjectItemType constant defined: ${hasProjectItemType}`);
  console.log(`   Uses optional chaining: ${hasOptionalChaining}`);
  console.log(`   Has fallback values: ${hasFallbackObject}`);

  assert(hasProjectItemType, 'Should define ProjectItemType constant');
  assert(hasOptionalChaining, 'Should use optional chaining for pproBuilder.Constants');
  assert(hasFallbackObject, 'Should have fallback enum values');
});

test('builder.js: has TrackItemType fallback', () => {
  const hasTrackItemType = builderSource.includes('const TrackItemType =');
  const hasOptionalChaining = builderSource.includes('pproBuilder?.Constants?.TrackItemType');
  const hasFallbackObject = builderSource.includes('CLIP: 1') && builderSource.includes('TRANSITION: 2');

  console.log(`   TrackItemType constant defined: ${hasTrackItemType}`);
  console.log(`   Uses optional chaining: ${hasOptionalChaining}`);
  console.log(`   Has fallback values: ${hasFallbackObject}`);

  assert(hasTrackItemType, 'Should define TrackItemType constant');
  assert(hasOptionalChaining, 'Should use optional chaining for pproBuilder.Constants');
});

test('builder.js: uses local ProjectItemType.BIN (not pproBuilder.Constants)', () => {
  // Check that pproBuilder.Constants.ProjectItemType.BIN is NOT used
  const usesDirectConstant = builderSource.includes('pproBuilder.Constants.ProjectItemType.BIN');
  const usesLocalConstant = builderSource.includes('ProjectItemType.BIN');

  console.log(`   Uses pproBuilder.Constants.ProjectItemType.BIN: ${usesDirectConstant}`);
  console.log(`   Uses local ProjectItemType.BIN: ${usesLocalConstant}`);

  assert(!usesDirectConstant, 'Should NOT use pproBuilder.Constants.ProjectItemType.BIN directly');
  assert(usesLocalConstant, 'Should use local ProjectItemType.BIN constant');
});

test('builder.js: uses local TrackItemType.CLIP (not pproBuilder.Constants)', () => {
  // Check that pproBuilder.Constants.TrackItemType.CLIP is NOT used
  const usesDirectConstant = builderSource.includes('pproBuilder.Constants.TrackItemType.CLIP');
  const usesLocalConstant = builderSource.includes('TrackItemType.CLIP');

  console.log(`   Uses pproBuilder.Constants.TrackItemType.CLIP: ${usesDirectConstant}`);
  console.log(`   Uses local TrackItemType.CLIP: ${usesLocalConstant}`);

  assert(!usesDirectConstant, 'Should NOT use pproBuilder.Constants.TrackItemType.CLIP directly');
  assert(usesLocalConstant, 'Should use local TrackItemType.CLIP constant');
});

test('builder.js: ProjectItemType has all required enum values', () => {
  // Check for all required enum values
  const hasClip = builderSource.includes('CLIP: 1');
  const hasBin = builderSource.includes('BIN: 2');
  const hasRoot = builderSource.includes('ROOT: 3');
  const hasFile = builderSource.includes('FILE: 4');

  console.log(`   CLIP: 1 defined: ${hasClip}`);
  console.log(`   BIN: 2 defined: ${hasBin}`);
  console.log(`   ROOT: 3 defined: ${hasRoot}`);
  console.log(`   FILE: 4 defined: ${hasFile}`);

  assert(hasClip, 'ProjectItemType should have CLIP: 1');
  assert(hasBin, 'ProjectItemType should have BIN: 2');
  assert(hasRoot, 'ProjectItemType should have ROOT: 3');
  assert(hasFile, 'ProjectItemType should have FILE: 4');
});

test('main.js: has matching ProjectItemType fallback', () => {
  // Check main.js also has the constant (for findFirstMediaItem)
  const hasProjectItemType = mainSource.includes('const ProjectItemType =');
  const hasFallbackValues = mainSource.includes('CLIP: 1') && mainSource.includes('BIN: 2');

  console.log(`   main.js ProjectItemType defined: ${hasProjectItemType}`);
  console.log(`   main.js has fallback values: ${hasFallbackValues}`);

  assert(hasProjectItemType, 'main.js should also define ProjectItemType fallback');
  assert(hasFallbackValues, 'main.js should have matching fallback values');
});

// =============================================================================
// Summary
// =============================================================================

console.log('\n' + '='.repeat(50));
console.log(`Phase 4 Architecture Tests: ${passed} passed, ${failed} failed`);
console.log('='.repeat(50) + '\n');

process.exit(failed > 0 ? 1 : 0);
