/**
 * SPLICE Direct DOM Sequence Builder (v3.5)
 *
 * Builds sequences directly using UXP DOM APIs.
 * No XML export/import required - zero manual steps.
 *
 * Key APIs:
 * - SequenceEditor.createInsertProjectItemAction() - Insert clips at timecode
 * - ProjectItem.createSetColorLabelAction(index) - Color clips (set BEFORE insert)
 * - TrackItem.createSetInPointAction/OutPointAction() - Set in/out points
 * - project.executeTransaction(actions) - Batch execute atomically
 */

const pproBuilder = require('premierepro');

// Color label indices in Premiere Pro
const COLOR_LABELS = {
  NONE: 0,
  VIOLET: 1,    // Purple
  IRIS: 2,      // Light purple
  CARIBBEAN: 3, // Teal
  LAVENDER: 4,  // Light lavender
  CERULEAN: 5,  // Light blue
  FOREST: 6,    // Dark green
  ROSE: 7,      // Pink
  MANGO: 8,     // Orange
  PURPLE: 9,    // Dark purple
  BLUE: 10,     // Blue
  TEAL: 11,     // Teal/Cyan
  MAGENTA: 12,  // Magenta
  TAN: 13,      // Tan/Brown
  GREEN: 14,    // Green
  BROWN: 15,    // Dark brown
  YELLOW: 16    // Yellow
};

// SPLICE color scheme for cut list clips
const SPLICE_COLORS = {
  SPEECH: COLOR_LABELS.GREEN,      // Green for speech/takes
  SILENCE: COLOR_LABELS.VIOLET,    // Purple for silence segments (if kept)
  BEST_TAKE: COLOR_LABELS.CERULEAN // Light blue for best take
};

/**
 * Find a project item by name in the project bin
 * @param {Object} project - The active project
 * @param {string} name - Name of the clip to find
 * @returns {Promise<Object|null>} The project item or null
 */
async function findProjectItemByName(project, name) {
  const rootItem = await project.getRootItem();
  return await searchItemRecursively(rootItem, name);
}

/**
 * Recursively search for an item in the project bin
 * @param {Object} item - Current item to search
 * @param {string} name - Name to search for
 * @returns {Promise<Object|null>} The found item or null
 */
async function searchItemRecursively(item, name) {
  const children = await item.getItems();
  if (!children || children.length === 0) return null;

  for (const child of children) {
    const childName = await child.getName();
    if (childName === name) {
      return child;
    }

    // Check if it's a bin (folder) and search recursively
    const isFolder = await child.isFolder?.();
    if (isFolder) {
      const found = await searchItemRecursively(child, name);
      if (found) return found;
    }
  }

  return null;
}

/**
 * Find project item by file path
 * @param {Object} project - The active project
 * @param {string} filePath - Full path to the media file
 * @returns {Promise<Object|null>} The project item or null
 */
async function findProjectItemByPath(project, filePath) {
  const rootItem = await project.getRootItem();
  return await searchItemByPathRecursively(rootItem, filePath);
}

/**
 * Recursively search for an item by its file path
 * @param {Object} item - Current item to search
 * @param {string} filePath - Path to search for
 * @returns {Promise<Object|null>} The found item or null
 */
async function searchItemByPathRecursively(item, filePath) {
  const children = await item.getItems();
  if (!children || children.length === 0) return null;

  for (const child of children) {
    // Check if this item has a matching path
    try {
      const mediaPath = await child.getMediaPath?.();
      if (mediaPath === filePath) {
        return child;
      }
    } catch (e) {
      // Item might not have a media path (e.g., it's a bin)
    }

    // Check if it's a bin (folder) and search recursively
    const isFolder = await child.isFolder?.();
    if (isFolder) {
      const found = await searchItemByPathRecursively(child, filePath);
      if (found) return found;
    }
  }

  return null;
}

/**
 * Create a new sequence from a cut list
 * @param {Object} cutList - The cut list from backend
 * @param {Object} options - Build options
 * @returns {Promise<{success: boolean, sequence?: Object, error?: string, stats?: Object}>}
 */
async function buildSequenceFromCutList(cutList, options = {}) {
  const stats = {
    clipsInserted: 0,
    totalDuration: 0,
    errors: []
  };

  try {
    const context = await getActiveSequence();
    if (!context) {
      return { success: false, error: 'No project or sequence open' };
    }

    const { project, sequence } = context;

    // Get sequence settings from existing sequence
    const sequenceSettings = await getSequenceSettings(sequence);

    // Create new sequence with "_SPLICE" suffix
    const originalName = await sequence.getName();
    const newSequenceName = `${originalName}_SPLICE`;

    // Use SequenceFactory to create new sequence
    const seqFactory = pproBuilder.SequenceFactory;
    const newSequence = await seqFactory.createSequence(
      project,
      newSequenceName,
      sequenceSettings
    );

    if (!newSequence) {
      return { success: false, error: 'Failed to create new sequence' };
    }

    // Get the sequence editor for inserting clips
    const editor = await pproBuilder.SequenceEditor.getEditor(newSequence);
    if (!editor) {
      return { success: false, error: 'Failed to get sequence editor' };
    }

    // Process cut list segments
    const segments = cutList.segments || [];
    if (segments.length === 0) {
      return { success: false, error: 'Cut list has no segments' };
    }

    // Build all insert actions
    const actions = [];
    let currentPosition = 0; // In ticks

    for (const segment of segments) {
      try {
        // Find the source project item
        const sourceItem = await findProjectItemByPath(project, segment.sourcePath)
          || await findProjectItemByName(project, segment.sourceName);

        if (!sourceItem) {
          stats.errors.push(`Source not found: ${segment.sourceName || segment.sourcePath}`);
          continue;
        }

        // Calculate times in ticks
        const inPointTicks = Math.floor(segment.inPoint * TICKS_PER_SECOND);
        const outPointTicks = Math.floor(segment.outPoint * TICKS_PER_SECOND);
        const durationTicks = outPointTicks - inPointTicks;

        // Determine color based on segment type
        const colorIndex = getColorForSegmentType(segment.type);

        // Set color on source item BEFORE insert (required by UXP API)
        if (colorIndex !== null) {
          const colorAction = sourceItem.createSetColorLabelAction(colorIndex);
          actions.push(colorAction);
        }

        // Create insert action
        const insertAction = editor.createInsertProjectItemAction(
          sourceItem,
          currentPosition,    // Insert position in ticks
          0,                  // Video track index (0 = first track)
          0                   // Audio track index (0 = first track)
        );
        actions.push(insertAction);

        // Update position for next clip
        currentPosition += durationTicks;
        stats.clipsInserted++;
        stats.totalDuration += (segment.outPoint - segment.inPoint);

      } catch (err) {
        stats.errors.push(`Error processing segment: ${err.message}`);
        console.error('[SPLICE Builder] Segment error:', err);
      }
    }

    if (actions.length === 0) {
      return { success: false, error: 'No valid segments to insert' };
    }

    // Execute all actions in a single transaction
    await project.lockedAccess(async () => {
      await project.executeTransaction((compoundAction) => {
        for (const action of actions) {
          compoundAction.addAction(action);
        }
      }, 'SPLICE: Build Sequence from Cut List');
    });

    // Set in/out points for each track item (must be done after insert)
    await setTrackItemInOutPoints(newSequence, segments);

    console.log(`[SPLICE Builder] Built sequence with ${stats.clipsInserted} clips`);

    return {
      success: true,
      sequence: newSequence,
      sequenceName: newSequenceName,
      stats
    };

  } catch (err) {
    console.error('[SPLICE Builder] Build error:', err);
    return { success: false, error: err.message, stats };
  }
}

/**
 * Get color index for a segment type
 * @param {string} type - Segment type (speech, silence, best_take)
 * @returns {number|null} Color label index or null for no color
 */
function getColorForSegmentType(type) {
  switch (type) {
    case 'speech':
    case 'take':
      return SPLICE_COLORS.SPEECH;
    case 'best_take':
      return SPLICE_COLORS.BEST_TAKE;
    case 'silence':
      return SPLICE_COLORS.SILENCE;
    default:
      return null;
  }
}

/**
 * Set in/out points for track items after insertion
 * @param {Object} sequence - The sequence containing the clips
 * @param {Array} segments - The original segments with in/out points
 */
async function setTrackItemInOutPoints(sequence, segments) {
  try {
    // Get video tracks
    const videoTracks = await sequence.getVideoTracks();
    if (!videoTracks || videoTracks.length === 0) return;

    const firstTrack = videoTracks[0];
    const trackItems = await firstTrack.getTrackItems();

    if (!trackItems || trackItems.length === 0) return;

    const project = await pproBuilder.Project.getActiveProject();

    // Match track items with segments (in order)
    const actions = [];
    const itemCount = Math.min(trackItems.length, segments.length);

    for (let i = 0; i < itemCount; i++) {
      const trackItem = trackItems[i];
      const segment = segments[i];

      // Calculate in/out points in ticks
      const inPointTicks = Math.floor(segment.inPoint * TICKS_PER_SECOND);
      const outPointTicks = Math.floor(segment.outPoint * TICKS_PER_SECOND);

      // Create actions to set in/out points
      const inAction = trackItem.createSetInPointAction(inPointTicks);
      const outAction = trackItem.createSetOutPointAction(outPointTicks);

      actions.push(inAction);
      actions.push(outAction);
    }

    if (actions.length > 0) {
      await project.lockedAccess(async () => {
        await project.executeTransaction((compoundAction) => {
          for (const action of actions) {
            compoundAction.addAction(action);
          }
        }, 'SPLICE: Set In/Out Points');
      });
    }

  } catch (err) {
    console.error('[SPLICE Builder] Error setting in/out points:', err);
  }
}

/**
 * Get sequence settings from an existing sequence
 * @param {Object} sequence - Source sequence
 * @returns {Promise<Object>} Sequence settings object
 */
async function getSequenceSettings(sequence) {
  try {
    const settings = {};

    // Get basic settings from sequence
    settings.name = await sequence.getName();
    settings.videoTracks = 1;
    settings.audioTracks = 1;

    // Try to get frame rate and other settings
    const framerate = await sequence.getFrameRate?.();
    if (framerate) {
      settings.framerate = framerate;
    }

    return settings;
  } catch (err) {
    console.error('[SPLICE Builder] Error getting sequence settings:', err);
    return { videoTracks: 1, audioTracks: 1 };
  }
}

/**
 * Build sequence from detected silences and takes
 * Convenience wrapper that creates cut list from detection results
 * @param {Array} silences - Detected silence segments
 * @param {Array} takes - Detected speech takes
 * @param {Object} sourceClip - Source project item
 * @returns {Promise<Object>} Build result
 */
async function buildSequenceFromDetection(silences, takes, sourceClip) {
  // Create cut list from detection results
  // Keep speech segments, remove silences
  const segments = [];

  // Get source clip info
  const sourceName = await sourceClip.getName();
  const sourcePath = await sourceClip.getMediaPath?.();

  // Get clip duration
  const duration = await sourceClip.getDuration?.() || 0;
  const durationSecs = duration / TICKS_PER_SECOND;

  // Sort silences by start time
  const sortedSilences = [...silences].sort((a, b) => a.start - b.start);

  // Build segments from gaps between silences (speech segments)
  let lastEnd = 0;

  for (const silence of sortedSilences) {
    // Add speech segment before this silence
    if (silence.start > lastEnd) {
      segments.push({
        type: 'speech',
        sourceName,
        sourcePath,
        inPoint: lastEnd,
        outPoint: silence.start
      });
    }
    lastEnd = silence.end;
  }

  // Add final segment after last silence
  if (lastEnd < durationSecs) {
    segments.push({
      type: 'speech',
      sourceName,
      sourcePath,
      inPoint: lastEnd,
      outPoint: durationSecs
    });
  }

  // Build the cut list
  const cutList = {
    version: '3.5',
    source: sourceName,
    segments,
    metadata: {
      silencesRemoved: silences.length,
      takesDetected: takes?.length || 0,
      generatedAt: new Date().toISOString()
    }
  };

  return await buildSequenceFromCutList(cutList);
}

/**
 * Apply cut list to existing sequence (in-place edit)
 * Alternative to creating new sequence
 * @param {Object} cutList - The cut list from backend
 * @returns {Promise<Object>} Result object
 */
async function applyCutListToSequence(cutList) {
  // TODO: Implement in-place editing as alternative to new sequence
  // This would use razor cuts on existing clips rather than rebuilding
  return { success: false, error: 'In-place editing not yet implemented' };
}

// Export functions for use in main.js
window.spliceBuilder = {
  buildSequenceFromCutList,
  buildSequenceFromDetection,
  applyCutListToSequence,
  findProjectItemByName,
  findProjectItemByPath,
  COLOR_LABELS,
  SPLICE_COLORS
};
