/**
 * SPLICE CEP Comprehensive Simulation Tests
 * Tests all workflows, edge cases, and error scenarios in browser simulation mode.
 *
 * Run these tests by opening simulate.html in a browser.
 * The browser-simulation.js must be loaded first to mock the Adobe CEP environment.
 */

(function() {
    'use strict';

    // ============================================================================
    // TEST FRAMEWORK
    // ============================================================================

    const TestRunner = {
        results: [],
        currentSuite: '',
        totalPassed: 0,
        totalFailed: 0,
        totalSkipped: 0,

        /**
         * Start a new test suite
         */
        suite: function(name) {
            this.currentSuite = name;
            console.log(`%c\n=== ${name} ===`, 'color: #00d1b2; font-weight: bold; font-size: 14px;');
        },

        /**
         * Run a single test
         */
        async test(name, testFn) {
            const startTime = performance.now();
            try {
                await testFn();
                const duration = (performance.now() - startTime).toFixed(2);
                this.totalPassed++;
                this.results.push({ suite: this.currentSuite, name, status: 'PASS', duration });
                console.log(`%c  PASS %c ${name} (${duration}ms)`, 'color: #00ff00', 'color: inherit');
            } catch (error) {
                const duration = (performance.now() - startTime).toFixed(2);
                this.totalFailed++;
                this.results.push({ suite: this.currentSuite, name, status: 'FAIL', error: error.message, duration });
                console.log(`%c  FAIL %c ${name}: ${error.message}`, 'color: #ff0000', 'color: inherit');
            }
        },

        /**
         * Skip a test
         */
        skip(name, reason = '') {
            this.totalSkipped++;
            this.results.push({ suite: this.currentSuite, name, status: 'SKIP', reason });
            console.log(`%c  SKIP %c ${name}${reason ? ': ' + reason : ''}`, 'color: #ffaa00', 'color: inherit');
        },

        /**
         * Assert helper
         */
        assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        },

        /**
         * Assert equals
         */
        assertEquals(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected} but got ${actual}`);
            }
        },

        /**
         * Assert not null/undefined
         */
        assertDefined(value, message) {
            if (value === null || value === undefined) {
                throw new Error(message || 'Expected value to be defined');
            }
        },

        /**
         * Assert contains
         */
        assertContains(str, substring, message) {
            if (!str || !str.includes(substring)) {
                throw new Error(message || `Expected "${str}" to contain "${substring}"`);
            }
        },

        /**
         * Wait for condition
         */
        async waitFor(conditionFn, timeout = 5000, interval = 100) {
            const startTime = Date.now();
            while (Date.now() - startTime < timeout) {
                if (await conditionFn()) {
                    return true;
                }
                await this.sleep(interval);
            }
            throw new Error('Timeout waiting for condition');
        },

        /**
         * Sleep helper
         */
        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        },

        /**
         * Print summary
         */
        summary() {
            console.log(`%c\n========================================`, 'color: #00d1b2');
            console.log(`%c TEST SUMMARY`, 'color: #00d1b2; font-weight: bold; font-size: 16px;');
            console.log(`%c========================================`, 'color: #00d1b2');
            console.log(`%c  Passed: ${this.totalPassed}`, 'color: #00ff00');
            console.log(`%c  Failed: ${this.totalFailed}`, 'color: #ff0000');
            console.log(`%c  Skipped: ${this.totalSkipped}`, 'color: #ffaa00');
            console.log(`%c  Total: ${this.totalPassed + this.totalFailed + this.totalSkipped}`, 'color: inherit');
            console.log(`%c========================================\n`, 'color: #00d1b2');

            if (this.totalFailed > 0) {
                console.log('%c FAILED TESTS:', 'color: #ff0000; font-weight: bold');
                this.results.filter(r => r.status === 'FAIL').forEach(r => {
                    console.log(`  - [${r.suite}] ${r.name}: ${r.error}`);
                });
            }

            return {
                passed: this.totalPassed,
                failed: this.totalFailed,
                skipped: this.totalSkipped,
                results: this.results
            };
        },

        /**
         * Reset for fresh run
         */
        reset() {
            this.results = [];
            this.currentSuite = '';
            this.totalPassed = 0;
            this.totalFailed = 0;
            this.totalSkipped = 0;
        }
    };

    // ============================================================================
    // MOCK EXTENSIONS FOR EDGE CASES
    // ============================================================================

    /**
     * Configure mock to simulate specific scenarios
     */
    function configureMockScenario(scenario) {
        window._mockScenario = scenario;
    }

    /**
     * Reset mock to default behavior
     */
    function resetMockScenario() {
        window._mockScenario = null;
    }

    /**
     * Extended fetch mock that handles test scenarios
     */
    const originalMockFetch = window.fetch;
    window.fetch = async function(url, options) {
        const scenario = window._mockScenario;

        // Handle specific test scenarios
        if (scenario === 'network_failure') {
            throw new Error('Network request failed');
        }

        if (scenario === 'timeout') {
            await new Promise(resolve => setTimeout(resolve, 150000));
        }

        if (scenario === 'invalid_license' && url.includes('/license/activate')) {
            return new Response(JSON.stringify({
                success: false,
                error: 'Invalid license key'
            }), { status: 401 });
        }

        if (scenario === 'empty_sequence') {
            if (url.includes('/silences-rms')) {
                return new Response(JSON.stringify({ silences: [] }), { status: 200 });
            }
            if (url.includes('/analyze')) {
                return new Response(JSON.stringify({ takes: [] }), { status: 200 });
            }
        }

        if (scenario === 'very_long_video') {
            if (url.includes('/silences-rms')) {
                const silences = Array.from({ length: 500 }, (_, i) => ({
                    start: i * 10 + 5,
                    end: i * 10 + 7
                }));
                return new Response(JSON.stringify({ silences }), { status: 200 });
            }
        }

        if (scenario === 'api_error_500') {
            return new Response(JSON.stringify({ error: 'Internal server error' }), { status: 500 });
        }

        // Fall back to original mock
        return originalMockFetch.call(this, url, options);
    };

    // ============================================================================
    // TEST SUITES
    // ============================================================================

    /**
     * Quick Edit Workflow Tests
     */
    async function testQuickEditWorkflow() {
        TestRunner.suite('Quick Edit Workflow');

        await TestRunner.test('GO button is present and enabled', async () => {
            const goBtn = document.getElementById('goBtn');
            TestRunner.assertDefined(goBtn, 'GO button not found');
            TestRunner.assert(!goBtn.disabled, 'GO button should be enabled');
        });

        await TestRunner.test('Options panel toggles correctly', async () => {
            const optionsToggle = document.getElementById('optionsToggle');
            const optionsPanel = document.getElementById('optionsPanel');

            TestRunner.assertDefined(optionsToggle, 'Options toggle not found');
            TestRunner.assertDefined(optionsPanel, 'Options panel not found');

            const wasCollapsed = optionsPanel.classList.contains('collapsed');
            optionsToggle.click();
            await TestRunner.sleep(100);

            const isCollapsed = optionsPanel.classList.contains('collapsed');
            TestRunner.assert(wasCollapsed !== isCollapsed, 'Panel should toggle');
        });

        await TestRunner.test('Preset selector changes settings', async () => {
            const presetSelector = document.getElementById('presetSelector');
            const sensitivitySlider = document.getElementById('sensitivitySlider');

            TestRunner.assertDefined(presetSelector, 'Preset selector not found');
            TestRunner.assertDefined(sensitivitySlider, 'Sensitivity slider not found');

            // Select podcast preset
            presetSelector.value = 'podcast';
            presetSelector.dispatchEvent(new Event('change'));
            await TestRunner.sleep(100);

            // Podcast preset should have sensitivity around 35
            const sensitivity = parseInt(sensitivitySlider.value);
            TestRunner.assert(sensitivity >= 30 && sensitivity <= 40,
                `Podcast preset should set sensitivity ~35, got ${sensitivity}`);
        });

        await TestRunner.test('Sensitivity slider updates value display', async () => {
            const slider = document.getElementById('sensitivitySlider');
            const display = document.getElementById('sensitivityValue');

            slider.value = 75;
            slider.dispatchEvent(new Event('input'));
            await TestRunner.sleep(50);

            TestRunner.assertEquals(display.textContent, '75', 'Display should show 75');
        });

        await TestRunner.test('Detection flow completes successfully', async () => {
            resetMockScenario();

            // Trigger detection
            const goBtn = document.getElementById('goBtn');
            goBtn.click();

            // Wait for detection to complete (mocked API is fast)
            await TestRunner.sleep(1000);

            // Check results
            const combinedPreview = document.getElementById('combinedPreview');
            TestRunner.assert(
                !combinedPreview.classList.contains('hidden') ||
                document.getElementById('silenceCount'),
                'Preview should be visible or results displayed'
            );
        });

        await TestRunner.test('J-Cut settings toggle visibility', async () => {
            const jcutCheckbox = document.getElementById('enableJCut');
            const jcutSettings = document.getElementById('jcutSettings');

            TestRunner.assertDefined(jcutCheckbox, 'J-Cut checkbox not found');
            TestRunner.assertDefined(jcutSettings, 'J-Cut settings not found');

            jcutCheckbox.checked = true;
            jcutCheckbox.dispatchEvent(new Event('change'));
            await TestRunner.sleep(50);

            TestRunner.assert(!jcutSettings.classList.contains('collapsed'),
                'J-Cut settings should be visible when enabled');
        });
    }

    /**
     * Multitrack Workflow Tests
     */
    async function testMultitrackWorkflow() {
        TestRunner.suite('Multitrack Workflow');

        await TestRunner.test('Multitrack section exists', async () => {
            const section = document.getElementById('multitrackSection');
            TestRunner.assertDefined(section, 'Multitrack section not found');
        });

        await TestRunner.test('Toggle expands multitrack panel', async () => {
            const toggle = document.getElementById('multitrackToggle');
            const panel = document.getElementById('multitrackPanel');

            toggle.click();
            await TestRunner.sleep(100);

            const isCollapsed = panel.classList.contains('collapsed');
            // Toggle should work
            toggle.click();
            await TestRunner.sleep(100);
            TestRunner.assert(
                panel.classList.contains('collapsed') !== isCollapsed,
                'Panel should toggle'
            );
        });

        await TestRunner.test('Speaker list has default speakers', async () => {
            const speakerList = document.getElementById('speakerList');
            const speakers = speakerList.querySelectorAll('.speaker-item');

            TestRunner.assert(speakers.length >= 2, 'Should have at least 2 speakers');
        });

        await TestRunner.test('Add speaker button works', async () => {
            const addBtn = document.getElementById('addSpeakerBtn');
            const speakerList = document.getElementById('speakerList');
            const initialCount = speakerList.querySelectorAll('.speaker-item').length;

            if (initialCount < 4) {
                addBtn.click();
                await TestRunner.sleep(100);

                const newCount = speakerList.querySelectorAll('.speaker-item').length;
                TestRunner.assertEquals(newCount, initialCount + 1, 'Should add one speaker');
            } else {
                TestRunner.skip('Add speaker at max capacity');
            }
        });

        await TestRunner.test('Analyze multitrack button triggers analysis', async () => {
            resetMockScenario();

            const analyzeBtn = document.getElementById('analyzeMultitrackBtn');
            TestRunner.assertDefined(analyzeBtn, 'Analyze button not found');

            analyzeBtn.click();
            await TestRunner.sleep(500);

            // Button should show analyzing state
            TestRunner.assertContains(analyzeBtn.textContent.toLowerCase(), 'analyz',
                'Button should indicate analyzing');

            // Wait for completion
            await TestRunner.sleep(1500);
        });

        await TestRunner.test('Auto-balance button triggers balancing', async () => {
            resetMockScenario();

            const autoBalanceBtn = document.getElementById('autoBalanceBtn');
            TestRunner.assertDefined(autoBalanceBtn, 'Auto-balance button not found');

            autoBalanceBtn.click();
            await TestRunner.sleep(2000);

            // Should complete without error
            const preview = document.getElementById('multitrackPreview');
            TestRunner.assert(
                !preview.classList.contains('hidden') || true,
                'Preview should be visible after analysis'
            );
        });

        await TestRunner.test('Slider updates display values', async () => {
            const slider = document.getElementById('minShotDuration');
            const display = document.getElementById('minShotDurationValue');

            if (slider && display) {
                slider.value = 5;
                slider.dispatchEvent(new Event('input'));
                await TestRunner.sleep(50);

                TestRunner.assertContains(display.textContent, '5', 'Display should show 5');
            }
        });
    }

    /**
     * Captions Workflow Tests
     */
    async function testCaptionsWorkflow() {
        TestRunner.suite('Captions Workflow');

        await TestRunner.test('Captions section exists', async () => {
            const section = document.getElementById('captionsSection');
            TestRunner.assertDefined(section, 'Captions section not found');
        });

        await TestRunner.test('Template gallery loads', async () => {
            const gallery = document.getElementById('captionTemplateGallery');
            TestRunner.assertDefined(gallery, 'Template gallery not found');

            // Trigger init if not already done
            if (typeof initAnimatedCaptions === 'function') {
                await initAnimatedCaptions();
                await TestRunner.sleep(500);
            }

            const templates = gallery.querySelectorAll('.caption-template-card');
            TestRunner.assert(templates.length > 0 || gallery.innerHTML.length > 0,
                'Gallery should have templates or content');
        });

        await TestRunner.test('Template selection updates state', async () => {
            const gallery = document.getElementById('captionTemplateGallery');
            const firstCard = gallery.querySelector('.caption-template-card');

            if (firstCard) {
                firstCard.click();
                await TestRunner.sleep(100);

                TestRunner.assert(firstCard.classList.contains('selected'),
                    'Clicked card should be selected');
            }
        });

        await TestRunner.test('Generate captions button exists', async () => {
            const btn = document.getElementById('generateCaptionsBtn');
            TestRunner.assertDefined(btn, 'Generate captions button not found');
        });

        await TestRunner.test('Caption settings update state', async () => {
            const wordsPerLine = document.getElementById('captionWordsPerLine');
            const highlightKeywords = document.getElementById('captionHighlightKeywords');

            if (wordsPerLine) {
                wordsPerLine.value = '3';
                wordsPerLine.dispatchEvent(new Event('change'));
            }

            if (highlightKeywords) {
                highlightKeywords.checked = true;
                highlightKeywords.dispatchEvent(new Event('change'));
            }

            await TestRunner.sleep(50);
            // State should be updated (verified by no errors)
        });

        await TestRunner.test('Export buttons exist', async () => {
            const srtBtn = document.getElementById('exportCaptionsSrtBtn');
            const mogrtBtn = document.getElementById('exportCaptionsMogrtBtn');

            // At least one export option should exist
            TestRunner.assert(srtBtn || mogrtBtn, 'At least one export button should exist');
        });
    }

    /**
     * Text Editor Workflow Tests
     */
    async function testTextEditorWorkflow() {
        TestRunner.suite('Text Editor Workflow');

        await TestRunner.test('Text editor section exists', async () => {
            const section = document.getElementById('textEditorSection');
            TestRunner.assertDefined(section, 'Text editor section not found');
        });

        await TestRunner.test('Text editor panel toggles', async () => {
            const toggle = document.getElementById('textEditorToggle');
            const panel = document.getElementById('text-editor-panel');

            TestRunner.assertDefined(toggle, 'Toggle not found');
            TestRunner.assertDefined(panel, 'Panel not found');

            toggle.click();
            await TestRunner.sleep(100);

            // Verify toggle worked
            toggle.click();
            await TestRunner.sleep(100);
        });

        await TestRunner.test('Text area accepts input', async () => {
            const textarea = document.getElementById('text-editor-content');
            TestRunner.assertDefined(textarea, 'Text area not found');

            textarea.value = 'Test transcript content';
            textarea.dispatchEvent(new Event('input'));
            await TestRunner.sleep(50);

            TestRunner.assertEquals(textarea.value, 'Test transcript content');
        });

        await TestRunner.test('Undo/Redo buttons exist', async () => {
            const undoBtn = document.getElementById('text-editor-undo-btn');
            const redoBtn = document.getElementById('text-editor-redo-btn');

            TestRunner.assertDefined(undoBtn, 'Undo button not found');
            TestRunner.assertDefined(redoBtn, 'Redo button not found');
        });

        await TestRunner.test('Search input exists', async () => {
            const searchInput = document.getElementById('text-search-input');
            TestRunner.assertDefined(searchInput, 'Search input not found');
        });

        await TestRunner.test('Build sequence button exists', async () => {
            const buildBtn = document.getElementById('text-editor-build-btn');
            TestRunner.assertDefined(buildBtn, 'Build sequence button not found');
        });

        await TestRunner.test('Preview and Apply buttons exist', async () => {
            const previewBtn = document.getElementById('preview-text-edits-btn');
            const applyBtn = document.getElementById('apply-text-edits-btn');

            TestRunner.assertDefined(previewBtn, 'Preview button not found');
            TestRunner.assertDefined(applyBtn, 'Apply button not found');
        });
    }

    /**
     * Social Reframe Workflow Tests
     */
    async function testSocialReframeWorkflow() {
        TestRunner.suite('Social Reframe Workflow');

        await TestRunner.test('Social reframe section exists', async () => {
            const section = document.getElementById('socialReframeSection');
            TestRunner.assertDefined(section, 'Social reframe section not found');
        });

        await TestRunner.test('Platform selector renders', async () => {
            const selector = document.getElementById('reframe-platform-selector');
            TestRunner.assertDefined(selector, 'Platform selector not found');

            // Initialize if needed
            if (typeof initSocialReframe === 'function') {
                await initSocialReframe();
                await TestRunner.sleep(500);
            }
        });

        await TestRunner.test('Aspect ratio selector exists', async () => {
            const selector = document.getElementById('reframe-aspect-selector');
            TestRunner.assertDefined(selector, 'Aspect ratio selector not found');
        });

        await TestRunner.test('Analyze button exists', async () => {
            const btn = document.getElementById('analyze-reframe-btn');
            TestRunner.assertDefined(btn, 'Analyze button not found');
        });

        await TestRunner.test('Preview canvas exists', async () => {
            const canvas = document.getElementById('reframe-preview-canvas');
            TestRunner.assertDefined(canvas, 'Preview canvas not found');

            // Check canvas dimensions
            TestRunner.assert(canvas.width > 0, 'Canvas should have width');
            TestRunner.assert(canvas.height > 0, 'Canvas should have height');
        });

        await TestRunner.test('Export buttons exist', async () => {
            const exportBtn = document.getElementById('export-reframe-btn');
            const exportAllBtn = document.getElementById('export-all-formats-btn');

            TestRunner.assertDefined(exportBtn, 'Export button not found');
            TestRunner.assertDefined(exportAllBtn, 'Export all button not found');
        });

        await TestRunner.test('Safe zones toggle exists', async () => {
            const btn = document.getElementById('toggle-safe-zones-btn');
            TestRunner.assertDefined(btn, 'Safe zones toggle not found');
        });

        await TestRunner.test('Motion smoothing slider exists', async () => {
            const slider = document.getElementById('motion-smoothing-slider');
            TestRunner.assertDefined(slider, 'Smoothing slider not found');
        });
    }

    /**
     * Music Workflow Tests
     */
    async function testMusicWorkflow() {
        TestRunner.suite('Music Workflow');

        await TestRunner.test('Music section exists', async () => {
            const section = document.getElementById('musicSection');
            TestRunner.assertDefined(section, 'Music section not found');
        });

        await TestRunner.test('Music tabs work', async () => {
            const tabs = document.querySelectorAll('.music-tab');
            TestRunner.assert(tabs.length >= 3, 'Should have at least 3 tabs');

            // Click identify tab
            const identifyTab = Array.from(tabs).find(t => t.dataset.tab === 'identify');
            if (identifyTab) {
                identifyTab.click();
                await TestRunner.sleep(100);

                const identifyContent = document.getElementById('music-tab-identify');
                TestRunner.assert(
                    identifyContent.classList.contains('active'),
                    'Identify tab content should be active'
                );
            }

            // Return to generate tab
            const generateTab = Array.from(tabs).find(t => t.dataset.tab === 'generate');
            if (generateTab) {
                generateTab.click();
                await TestRunner.sleep(100);
            }
        });

        await TestRunner.test('Mood selector renders', async () => {
            const selector = document.getElementById('music-mood-selector');
            TestRunner.assertDefined(selector, 'Mood selector not found');

            // Initialize if needed
            if (typeof initMusicModule === 'function') {
                await initMusicModule();
                await TestRunner.sleep(300);
            }

            const moodCards = selector.querySelectorAll('.music-mood-card');
            TestRunner.assert(moodCards.length > 0 || selector.innerHTML.length > 0,
                'Mood selector should have content');
        });

        await TestRunner.test('Instrument selector renders', async () => {
            const selector = document.getElementById('music-instrument-selector');
            TestRunner.assertDefined(selector, 'Instrument selector not found');
        });

        await TestRunner.test('Duration slider works', async () => {
            const slider = document.getElementById('music-duration-slider');
            const display = document.getElementById('music-duration-value');

            TestRunner.assertDefined(slider, 'Duration slider not found');

            slider.value = 90;
            slider.dispatchEvent(new Event('input'));
            await TestRunner.sleep(50);

            if (display) {
                TestRunner.assertContains(display.textContent, '90', 'Display should show 90');
            }
        });

        await TestRunner.test('Generate button exists', async () => {
            const btn = document.getElementById('music-generate-btn');
            TestRunner.assertDefined(btn, 'Generate button not found');
        });

        await TestRunner.test('YouTube URL input exists', async () => {
            const input = document.getElementById('music-youtube-url');
            TestRunner.assertDefined(input, 'YouTube URL input not found');
        });

        await TestRunner.test('Identify button validates URL', async () => {
            const input = document.getElementById('music-youtube-url');
            const identifyBtn = document.getElementById('music-identify-btn');

            // Make sure music tab is active first
            const generateTab = Array.from(document.querySelectorAll('.music-tab'))
                .find(t => t.dataset.tab === 'identify');
            if (generateTab) {
                generateTab.click();
                await TestRunner.sleep(100);
            }

            // Invalid URL should disable button
            input.value = 'not a valid url';
            input.dispatchEvent(new Event('input', { bubbles: true }));
            await TestRunner.sleep(100);

            TestRunner.assert(identifyBtn.disabled, 'Button should be disabled for invalid URL');

            // Valid URL should enable button
            input.value = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
            input.dispatchEvent(new Event('input', { bubbles: true }));
            await TestRunner.sleep(100);

            // Call handleYoutubeUrlChange directly if available
            if (typeof handleYoutubeUrlChange === 'function') {
                handleYoutubeUrlChange();
                await TestRunner.sleep(50);
            }

            TestRunner.assert(!identifyBtn.disabled, 'Button should be enabled for valid URL');
        });

        await TestRunner.test('Music generation triggers polling', async () => {
            resetMockScenario();

            // Make sure generate tab is active
            const generateTab = Array.from(document.querySelectorAll('.music-tab'))
                .find(t => t.dataset.tab === 'generate');
            if (generateTab) {
                generateTab.click();
                await TestRunner.sleep(100);
            }

            const generateBtn = document.getElementById('music-generate-btn');
            const originalText = generateBtn.textContent;

            generateBtn.click();
            await TestRunner.sleep(200);

            // Button should show generating state - text changes to "Starting..." or be disabled
            const newText = generateBtn.textContent.toLowerCase();
            TestRunner.assert(
                newText !== originalText.toLowerCase() || generateBtn.disabled,
                'Button should change state when clicked'
            );

            await TestRunner.sleep(1500);
        });

        await TestRunner.test('Library tab loads', async () => {
            const libraryTab = Array.from(document.querySelectorAll('.music-tab'))
                .find(t => t.dataset.tab === 'library');

            if (libraryTab) {
                libraryTab.click();
                await TestRunner.sleep(500);

                const libraryList = document.getElementById('music-library-list');
                TestRunner.assertDefined(libraryList, 'Library list not found');
            }
        });
    }

    /**
     * Authentication Workflow Tests
     */
    async function testAuthenticationWorkflow() {
        TestRunner.suite('Authentication Workflow');

        await TestRunner.test('Credit badge exists', async () => {
            const badge = document.getElementById('creditBadge');
            TestRunner.assertDefined(badge, 'Credit badge not found');
        });

        await TestRunner.test('Login modal exists', async () => {
            const modal = document.getElementById('loginModal');
            TestRunner.assertDefined(modal, 'Login modal not found');
        });

        await TestRunner.test('License key input exists', async () => {
            const input = document.getElementById('licenseKeyInput');
            TestRunner.assertDefined(input, 'License key input not found');
        });

        await TestRunner.test('Credit badge click shows login', async () => {
            // Clear any existing customer ID
            const settings = typeof getSettings === 'function' ? getSettings() : {};
            if (!settings.customerId) {
                const badge = document.getElementById('creditBadge');
                badge.click();
                await TestRunner.sleep(100);

                const modal = document.getElementById('loginModal');
                TestRunner.assert(
                    !modal.classList.contains('hidden'),
                    'Login modal should be visible'
                );

                // Close modal
                const closeBtn = document.getElementById('closeLoginBtn');
                if (closeBtn) closeBtn.click();
            }
        });

        await TestRunner.test('License key format validation', async () => {
            if (typeof isValidLicenseKeyFormat === 'function') {
                TestRunner.assert(
                    isValidLicenseKeyFormat('SPLICE-ABCD-EFGH-IJKL'),
                    'Valid format should pass'
                );
                TestRunner.assert(
                    !isValidLicenseKeyFormat('invalid-key'),
                    'Invalid format should fail'
                );
                TestRunner.assert(
                    !isValidLicenseKeyFormat(''),
                    'Empty string should fail'
                );
            }
        });

        await TestRunner.test('Invalid license key shows error', async () => {
            configureMockScenario('invalid_license');

            const input = document.getElementById('licenseKeyInput');
            const saveBtn = document.getElementById('saveLoginBtn');
            const loginModal = document.getElementById('loginModal');

            // Make sure login modal is visible first
            if (loginModal) {
                loginModal.classList.remove('hidden');
            }

            input.value = 'SPLICE-AAAA-BBBB-CCCC';
            saveBtn.click();
            await TestRunner.sleep(800);

            // Should show error status - message is "Activation failed: ..."
            const status = document.getElementById('status');
            if (status && status.textContent) {
                const statusText = status.textContent.toLowerCase();
                // Check for either "failed" or "invalid" or "error" in the message
                const hasErrorMessage = statusText.includes('failed') ||
                                        statusText.includes('invalid') ||
                                        statusText.includes('error');
                TestRunner.assert(hasErrorMessage,
                    `Should show error message, got: "${status.textContent}"`);
            }

            // Close modal if still open
            if (loginModal) {
                loginModal.classList.add('hidden');
            }

            resetMockScenario();
        });

        await TestRunner.test('Email lookup button exists', async () => {
            const btn = document.getElementById('lookupLicenseBtn');
            const input = document.getElementById('lookupEmailInput');

            TestRunner.assertDefined(btn, 'Lookup button not found');
            TestRunner.assertDefined(input, 'Email input not found');
        });
    }

    /**
     * Edge Case Tests
     */
    async function testEdgeCases() {
        TestRunner.suite('Edge Cases');

        await TestRunner.test('Empty sequence handling', async () => {
            configureMockScenario('empty_sequence');

            const goBtn = document.getElementById('goBtn');
            goBtn.click();
            await TestRunner.sleep(1500);

            // Should handle gracefully - no crashes
            const silenceCount = document.getElementById('silenceCount');
            if (silenceCount) {
                TestRunner.assertEquals(silenceCount.textContent, '0',
                    'Should show 0 silences for empty sequence');
            }

            resetMockScenario();
        });

        await TestRunner.test('Very long video handling', async () => {
            configureMockScenario('very_long_video');

            const goBtn = document.getElementById('goBtn');
            goBtn.click();
            await TestRunner.sleep(2000);

            // Should handle 500+ silences without crashing
            const previewList = document.getElementById('previewList');
            if (previewList) {
                const items = previewList.querySelectorAll('.preview-item');
                TestRunner.assert(items.length > 0 || true, 'Should render silences');
            }

            resetMockScenario();
        });

        await TestRunner.test('Network failure handling', async () => {
            configureMockScenario('network_failure');

            try {
                // This should handle the network error gracefully
                const goBtn = document.getElementById('goBtn');
                goBtn.click();
                await TestRunner.sleep(1000);

                // Check for error status
                const status = document.getElementById('status');
                // Should show error or be handled gracefully
            } catch (e) {
                // Expected to potentially throw
            }

            resetMockScenario();
        });

        await TestRunner.test('API error 500 handling', async () => {
            configureMockScenario('api_error_500');

            const goBtn = document.getElementById('goBtn');
            goBtn.click();
            await TestRunner.sleep(1000);

            // Should show error status
            const status = document.getElementById('status');
            if (status && status.textContent) {
                // Error should be displayed
            }

            resetMockScenario();
        });

        await TestRunner.test('Select all silences toggle', async () => {
            resetMockScenario();

            // Run detection first
            const goBtn = document.getElementById('goBtn');
            goBtn.click();
            await TestRunner.sleep(1500);

            const selectAll = document.getElementById('selectAllSilences');
            if (selectAll) {
                selectAll.checked = false;
                selectAll.dispatchEvent(new Event('change'));
                await TestRunner.sleep(100);

                const selectedCount = document.getElementById('selectedCount');
                if (selectedCount) {
                    TestRunner.assertEquals(selectedCount.textContent, '0',
                        'Should deselect all');
                }

                selectAll.checked = true;
                selectAll.dispatchEvent(new Event('change'));
                await TestRunner.sleep(100);
            }
        });

        await TestRunner.test('Rapid button clicks handling', async () => {
            const goBtn = document.getElementById('goBtn');

            // Click rapidly
            for (let i = 0; i < 5; i++) {
                goBtn.click();
            }

            await TestRunner.sleep(2000);

            // Should not crash and should only process once
        });

        await TestRunner.test('Special characters in text input', async () => {
            const textarea = document.getElementById('text-editor-content');
            if (textarea) {
                const specialContent = '<script>alert("xss")</script> & "quotes" \'apostrophes\'';
                textarea.value = specialContent;
                textarea.dispatchEvent(new Event('input'));
                await TestRunner.sleep(50);

                // Should not execute XSS
                TestRunner.assertEquals(textarea.value, specialContent,
                    'Should preserve special characters safely');
            }
        });

        await TestRunner.test('Empty custom prompt handling', async () => {
            const promptInput = document.getElementById('music-custom-prompt');
            if (promptInput) {
                promptInput.value = '';
                // Should not cause issues
            }
        });
    }

    /**
     * UI State Tests
     */
    async function testUIState() {
        TestRunner.suite('UI State');

        await TestRunner.test('Loading overlay hides after init', async () => {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                await TestRunner.sleep(1000);
                TestRunner.assert(
                    overlay.classList.contains('hidden') || overlay.style.display === 'none',
                    'Loading overlay should be hidden'
                );
            }
        });

        await TestRunner.test('Status element updates', async () => {
            if (typeof setStatus === 'function') {
                setStatus('Test message');
                await TestRunner.sleep(50);

                const status = document.getElementById('status');
                TestRunner.assertEquals(status.textContent, 'Test message');

                setStatus('Ready');
            }
        });

        await TestRunner.test('Settings persist to localStorage', async () => {
            if (typeof saveSettings === 'function' && typeof getSettings === 'function') {
                saveSettings({ testKey: 'testValue' });
                const settings = getSettings();
                TestRunner.assertEquals(settings.testKey, 'testValue');
            }
        });

        await TestRunner.test('Modals close on backdrop click', async () => {
            const settingsModal = document.getElementById('settingsModal');
            const settingsBtn = document.getElementById('settingsBtn');

            if (settingsBtn && settingsModal) {
                settingsBtn.click();
                await TestRunner.sleep(100);

                // Click on modal backdrop (the modal element itself)
                settingsModal.click();
                await TestRunner.sleep(100);

                TestRunner.assert(
                    settingsModal.classList.contains('hidden'),
                    'Modal should close on backdrop click'
                );
            }
        });

        await TestRunner.test('Help button shows help text', async () => {
            const helpBtn = document.getElementById('helpBtn');
            if (helpBtn) {
                helpBtn.click();
                await TestRunner.sleep(100);

                const status = document.getElementById('status');
                TestRunner.assert(
                    status.textContent.length > 0,
                    'Help text should be displayed'
                );
            }
        });

        await TestRunner.test('All section toggles work', async () => {
            const toggles = [
                { toggle: 'multitrackToggle', panel: 'multitrackPanel' },
                { toggle: 'captionsToggle', panel: 'captionsPanel' },
                { toggle: 'textEditorToggle', panel: 'text-editor-panel' },
                { toggle: 'socialReframeToggle', panel: 'social-reframe-panel' },
                { toggle: 'musicToggle', panel: 'music-panel' }
            ];

            for (const { toggle, panel } of toggles) {
                const toggleEl = document.getElementById(toggle);
                const panelEl = document.getElementById(panel);

                if (toggleEl && panelEl) {
                    const wasCollapsed = panelEl.classList.contains('collapsed');
                    toggleEl.click();
                    await TestRunner.sleep(50);

                    const isCollapsed = panelEl.classList.contains('collapsed');
                    TestRunner.assert(
                        wasCollapsed !== isCollapsed,
                        `${toggle} should toggle ${panel}`
                    );

                    // Toggle back
                    toggleEl.click();
                    await TestRunner.sleep(50);
                }
            }
        });
    }

    /**
     * JSX Bridge Tests
     */
    async function testJSXBridge() {
        TestRunner.suite('JSX Bridge');

        await TestRunner.test('JSX object exists', async () => {
            TestRunner.assertDefined(window.jsx, 'jsx object not found');
        });

        await TestRunner.test('JSX init succeeds', async () => {
            if (typeof jsx.init === 'function') {
                const result = await jsx.init();
                TestRunner.assert(result === true, 'JSX init should succeed in simulation');
            }
        });

        await TestRunner.test('JSX call works for getVersion', async () => {
            if (typeof jsx.call === 'function') {
                const version = await jsx.call('getVersion');
                TestRunner.assertDefined(version, 'Version should be returned');
            }
        });

        await TestRunner.test('JSX call works for getActiveSequence', async () => {
            if (typeof jsx.call === 'function') {
                const seq = await jsx.call('getActiveSequence');
                TestRunner.assertDefined(seq, 'Sequence info should be returned');
                TestRunner.assertDefined(seq.name, 'Sequence should have name');
            }
        });

        await TestRunner.test('JSX call works for checkSequenceOpen', async () => {
            if (typeof jsx.call === 'function') {
                const result = await jsx.call('checkSequenceOpen');
                TestRunner.assert(
                    result === true || result === 'true',
                    'Sequence should be open in simulation'
                );
            }
        });
    }

    /**
     * Global State Tests
     */
    async function testGlobalState() {
        TestRunner.suite('Global State');

        await TestRunner.test('spliceState object exists', async () => {
            TestRunner.assertDefined(window.spliceState, 'spliceState not found');
        });

        await TestRunner.test('spliceState has expected properties', async () => {
            const state = window.spliceState;
            TestRunner.assertDefined(state, 'spliceState not defined');

            // Check for expected properties
            TestRunner.assert('lastTranscript' in state, 'Should have lastTranscript');
            TestRunner.assert('currentVideoPath' in state, 'Should have currentVideoPath');
            TestRunner.assert('activeSequence' in state, 'Should have activeSequence');
        });

        await TestRunner.test('Module exports are available', async () => {
            // Check for module exports
            const modules = [
                'spliceMultitrack',
                'spliceAnimatedCaptions',
                'spliceTextEditor',
                'spliceSocialReframe',
                'musicModule'
            ];

            let foundModules = 0;
            for (const mod of modules) {
                if (window[mod]) foundModules++;
            }

            TestRunner.assert(foundModules > 0, 'At least some modules should be exported');
        });

        await TestRunner.test('PRESETS constant exists', async () => {
            TestRunner.assertDefined(window.PRESETS, 'PRESETS not found');
            TestRunner.assertDefined(window.PRESETS.podcast, 'podcast preset not found');
        });

        await TestRunner.test('SPLICE_CONFIG exists', async () => {
            TestRunner.assertDefined(window.SPLICE_CONFIG, 'SPLICE_CONFIG not found');
            TestRunner.assertDefined(window.SPLICE_CONFIG.VERSION, 'VERSION not found');
        });
    }

    // ============================================================================
    // RUN ALL TESTS
    // ============================================================================

    async function runAllTests() {
        console.log('%c\n SPLICE CEP Simulation Tests \n',
            'background: #00d1b2; color: black; font-weight: bold; font-size: 16px; padding: 10px;');

        TestRunner.reset();

        // Wait for DOM and modules to initialize
        await TestRunner.sleep(1500);

        // Run all test suites
        await testQuickEditWorkflow();
        await testMultitrackWorkflow();
        await testCaptionsWorkflow();
        await testTextEditorWorkflow();
        await testSocialReframeWorkflow();
        await testMusicWorkflow();
        await testAuthenticationWorkflow();
        await testEdgeCases();
        await testUIState();
        await testJSXBridge();
        await testGlobalState();

        // Print summary
        const summary = TestRunner.summary();

        // Create visual results in page
        displayResultsInPage(summary);

        return summary;
    }

    /**
     * Display results in the page
     */
    function displayResultsInPage(summary) {
        let resultsDiv = document.getElementById('test-results');
        if (!resultsDiv) {
            resultsDiv = document.createElement('div');
            resultsDiv.id = 'test-results';
            resultsDiv.style.cssText = `
                position: fixed;
                bottom: 10px;
                right: 10px;
                background: #1a1a2e;
                border: 2px solid #00d1b2;
                border-radius: 8px;
                padding: 15px;
                max-width: 300px;
                max-height: 400px;
                overflow-y: auto;
                z-index: 10000;
                font-family: monospace;
                font-size: 12px;
                color: #fff;
            `;
            document.body.appendChild(resultsDiv);
        }

        resultsDiv.innerHTML = `
            <div style="font-size: 14px; font-weight: bold; margin-bottom: 10px;">
                Test Results
            </div>
            <div style="color: #00ff00;">Passed: ${summary.passed}</div>
            <div style="color: #ff0000;">Failed: ${summary.failed}</div>
            <div style="color: #ffaa00;">Skipped: ${summary.skipped}</div>
            <div style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                Total: ${summary.passed + summary.failed + summary.skipped}
            </div>
            ${summary.failed > 0 ? `
                <div style="margin-top: 10px; color: #ff0000; font-size: 11px;">
                    <strong>Failures:</strong><br>
                    ${summary.results.filter(r => r.status === 'FAIL')
                        .map(r => `- ${r.name}`)
                        .join('<br>')}
                </div>
            ` : ''}
            <button onclick="this.parentElement.remove()"
                style="margin-top: 10px; padding: 5px 10px; cursor: pointer;">
                Close
            </button>
        `;
    }

    // ============================================================================
    // EXPORTS
    // ============================================================================

    window.spliceSimulationTests = {
        run: runAllTests,
        TestRunner,
        configureMockScenario,
        resetMockScenario,

        // Individual test suites for selective running
        suites: {
            quickEdit: testQuickEditWorkflow,
            multitrack: testMultitrackWorkflow,
            captions: testCaptionsWorkflow,
            textEditor: testTextEditorWorkflow,
            socialReframe: testSocialReframeWorkflow,
            music: testMusicWorkflow,
            authentication: testAuthenticationWorkflow,
            edgeCases: testEdgeCases,
            uiState: testUIState,
            jsxBridge: testJSXBridge,
            globalState: testGlobalState
        }
    };

    // Auto-run if URL contains ?autotest
    if (window.location.search.includes('autotest')) {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(runAllTests, 2000);
        });
    }

    console.log('%c[SPLICE] Simulation tests loaded. Run with: spliceSimulationTests.run()',
        'color: #00d1b2');

})();
