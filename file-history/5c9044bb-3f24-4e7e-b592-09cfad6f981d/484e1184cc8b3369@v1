# ReflexionAgent → autonomous-orchestrator-v2.sh Integration Plan

**Date**: 2026-01-14
**Purpose**: Integrate ReflexionAgent into autonomous orchestrator for improved task execution
**Status**: Planning Phase

---

## Executive Summary

ReflexionAgent has proven production-ready for simple-to-medium complexity tasks (9/9 tests passing, 1-3 iterations typical). This document outlines the integration strategy into `autonomous-orchestrator-v2.sh` to enable autonomous, self-correcting task execution.

---

## Current State Analysis

### ReflexionAgent Capabilities (Validated)
✅ **Think-Act-Observe-Reflect Loop** - LLM-powered reasoning
✅ **Real Action Execution** - File creation, modification, shell commands
✅ **Stagnation Detection** - Catches infinite loops (5 iterations no progress)
✅ **Goal Alignment Validation** - Detects when actions don't match goal
✅ **Filename Context Tracking** - Observations include which files changed
✅ **Performance Metrics** - Tracks files created/modified, lines changed, iterations

### Current Orchestrator Capabilities
- ✅ Task analysis and decomposition
- ✅ Parallel execution planning
- ✅ Multi-agent coordination
- ✅ ReAct+Reflexion hooks (bash-based)
- ✅ Constitutional AI safety checks
- ✅ Auto-evaluation (LLM-as-judge)
- ✅ Swarm orchestration
- ✅ Memory integration

### Gap Analysis
Current bash-based ReAct hooks vs TypeScript ReflexionAgent:

| Feature | Bash Hooks | TypeScript Agent | Winner |
|---------|-----------|------------------|--------|
| LLM Integration | ✅ Via router | ✅ Direct router | **Tie** |
| Action Execution | ⚠️ Shell-only | ✅ File ops + shell | **TypeScript** |
| Stagnation Detection | ❌ None | ✅ Built-in | **TypeScript** |
| Goal Tracking | ❌ None | ✅ Built-in | **TypeScript** |
| Metrics | ❌ None | ✅ Detailed | **TypeScript** |
| Performance | ✅ Fast (bash) | ⚠️ Slower (Node) | **Bash** |

**Recommendation**: Use TypeScript ReflexionAgent for complex tasks, keep bash for simple coordination.

---

## Integration Strategies

### Option 1: CLI Command Integration (Recommended)
**Approach**: Create new command that calls ReflexionAgent, orchestrator invokes via CLI

**Pros**:
- ✅ Clean separation of concerns
- ✅ No bash→TypeScript bridge complexity
- ✅ Easy to test and debug
- ✅ Reusable from other contexts

**Cons**:
- ⚠️ Slightly slower (process spawn overhead)
- ⚠️ Requires IPC for status updates

**Implementation**:
```bash
# In autonomous-orchestrator-v2.sh
execute_with_reflexion_agent() {
    local goal="$1"
    local max_iterations="${2:-30}"

    # Call ReflexionAgent via CLI
    bun run src/cli/commands/ReflexionCommand.ts execute \
        --goal "$goal" \
        --max-iterations "$max_iterations" \
        --output-json
}
```

```typescript
// New file: src/cli/commands/ReflexionCommand.ts
export class ReflexionCommand extends BaseCommand {
  async execute(options: { goal: string; maxIterations: number; outputJson: boolean }) {
    const router = new LLMRouter(await createDefaultRegistry());
    const agent = new ReflexionAgent(options.goal, router);

    let cycles = 0;
    let lastInput = 'Start task';

    while (cycles < options.maxIterations) {
      const result = await agent.cycle(lastInput);
      cycles++;

      if (options.outputJson) {
        console.log(JSON.stringify({ cycle: cycles, ...result }));
      }

      // Check completion
      if (this.isComplete(result, agent.getMetrics())) {
        break;
      }

      lastInput = result.observation;
    }

    // Output final metrics
    const metrics = agent.getMetrics();
    console.log(JSON.stringify({ status: 'complete', metrics }));
  }
}
```

---

### Option 2: Direct TypeScript Integration (Future)
**Approach**: Rewrite orchestrator in TypeScript, call ReflexionAgent directly

**Pros**:
- ✅ Fastest performance (no IPC)
- ✅ Shared state and context
- ✅ Better error handling

**Cons**:
- ❌ Requires full orchestrator rewrite
- ❌ Breaks existing bash hooks integration
- ❌ Large migration effort

**Status**: Future work after CLI fully stabilized

---

### Option 3: Hybrid Approach (Not Recommended)
**Approach**: Call Bun script from bash, parse JSON output

**Pros**:
- ✅ Quick to implement

**Cons**:
- ❌ Fragile (JSON parsing in bash)
- ❌ Poor error handling
- ❌ Hard to debug

**Status**: Rejected

---

## Recommended Integration Plan

### Phase 1: CLI Command (Week 1)
✅ **Goal**: Make ReflexionAgent accessible from orchestrator

**Tasks**:
1. Create `ReflexionCommand.ts` in `src/cli/commands/`
2. Add `execute`, `status`, `metrics` subcommands
3. Support JSON output for bash consumption
4. Add to CLI router in `src/index.ts`

**Acceptance Criteria**:
- [ ] `bun run kk reflexion execute --goal "..." --max-iterations 30` works
- [ ] JSON output parseable by jq
- [ ] Returns exit code 0 on success, non-zero on failure
- [ ] Includes detailed metrics in output

---

### Phase 2: Orchestrator Integration (Week 1)
✅ **Goal**: Use ReflexionAgent for appropriate tasks in orchestrator

**Tasks**:
1. Add `use_reflexion_agent` function to `autonomous-orchestrator-v2.sh`
2. Integrate into task execution decision tree
3. Parse JSON output and update orchestrator state
4. Add fallback to bash hooks on ReflexionAgent failure

**Decision Logic** (when to use ReflexionAgent):
```bash
should_use_reflexion_agent() {
    local task="$1"
    local complexity="$2"  # simple|medium|complex

    # Use ReflexionAgent for:
    # - Multi-file tasks
    # - Tasks requiring self-correction
    # - Tasks with explicit iteration requirements
    # - Complex logic implementation

    if [[ "$complexity" == "complex" ]]; then
        return 0  # Use ReflexionAgent
    elif [[ "$task" =~ "implement"|"build"|"create.*with" ]]; then
        return 0  # Use ReflexionAgent
    else
        return 1  # Use bash hooks
    fi
}
```

**Acceptance Criteria**:
- [ ] Orchestrator detects ReflexionAgent-appropriate tasks
- [ ] Successfully executes agent and parses output
- [ ] Updates task state based on agent metrics
- [ ] Handles agent failures gracefully (falls back to bash)
- [ ] Logs agent execution to audit trail

---

### Phase 3: Testing & Validation (Week 2)
✅ **Goal**: Verify integration works end-to-end

**Tasks**:
1. Create integration test suite (`tests/integration/reflexion-orchestrator.test.ts`)
2. Test orchestrator with ReflexionAgent tasks
3. Validate metrics propagation
4. Test fallback behavior on agent failure
5. Performance benchmarks vs bash hooks

**Test Scenarios**:
- Simple task (should NOT use ReflexionAgent)
- Medium task (single file, should use ReflexionAgent)
- Complex task (multi-file, should use ReflexionAgent)
- Error scenario (agent fails, bash fallback)
- Rate limit scenario (handle gracefully)

**Acceptance Criteria**:
- [ ] All integration tests passing
- [ ] No regressions in orchestrator behavior
- [ ] Performance acceptable (<2s overhead per agent invocation)
- [ ] Memory usage within limits

---

### Phase 4: Production Deployment (Week 2)
✅ **Goal**: Enable in /auto mode for real-world usage

**Tasks**:
1. Add feature flag: `ENABLE_REFLEXION_AGENT=1` (default: off)
2. Update `/auto` command documentation
3. Add monitoring/logging for agent usage
4. Create troubleshooting guide

**Rollout Plan**:
- Week 1: Internal testing with flag enabled
- Week 2: Opt-in beta (users set flag manually)
- Week 3: Default enabled (if no issues)

**Acceptance Criteria**:
- [ ] Feature flag controls integration
- [ ] Documentation updated (CLAUDE.md, README.md)
- [ ] Monitoring shows successful executions
- [ ] No user-reported regressions

---

## Rate Limit Considerations

### Known Constraints
- **Kimi-K2**: 4-unit concurrency limit (feather_pro_plus plan)
- **Impact**: Can't run multiple agents in parallel
- **Mitigation**: Queue agent instances, use lower-cost models

### Recommended Configuration
```bash
# In autonomous-orchestrator-v2.sh
MAX_CONCURRENT_REFLEXION_AGENTS=1  # For Kimi-K2
REFLEXION_AGENT_MODEL="glm-4.7"    # Fallback model (no concurrency limits)
```

### Model Selection Strategy
1. **Simple tasks (1-5 iterations)**: Use Kimi-K2 (fastest, best quality)
2. **Medium tasks (6-20 iterations)**: Use GLM-4.7 (good balance)
3. **Complex tasks (20-50 iterations)**: Use Llama-70B (most reliable for long runs)

---

## Success Metrics

### Technical Metrics
- [ ] Agent execution success rate > 90%
- [ ] Average iterations per task < 15
- [ ] Stagnation detection triggers < 5% of runs
- [ ] Performance overhead < 2s per agent invocation

### User Experience Metrics
- [ ] /auto mode completion rate unchanged or improved
- [ ] No increase in user-reported errors
- [ ] Task completion time competitive with bash hooks

### Quality Metrics
- [ ] Code generated passes linting
- [ ] Files created have correct structure
- [ ] Self-correction reduces error rate

---

## Risk Mitigation

### Risk 1: Rate Limits Block Progress
**Likelihood**: High (already observed in testing)
**Impact**: Medium (delays completion)
**Mitigation**:
- Implement agent queuing (max 1 concurrent)
- Add model fallback (Kimi-K2 → GLM-4.7 → Llama-70B)
- Add retry with exponential backoff

### Risk 2: Agent Stagnation on Complex Tasks
**Likelihood**: Medium (30-50 iteration tests pending)
**Impact**: High (wastes API calls, delays completion)
**Mitigation**:
- Tune stagnation detection threshold (currently 5 iterations)
- Add intermediate checkpoints (every 10 iterations)
- Implement early termination signals

### Risk 3: Performance Regression
**Likelihood**: Low (TypeScript slower than bash)
**Impact**: Medium (user experience degradation)
**Mitigation**:
- Use ReflexionAgent only for complex tasks
- Keep bash hooks for simple coordination
- Benchmark before/after integration

### Risk 4: Integration Bugs
**Likelihood**: Medium (new component)
**Impact**: High (orchestrator failure)
**Mitigation**:
- Comprehensive integration testing
- Feature flag for gradual rollout
- Fallback to bash hooks on agent error

---

## Next Actions

### Immediate (This Session)
1. ✅ Complete edge case test documentation
2. ⏳ Wait for rate limits to reset, re-run edge case tests sequentially
3. ⏳ Document findings in REFLEXION-EDGE-CASE-TEST-RESULTS.md

### This Week
1. [ ] Create ReflexionCommand.ts CLI command
2. [ ] Integrate into orchestrator decision tree
3. [ ] Create integration test suite
4. [ ] Run end-to-end validation

### Next Week
1. [ ] Performance benchmarks
2. [ ] Documentation updates
3. [ ] Feature flag rollout
4. [ ] Production monitoring

---

## Open Questions

### Q1: Should we use ReflexionAgent for ALL tasks or just complex ones?
**Answer**: Just complex ones initially. Bash hooks are faster for simple coordination.

### Q2: How do we handle rate limits in swarm mode (multiple agents)?
**Answer**: Implement agent queue in swarm-orchestrator.sh, limit to 1 concurrent ReflexionAgent.

### Q3: What's the fallback if ReflexionAgent fails?
**Answer**: Fall back to existing bash-based ReAct hooks. Log failure for investigation.

### Q4: Should ReflexionAgent replace existing bash hooks entirely?
**Answer**: No. Bash hooks stay for simple tasks. ReflexionAgent for complex tasks only.

---

## Conclusion

ReflexionAgent is production-ready for complex tasks but requires careful integration:
- ✅ **Technically Sound**: 9/9 tests passing, proven capabilities
- ⚠️ **Rate Limit Aware**: Need queuing and model fallback
- ✅ **Incremental Rollout**: CLI command → orchestrator → production
- ✅ **Risk Mitigated**: Feature flag, fallbacks, testing

**Recommendation**: Proceed with Phase 1 (CLI command) implementation this week.

---

**Document Status**: Draft
**Next Review**: After edge case test completion
**Owner**: Autonomous System (/auto mode)
