/**
 * Comprehensive test suite for ReflexionAgent improvements
 * Tests: goal validation, repetition detection, file validation, reflection, metrics
 */

import { describe, test, expect, beforeEach } from 'bun:test';
import { ReflexionAgent } from '../../src/core/agents/reflexion';
import { ActionExecutor } from '../../src/core/agents/ActionExecutor';
import type { LLMRouter } from '../../src/core/llm/Router';
import * as fs from 'fs/promises';
import * as path from 'path';

// Mock LLM Router for testing
class MockLLMRouter implements Partial<LLMRouter> {
  async route(request: any, options?: any) {
    // Mock response for parseThoughtToAction
    if (request.messages[0].content.includes('action parser')) {
      return {
        id: 'mock',
        model: 'mock',
        role: 'assistant',
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              type: 'file_write',
              params: {
                path: 'test-output.ts',
                content: '// Test content\nexport const test = true;\n'
              }
            })
          }
        ],
        stopReason: 'end_turn',
        usage: { inputTokens: 0, outputTokens: 0 }
      };
    }

    // Default mock response
    return {
      id: 'mock',
      model: 'mock',
      role: 'assistant',
      content: [{ type: 'text', text: 'Mock response' }],
      stopReason: 'end_turn',
      usage: { inputTokens: 0, outputTokens: 0 }
    };
  }
}

describe('ReflexionAgent Improvements', () => {
  const testDir = path.join(process.cwd(), 'tests', 'tmp');
  let agent: ReflexionAgent;
  let mockRouter: MockLLMRouter;

  beforeEach(async () => {
    // Create test directory
    await fs.mkdir(testDir, { recursive: true });

    // Initialize mock router and agent
    mockRouter = new MockLLMRouter();
    agent = new ReflexionAgent(
      'Create a Calculator class in calculator.ts with add and subtract methods',
      mockRouter as any
    );
  });

  describe('Progress Metrics Tracking', () => {
    test('should initialize metrics to zero', () => {
      const metrics = agent.getMetrics();

      expect(metrics.filesCreated).toBe(0);
      expect(metrics.filesModified).toBe(0);
      expect(metrics.linesChanged).toBe(0);
      expect(metrics.iterations).toBe(0);
    });

    test('should increment iterations on each cycle', async () => {
      await agent.cycle('Create calculator.ts');
      expect(agent.getMetrics().iterations).toBe(1);

      await agent.cycle('Add add method');
      expect(agent.getMetrics().iterations).toBe(2);
    });

    test('should track files created', async () => {
      await agent.cycle('Create calculator.ts file');

      const metrics = agent.getMetrics();
      expect(metrics.filesCreated).toBeGreaterThan(0);
    });

    test('should differentiate between created and modified files', async () => {
      // Create file
      await agent.cycle('Create test-file.ts');
      const afterCreate = agent.getMetrics();
      const initialCreated = afterCreate.filesCreated;

      // Modify same file
      await agent.cycle('Update test-file.ts');
      const afterModify = agent.getMetrics();

      // Either created count stays same or modified increases
      expect(
        afterModify.filesCreated === initialCreated ||
        afterModify.filesModified > 0
      ).toBe(true);
    });
  });

  describe('Stagnation Detection', () => {
    test('should not detect stagnation with < 5 iterations', async () => {
      await agent.cycle('Planning step 1');
      await agent.cycle('Planning step 2');
      await agent.cycle('Planning step 3');

      // Should not throw
      expect(async () => {
        await agent.cycle('Planning step 4');
      }).not.toThrow();
    });

    test('should detect stagnation after multiple planning iterations', async () => {
      // Simulate 5+ planning iterations with no file changes
      const planningCycles = Array(6).fill('Reasoning about the task');

      let threwError = false;
      try {
        for (const input of planningCycles) {
          await agent.cycle(input);
        }
      } catch (error) {
        threwError = true;
        expect((error as Error).message).toContain('stuck');
      }

      // Should eventually throw stagnation error
      expect(threwError).toBe(true);
    });
  });

  describe('Repetition Detection', () => {
    test('should detect when agent repeats identical thoughts', async () => {
      const repeatedInput = 'Read the contents of test.ts';

      let threwError = false;
      try {
        // Repeat same thought 4 times
        await agent.cycle(repeatedInput);
        await agent.cycle(repeatedInput);
        await agent.cycle(repeatedInput);
        await agent.cycle(repeatedInput);
      } catch (error) {
        threwError = true;
        expect((error as Error).message).toContain('Repeating same actions');
      }

      expect(threwError).toBe(true);
    });

    test('should not detect repetition for different inputs', async () => {
      await agent.cycle('Create file');
      await agent.cycle('Add method');
      await agent.cycle('Add tests');

      // Should not throw
      expect(async () => {
        await agent.cycle('Complete implementation');
      }).not.toThrow();
    });
  });

  describe('Goal Alignment Validation', () => {
    test('should detect misalignment when wrong file is modified', async () => {
      // Goal mentions calculator.ts but action affects different file
      const agentWrongFile = new ReflexionAgent(
        'Create calculator.ts file',
        mockRouter as any
      );

      const cycle = await agentWrongFile.cycle('Create test.ts file');

      // Observation should contain misalignment warning
      expect(cycle.observation).toContain('misalignment');
    });

    test('should detect create vs update misalignment', async () => {
      const agentCreate = new ReflexionAgent(
        'Create new calculator.ts',
        mockRouter as any
      );

      // Simulate observation showing update instead of create
      const cycle = await agentCreate.cycle('Update calculator.ts');

      // Should flag misalignment in observation
      expect(cycle.observation.toLowerCase()).toContain(
        'goal' || 'misalignment' || 'create'
      );
    });
  });

  describe('File Existence Validation', () => {
    test('should allow file_write for non-existent files', async () => {
      const executor = new ActionExecutor(mockRouter as any, testDir);

      const result = await executor.execute({
        type: 'file_write',
        params: {
          path: 'new-file.ts',
          content: 'export const test = true;'
        }
      });

      expect(result.success).toBe(true);
      expect(result.output).toContain('created');
    });

    test('should reject file_edit for non-existent files', async () => {
      const executor = new ActionExecutor(mockRouter as any, testDir);

      const result = await executor.execute({
        type: 'file_edit',
        params: {
          path: 'non-existent.ts',
          searchPattern: 'old',
          replacement: 'new'
        }
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('does not exist');
      expect(result.error).toContain('file_write');
    });

    test('should allow file_edit for existing files', async () => {
      const executor = new ActionExecutor(mockRouter as any, testDir);
      const testFile = path.join(testDir, 'existing.ts');

      // Create file first
      await fs.writeFile(testFile, 'const old = true;', 'utf-8');

      // Now edit should work
      const result = await executor.execute({
        type: 'file_edit',
        params: {
          path: 'existing.ts',
          searchPattern: 'old',
          replacement: 'new'
        }
      });

      expect(result.success).toBe(true);
      expect(result.metadata?.replacements).toBeGreaterThan(0);
    });
  });

  describe('Enhanced Reflection', () => {
    test('should detect expectation mismatches', async () => {
      const cycle = await agent.cycle('Create calculator.ts but observe test.ts was created');

      // Reflection should mention mismatch
      expect(cycle.reflection).toContain('mismatch' || 'Expected' || '⚠️');
    });

    test('should detect error patterns in reflection', async () => {
      // Simulate failed action
      const failAgent = new ReflexionAgent(
        'Complete task',
        mockRouter as any
      );

      // Mock a failure scenario by creating a cycle with error observation
      const cycle = await failAgent.cycle('[ERROR] Action failed');

      expect(cycle.reflection).toContain('failed' || 'error' || '❌');
    });

    test('should detect lack of progress towards goal', async () => {
      const unrelatedAgent = new ReflexionAgent(
        'Implement authentication system',
        mockRouter as any
      );

      // Action unrelated to goal
      const cycle = await unrelatedAgent.cycle('Create unrelated-file.ts');

      // Reflection should mention goal misalignment
      expect(cycle.reflection.toLowerCase()).toContain(
        'goal' || 'contributing' || '⚠️'
      );
    });

    test('should acknowledge success patterns', async () => {
      const cycle = await agent.cycle('Create calculator.ts successfully');

      // Reflection should acknowledge success
      expect(cycle.reflection).toContain('success' || '✅' || 'succeeded');
    });

    test('should warn about planning loops', async () => {
      // Simulate many iterations with no file changes
      for (let i = 0; i < 6; i++) {
        try {
          await agent.cycle(`Planning iteration ${i}`);
        } catch (error) {
          // Expected stagnation error
          break;
        }
      }

      const history = agent.getHistory();
      const lastReflection = history[history.length - 1]?.reflection;

      // Should mention stuck or iterations
      if (lastReflection) {
        expect(lastReflection.toLowerCase()).toContain(
          'iterations' || 'stuck' || 'planning'
        );
      }
    });
  });

  describe('Integration: Full Cycle', () => {
    test('should complete full cycle with all validations', async () => {
      const cycle = await agent.cycle('Create calculator.ts with Calculator class');

      // Verify cycle structure
      expect(cycle.thought).toBeDefined();
      expect(cycle.action).toBeDefined();
      expect(cycle.observation).toBeDefined();
      expect(cycle.reflection).toBeDefined();
      expect(typeof cycle.success).toBe('boolean');

      // Verify metrics updated
      const metrics = agent.getMetrics();
      expect(metrics.iterations).toBe(1);
    });

    test('should maintain history across multiple cycles', async () => {
      await agent.cycle('Step 1');
      await agent.cycle('Step 2');
      await agent.cycle('Step 3');

      const history = agent.getHistory();
      expect(history.length).toBe(3);
      expect(history[0].thought).toContain('Step 1');
      expect(history[1].thought).toContain('Step 2');
      expect(history[2].thought).toContain('Step 3');
    });
  });
});
