/**
 * Slice 8: Silence Detection Utilities (CEP Port)
 *
 * Provides core functionality for silence detection and removal.
 * Port of UXP slice8-silence.js for CEP compatibility.
 */

// Store detected silences
let currentSilences = [];

/**
 * Get current silences
 */
function getCurrentSilences() {
    return currentSilences;
}

/**
 * Set current silences (used by main.js)
 */
function setCurrentSilences(silences) {
    currentSilences = silences;
}

/**
 * Clear current silences
 */
function clearCurrentSilences() {
    currentSilences = [];
}

/**
 * Maps 0-100 sensitivity slider to detection parameters
 * Lower = keep more pauses, Higher = remove more aggressively
 */
function mapSensitivity(value) {
    const t = value / 100;
    return {
        dbThreshold: Math.round(-50 + (30 * t)),                    // -50dB to -20dB
        minDuration: parseFloat((2.0 - (1.7 * t)).toFixed(2)),      // 2.0s to 0.3s
        padding: parseFloat((0.2 - (0.15 * t)).toFixed(2))          // 0.2s to 0.05s
    };
}

/**
 * Get silence statistics
 * @returns {Object} Statistics about current silences
 */
function getSilenceStats() {
    if (!currentSilences || currentSilences.length === 0) {
        return {
            count: 0,
            totalDuration: 0,
            averageDuration: 0
        };
    }

    let totalDuration = 0;
    for (const silence of currentSilences) {
        totalDuration += (silence.end - silence.start);
    }

    return {
        count: currentSilences.length,
        totalDuration,
        averageDuration: totalDuration / currentSilences.length
    };
}

/**
 * Remove silences from timeline using razor and delete
 * Returns count of removed sections
 */
async function removeSilencesFromTimeline() {
    if (!currentSilences || currentSilences.length === 0) {
        return 0;
    }

    // Check if sequence is open
    const seqResult = await jsx.call('getActiveSequence');
    if (seqResult.error) {
        throw new Error('No project or sequence open');
    }

    // Convert silences to frame arrays for razor
    const seqSettings = await jsx.call('getSequenceSettings');
    const settings = JSON.parse(seqSettings);
    const frameRate = 1 / settings.frameRate; // frames per second

    // Sort silences by start time DESCENDING (work from end to avoid time shifts)
    const sortedSilences = [...currentSilences].sort((a, b) => b.start - a.start);

    let removedCount = 0;
    const numVideoTracks = await jsx.call('getNumTracks', 'video');
    const numAudioTracks = await jsx.call('getNumTracks', 'audio');

    for (const silence of sortedSilences) {
        const startSeconds = silence.start;
        const endSeconds = silence.end;

        // Convert to frames for razor operations
        const startFrames = Math.round(startSeconds * frameRate);
        const endFrames = Math.round(endSeconds * frameRate);

        // Razor at silence boundaries
        await jsx.call('razorSequenceAtSeconds', startSeconds);
        await jsx.call('razorSequenceAtSeconds', endSeconds);

        // Delete clips that fall within silence regions
        // Process video tracks
        for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
            const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'video');
            const clips = JSON.parse(clipsJson);

            // Process from end to avoid index shifting
            for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
                const clip = clips[clipIndex];
                const clipCenter = (clip.start + clip.end) / 2;

                // Check if clip center is within silence region
                if (clipCenter > startSeconds && clipCenter < endSeconds) {
                    await jsx.call('removeClipByIndex', 'video', trackIndex, clipIndex);
                    removedCount++;
                }
            }
        }

        // Process audio tracks
        for (let trackIndex = 0; trackIndex < numAudioTracks; trackIndex++) {
            const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'audio');
            const clips = JSON.parse(clipsJson);

            // Process from end to avoid index shifting
            for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
                const clip = clips[clipIndex];
                const clipCenter = (clip.start + clip.end) / 2;

                // Check if clip center is within silence region
                if (clipCenter > startSeconds && clipCenter < endSeconds) {
                    await jsx.call('removeClipByIndex', 'audio', trackIndex, clipIndex);
                    removedCount++;
                }
            }
        }
    }

    return removedCount;
}

/**
 * Add silence markers to timeline without removing
 * @returns {Promise<number>} Number of markers added
 */
async function addSilenceMarkers() {
    if (!currentSilences || currentSilences.length === 0) {
        return 0;
    }

    let markerCount = 0;

    for (const silence of currentSilences) {
        const duration = silence.end - silence.start;
        const name = `Silence: ${duration.toFixed(1)}s`;
        const comments = `Start: ${formatTime(silence.start)} | End: ${formatTime(silence.end)}`;
        const colorIndex = 1; // Violet for silences

        await jsx.call('createMarker', silence.start, name, duration, comments, colorIndex);
        markerCount++;
    }

    return markerCount;
}

/**
 * Delete all SPLICE silence markers from timeline
 * @returns {Promise<number>} Number of markers deleted
 */
async function clearSilenceMarkers() {
    const result = await jsx.call('deleteMarkersByName', 'Silence:');
    const parsed = JSON.parse(result);
    return parsed.deleted || 0;
}

// Legacy function name for compatibility
function showSilenceSection() {
    // No longer needed in new UI
}

// Legacy init function - no longer needed
function initDetectRemove() {
    // Workflow is now handled by main.js initSilenceWorkflow()
}

// Export for window access
window.getCurrentSilences = getCurrentSilences;
window.setCurrentSilences = setCurrentSilences;
window.clearCurrentSilences = clearCurrentSilences;
window.mapSensitivity = mapSensitivity;
window.getSilenceStats = getSilenceStats;
window.removeSilencesFromTimeline = removeSilencesFromTimeline;
window.addSilenceMarkers = addSilenceMarkers;
window.clearSilenceMarkers = clearSilenceMarkers;
