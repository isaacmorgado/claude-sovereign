/**
 * Slice 7: Apply Takes to Timeline (CEP Port)
 *
 * Timeline manipulation functions via JSX:
 * - Label clips with take information
 * - Delete non-best takes
 *
 * Port of UXP slice7-apply.js for CEP compatibility.
 */

/**
 * Label clips on timeline with take information
 * @returns {Promise<number>} Number of clips labeled
 */
async function labelTakesOnTimeline() {
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
        throw new Error('No takes to label');
    }

    // Check if sequence is open
    const seqResult = await jsx.call('getActiveSequence');
    if (seqResult.error) {
        throw new Error('No project or sequence open');
    }

    let labeledCount = 0;

    // Get clips from all video tracks
    const numVideoTracks = await jsx.call('getNumTracks', 'video');

    for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
        const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'video');
        const clips = JSON.parse(clipsJson);

        for (let clipIndex = 0; clipIndex < clips.length; clipIndex++) {
            const clip = clips[clipIndex];
            const clipStart = clip.start;

            // Find which take this clip belongs to
            for (const take of takes) {
                const takeStart = take.start || take.startTime || 0;
                const takeEnd = take.end || take.endTime || 0;

                if (clipStart >= takeStart && clipStart < takeEnd) {
                    // Build label
                    const isBest = take.isBest || take.userMarkedBest;
                    const prefix = isBest ? '* ' : '';
                    const takeNum = take.takeNumber || takes.indexOf(take) + 1;
                    const desc = take.shortLabel || take.description || take.text || '';
                    const shortDesc = desc.split(' ').slice(0, 4).join(' ');
                    const label = `${prefix}Take ${takeNum} - ${shortDesc}`;

                    // Note: CEP doesn't have direct clip rename - using marker instead
                    // Create a marker at the clip start with the label
                    await jsx.call('createMarker', clipStart, label, 0, `Take ${takeNum}`, 5);
                    labeledCount++;
                    break;
                }
            }
        }
    }

    return labeledCount;
}

/**
 * Apply best takes - disable non-best takes by removing clips
 * @returns {Promise<number>} Number of clips removed
 */
async function applyBestTakes() {
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
        throw new Error('No takes to apply');
    }

    // Check if sequence is open
    const seqResult = await jsx.call('getActiveSequence');
    if (seqResult.error) {
        throw new Error('No project or sequence open');
    }

    // Sort takes by start time (descending) - work from end to avoid time shifts
    const sortedTakes = [...takes].sort((a, b) => {
        const aStart = a.start || a.startTime || 0;
        const bStart = b.start || b.startTime || 0;
        return bStart - aStart;
    });

    let removedCount = 0;
    const numVideoTracks = await jsx.call('getNumTracks', 'video');
    const numAudioTracks = await jsx.call('getNumTracks', 'audio');

    for (const take of sortedTakes) {
        const isBest = take.isBest || take.userMarkedBest;
        if (isBest) {
            continue; // Keep best takes
        }

        const takeStart = take.start || take.startTime || 0;
        const takeEnd = take.end || take.endTime || 0;

        // Process video tracks
        for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
            const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'video');
            const clips = JSON.parse(clipsJson);

            // Process from end to avoid index shifting
            for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
                const clip = clips[clipIndex];

                // Check if clip is within the non-best take range
                if (clip.start >= takeStart && clip.end <= takeEnd) {
                    await jsx.call('removeClipByIndex', 'video', trackIndex, clipIndex);
                    removedCount++;
                }
            }
        }

        // Process audio tracks
        for (let trackIndex = 0; trackIndex < numAudioTracks; trackIndex++) {
            const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'audio');
            const clips = JSON.parse(clipsJson);

            // Process from end to avoid index shifting
            for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
                const clip = clips[clipIndex];

                // Check if clip is within the non-best take range
                if (clip.start >= takeStart && clip.end <= takeEnd) {
                    await jsx.call('removeClipByIndex', 'audio', trackIndex, clipIndex);
                    removedCount++;
                }
            }
        }
    }

    return removedCount;
}

/**
 * Add take markers to timeline
 * @returns {Promise<number>} Number of markers added
 */
async function addTakeMarkers() {
    const takes = getCurrentTakes();

    if (!takes || takes.length === 0) {
        throw new Error('No takes to mark');
    }

    let markerCount = 0;

    for (const take of takes) {
        const isBest = take.isBest || take.userMarkedBest;
        const takeStart = take.start || take.startTime || 0;
        const takeEnd = take.end || take.endTime || 0;
        const takeNum = take.takeNumber || takes.indexOf(take) + 1;
        const duration = takeEnd - takeStart;

        const name = `${isBest ? '* ' : ''}Take ${takeNum}`;
        const comments = take.shortLabel || take.description || '';
        const colorIndex = isBest ? 5 : 4; // Cerulean for best, Lavender for others

        await jsx.call('createMarker', takeStart, name, duration, comments, colorIndex);
        markerCount++;
    }

    return markerCount;
}

// Legacy init functions - no longer needed
function initLabelTimeline() {
    // Now called directly via labelTakesOnTimeline()
}

function initApplyTakes() {
    // Now called directly via applyBestTakes()
}

// Export for window access
window.labelTakesOnTimeline = labelTakesOnTimeline;
window.applyBestTakes = applyBestTakes;
window.addTakeMarkers = addTakeMarkers;
