/**
 * Slice 8: Unified Silence Detection & Removal
 *
 * Simplified 3-click workflow:
 * 1. SELECT - Choose Original or Isolated audio
 * 2. ADJUST - Set sensitivity slider
 * 3. EXECUTE - Click "Detect & Remove Silences"
 */

// Store detected silences
let currentSilences = [];

/**
 * Get current silences
 */
function getCurrentSilences() {
  return currentSilences;
}

/**
 * Maps 0-100 sensitivity slider to detection parameters
 * Lower = keep more pauses, Higher = remove more aggressively
 */
function mapSensitivity(value) {
  const t = value / 100;
  return {
    dbThreshold: Math.round(-50 + (30 * t)),                    // -50dB → -20dB
    minDuration: parseFloat((2.0 - (1.7 * t)).toFixed(2)),      // 2.0s → 0.3s
    padding: parseFloat((0.2 - (0.15 * t)).toFixed(2))          // 0.2s → 0.05s
  };
}

/**
 * Initialize the unified Detect & Remove button
 */
function initDetectRemove() {
  document.getElementById('detectRemoveBtn').addEventListener('click', async () => {
    const btn = document.getElementById('detectRemoveBtn');
    const resultsDiv = document.getElementById('silenceResults');
    const progressDiv = document.getElementById('isolationProgress');

    const useOriginal = document.getElementById('sourceOriginal').checked;
    const useIsolated = document.getElementById('sourceIsolated').checked;
    const sensitivity = parseInt(document.getElementById('sensitivitySlider').value);

    if (!useOriginal && !useIsolated) {
      setStatus('Please select at least one audio source');
      return;
    }

    btn.disabled = true;
    btn.textContent = 'Processing...';
    resultsDiv.innerHTML = '';

    try {
      const params = mapSensitivity(sensitivity);
      let audioPath = WAV_PATH;

      // Step 1: Vocal isolation if selected (Creator+ only)
      if (useIsolated) {
        progressDiv.style.display = 'block';
        progressDiv.querySelector('span').textContent = 'Isolating vocals (this may take a few minutes)...';

        const isolateResponse = await fetch(`${BACKEND_URL}/isolate-vocals`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ audioPath: WAV_PATH })
        });

        if (!isolateResponse.ok) {
          const err = await isolateResponse.json();
          throw new Error(err.error || 'Failed to isolate vocals');
        }

        const isolateData = await isolateResponse.json();
        if (!isolateData.success) throw new Error(isolateData.error || 'Vocal isolation failed');

        audioPath = isolateData.outputPath;
      }

      // Step 2: Detect silences using FFprobe
      progressDiv.style.display = 'block';
      progressDiv.querySelector('span').textContent = 'Detecting silences...';

      const detectResponse = await fetch(`${BACKEND_URL}/silences-audio`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          wavPath: audioPath,
          threshold: params.dbThreshold,
          minDuration: params.minDuration,
          padding: params.padding
        })
      });

      if (!detectResponse.ok) {
        const err = await detectResponse.json();
        throw new Error(err.error || 'Failed to detect silences');
      }

      const detectData = await detectResponse.json();
      if (!detectData.success) throw new Error(detectData.error || 'Silence detection failed');

      currentSilences = detectData.silences;

      // Display results
      resultsDiv.innerHTML = `
        <p><strong>${detectData.count}</strong> silence(s) found</p>
        <p style="color: #888;">Total: ${detectData.totalSilenceDuration}s of silence</p>
        <p style="color: #666; font-size: 10px;">
          ${params.dbThreshold}dB, ${params.minDuration}s min, ${params.padding}s padding
        </p>
      `;

      // Step 3: Apply to timeline if silences found
      if (detectData.count > 0) {
        progressDiv.querySelector('span').textContent = 'Applying to timeline...';

        const removedCount = await removeSilencesFromTimeline();

        progressDiv.style.display = 'none';

        if (removedCount > 0) {
          setStatus(`Disabled ${removedCount} clip(s) in ${detectData.count} silence region(s)`);
        } else {
          setStatus(`Found ${detectData.count} silences. Use Razor tool to split clips first.`);
        }

        // Show razor section for advanced splitting
        showRazorSection();
      } else {
        progressDiv.style.display = 'none';
        setStatus('No silences detected. Try increasing sensitivity.');
      }

    } catch (err) {
      progressDiv.style.display = 'none';
      resultsDiv.innerHTML = `<p style="color: #f66;">Error: ${err.message}</p>`;
      setStatus('Error: ' + err.message);
      console.error('SPLICE detection error:', err);
    } finally {
      btn.disabled = false;
      btn.textContent = 'Detect & Remove Silences';
    }
  });
}

/**
 * Remove silences from timeline by disabling clips
 * Returns count of disabled clips
 */
async function removeSilencesFromTimeline() {
  if (!currentSilences || currentSilences.length === 0) {
    return 0;
  }

  const context = await getActiveSequence();
  if (!context) {
    throw new Error('No project or sequence open');
  }

  const { sequence } = context;

  // Sort silences by start time DESCENDING (work from end to avoid time shifts)
  const sortedSilences = [...currentSilences].sort((a, b) => b.start - a.start);

  let removedCount = 0;
  const videoTrackCount = await sequence.getVideoTrackCount();
  const audioTrackCount = await sequence.getAudioTrackCount();

  for (const silence of sortedSilences) {
    const startTicks = Math.floor(silence.start * TICKS_PER_SECOND);
    const endTicks = Math.floor(silence.end * TICKS_PER_SECOND);

    // Process video tracks
    for (let i = 0; i < videoTrackCount; i++) {
      const track = await sequence.getVideoTrack(i);
      if (!track) continue;

      const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      if (!clips) continue;

      for (let j = clips.length - 1; j >= 0; j--) {
        const clip = clips[j];
        if (!clip) continue;

        const clipStartObj = await clip.getStartTime();
        const clipEndObj = await clip.getEndTime();
        const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
        const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

        // Check if clip is FULLY CONTAINED within silence region
        if (clipStart >= startTicks && clipEnd <= endTicks) {
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;

          project.lockedAccess(() => {
            project.executeTransaction((compoundAction) => {
              const disableAction = clipRef.createSetDisabledAction(true);
              compoundAction.addAction(disableAction);
            }, 'SPLICE: Remove Silence');
          });
          removedCount++;
        }
      }
    }

    // Process audio tracks
    for (let i = 0; i < audioTrackCount; i++) {
      const track = await sequence.getAudioTrack(i);
      if (!track) continue;

      const clips = await track.getTrackItems(ppro.Constants.TrackItemType.CLIP, false);
      if (!clips) continue;

      for (let j = clips.length - 1; j >= 0; j--) {
        const clip = clips[j];
        if (!clip) continue;

        const clipStartObj = await clip.getStartTime();
        const clipEndObj = await clip.getEndTime();
        const clipStart = clipStartObj.ticks !== undefined ? clipStartObj.ticks : clipStartObj;
        const clipEnd = clipEndObj.ticks !== undefined ? clipEndObj.ticks : clipEndObj;

        // Check if clip is FULLY CONTAINED within silence region
        if (clipStart >= startTicks && clipEnd <= endTicks) {
          const project = await ppro.Project.getActiveProject();
          const clipRef = clip;

          project.lockedAccess(() => {
            project.executeTransaction((compoundAction) => {
              const disableAction = clipRef.createSetDisabledAction(true);
              compoundAction.addAction(disableAction);
            }, 'SPLICE: Remove Silence');
          });
          removedCount++;
        }
      }
    }
  }

  return removedCount;
}

/**
 * Show the silence section (called after audio export)
 */
function showSilenceSection() {
  document.getElementById('silenceSection').style.display = 'block';
}
