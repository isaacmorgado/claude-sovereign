'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { RGBShiftShader } from 'three/examples/jsm/shaders/RGBShiftShader.js';

// Score color gradient function
function getScoreColorRGB(score: number): string {
  if (typeof score !== 'number') return 'rgb(37, 99, 235)';
  const clamp = Math.max(1, Math.min(10, score));
  const stops = [
    { t: 1, c: [185, 28, 28] },
    { t: 2, c: [220, 53, 53] },
    { t: 3, c: [239, 88, 88] },
    { t: 4, c: [245, 130, 75] },
    { t: 5, c: [251, 175, 60] },
    { t: 6, c: [220, 200, 80] },
    { t: 7, c: [140, 215, 100] },
    { t: 8, c: [74, 222, 128] },
    { t: 9, c: [40, 205, 170] },
    { t: 10, c: [6, 182, 212] }
  ];
  let out = stops[stops.length - 1].c;
  for (let i = 0; i < stops.length - 1; i++) {
    const a = stops[i], b = stops[i + 1];
    if (clamp >= a.t && clamp <= b.t) {
      const f = (clamp - a.t) / (b.t - a.t);
      out = [
        Math.round(a.c[0] + f * (b.c[0] - a.c[0])),
        Math.round(a.c[1] + f * (b.c[1] - a.c[1])),
        Math.round(a.c[2] + f * (b.c[2] - a.c[2]))
      ];
      break;
    }
  }
  return `rgb(${out[0]}, ${out[1]}, ${out[2]})`;
}

// Create vertical gradient texture for walls
function createVerticalGradientTexture(topHex: string, bottomHex: string): THREE.CanvasTexture {
  const canvas = document.createElement('canvas');
  canvas.width = 1;
  canvas.height = 256;
  const ctx = canvas.getContext('2d')!;
  const grad = ctx.createLinearGradient(0, 0, 0, 256);
  grad.addColorStop(0, topHex);
  grad.addColorStop(1, bottomHex);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 1, 256);
  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = THREE.ClampToEdgeWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  return tex;
}

interface HeadSceneProps {
  className?: string;
}

export default function HeadScene({ className = '' }: HeadSceneProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<{
    scene: THREE.Scene;
    camera: THREE.PerspectiveCamera;
    renderer: THREE.WebGLRenderer;
    composer: EffectComposer;
    headModel: THREE.Group | null;
    roomGroup: THREE.Group;
    outlinePass: OutlinePass;
    bloomPass: UnrealBloomPass;
    rgbShiftPass: ShaderPass;
    pointer: { x: number; y: number };
    pointerTarget: { x: number; y: number };
    currentScore: number;
    targetScore: number;
    cameraBaseZ: number;
    cameraBaseY: number;
    cameraTargetY: number;
    gridColorsAttr: THREE.Float32BufferAttribute | null;
    floorY: number;
  } | null>(null);
  const animationRef = useRef<number | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initialize Three.js scene
  const initScene = useCallback(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;
    const rect = container.getBoundingClientRect();
    const width = rect.width || window.innerWidth * 0.5;
    const height = rect.height || window.innerHeight;

    // Scene
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.01, 500);

    // Renderer
    const renderer = new THREE.WebGLRenderer({
      antialias: window.devicePixelRatio <= 1.25,
      alpha: false
    });
    renderer.setClearColor(0x0d1117, 1);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(width, height);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;

    // Style the canvas element
    renderer.domElement.style.display = 'block';
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';

    container.appendChild(renderer.domElement);

    // Effect Composer
    const composer = new EffectComposer(renderer);
    composer.setSize(width, height);
    composer.addPass(new RenderPass(scene, camera));

    // Outline Pass
    const outlinePass = new OutlinePass(new THREE.Vector2(width, height), scene, camera);
    outlinePass.edgeStrength = 1.3;
    outlinePass.edgeThickness = 1.2;
    outlinePass.pulsePeriod = 3;
    outlinePass.visibleEdgeColor.set(0xffffff);
    outlinePass.hiddenEdgeColor.set(0x000000);
    composer.addPass(outlinePass);

    // Bloom Pass
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 0.2, 0.3, 0.88);
    composer.addPass(bloomPass);

    // RGB Shift Pass
    const rgbShiftPass = new ShaderPass(RGBShiftShader);
    rgbShiftPass.uniforms['amount'].value = 0.0015;
    composer.addPass(rgbShiftPass);

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.35);
    scene.add(hemiLight);

    const keyLight = new THREE.DirectionalLight(0xfff1e0, 1.2);
    keyLight.position.set(10, 20, 15);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0xe8f0ff, 0.5);
    fillLight.position.set(-5, 3, 5);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xcfe8ff, 0.8);
    rimLight.position.set(2, 3, -5);
    scene.add(rimLight);

    // Room Group
    const roomGroup = new THREE.Group();
    const floorY = -30;

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(400, 400);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x19212c,
      roughness: 1.0,
      metalness: 0.0
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = floorY;
    roomGroup.add(floor);

    // Grid
    const gridSize = 400;
    const gridDivisions = 20;
    const gridPoints: number[] = [];
    const step = gridSize / gridDivisions;
    const halfSize = gridSize / 2;

    for (let i = 0; i <= gridDivisions; i++) {
      const pos = -halfSize + i * step;
      gridPoints.push(-halfSize, 0, pos, halfSize, 0, pos);
      gridPoints.push(pos, 0, -halfSize, pos, 0, halfSize);
    }

    const gridGeometry = new THREE.BufferGeometry();
    gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPoints, 3));
    const gridColorsAttr = new THREE.Float32BufferAttribute(new Float32Array(gridPoints.length), 3);
    gridGeometry.setAttribute('color', gridColorsAttr);

    const gridMaterial = new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.3,
      vertexColors: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const gridLines = new THREE.LineSegments(gridGeometry, gridMaterial);
    gridLines.position.y = floorY + 0.1;
    roomGroup.add(gridLines);

    // Back Wall
    const wallBackGeometry = new THREE.PlaneGeometry(400, 400);
    const wallBackMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 1.0,
      metalness: 0.0
    });
    wallBackMaterial.map = createVerticalGradientTexture('#2a344a', '#0f141d');
    const wallBack = new THREE.Mesh(wallBackGeometry, wallBackMaterial);
    wallBack.position.set(0, 170, -200);
    roomGroup.add(wallBack);

    // Side Walls
    const wallLeftMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 1.0,
      metalness: 0.0
    });
    wallLeftMaterial.map = createVerticalGradientTexture('#253145', '#0d121a');
    const wallLeft = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), wallLeftMaterial);
    wallLeft.rotation.y = Math.PI / 2;
    wallLeft.position.set(-200, 170, 0);
    roomGroup.add(wallLeft);

    const wallRightMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 1.0,
      metalness: 0.0
    });
    wallRightMaterial.map = createVerticalGradientTexture('#253145', '#0d121a');
    const wallRight = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), wallRightMaterial);
    wallRight.rotation.y = -Math.PI / 2;
    wallRight.position.set(200, 170, 0);
    roomGroup.add(wallRight);

    scene.add(roomGroup);

    // Set initial camera position
    camera.position.set(0, 10, 100);
    camera.lookAt(0, 0, 0);
    camera.updateProjectionMatrix();

    // Store refs
    sceneRef.current = {
      scene,
      camera,
      renderer,
      composer,
      headModel: null,
      roomGroup,
      outlinePass,
      bloomPass,
      rgbShiftPass,
      pointer: { x: 0, y: 0 },
      pointerTarget: { x: 0, y: 0 },
      currentScore: 0,
      targetScore: 4.27,
      cameraBaseZ: 50,
      cameraBaseY: 5,
      cameraTargetY: 0,
      gridColorsAttr,
      floorY
    };

    // Load 3D Model
    const loader = new GLTFLoader();
    loader.load('/face.glb', (gltf) => {
      const model = gltf.scene;

      console.log('GLTF loaded:', gltf);
      console.log('Model scene:', model);

      // Collect meshes first to avoid infinite recursion when adding overlays
      const meshes: THREE.Mesh[] = [];
      model.traverse((obj) => {
        if ((obj as THREE.Mesh).isMesh) {
          meshes.push(obj as THREE.Mesh);
        }
      });

      console.log('Total meshes found:', meshes.length);

      // Apply materials to collected meshes
      meshes.forEach((mesh) => {
        console.log('Processing mesh:', mesh.name, 'geometry vertices:', mesh.geometry?.attributes?.position?.count);

        // Create a skin-like material
        const skinMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5e6d3,
          emissive: 0x331100,
          emissiveIntensity: 0.1,
          metalness: 0.0,
          roughness: 0.6,
          side: THREE.DoubleSide
        });

        mesh.material = skinMaterial;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Add wireframe overlay
        if (mesh.geometry) {
          const overlayMaterial = new THREE.MeshBasicMaterial({
            color: 0x4488ff,
            wireframe: true,
            transparent: true,
            opacity: 0.08,
            depthWrite: false
          });
          const overlayMesh = new THREE.Mesh(mesh.geometry, overlayMaterial);
          overlayMesh.renderOrder = 1;
          mesh.add(overlayMesh);
        }
      });

      if (meshes.length === 0) {
        console.error('No meshes found in model!');
        setIsLoading(false);
        return;
      }

      // Get initial bounding box
      const initialBox = new THREE.Box3().setFromObject(model);
      const initialCenter = initialBox.getCenter(new THREE.Vector3());
      const initialSize = initialBox.getSize(new THREE.Vector3());

      console.log('Initial bounding box - center:', initialCenter, 'size:', initialSize);

      // Create a group to hold the model
      const headGroup = new THREE.Group();

      // Center the model by offsetting its position
      model.position.set(-initialCenter.x, -initialCenter.y, -initialCenter.z);

      // Scale the model - the original is quite small (about 26 units)
      const scaleFactor = 3;
      model.scale.set(scaleFactor, scaleFactor, scaleFactor);

      headGroup.add(model);
      headGroup.updateMatrixWorld(true);

      // Recalculate bounding box
      const finalBox = new THREE.Box3().setFromObject(headGroup);
      const finalSize = finalBox.getSize(new THREE.Vector3());
      const finalCenter = finalBox.getCenter(new THREE.Vector3());

      console.log('Final bounding box - center:', finalCenter, 'size:', finalSize);

      // Add to scene
      scene.add(headGroup);

      if (sceneRef.current) {
        sceneRef.current.headModel = headGroup;
        sceneRef.current.outlinePass.selectedObjects = [headGroup];

        // Calculate camera position
        const maxDim = Math.max(finalSize.x, finalSize.y, finalSize.z);
        const fovRad = (camera.fov * Math.PI) / 180;
        const cameraDistance = (maxDim / 2) / Math.tan(fovRad / 2);
        const finalZ = cameraDistance * 1.8;
        const finalY = finalZ * 0.1;

        console.log('Camera setup - maxDim:', maxDim, 'distance:', finalZ, 'y:', finalY);

        sceneRef.current.cameraBaseZ = finalZ;
        sceneRef.current.cameraBaseY = finalY;
        sceneRef.current.cameraTargetY = 0;

        camera.position.set(0, finalY, finalZ);
        camera.lookAt(0, 0, 0);
        camera.updateProjectionMatrix();

        console.log('Camera position set to:', camera.position);
      }

      setIsLoading(false);
    },
    (progress) => {
      if (progress.total > 0) {
        console.log('Loading progress:', ((progress.loaded / progress.total) * 100).toFixed(1) + '%');
      }
    },
    (error) => {
      console.error('Error loading model:', error);
      setIsLoading(false);
    });

  }, []);

  // Animation loop
  const animate = useCallback(() => {
    if (!sceneRef.current) return;

    const {
      camera,
      composer,
      headModel,
      roomGroup,
      outlinePass,
      bloomPass,
      rgbShiftPass,
      pointer,
      pointerTarget,
      cameraBaseZ,
      cameraBaseY,
      cameraTargetY,
      gridColorsAttr
    } = sceneRef.current;

    const t = performance.now() * 0.001;

    // Smooth pointer
    pointer.x += (pointerTarget.x - pointer.x) * 0.08;
    pointer.y += (pointerTarget.y - pointer.y) * 0.08;

    const isMobile = window.innerWidth <= 800;
    const headBasePitch = isMobile ? -0.35 : -0.10;

    // Animate head model
    if (headModel) {
      headModel.rotation.y = pointer.x * 0.1;
      headModel.rotation.x = headBasePitch + pointer.y * 0.03;
    }

    // Animate room
    if (roomGroup) {
      roomGroup.rotation.y = pointer.x * 0.08;
      roomGroup.rotation.x = (isMobile ? -0.35 : -0.10) + pointer.y * 0.04;
    }

    // Camera sway
    const sway = Math.max(0.02, Math.min(0.06, cameraBaseZ * 0.0004));
    const lift = Math.max(0.015, Math.min(0.05, cameraBaseZ * 0.0003));
    camera.position.set(
      pointer.x * cameraBaseZ * sway,
      cameraBaseY + pointer.y * cameraBaseZ * lift,
      cameraBaseZ
    );
    camera.lookAt(0, cameraTargetY, 0);

    // Animate score
    sceneRef.current.currentScore += (sceneRef.current.targetScore - sceneRef.current.currentScore) * 0.08;
    const scoreColor = getScoreColorRGB(sceneRef.current.currentScore);

    // Update outline color
    if (outlinePass) {
      outlinePass.visibleEdgeColor.setStyle(scoreColor);
      outlinePass.edgeStrength = 2.0 + 1.5 * (0.5 + 0.5 * Math.sin(t * 1.2));
    }

    // Update bloom
    if (bloomPass) {
      const targetBloom = 0.25 + Math.max(0, Math.min(1, (sceneRef.current.currentScore - 5) / 5)) * 0.7;
      bloomPass.strength += (targetBloom - bloomPass.strength) * 0.05;
      bloomPass.radius = 0.4 + 0.2 * (0.5 + 0.5 * Math.sin(t * 0.6));
    }

    // Update RGB shift
    if (rgbShiftPass) {
      rgbShiftPass.uniforms['amount'].value = 0.0012 + 0.0008 * (0.5 + 0.5 * Math.sin(t * 0.75));
    }

    // Update grid colors
    if (gridColorsAttr) {
      const rgbMatch = scoreColor.match(/\d+/g);
      if (rgbMatch) {
        const r = parseInt(rgbMatch[0]) / 255;
        const g = parseInt(rgbMatch[1]) / 255;
        const b = parseInt(rgbMatch[2]) / 255;
        const arr = gridColorsAttr.array as Float32Array;
        for (let i = 0; i < arr.length; i += 3) {
          const wave = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(t * 0.5 + i * 0.01));
          arr[i] = r * wave;
          arr[i + 1] = g * wave;
          arr[i + 2] = b * wave;
        }
        gridColorsAttr.needsUpdate = true;
      }
    }

    composer.render();
    animationRef.current = requestAnimationFrame(animate);
  }, []);

  // Handle pointer move
  const handlePointerMove = useCallback((e: PointerEvent) => {
    if (!containerRef.current || !sceneRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const ny = ((e.clientY - rect.top) / rect.height) * 2 - 1;
    sceneRef.current.pointerTarget.x = Math.max(-1, Math.min(1, nx));
    sceneRef.current.pointerTarget.y = Math.max(-1, Math.min(1, ny));
  }, []);

  const handlePointerLeave = useCallback(() => {
    if (sceneRef.current) {
      sceneRef.current.pointerTarget.x = 0;
      sceneRef.current.pointerTarget.y = 0;
    }
  }, []);

  // Handle resize
  const handleResize = useCallback(() => {
    if (!containerRef.current || !sceneRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;

    sceneRef.current.camera.aspect = width / height;
    sceneRef.current.camera.updateProjectionMatrix();
    sceneRef.current.renderer.setSize(width, height);
    sceneRef.current.composer.setSize(width, height);
  }, []);

  // Setup and cleanup
  useEffect(() => {
    initScene();

    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerleave', handlePointerLeave);
    window.addEventListener('resize', handleResize);

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerleave', handlePointerLeave);
      window.removeEventListener('resize', handleResize);

      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }

      if (sceneRef.current) {
        sceneRef.current.renderer.dispose();
        sceneRef.current.composer.dispose();
      }
    };
  }, [initScene, animate, handlePointerMove, handlePointerLeave, handleResize]);

  return (
    <div
      ref={containerRef}
      className={`relative ${className}`}
      style={{ width: '100%', height: '100%', minHeight: '100vh' }}
    >
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/50 z-10">
          <div className="w-8 h-8 border-2 border-blue-400 border-t-transparent rounded-full animate-spin" />
        </div>
      )}
    </div>
  );
}
