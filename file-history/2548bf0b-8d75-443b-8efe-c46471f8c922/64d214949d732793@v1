"""
Authentication router - register, login, profile, password reset
"""

import random
import secrets
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from uuid import uuid4

from app.database import get_db
from app.models.user import User, ReferralCode, PlanType
from app.schemas.user import (
    UserCreate, UserLogin, UserResponse, Token,
    ForgotPasswordRequest, ResetPasswordRequest
)
from app.services.auth import AuthService, get_current_user
from app.services.email import email_service

router = APIRouter(prefix="/auth", tags=["auth"])


@router.post("/register", response_model=Token)
async def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)):
    """Register a new user"""
    # Check if email exists - only select id to avoid loading full model
    result = await db.execute(select(User.id).where(User.email == user_data.email))
    existing_user = result.scalar_one_or_none()

    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # Check if username already exists (case-insensitive) - only select id
    result = await db.execute(
        select(User.id).where(func.lower(User.username) == user_data.username.lower())
    )
    existing_username = result.scalar_one_or_none()

    if existing_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )

    # Validate referral code if provided
    stripe_promo_id = None
    if user_data.referral_code:
        result = await db.execute(
            select(ReferralCode).where(
                func.upper(ReferralCode.code) == user_data.referral_code.upper(),
                ReferralCode.is_active == True
            )
        )
        referral = result.scalar_one_or_none()
        if referral:
            stripe_promo_id = referral.stripe_promotion_code_id
            # Increment usage count
            referral.total_uses += 1
        else:
            # Fallback: Check if it matches a user's username
            # This allows any user to be a referrer using their username
            result = await db.execute(
                select(User.id).where(func.upper(User.username) == user_data.referral_code.upper())
            )
            referrer_user_id = result.scalar_one_or_none()
            
            # Note: We rely on the fact that the code is stored in user.referral_code
            # We don't need to do anything else here, the registration below will persist it
            pass

    # Create user with explicit defaults (avoid db.refresh which causes schema issues)
    hashed_password = AuthService.hash_password(user_data.password)
    now = datetime.utcnow()

    # Generate email verification token (expires in 24 hours)
    verification_token = secrets.token_urlsafe(32)

    user = User(
        id=uuid4(),
        email=user_data.email,
        password_hash=hashed_password,
        name=user_data.name,
        username=user_data.username,
        terms_accepted_at=now if user_data.terms_accepted else None,
        referral_code=user_data.referral_code,
        referred_by=stripe_promo_id,
        plan=PlanType.FREE,
        email_verified=False,
        email_verification_token=verification_token,
        email_verification_expires=now + timedelta(hours=24),
        created_at=now,
        updated_at=now,
    )

    db.add(user)
    await db.commit()

    # Send verification email (non-blocking, don't fail registration if email fails)
    try:
        await email_service.send_verification_email(user.email, verification_token)
    except Exception as e:
        print(f"[AUTH] Failed to send verification email: {e}")

    # Send welcome email (non-blocking, don't fail registration if email fails)
    try:
        await email_service.send_welcome_email(user.email, user.username)
    except Exception as e:
        print(f"[AUTH] Failed to send welcome email: {e}")

    # Generate token
    access_token = AuthService.create_access_token(str(user.id))

    # Explicitly create UserResponse to avoid serialization issues
    user_response = UserResponse(
        id=user.id,
        email=user.email,
        name=user.name,
        username=user.username,
        plan=user.plan.value if hasattr(user.plan, 'value') else str(user.plan),
        email_verified=user.email_verified or False,
        created_at=user.created_at,
    )

    return Token(access_token=access_token, token_type="bearer", user=user_response)


@router.post("/login", response_model=Token)
async def login(credentials: UserLogin, db: AsyncSession = Depends(get_db)):
    """Login and get JWT token"""
    # Only select columns needed for authentication and response
    result = await db.execute(
        select(
            User.id, User.email, User.name, User.username,
            User.password_hash, User.plan, User.email_verified, User.created_at
        ).where(User.email == credentials.email)
    )
    row = result.one_or_none()

    if not row or not AuthService.verify_password(credentials.password, row.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = AuthService.create_access_token(str(row.id))

    # Explicitly create UserResponse
    user_response = UserResponse(
        id=row.id,
        email=row.email,
        name=row.name,
        username=row.username,
        plan=row.plan.value if hasattr(row.plan, 'value') else str(row.plan),
        email_verified=row.email_verified or False,
        created_at=row.created_at,
    )

    return Token(access_token=access_token, token_type="bearer", user=user_response)


@router.get("/me", response_model=UserResponse)
async def get_me(current_user: User = Depends(get_current_user)):
    """Get current user profile"""
    return UserResponse(
        id=current_user.id,
        email=current_user.email,
        name=current_user.name,
        username=current_user.username,
        plan=current_user.plan.value if hasattr(current_user.plan, 'value') else str(current_user.plan),
        email_verified=current_user.email_verified or False,
        created_at=current_user.created_at,
    )


@router.get("/check-username/{username}")
async def check_username(username: str, db: AsyncSession = Depends(get_db)):
    """Check if a username is available (no auth required)"""
    # Validate format
    if len(username) < 3:
        return {"available": False, "reason": "Too short"}
    if len(username) > 30:
        return {"available": False, "reason": "Too long"}
    if not all(c.isalnum() or c == '_' for c in username):
        return {"available": False, "reason": "Invalid characters"}
    if username.lower().startswith('user_'):
        return {"available": False, "reason": "Reserved prefix"}

    # Check database - only select id to avoid loading full model
    result = await db.execute(
        select(User.id).where(func.lower(User.username) == username.lower())
    )
    exists = result.scalar_one_or_none()

    return {
        "available": exists is None,
        "reason": "Username taken" if exists else None
    }


@router.get("/validate-referral/{code}")
async def validate_referral_code(code: str, db: AsyncSession = Depends(get_db)):
    """Validate a referral code (no auth required)"""
    if len(code) < 3:
        return {"valid": False, "message": "Invalid code format"}

    result = await db.execute(
        select(ReferralCode).where(
            func.upper(ReferralCode.code) == code.upper(),
            ReferralCode.is_active == True
        )
    )
    referral = result.scalar_one_or_none()

    if referral:
        discount_msg = f"{referral.discount_percent}% discount" if referral.discount_percent else "Special offer"
        return {
            "valid": True,
            "message": f"Code applied! {discount_msg} from {referral.influencer_name}"
        }
    
    # Check if it matches a user
    result = await db.execute(
        select(User.username).where(func.upper(User.username) == code.upper())
    )
    username_match = result.scalar_one_or_none()
    
    if username_match:
        return {
            "valid": True,
            "message": f"Code applied! 10% discount from {username_match}"
        }

    return {"valid": False, "message": "Invalid or expired code"}


@router.post("/forgot-password")
async def forgot_password(data: ForgotPasswordRequest, db: AsyncSession = Depends(get_db)):
    """Request a password reset email"""
    # Always return success to prevent email enumeration
    result = await db.execute(select(User).where(User.email == data.email))
    user = result.scalar_one_or_none()

    if user:
        # Generate secure reset token
        reset_token = secrets.token_urlsafe(32)
        user.password_reset_token = reset_token
        user.password_reset_expires = datetime.utcnow() + timedelta(hours=1)
        await db.commit()

        # Send password reset email
        await email_service.send_password_reset_email(user.email, reset_token)

    return {"message": "If an account exists with this email, a reset link has been sent."}


@router.post("/reset-password")
async def reset_password(data: ResetPasswordRequest, db: AsyncSession = Depends(get_db)):
    """Reset password using token"""
    result = await db.execute(
        select(User).where(
            User.password_reset_token == data.token,
            User.password_reset_expires > datetime.utcnow()
        )
    )
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )

    # Update password
    user.password_hash = AuthService.hash_password(data.new_password)
    user.password_reset_token = None
    user.password_reset_expires = None
    await db.commit()

    return {"message": "Password has been reset successfully"}


@router.get("/verify-email")
async def verify_email(token: str, db: AsyncSession = Depends(get_db)):
    """Verify email using token from email link"""
    result = await db.execute(
        select(User).where(
            User.email_verification_token == token,
            User.email_verification_expires > datetime.utcnow()
        )
    )
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired verification token"
        )

    # Mark email as verified and clear token
    user.email_verified = True
    user.email_verification_token = None
    user.email_verification_expires = None
    await db.commit()

    return {"message": "Email verified successfully", "email": user.email}


@router.post("/resend-verification")
async def resend_verification(current_user: User = Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    """Resend verification email for authenticated user"""
    if current_user.email_verified:
        return {"message": "Email is already verified"}

    # Generate new verification token
    verification_token = secrets.token_urlsafe(32)
    current_user.email_verification_token = verification_token
    current_user.email_verification_expires = datetime.utcnow() + timedelta(hours=24)
    await db.commit()

    # Send verification email
    try:
        await email_service.send_verification_email(current_user.email, verification_token)
        return {"message": "Verification email sent"}
    except Exception as e:
        print(f"[AUTH] Failed to resend verification email: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to send verification email"
        )
