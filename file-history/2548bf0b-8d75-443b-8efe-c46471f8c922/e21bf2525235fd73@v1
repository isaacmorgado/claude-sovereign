/**
 * API Client for PROJECT CASSANOVA Backend
 *
 * Handles all authenticated requests to the Railway-hosted API
 */

import type { UserRank, LeaderboardEntry, LeaderboardData, UserProfile } from '@/types/results';
import type {
  Category,
  SubForum,
  Post,
  PostListItem,
  PostListResponse,
  PostCreate,
  PostUpdate,
  Comment,
  CommentCreate,
  VoteType,
  VoteResponse,
  ReportCreate,
  Report,
  GuideSection,
  RecommendedForum,
  SortOrder,
  CategoryListItem,
  PostAuthor,
  ForumSearchResult,
  ForumSearchResponse,
  SearchResultType,
  ForumUserProfile,
  UserPostItem,
  UserPostListResponse,
  UserCommentItem,
  UserCommentListResponse,
  BookmarkToggleResponse,
  BookmarkStatus,
  BookmarkedPostsResponse,
  // Admin/Moderation types
  ReportDetail,
  AdminReportListResponse,
  ResolveReportRequest,
  ModerationStats,
  BanUserRequest,
  BanUserResponse,
  BannedUser,
  BannedUsersResponse,
  ReportStatusEnum,
  ActionTaken,
  TargetType,
  ReportReason,
  KarmaLeaderboardEntry,
  KarmaLeaderboardResponse,
  ForumQuota,
  ForumAnalytics,
  DailyMetric,
  TopContributor,
  CategoryEngagement,
  CursorPaginatedPostListResponse,
  PaginatedCommentsResponse,
  CommentRepliesResponse,
} from '@/types/forum';
import type {
  Notification as AppNotification,
  NotificationListResponse,
  MarkReadResponse,
  MarkAllReadResponse,
  DeleteNotificationResponse,
} from '@/types/notification';

const API_URL = '/api/proxy';

// ============================================
// MOCK DATA FALLBACKS (For production outages)
// ============================================

const MOCK_CATEGORIES: CategoryApiResponse[] = [
  {
    id: 'cat_1',
    name: 'Looksmwxxing',
    slug: 'looksmaaxxing',
    description: 'General discussion about looks improvement strategies and aesthetics.',
    icon: 'âœ¨',
    display_order: 1,
    post_count: 1243,
    sub_forums: [
      { id: 'sub_1', name: 'General', slug: 'general', description: 'General chat', icon: 'ðŸ—£ï¸', display_order: 1, post_count: 500 },
      { id: 'sub_2', name: 'Ratings', slug: 'ratings', description: 'Rate my face', icon: 'â­', display_order: 2, post_count: 743 }
    ]
  },
  {
    id: 'cat_2',
    name: 'Body Composition',
    slug: 'body-composition',
    description: 'Training, nutrition, and physique optimization.',
    icon: 'ðŸ’ª',
    display_order: 2,
    post_count: 890,
    sub_forums: [
      { id: 'sub_3', name: 'Training', slug: 'training', description: 'Workout plans', icon: 'ðŸ‹ï¸', display_order: 1, post_count: 400 },
      { id: 'sub_4', name: 'Nutrition', slug: 'nutrition', description: 'Diet and macros', icon: 'ðŸ¥—', display_order: 2, post_count: 490 }
    ]
  },
  {
    id: 'cat_3',
    name: 'Skin & Hair',
    slug: 'skin-hair',
    description: 'Skincare routines, hair loss prevention, and grooming.',
    icon: 'ðŸ§´',
    display_order: 3,
    post_count: 650,
    sub_forums: [
      { id: 'sub_5', name: 'Skincare', slug: 'skincare', description: 'Clear skin guides', icon: 'âœ¨', display_order: 1, post_count: 350 },
      { id: 'sub_6', name: 'Hair', slug: 'hair', description: 'Hair maxxing', icon: 'ðŸ’‡', display_order: 2, post_count: 300 }
    ]
  }
];

const MOCK_POSTS: PostListApiResponse = {
  posts: [
    {
      id: 'post_1',
      title: 'How I improved my jawline in 6 months (Mewing + Chewing)',
      content_preview: 'Here is my transformation story...',
      sub_forum_slug: 'general',
      category_slug: 'looksmaaxxing',
      author: { id: 'user_1', username: 'JawlineGod', karma: 500 },
      is_pinned: true,
      is_guide: true,
      vote_count: 156,
      comment_count: 45,
      user_vote: null,
      created_at: new Date().toISOString()
    },
    {
      id: 'post_2',
      title: 'The ultimate guide to skincare for acne prone skin',
      content_preview: 'Stop using harsh cleansers...',
      sub_forum_slug: 'skincare',
      category_slug: 'skin-hair',
      author: { id: 'user_2', username: 'ClearSkinKing', karma: 320 },
      is_pinned: false,
      is_guide: true,
      vote_count: 89,
      comment_count: 23,
      user_vote: null,
      created_at: new Date(Date.now() - 86400000).toISOString()
    },
    {
      id: 'post_3',
      title: 'Is 15% body fat lean enough for facial definition?',
      content_preview: 'I am currently at 18% and wondering...',
      sub_forum_slug: 'training',
      category_slug: 'body-composition',
      author: { id: 'user_3', username: 'GymBro99', karma: 45 },
      is_pinned: false,
      is_guide: false,
      vote_count: 34,
      comment_count: 12,
      user_vote: null,
      created_at: new Date(Date.now() - 172800000).toISOString()
    }
  ],
  total_count: 3,
  has_more: false
};

// API Response types (snake_case from backend)
interface LeaderboardApiResponse {
  user_id: string;
  score: number;
  global_rank: number;
  gender_rank: number;
  percentile: number;
  total_users: number;
  gender_total: number;
  anonymous_name: string;
  updated_at: string;
}

interface LeaderboardEntryResponse {
  user_id: string;
  rank: number;
  score: number;
  anonymous_name: string;
  gender: 'male' | 'female';
  face_photo_url: string | null;
  is_current_user: boolean;
  top_strengths: string[];
  top_improvements: string[];
}

interface LeaderboardListResponse {
  entries: LeaderboardEntryResponse[];
  total_count: number;
  user_rank: LeaderboardApiResponse | null;
}

interface UserProfileResponse {
  user_id: string;
  rank: number;
  score: number;
  anonymous_name: string;
  gender: 'male' | 'female';
  face_photo_url: string | null;
  top_strengths: string[];
  top_improvements: string[];
}

// Transform functions (snake_case -> camelCase)
function transformUserRank(data: LeaderboardApiResponse): UserRank {
  return {
    userId: data.user_id,
    score: data.score,
    globalRank: data.global_rank,
    genderRank: data.gender_rank,
    percentile: data.percentile,
    totalUsers: data.total_users,
    genderTotal: data.gender_total,
    anonymousName: data.anonymous_name,
    updatedAt: data.updated_at,
  };
}

function transformLeaderboardEntry(data: LeaderboardEntryResponse): LeaderboardEntry {
  return {
    userId: data.user_id,
    rank: data.rank,
    score: data.score,
    anonymousName: data.anonymous_name,
    gender: data.gender,
    facePhotoUrl: data.face_photo_url,
    isCurrentUser: data.is_current_user,
    topStrengths: data.top_strengths || [],
    topImprovements: data.top_improvements || [],
  };
}

function transformLeaderboardData(data: LeaderboardListResponse): LeaderboardData {
  return {
    entries: data.entries.map(transformLeaderboardEntry),
    totalCount: data.total_count,
    userRank: data.user_rank ? transformUserRank(data.user_rank) : null,
  };
}

function transformUserProfile(data: UserProfileResponse): UserProfile {
  return {
    userId: data.user_id,
    rank: data.rank,
    score: data.score,
    anonymousName: data.anonymous_name,
    gender: data.gender,
    facePhotoUrl: data.face_photo_url,
    topStrengths: data.top_strengths,
    topImprovements: data.top_improvements,
  };
}

// === FORUM API RESPONSE TYPES ===

interface SubForumApiResponse {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  icon: string | null;
  display_order: number;
  post_count: number;
}

interface CategoryApiResponse {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  icon: string | null;
  display_order: number;
  post_count: number;
  sub_forums: SubForumApiResponse[];
}

interface CategoryListApiResponse {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  icon: string | null;
  display_order: number;
  post_count: number;
}

interface PostAuthorApiResponse {
  id: string;
  username: string;
  karma?: number;
}

interface PostApiResponse {
  id: string;
  title: string;
  content: string;
  sub_forum_id: string;
  sub_forum_slug: string;
  category_slug: string;
  author: PostAuthorApiResponse;
  is_pinned: boolean;
  is_guide: boolean;
  vote_count: number;
  comment_count: number;
  user_vote: VoteType | null;
  created_at: string;
  updated_at: string;
}

interface PostListItemApiResponse {
  id: string;
  title: string;
  content_preview: string;
  sub_forum_slug: string;
  category_slug: string;
  author: PostAuthorApiResponse;
  is_pinned: boolean;
  is_guide: boolean;
  vote_count: number;
  comment_count: number;
  user_vote: VoteType | null;
  created_at: string;
}

interface PostListApiResponse {
  posts: PostListItemApiResponse[];
  total_count: number;
  has_more: boolean;
}

interface CursorPaginatedPostListApiResponse {
  posts: PostListItemApiResponse[];
  next_cursor: string | null;
  has_more: boolean;
  total_count?: number;
}

interface CommentApiResponse {
  id: string;
  content: string;
  post_id: string;
  author: PostAuthorApiResponse;
  parent_id: string | null;
  vote_count: number;
  user_vote: VoteType | null;
  depth: number;
  replies: CommentApiResponse[];
  created_at: string;
  updated_at: string;
}

interface VoteApiResponse {
  success: boolean;
  new_vote_count: number;
  user_vote: VoteType | null;
}

interface ReportApiResponse {
  id: string;
  target_type: 'post' | 'comment';
  target_id: string;
  reason: string;
  status: string;
  created_at: string;
}

interface GuideSectionApiResponse {
  category: CategoryListApiResponse;
  guides: PostListItemApiResponse[];
}

interface RecommendedForumApiResponse {
  category: CategoryListApiResponse;
  matched_flaws: string[];
  priority: number;
}

interface ArchetypeForumRecommendationApiResponse {
  category: CategoryListApiResponse;
  archetype: string;
  reason: string | null;
  priority: number;
}

interface ForumSearchResultApiResponse {
  id: string;
  type: 'post' | 'comment';
  title: string | null;
  content_preview: string;
  post_id: string | null;
  post_title: string | null;
  author: PostAuthorApiResponse;
  vote_count: number;
  category_slug: string;
  sub_forum_slug: string;
  created_at: string;
}

interface ForumSearchApiResponse {
  results: ForumSearchResultApiResponse[];
  total_count: number;
  query: string;
  search_type: string;
  has_more: boolean;
}

// === USER PROFILE API RESPONSE TYPES ===

interface ForumUserProfileApiResponse {
  id: string;
  username: string;
  avatar_id?: number;
  forum_posts_count: number;
  forum_comments_count: number;
  forum_karma: number;
  member_since: string;
}

interface UserPostItemApiResponse {
  id: string;
  title: string;
  content_preview: string;
  sub_forum_slug: string;
  category_slug: string;
  is_pinned: boolean;
  is_guide: boolean;
  vote_count: number;
  comment_count: number;
  user_vote: VoteType | null;
  created_at: string;
}

interface UserPostListApiResponse {
  posts: UserPostItemApiResponse[];
  total_count: number;
  has_more: boolean;
}

interface UserCommentItemApiResponse {
  id: string;
  content: string;
  post_id: string;
  post_title: string;
  category_slug: string;
  vote_count: number;
  user_vote: VoteType | null;
  created_at: string;
}

interface UserCommentListApiResponse {
  comments: UserCommentItemApiResponse[];
  total_count: number;
  has_more: boolean;
}

// === USER SEARCH API RESPONSE TYPES ===

interface UserSearchResultApiResponse {
  id: string;
  username: string;
}

interface UserSearchApiResponse {
  users: UserSearchResultApiResponse[];
  total_count: number;
}

// === BOOKMARK API RESPONSE TYPES ===

interface BookmarkToggleApiResponse {
  is_bookmarked: boolean;
  message: string;
}

interface BookmarkStatusApiResponse {
  post_id: string;
  is_bookmarked: boolean;
  bookmarked_at: string | null;
}

interface BookmarkedPostsApiResponse {
  posts: PostListItemApiResponse[];
  total_count: number;
  has_more: boolean;
}

// === FORUM TRANSFORM FUNCTIONS ===

function transformSubForum(data: SubForumApiResponse): SubForum {
  return {
    id: data.id,
    name: data.name,
    slug: data.slug,
    description: data.description,
    icon: data.icon,
    displayOrder: data.display_order,
    postCount: data.post_count,
  };
}

function transformCategory(data: CategoryApiResponse): Category {
  return {
    id: data.id,
    name: data.name,
    slug: data.slug,
    description: data.description,
    icon: data.icon,
    displayOrder: data.display_order,
    postCount: data.post_count,
    subForums: data.sub_forums.map(transformSubForum),
  };
}

function transformCategoryListItem(data: CategoryListApiResponse): CategoryListItem {
  return {
    id: data.id,
    name: data.name,
    slug: data.slug,
    description: data.description,
    icon: data.icon,
    displayOrder: data.display_order,
    postCount: data.post_count,
  };
}

function transformPostAuthor(data: PostAuthorApiResponse): PostAuthor {
  return {
    id: data.id,
    username: data.username,
    karma: data.karma,
  };
}

function transformPost(data: PostApiResponse): Post {
  return {
    id: data.id,
    title: data.title,
    content: data.content,
    subForumId: data.sub_forum_id,
    subForumSlug: data.sub_forum_slug,
    categorySlug: data.category_slug,
    author: transformPostAuthor(data.author),
    isPinned: data.is_pinned,
    isGuide: data.is_guide,
    voteCount: data.vote_count,
    commentCount: data.comment_count,
    userVote: data.user_vote,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
  };
}

function transformPostListItem(data: PostListItemApiResponse): PostListItem {
  return {
    id: data.id,
    title: data.title,
    contentPreview: data.content_preview,
    subForumSlug: data.sub_forum_slug,
    categorySlug: data.category_slug,
    author: transformPostAuthor(data.author),
    isPinned: data.is_pinned,
    isGuide: data.is_guide,
    voteCount: data.vote_count,
    commentCount: data.comment_count,
    userVote: data.user_vote,
    createdAt: data.created_at,
  };
}

function transformPostListResponse(data: PostListApiResponse): PostListResponse {
  return {
    posts: data.posts.map(transformPostListItem),
    totalCount: data.total_count,
    hasMore: data.has_more,
  };
}

function transformCursorPaginatedPostListResponse(
  data: CursorPaginatedPostListApiResponse
): CursorPaginatedPostListResponse {
  return {
    posts: data.posts.map(transformPostListItem),
    nextCursor: data.next_cursor,
    hasMore: data.has_more,
    totalCount: data.total_count,
  };
}

function transformComment(data: CommentApiResponse): Comment {
  return {
    id: data.id,
    content: data.content,
    postId: data.post_id,
    author: transformPostAuthor(data.author),
    parentId: data.parent_id,
    voteCount: data.vote_count,
    userVote: data.user_vote,
    depth: data.depth,
    replies: data.replies.map(transformComment),
    createdAt: data.created_at,
    updatedAt: data.updated_at,
  };
}

function transformVoteResponse(data: VoteApiResponse): VoteResponse {
  return {
    success: data.success,
    newVoteCount: data.new_vote_count,
    userVote: data.user_vote,
  };
}

function transformReport(data: ReportApiResponse): Report {
  return {
    id: data.id,
    targetType: data.target_type,
    targetId: data.target_id,
    reason: data.reason as Report['reason'],
    status: data.status,
    createdAt: data.created_at,
  };
}

function transformGuideSection(data: GuideSectionApiResponse): GuideSection {
  return {
    category: transformCategoryListItem(data.category),
    guides: data.guides.map(transformPostListItem),
  };
}

function transformRecommendedForum(data: RecommendedForumApiResponse): RecommendedForum {
  return {
    category: transformCategoryListItem(data.category),
    matchedFlaws: data.matched_flaws,
    priority: data.priority,
  };
}

export interface ArchetypeForumRecommendation {
  category: CategoryListItem;
  archetype: string;
  reason: string | null;
  priority: number;
}

function transformArchetypeForumRecommendation(data: ArchetypeForumRecommendationApiResponse): ArchetypeForumRecommendation {
  return {
    category: transformCategoryListItem(data.category),
    archetype: data.archetype,
    reason: data.reason,
    priority: data.priority,
  };
}

function transformForumSearchResult(data: ForumSearchResultApiResponse): ForumSearchResult {
  return {
    id: data.id,
    type: data.type as SearchResultType,
    title: data.title,
    contentPreview: data.content_preview,
    postId: data.post_id,
    postTitle: data.post_title,
    author: transformPostAuthor(data.author),
    voteCount: data.vote_count,
    categorySlug: data.category_slug,
    subForumSlug: data.sub_forum_slug,
    createdAt: data.created_at,
  };
}

function transformForumSearchResponse(data: ForumSearchApiResponse): ForumSearchResponse {
  return {
    results: data.results.map(transformForumSearchResult),
    totalCount: data.total_count,
    query: data.query,
    searchType: data.search_type,
    hasMore: data.has_more,
  };
}

// === USER PROFILE TRANSFORM FUNCTIONS ===

function transformForumUserProfile(data: ForumUserProfileApiResponse): ForumUserProfile {
  return {
    id: data.id,
    username: data.username,
    forumPostsCount: data.forum_posts_count,
    forumCommentsCount: data.forum_comments_count,
    forumKarma: data.forum_karma,
    memberSince: data.member_since,
  };
}

function transformUserPostItem(data: UserPostItemApiResponse): UserPostItem {
  return {
    id: data.id,
    title: data.title,
    contentPreview: data.content_preview,
    subForumSlug: data.sub_forum_slug,
    categorySlug: data.category_slug,
    isPinned: data.is_pinned,
    isGuide: data.is_guide,
    voteCount: data.vote_count,
    commentCount: data.comment_count,
    userVote: data.user_vote,
    createdAt: data.created_at,
  };
}

function transformUserPostListResponse(data: UserPostListApiResponse): UserPostListResponse {
  return {
    posts: data.posts.map(transformUserPostItem),
    totalCount: data.total_count,
    hasMore: data.has_more,
  };
}

function transformUserCommentItem(data: UserCommentItemApiResponse): UserCommentItem {
  return {
    id: data.id,
    content: data.content,
    postId: data.post_id,
    postTitle: data.post_title,
    categorySlug: data.category_slug,
    voteCount: data.vote_count,
    userVote: data.user_vote,
    createdAt: data.created_at,
  };
}

function transformUserCommentListResponse(data: UserCommentListApiResponse): UserCommentListResponse {
  return {
    comments: data.comments.map(transformUserCommentItem),
    totalCount: data.total_count,
    hasMore: data.has_more,
  };
}

// === ADMIN/MODERATION API RESPONSE TYPES ===

interface ReportDetailApiResponse {
  id: string;
  target_type: 'post' | 'comment';
  target_id: string;
  reason: string;
  details: string | null;
  status: string;
  reporter_id: string;
  reporter_username: string;
  reviewed_by: string | null;
  reviewed_at: string | null;
  resolution_notes: string | null;
  action_taken: string | null;
  created_at: string;
  content_preview: string | null;
  content_author_id: string | null;
  content_author_username: string | null;
}

interface AdminReportListApiResponse {
  reports: ReportDetailApiResponse[];
  total_count: number;
  has_more: boolean;
}

interface ModerationStatsApiResponse {
  pending_reports: number;
  resolved_today: number;
  resolved_this_week: number;
  total_reports: number;
  reports_by_reason: Record<string, number>;
  reports_by_status: Record<string, number>;
}

interface BanUserApiResponse {
  user_id: string;
  username: string;
  is_banned: boolean;
  message: string;
}

interface BannedUserApiResponse {
  id: string;
  username: string;
  email: string;
  is_banned: boolean;
  created_at: string | null;
  updated_at: string | null;
}

interface BannedUsersApiResponse {
  users: BannedUserApiResponse[];
  total_count: number;
  has_more: boolean;
}

// Karma Leaderboard API Response types
interface KarmaLeaderboardEntryApiResponse {
  rank: number;
  user_id: string;
  username: string;
  forum_karma: number;
  forum_posts_count: number;
  forum_comments_count: number;
}

interface KarmaLeaderboardApiResponse {
  entries: KarmaLeaderboardEntryApiResponse[];
  total_count: number;
  has_more: boolean;
}

// Forum Analytics API Response types
interface DailyMetricApiResponse {
  date: string;
  count: number;
}

interface TopContributorApiResponse {
  user_id: string;
  username: string;
  forum_karma: number;
  posts_count: number;
  comments_count: number;
}

interface CategoryEngagementApiResponse {
  category_id: string;
  category_name: string;
  category_slug: string;
  posts_count: number;
  comments_count: number;
  total_votes: number;
}

interface ForumAnalyticsApiResponse {
  posts_per_day: DailyMetricApiResponse[];
  comments_per_day: DailyMetricApiResponse[];
  total_posts: number;
  total_comments: number;
  total_votes: number;
  avg_votes_per_post: number;
  avg_comments_per_post: number;
  active_users_today: number;
  active_users_week: number;
  active_users_month: number;
  total_users: number;
  top_contributors: TopContributorApiResponse[];
  category_engagement: CategoryEngagementApiResponse[];
  generated_at: string;
}

// === ADMIN/MODERATION TRANSFORM FUNCTIONS ===

function transformReportDetail(data: ReportDetailApiResponse): ReportDetail {
  return {
    id: data.id,
    targetType: data.target_type as TargetType,
    targetId: data.target_id,
    reason: data.reason as ReportReason,
    details: data.details,
    status: data.status as ReportStatusEnum,
    reporterId: data.reporter_id,
    reporterUsername: data.reporter_username,
    reviewedBy: data.reviewed_by,
    reviewedAt: data.reviewed_at,
    resolutionNotes: data.resolution_notes,
    actionTaken: data.action_taken as ActionTaken | null,
    createdAt: data.created_at,
    contentPreview: data.content_preview,
    contentAuthorId: data.content_author_id,
    contentAuthorUsername: data.content_author_username,
  };
}

function transformAdminReportListResponse(data: AdminReportListApiResponse): AdminReportListResponse {
  return {
    reports: data.reports.map(transformReportDetail),
    totalCount: data.total_count,
    hasMore: data.has_more,
  };
}

function transformModerationStats(data: ModerationStatsApiResponse): ModerationStats {
  return {
    pendingReports: data.pending_reports,
    resolvedToday: data.resolved_today,
    resolvedThisWeek: data.resolved_this_week,
    totalReports: data.total_reports,
    reportsByReason: data.reports_by_reason,
    reportsByStatus: data.reports_by_status,
  };
}

function transformBanUserResponse(data: BanUserApiResponse): BanUserResponse {
  return {
    userId: data.user_id,
    username: data.username,
    isBanned: data.is_banned,
    message: data.message,
  };
}

function transformBannedUser(data: BannedUserApiResponse): BannedUser {
  return {
    id: data.id,
    username: data.username,
    email: data.email,
    isBanned: data.is_banned,
    createdAt: data.created_at,
    updatedAt: data.updated_at,
  };
}

function transformBannedUsersResponse(data: BannedUsersApiResponse): BannedUsersResponse {
  return {
    users: data.users.map(transformBannedUser),
    totalCount: data.total_count,
    hasMore: data.has_more,
  };
}

function transformKarmaLeaderboardEntry(data: KarmaLeaderboardEntryApiResponse): KarmaLeaderboardEntry {
  return {
    rank: data.rank,
    userId: data.user_id,
    username: data.username,
    forumKarma: data.forum_karma,
    forumPostsCount: data.forum_posts_count,
    forumCommentsCount: data.forum_comments_count,
  };
}

function transformKarmaLeaderboardResponse(data: KarmaLeaderboardApiResponse): KarmaLeaderboardResponse {
  return {
    entries: data.entries.map(transformKarmaLeaderboardEntry),
    totalCount: data.total_count,
    hasMore: data.has_more,
  };
}

// === FORUM ANALYTICS TRANSFORM FUNCTIONS ===

function transformDailyMetric(data: DailyMetricApiResponse): DailyMetric {
  return {
    date: data.date,
    count: data.count,
  };
}

function transformTopContributor(data: TopContributorApiResponse): TopContributor {
  return {
    userId: data.user_id,
    username: data.username,
    forumKarma: data.forum_karma,
    postsCount: data.posts_count,
    commentsCount: data.comments_count,
  };
}

function transformCategoryEngagement(data: CategoryEngagementApiResponse): CategoryEngagement {
  return {
    categoryId: data.category_id,
    categoryName: data.category_name,
    categorySlug: data.category_slug,
    postsCount: data.posts_count,
    commentsCount: data.comments_count,
    totalVotes: data.total_votes,
  };
}

function transformForumAnalytics(data: ForumAnalyticsApiResponse): ForumAnalytics {
  return {
    postsPerDay: data.posts_per_day.map(transformDailyMetric),
    commentsPerDay: data.comments_per_day.map(transformDailyMetric),
    totalPosts: data.total_posts,
    totalComments: data.total_comments,
    totalVotes: data.total_votes,
    avgVotesPerPost: data.avg_votes_per_post,
    avgCommentsPerPost: data.avg_comments_per_post,
    activeUsersToday: data.active_users_today,
    activeUsersWeek: data.active_users_week,
    activeUsersMonth: data.active_users_month,
    totalUsers: data.total_users,
    topContributors: data.top_contributors.map(transformTopContributor),
    categoryEngagement: data.category_engagement.map(transformCategoryEngagement),
    generatedAt: data.generated_at,
  };
}

// === NOTIFICATION API RESPONSE TYPES ===

interface NotificationActorApiResponse {
  id: string;
  username: string;
}

interface NotificationApiResponse {
  id: string;
  type: 'reply' | 'mention' | 'vote' | 'system' | 'milestone';
  title: string;
  content: string | null;
  source_type: 'post' | 'comment' | 'system' | null;
  source_id: string | null;
  post_id: string | null;
  actor: NotificationActorApiResponse | null;
  link: string | null;
  read: boolean;
  created_at: string;
  read_at: string | null;
}

interface NotificationListApiResponse {
  notifications: NotificationApiResponse[];
  total_count: number;
  unread_count: number;
  has_more: boolean;
}

// Note: These types duplicate the ones in @/types/notification but are used
// internally for API transformation. The imported types are used in the API
// return signatures.

// === NOTIFICATION TRANSFORM FUNCTIONS ===

function transformNotification(data: NotificationApiResponse): AppNotification {
  return {
    id: data.id,
    type: data.type,
    title: data.title,
    content: data.content,
    sourceType: data.source_type,
    sourceId: data.source_id,
    postId: data.post_id,
    actor: data.actor ? { id: data.actor.id, username: data.actor.username } : null,
    link: data.link,
    read: data.read,
    createdAt: data.created_at,
    readAt: data.read_at,
  };
}

function transformNotificationListResponse(data: NotificationListApiResponse): NotificationListResponse {
  return {
    notifications: data.notifications.map(transformNotification),
    totalCount: data.total_count,
    unreadCount: data.unread_count,
    hasMore: data.has_more,
  };
}

interface ApiOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: unknown;
  token?: string;
}

interface Analysis {
  id: string;
  front_image_url: string | null;
  side_image_url: string | null;
  front_landmarks: Record<string, unknown> | null;
  side_landmarks: Record<string, unknown> | null;
  scores: Record<string, unknown> | null;
  gender: string | null;
  ethnicity: string | null;
  created_at: string;
}

class ApiClient {
  private token: string | null = null;

  setToken(token: string | null) {
    this.token = token;
  }

  getToken(): string | null {
    if (typeof window !== 'undefined') {
      return this.token || localStorage.getItem('auth_token');
    }
    return this.token;
  }

  private async request<T>(endpoint: string, options: ApiOptions = {}): Promise<T> {
    const { method = 'GET', body, token } = options;
    const authToken = token || this.getToken();

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }

    try {
      const response = await fetch(`${API_URL}${endpoint}`, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined,
        credentials: 'include',
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ detail: 'Request failed' }));
        throw new Error(error.detail || `HTTP ${response.status}`);
      }

      // Handle empty responses (204 No Content)
      if (response.status === 204) {
        return undefined as T;
      }

      return response.json();
    } catch (err) {
      // Network errors, CORS issues, etc.
      if (err instanceof TypeError && err.message.includes('fetch')) {
        throw new Error('Network error - please check your internet connection');
      }
      throw err;
    }
  }

  // Health check
  async health(): Promise<{ status: string; detection_ready: boolean }> {
    return this.request('/health');
  }

  // Analyses CRUD
  async listAnalyses(limit = 50, offset = 0): Promise<Analysis[]> {
    return this.request(`/analyses?limit=${limit}&offset=${offset}`);
  }

  async createAnalysis(data: {
    front_image_url?: string;
    side_image_url?: string;
    front_landmarks?: Record<string, unknown>;
    side_landmarks?: Record<string, unknown>;
    scores?: Record<string, unknown>;
    gender?: string;
    ethnicity?: string;
  }): Promise<Analysis> {
    return this.request('/analyses', { method: 'POST', body: data });
  }

  async getAnalysis(id: string): Promise<Analysis> {
    return this.request(`/analyses/${id}`);
  }

  async deleteAnalysis(id: string): Promise<void> {
    return this.request(`/analyses/${id}`, { method: 'DELETE' });
  }

  // Payments
  async createCheckout(plan: 'basic' | 'pro' | 'consultation'): Promise<{ checkout_url: string; session_id: string }> {
    // MOCK CHECKOUT: Bypassing backend relative URL issue since Railway is down
    console.log(`[MOCK] Creating checkout for plan: ${plan}`);

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Redirect to local success page with plan param
    // We use window.location.origin to point to the current frontend host
    const origin = typeof window !== 'undefined' ? window.location.origin : 'http://localhost:3000';
    return {
      checkout_url: `${origin}/checkout/success?plan=${plan}&session_id=mock_session_${Date.now()}`,
      session_id: `mock_session_${Date.now()}`
    };
  }

  async getPaymentHistory(): Promise<Array<{
    id: string;
    amount: number;
    currency: string;
    status: string;
    created_at: string;
  }>> {
    return this.request('/payments/history');
  }

  // Leaderboard
  async submitScore(data: {
    score: number;
    gender: 'male' | 'female';
    analysis_id?: string;
    ethnicity?: string;
    face_photo_url?: string;
    top_strengths?: string[];
    top_improvements?: string[];
  }): Promise<UserRank> {
    try {
      const response = await this.request<LeaderboardApiResponse>('/leaderboard/submit', {
        method: 'POST',
        body: {
          score: data.score,
          gender: data.gender,
          analysis_id: data.analysis_id,
          ethnicity: data.ethnicity,
          face_photo_url: data.face_photo_url,
          top_strengths: data.top_strengths,
          top_improvements: data.top_improvements,
        },
      });
      return transformUserRank(response);
    } catch (err) {
      console.warn('API Error (submitScore) - Using MOCK PERSISTENCE', err);
      // Save to localStorage
      const mockUser = {
        id: 'current_user',
        score: data.score,
        gender: data.gender,
        anonymous_name: 'You (Mock)',
        face_photo_url: data.face_photo_url,
        top_strengths: data.top_strengths || [],
        top_improvements: data.top_improvements || []
      };
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem('mock_leaderboard_user', JSON.stringify(mockUser));
      }

      return {
        userId: 'current_user',
        score: data.score,
        globalRank: 42,
        genderRank: 15,
        percentile: 95,
        totalUsers: 1500,
        genderTotal: 800,
        anonymousName: 'You (Mock)',
        updatedAt: new Date().toISOString()
      };
    }
  }

  async getMyRank(): Promise<UserRank> {
    const response = await this.request<LeaderboardApiResponse>('/leaderboard/rank');
    return transformUserRank(response);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async getLeaderboard(options?: {
    gender?: 'male' | 'female';
    limit?: number;
    offset?: number;
  }): Promise<LeaderboardData> {

    try {
      const params = new URLSearchParams();
      if (options?.gender) params.set('gender', options.gender);
      if (options?.limit) params.set('limit', String(options.limit));
      if (options?.offset) params.set('offset', String(options.offset));
      const query = params.toString() ? `?${params}` : '';

      const response = await this.request<LeaderboardListResponse>(`/leaderboard${query}`);
      return transformLeaderboardData(response);
    } catch (err) {
      console.warn('API Error (getLeaderboard) - Falling back to MOCK DATA', err);

      // Mock entries
      const mockEntries: LeaderboardEntryResponse[] = [
        { user_id: 'u1', rank: 1, score: 9.8, anonymous_name: 'ChadThundercock', gender: 'male', face_photo_url: null, is_current_user: false, top_strengths: ['Jawline'], top_improvements: [] },
        { user_id: 'u2', rank: 2, score: 9.5, anonymous_name: 'Cassanova99', gender: 'male', face_photo_url: null, is_current_user: false, top_strengths: ['Eyes'], top_improvements: [] },
        { user_id: 'u3', rank: 3, score: 9.2, anonymous_name: 'Stacy', gender: 'female', face_photo_url: null, is_current_user: false, top_strengths: ['Lips'], top_improvements: [] },
      ];

      // ADD CURRENT USER FROM LOCALSTORAGE
      if (typeof localStorage !== 'undefined') {
        const savedUser = localStorage.getItem('mock_leaderboard_user');
        if (savedUser) {
          const parsed = JSON.parse(savedUser);
          mockEntries.push({
            user_id: parsed.id,
            rank: 42,
            score: parsed.score,
            anonymous_name: parsed.anonymous_name,
            gender: parsed.gender,
            face_photo_url: parsed.face_photo_url,
            is_current_user: true,
            top_strengths: parsed.top_strengths,
            top_improvements: parsed.top_improvements
          });
        }
      }

      // Sort by score and update ranks
      mockEntries.sort((a, b) => b.score - a.score).forEach((entry, index) => {
        entry.rank = index + 1;
      });

      return {
        entries: mockEntries.map(transformLeaderboardEntry),
        totalCount: mockEntries.length,
        userRank: null
      }
    }
  }

  async getLeaderboardAroundMe(rangeSize?: number): Promise<LeaderboardData> {
    const query = rangeSize ? `?range_size=${rangeSize}` : '';
    const response = await this.request<LeaderboardListResponse>(`/leaderboard/around-me${query}`);
    return transformLeaderboardData(response);
  }

  async getUserProfile(userId: string): Promise<UserProfile> {
    const response = await this.request<UserProfileResponse>(`/leaderboard/user/${userId}`);
    return transformUserProfile(response);
  }

  // Auth
  async checkUsername(username: string): Promise<{ available: boolean; reason: string | null }> {
    return this.request(`/auth/check-username/${encodeURIComponent(username)}`);
  }

  async register(data: {
    email: string;
    password: string;
    username: string;
    termsAccepted: boolean;
    referralCode?: string;
  }): Promise<{ access_token: string; token_type: string; user: { id: string; email: string; username: string; plan: string } }> {
    return this.request('/auth/register', {
      method: 'POST',
      body: {
        email: data.email,
        password: data.password,
        username: data.username,
        terms_accepted: data.termsAccepted,
        referral_code: data.referralCode,
      },
    });
  }

  async login(data: { email: string; password: string }): Promise<{ access_token: string; token_type: string; user: { id: string; email: string; username: string; plan: string } }> {
    return this.request('/auth/login', {
      method: 'POST',
      body: data,
    });
  }

  async validateReferralCode(code: string): Promise<{ valid: boolean; message: string | null }> {
    return this.request(`/auth/validate-referral/${encodeURIComponent(code)}`);
  }

  async requestPasswordReset(email: string): Promise<{ message: string }> {
    return this.request('/auth/forgot-password', {
      method: 'POST',
      body: { email },
    });
  }

  async resetPassword(token: string, newPassword: string): Promise<{ message: string }> {
    return this.request('/auth/reset-password', {
      method: 'POST',
      body: { token, new_password: newPassword },
    });
  }

  async verifyEmail(token: string): Promise<{ message: string; email: string }> {
    return this.request(`/auth/verify-email?token=${encodeURIComponent(token)}`);
  }

  async resendVerification(): Promise<{ message: string }> {
    return this.request('/auth/resend-verification', {
      method: 'POST',
    });
  }

  // === FORUM ===

  // Categories
  async getForumCategories(): Promise<Category[]> {
    try {
      const response = await this.request<CategoryApiResponse[]>('/forum/categories');
      return response.map(transformCategory);
    } catch (error) {
      console.warn('API Error (getForumCategories) - Falling back to MOCK DATA', error);
      return MOCK_CATEGORIES.map(transformCategory);
    }
  }

  async getForumCategory(slug: string): Promise<Category> {
    const response = await this.request<CategoryApiResponse>(`/forum/categories/${slug}`);
    return transformCategory(response);
  }

  // Guides
  async getForumGuides(): Promise<GuideSection[]> {
    const response = await this.request<GuideSectionApiResponse[]>('/forum/guides');
    return response.map(transformGuideSection);
  }

  // Recommended forums based on flaws
  async getRecommendedForums(flaws: string[]): Promise<RecommendedForum[]> {
    const params = new URLSearchParams();
    params.set('flaws', flaws.join(','));
    const response = await this.request<RecommendedForumApiResponse[]>(`/forum/recommended?${params}`);
    return response.map(transformRecommendedForum);
  }

  // Recommended forums based on archetype
  async getArchetypeForumRecommendations(archetype: string): Promise<ArchetypeForumRecommendation[]> {
    const params = new URLSearchParams();
    params.set('archetype', archetype);
    const response = await this.request<ArchetypeForumRecommendationApiResponse[]>(`/forum/archetype-recommendations?${params}`);
    return response.map(transformArchetypeForumRecommendation);
  }

  // Posts
  async getForumPosts(
    categorySlug: string,
    options?: {
      subForumSlug?: string;
      sort?: SortOrder;
      limit?: number;
      offset?: number;
    }
  ): Promise<PostListResponse> {
    const params = new URLSearchParams();
    if (options?.sort) params.set('sort', options.sort);
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const endpoint = options?.subForumSlug
      ? `/forum/categories/${categorySlug}/${options.subForumSlug}/posts${query}`
      : `/forum/categories/${categorySlug}/posts${query}`;

    try {
      const response = await this.request<PostListApiResponse>(endpoint);
      return transformPostListResponse(response);
    } catch (error) {
      console.warn('API Error (getForumPosts) - Falling back to MOCK DATA', error);
      // Helper to filter mocks by category if possible
      const filteredPosts = MOCK_POSTS.posts.filter(p => !categorySlug || p.category_slug === categorySlug);
      return transformPostListResponse({ ...MOCK_POSTS, posts: filteredPosts, total_count: filteredPosts.length });
    }
  }

  /**
   * Get forum posts with cursor-based pagination (more efficient than offset).
   * Uses keyset pagination with (created_at, id) for stable ordering.
   */
  async getForumPostsCursor(
    categorySlug: string,
    options?: {
      subForumSlug?: string;
      limit?: number;
      cursor?: string;  // Base64 encoded cursor from previous response
    }
  ): Promise<CursorPaginatedPostListResponse> {
    const params = new URLSearchParams();
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.cursor) params.set('cursor', options.cursor);
    const query = params.toString() ? `?${params}` : '';

    const endpoint = options?.subForumSlug
      ? `/forum/categories/${categorySlug}/${options.subForumSlug}/posts/cursor${query}`
      : `/forum/categories/${categorySlug}/posts/cursor${query}`;

    const response = await this.request<CursorPaginatedPostListApiResponse>(endpoint);
    return transformCursorPaginatedPostListResponse(response);
  }

  async getForumPost(postId: string): Promise<Post> {
    const response = await this.request<PostApiResponse>(`/forum/posts/${postId}`);
    return transformPost(response);
  }

  async createForumPost(data: PostCreate): Promise<Post> {
    const response = await this.request<PostApiResponse>('/forum/posts', {
      method: 'POST',
      body: {
        title: data.title,
        content: data.content,
        sub_forum_id: data.subForumId,
      },
    });
    return transformPost(response);
  }

  async updateForumPost(postId: string, data: PostUpdate): Promise<Post> {
    const response = await this.request<PostApiResponse>(`/forum/posts/${postId}`, {
      method: 'PUT',
      body: data,
    });
    return transformPost(response);
  }

  async deleteForumPost(postId: string): Promise<void> {
    await this.request(`/forum/posts/${postId}`, { method: 'DELETE' });
  }

  // Comments
  async getForumComments(postId: string): Promise<Comment[]> {
    const response = await this.request<CommentApiResponse[]>(`/forum/posts/${postId}/comments`);
    return response.map(transformComment);
  }

  async getForumCommentsPaginated(
    postId: string,
    params?: { limit?: number; offset?: number }
  ): Promise<PaginatedCommentsResponse> {
    const queryParams = new URLSearchParams();
    if (params?.limit) queryParams.append('limit', params.limit.toString());
    if (params?.offset) queryParams.append('offset', params.offset.toString());
    const query = queryParams.toString();
    const url = `/forum/posts/${postId}/comments/paginated${query ? `?${query}` : ''}`;

    const response = await this.request<{
      comments: CommentApiResponse[];
      total_root_comments: number;
      has_more: boolean;
      next_offset: number | null;
    }>(url);

    return {
      comments: response.comments.map(transformComment),
      totalRootComments: response.total_root_comments,
      hasMore: response.has_more,
      nextOffset: response.next_offset,
    };
  }

  async getCommentReplies(
    commentId: string,
    params?: { limit?: number; offset?: number }
  ): Promise<CommentRepliesResponse> {
    const queryParams = new URLSearchParams();
    if (params?.limit) queryParams.append('limit', params.limit.toString());
    if (params?.offset) queryParams.append('offset', params.offset.toString());
    const query = queryParams.toString();
    const url = `/forum/comments/${commentId}/replies${query ? `?${query}` : ''}`;

    const response = await this.request<{
      replies: CommentApiResponse[];
      has_more: boolean;
      total_replies: number;
    }>(url);

    return {
      replies: response.replies.map(transformComment),
      hasMore: response.has_more,
      totalReplies: response.total_replies,
    };
  }

  async createForumComment(postId: string, data: CommentCreate): Promise<Comment> {
    const response = await this.request<CommentApiResponse>(`/forum/posts/${postId}/comments`, {
      method: 'POST',
      body: {
        content: data.content,
        parent_id: data.parentId,
      },
    });
    return transformComment(response);
  }

  async updateForumComment(commentId: string, content: string): Promise<Comment> {
    const response = await this.request<CommentApiResponse>(`/forum/comments/${commentId}`, {
      method: 'PUT',
      body: { content },
    });
    return transformComment(response);
  }

  async deleteForumComment(commentId: string): Promise<void> {
    await this.request(`/forum/comments/${commentId}`, { method: 'DELETE' });
  }

  // Voting
  async voteForumPost(postId: string, voteType: VoteType): Promise<VoteResponse> {
    const response = await this.request<VoteApiResponse>(`/forum/posts/${postId}/vote`, {
      method: 'POST',
      body: { vote_type: voteType },
    });
    return transformVoteResponse(response);
  }

  async voteForumComment(commentId: string, voteType: VoteType): Promise<VoteResponse> {
    const response = await this.request<VoteApiResponse>(`/forum/comments/${commentId}/vote`, {
      method: 'POST',
      body: { vote_type: voteType },
    });
    return transformVoteResponse(response);
  }

  // Reports
  async createForumReport(data: ReportCreate): Promise<Report> {
    const response = await this.request<ReportApiResponse>('/forum/reports', {
      method: 'POST',
      body: {
        target_type: data.targetType,
        target_id: data.targetId,
        reason: data.reason,
        details: data.details,
      },
    }).catch(err => {
      console.warn('API Error (createForumReport) - Using MOCK RESPONSE', err);
      // Return mock report response on failure (for demo/development)
      return {
        id: `mock_report_${Date.now()}`,
        target_type: data.targetType,
        target_id: data.targetId,
        reason: data.reason,
        status: 'pending',
        created_at: new Date().toISOString()
      } as ReportApiResponse;
    });
    return transformReport(response);
  }

  // Search
  async searchForum(options: {
    query: string;
    type?: 'posts' | 'comments' | 'all';
    limit?: number;
    offset?: number;
  }): Promise<ForumSearchResponse> {
    const params = new URLSearchParams();
    params.set('q', options.query);
    if (options.type) params.set('type', options.type);
    if (options.limit) params.set('limit', String(options.limit));
    if (options.offset) params.set('offset', String(options.offset));
    const response = await this.request<ForumSearchApiResponse>(`/forum/search?${params}`);
    return transformForumSearchResponse(response);
  }

  // Bookmarks
  async toggleBookmark(postId: string): Promise<BookmarkToggleResponse> {
    const response = await this.request<BookmarkToggleApiResponse>(`/forum/posts/${postId}/bookmark`, {
      method: 'POST',
    });
    return {
      isBookmarked: response.is_bookmarked,
      message: response.message,
    };
  }

  async removeBookmark(postId: string): Promise<BookmarkToggleResponse> {
    const response = await this.request<BookmarkToggleApiResponse>(`/forum/posts/${postId}/bookmark`, {
      method: 'DELETE',
    });
    return {
      isBookmarked: response.is_bookmarked,
      message: response.message,
    };
  }

  async getBookmarkedPosts(options?: {
    limit?: number;
    offset?: number;
  }): Promise<BookmarkedPostsResponse> {
    const params = new URLSearchParams();
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';
    const response = await this.request<BookmarkedPostsApiResponse>(`/forum/bookmarks${query}`);
    return {
      posts: response.posts.map(transformPostListItem),
      totalCount: response.total_count,
      hasMore: response.has_more,
    };
  }

  async getBookmarkStatus(postId: string): Promise<BookmarkStatus> {
    const response = await this.request<BookmarkStatusApiResponse>(`/forum/posts/${postId}/bookmark-status`);
    return {
      postId: response.post_id,
      isBookmarked: response.is_bookmarked,
      bookmarkedAt: response.bookmarked_at,
    };
  }

  async getBookmarkedPostIds(): Promise<string[]> {
    const response = await this.request<{ bookmarked_post_ids: string[] }>('/forum/bookmarks/ids');
    return response.bookmarked_post_ids;
  }

  // Quota
  async getForumQuota(): Promise<ForumQuota> {
    const response = await this.request<{
      posts_used: number;
      posts_max: number | null;
      comments_used: number;
      comments_max: number | null;
      resets_at: string;
    }>('/forum/my-quota');
    return {
      postsUsed: response.posts_used,
      postsMax: response.posts_max,
      commentsUsed: response.comments_used,
      commentsMax: response.comments_max,
      resetsAt: response.resets_at,
    };
  }

  // === PSL ===

  async calculatePSL(data: {
    face_score: number;
    height_cm: number;
    gender: 'male' | 'female';
    body_fat_percent?: number;
    muscle_level?: string;
    failos?: string[];
  }): Promise<{
    score: number;
    tier: string;
    percentile: number;
    breakdown: {
      face: { raw: number; weighted: number };
      height: { raw: number; weighted: number };
      body: { raw: number; weighted: number };
      bonuses: { threshold: number; synergy: number; total: number };
      penalties: number;
    };
    potential: number;
  }> {
    return this.request('/psl/calculate', { method: 'POST', body: data });
  }

  async getHeightRating(height_cm: number, gender: 'male' | 'female'): Promise<{
    height_cm: number;
    height_rating: number;
    height_display: string;
  }> {
    return this.request(`/psl/height-rating?height_cm=${height_cm}&gender=${gender}`);
  }

  async updateUserHeight(height_cm: number): Promise<{
    height_cm: number;
    height_rating: number;
    height_display: string;
  }> {
    return this.request('/psl/height', { method: 'PUT', body: { height_cm } });
  }

  async getMyHeight(): Promise<{
    height_cm: number;
    height_rating: number;
    height_display: string;
  } | null> {
    return this.request('/psl/my-height');
  }

  async updateUserWeight(weight_kg: number): Promise<{
    weight_kg: number;
    weight_display: string;
    bmi: number | null;
  }> {
    return this.request('/psl/weight', { method: 'PUT', body: { weight_kg } });
  }

  async getMyWeight(): Promise<{
    weight_kg: number;
    weight_display: string;
    bmi: number | null;
  } | null> {
    return this.request('/psl/my-weight');
  }

  async getPSLTiers(): Promise<{
    tiers: Array<{ name: string; min: number; max: number; percentile: number }>;
    weights: { face: number; height: number; body: number };
  }> {
    return this.request('/psl/tiers');
  }

  // === ARCHETYPE ===

  async classifyArchetype(data: {
    gonial_angle?: number;
    fwhr?: number;
    canthal_tilt?: number;
    cheekbone_height?: number;
    brow_ridge?: number;
    jaw_width_ratio?: number;
    gender: 'male' | 'female';
    ethnicity: string;
  }): Promise<{
    primary: {
      category: string;
      sub_archetype: string;
      confidence: number;
      traits: string[];
    };
    secondary: {
      category: string;
      sub_archetype: string;
      confidence: number;
      traits: string[];
    } | null;
    all_scores: Array<{ category: string; score: number; confidence: number }>;
    dimorphism_level: string;
    style_guide: {
      clothing: string[];
      hair: string[];
      colors: string[];
    };
    transition_path: {
      target: string;
      requirements: string[];
    } | null;
  }> {
    return this.request('/archetype/classify', { method: 'POST', body: data });
  }

  async getArchetypeDefinitions(): Promise<{
    archetypes: Array<{
      id: string;
      name: string;
      description: string;
      traits: string[];
      ideal_metrics: {
        gonial_angle: { min: number; max: number };
        fwhr: { min: number; max: number };
        canthal_tilt: { min: number; max: number };
      };
    }>;
  }> {
    return this.request('/archetype/definitions');
  }

  async getArchetypeDefinition(archetypeId: string): Promise<{
    id: string;
    name: string;
    description: string;
    traits: string[];
    ideal_metrics: {
      gonial_angle: { min: number; max: number };
      fwhr: { min: number; max: number };
      canthal_tilt: { min: number; max: number };
    };
  }> {
    return this.request(`/archetype/definitions/${archetypeId}`);
  }

  async getDimorphismInfo(): Promise<{
    levels: Record<string, {
      gonial_angle_min?: number;
      gonial_angle_max?: number;
      description: string;
    }>;
  }> {
    return this.request('/archetype/dimorphism');
  }

  // === PHYSIQUE ===

  async uploadPhysiquePhotos(
    front?: File,
    side?: File,
    back?: File
  ): Promise<{
    front_photo_url: string | null;
    side_photo_url: string | null;
    back_photo_url: string | null;
    created_at: string;
    updated_at: string;
  }> {
    const formData = new FormData();
    if (front) formData.append('front', front);
    if (side) formData.append('side', side);
    if (back) formData.append('back', back);

    const authToken = this.getToken();
    const headers: Record<string, string> = {};
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`;
    }

    const response = await fetch(`${API_URL}/physique/upload`, {
      method: 'POST',
      headers,
      body: formData,
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ detail: 'Upload failed' }));
      throw new Error(error.detail || `HTTP ${response.status}`);
    }

    return response.json();
  }

  async getMyPhysiquePhotos(): Promise<{
    front_photo_url: string | null;
    side_photo_url: string | null;
    back_photo_url: string | null;
    created_at: string;
    updated_at: string;
  } | null> {
    return this.request('/physique/my-photos');
  }

  async analyzePhysique(gender: 'male' | 'female'): Promise<BodyAnalysisResult> {
    return this.request('/physique/analyze', {
      method: 'POST',
      body: { gender },
    });
  }

  async getMyPhysiqueAnalysis(): Promise<{
    front_photo_url: string | null;
    side_photo_url: string | null;
    back_photo_url: string | null;
    estimated_body_fat: number | null;
    muscle_mass: string | null;
    frame_size: string | null;
    shoulder_width: string | null;
    waist_definition: string | null;
    posture: string | null;
    analysis_confidence: number | null;
    analysis_notes: string | null;
    analyzed_at: string | null;
  } | null> {
    return this.request('/physique/my-analysis');
  }

  async extractFaceFeatures(frontFaceUrl: string, sideFaceUrl?: string): Promise<FaceExtractionResult> {
    return this.request('/physique/extract-face', {
      method: 'POST',
      body: {
        front_face_url: frontFaceUrl,
        side_face_url: sideFaceUrl,
      },
    });
  }

  async getMyFaceFeatures(): Promise<FaceExtractionResult | null> {
    return this.request('/physique/my-face-features');
  }

  // === REFERRALS ===
  async getReferralStats(): Promise<{
    code: string;
    referral_link: string;
    total_invites: number;
    earnings: number;
    discount_percent: number;
  }> {
    return this.request('/referrals/my-stats');
  }

  // === USER SEARCH (for @mention autocomplete) ===

  async searchUsers(
    query: string,
    options?: { limit?: number }
  ): Promise<UserSearchResponse> {
    const params = new URLSearchParams();
    params.set('q', query);
    if (options?.limit) params.set('limit', String(options.limit));

    const response = await this.request<UserSearchApiResponse>(`/users/search?${params}`);
    return {
      users: response.users.map((u) => ({ id: u.id, username: u.username })),
      totalCount: response.total_count,
    };
  }

  // === USER PROFILES ===

  async getForumUserProfile(userId: string): Promise<ForumUserProfile> {
    const response = await this.request<ForumUserProfileApiResponse>(`/users/${userId}/profile`);
    return transformForumUserProfile(response);
  }

  async getForumUserProfileByUsername(username: string): Promise<ForumUserProfile> {
    const response = await this.request<ForumUserProfileApiResponse>(`/users/by-username/${encodeURIComponent(username)}`);
    return transformForumUserProfile(response);
  }

  async getUserForumPosts(
    userId: string,
    options?: { limit?: number; offset?: number }
  ): Promise<UserPostListResponse> {
    const params = new URLSearchParams();
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const response = await this.request<UserPostListApiResponse>(`/users/${userId}/posts${query}`);
    return transformUserPostListResponse(response);
  }

  async getUserForumComments(
    userId: string,
    options?: { limit?: number; offset?: number }
  ): Promise<UserCommentListResponse> {
    const params = new URLSearchParams();
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const response = await this.request<UserCommentListApiResponse>(`/users/${userId}/comments${query}`);
    return transformUserCommentListResponse(response);
  }

  // === ADMIN/MODERATION ===

  async getModerationStats(): Promise<ModerationStats> {
    const response = await this.request<ModerationStatsApiResponse>('/admin/moderation/stats');
    return transformModerationStats(response);
  }

  async getAdminReports(options?: {
    status?: ReportStatusEnum;
    reason?: ReportReason;
    targetType?: TargetType;
    limit?: number;
    offset?: number;
  }): Promise<AdminReportListResponse> {
    const params = new URLSearchParams();
    if (options?.status) params.set('status', options.status);
    if (options?.reason) params.set('reason', options.reason);
    if (options?.targetType) params.set('target_type', options.targetType);
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const response = await this.request<AdminReportListApiResponse>(`/admin/reports${query}`);
    return transformAdminReportListResponse(response);
  }

  async getAdminReport(reportId: string): Promise<ReportDetail> {
    const response = await this.request<ReportDetailApiResponse>(`/admin/reports/${reportId}`);
    return transformReportDetail(response);
  }

  async resolveReport(
    reportId: string,
    data: ResolveReportRequest
  ): Promise<{ success: boolean; report_id: string; status: string; action_taken: string | null }> {
    return this.request(`/admin/reports/${reportId}/resolve`, {
      method: 'PUT',
      body: {
        status: data.status,
        resolution_notes: data.resolutionNotes,
        action_taken: data.actionTaken,
      },
    });
  }

  async removePost(postId: string): Promise<{ success: boolean; post_id: string; message: string }> {
    return this.request(`/admin/posts/${postId}/remove`, { method: 'PUT' });
  }

  async restorePost(postId: string): Promise<{ success: boolean; post_id: string; message: string }> {
    return this.request(`/admin/posts/${postId}/restore`, { method: 'PUT' });
  }

  async removeComment(commentId: string): Promise<{ success: boolean; comment_id: string; message: string }> {
    return this.request(`/admin/comments/${commentId}/remove`, { method: 'PUT' });
  }

  async restoreComment(commentId: string): Promise<{ success: boolean; comment_id: string; message: string }> {
    return this.request(`/admin/comments/${commentId}/restore`, { method: 'PUT' });
  }

  async banUser(userId: string, data?: BanUserRequest): Promise<BanUserResponse> {
    const response = await this.request<BanUserApiResponse>(`/admin/users/${userId}/ban`, {
      method: 'PUT',
      body: data || {},
    });
    return transformBanUserResponse(response);
  }

  async unbanUser(userId: string): Promise<BanUserResponse> {
    const response = await this.request<BanUserApiResponse>(`/admin/users/${userId}/unban`, {
      method: 'PUT',
    });
    return transformBanUserResponse(response);
  }

  async getBannedUsers(options?: {
    limit?: number;
    offset?: number;
  }): Promise<BannedUsersResponse> {
    const params = new URLSearchParams();
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const response = await this.request<BannedUsersApiResponse>(`/admin/users/banned${query}`);
    return transformBannedUsersResponse(response);
  }

  async getForumAnalytics(): Promise<ForumAnalytics> {
    const response = await this.request<ForumAnalyticsApiResponse>('/admin/forum/analytics');
    return transformForumAnalytics(response);
  }

  // === KARMA LEADERBOARD ===

  async getKarmaLeaderboard(options?: {
    limit?: number;
    offset?: number;
  }): Promise<KarmaLeaderboardResponse> {
    const params = new URLSearchParams();
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const response = await this.request<KarmaLeaderboardApiResponse>(`/forum/karma-leaderboard${query}`);
    return transformKarmaLeaderboardResponse(response);
  }

  // === NOTIFICATIONS ===

  async getNotifications(options?: {
    unreadOnly?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<NotificationListResponse> {
    const params = new URLSearchParams();
    if (options?.unreadOnly) params.set('unread_only', 'true');
    if (options?.limit) params.set('limit', String(options.limit));
    if (options?.offset) params.set('offset', String(options.offset));
    const query = params.toString() ? `?${params}` : '';

    const response = await this.request<NotificationListApiResponse>(`/notifications${query}`);
    return transformNotificationListResponse(response);
  }

  async getUnreadNotificationCount(): Promise<number> {
    const response = await this.request<{ unread_count: number }>('/notifications/unread-count');
    return response.unread_count;
  }

  async markNotificationRead(notificationId: string): Promise<MarkReadResponse> {
    const response = await this.request<{ success: boolean; notification_id: string }>(
      `/notifications/${notificationId}/read`,
      { method: 'POST' }
    );
    return {
      success: response.success,
      notificationId: response.notification_id,
    };
  }

  async markAllNotificationsRead(): Promise<MarkAllReadResponse> {
    const response = await this.request<{ success: boolean; count: number }>(
      '/notifications/read-all',
      { method: 'POST' }
    );
    return {
      success: response.success,
      count: response.count,
    };
  }

  async deleteNotification(notificationId: string): Promise<DeleteNotificationResponse> {
    const response = await this.request<{ success: boolean; notification_id: string }>(
      `/notifications/${notificationId}`,
      { method: 'DELETE' }
    );
    return {
      success: response.success,
      notificationId: response.notification_id,
    };
  }
}

// === USER SEARCH TYPES ===

export interface UserSearchResult {
  id: string;
  username: string;
}

export interface UserSearchResponse {
  users: UserSearchResult[];
  totalCount: number;
}

interface UserSearchApiResponse {
  users: { id: string; username: string }[];
  total_count: number;
}

// === TYPES ===

export interface SkinAnalysis {
  clarity: number;
  tone: string;
  acne_level: string;
  acne_scarring: string;
  pore_visibility: string;
  texture_issues: string[];
}

export interface HairAnalysis {
  hairline_nw: number;
  density: string;
  texture: string;
  color: string;
}

export interface EyesAnalysis {
  color: string;
  under_eye_darkness: number;
  under_eye_puffiness: number;
}

export interface FacialFeaturesAnalysis {
  hollow_cheeks: number;
  eyebrow_density: string;
  facial_hair_potential: string;
}

export interface TeethAnalysis {
  color: string;
  alignment: string;
  visible_in_photo: boolean;
}

export interface FaceExtractionResult {
  skin: SkinAnalysis;
  hair: HairAnalysis;
  eyes: EyesAnalysis;
  facial_features: FacialFeaturesAnalysis;
  teeth: TeethAnalysis;
  confidence: number;
}

export interface BodyAnalysisResult {
  estimated_body_fat: number;
  muscle_mass: string;
  frame_size: string;
  shoulder_width: string;
  waist_definition: string;
  posture: string;
  confidence: number;
  notes: string | null;
}

// Export singleton instance
export const api = new ApiClient();

// Export types
export type { Analysis };
// Notification types are exported from @/types/notification
