"""
Forum schemas for request/response validation
"""

import bleach
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List
from datetime import datetime
from uuid import UUID
from enum import Enum


def sanitize_html(value: str) -> str:
    """Strip all HTML tags from input to prevent XSS attacks."""
    if value is None:
        return value
    return bleach.clean(value, tags=[], strip=True)


# === ENUMS ===

class VoteType(str, Enum):
    UP = "up"
    DOWN = "down"


class TargetType(str, Enum):
    POST = "post"
    COMMENT = "comment"


class ReportReason(str, Enum):
    SPAM = "spam"
    HARASSMENT = "harassment"
    MISINFORMATION = "misinformation"
    OFF_TOPIC = "off_topic"
    INAPPROPRIATE = "inappropriate"
    OTHER = "other"


class SortOrder(str, Enum):
    HOT = "hot"  # vote_count DESC, recent bias
    NEW = "new"  # created_at DESC
    TOP = "top"  # vote_count DESC


# === SUB-FORUM SCHEMAS ===

class SubForumResponse(BaseModel):
    id: UUID
    name: str
    slug: str
    description: Optional[str]
    icon: Optional[str]
    display_order: int
    post_count: int = 0

    class Config:
        from_attributes = True


# === CATEGORY SCHEMAS ===

class CategoryResponse(BaseModel):
    id: UUID
    name: str
    slug: str
    description: Optional[str]
    icon: Optional[str]
    display_order: int
    post_count: int = 0
    sub_forums: List[SubForumResponse] = []

    class Config:
        from_attributes = True


class CategoryListResponse(BaseModel):
    id: UUID
    name: str
    slug: str
    description: Optional[str]
    icon: Optional[str]
    display_order: int
    post_count: int = 0

    class Config:
        from_attributes = True


# === POST SCHEMAS ===

class PostCreate(BaseModel):
    title: str = Field(..., min_length=5, max_length=200)
    content: str = Field(..., min_length=10, max_length=10000)
    sub_forum_id: UUID

    @field_validator('title', 'content', mode='before')
    @classmethod
    def sanitize_text_fields(cls, v: str) -> str:
        """Strip HTML tags to prevent XSS attacks."""
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class PostUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=5, max_length=200)
    content: Optional[str] = Field(None, min_length=10, max_length=10000)

    @field_validator('title', 'content', mode='before')
    @classmethod
    def sanitize_text_fields(cls, v: Optional[str]) -> Optional[str]:
        """Strip HTML tags to prevent XSS attacks."""
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class PostAuthor(BaseModel):
    id: UUID
    username: str
    avatar_id: int = 1  # Preset avatar (1-20)
    karma: Optional[int] = 0  # Forum karma for display

    class Config:
        from_attributes = True


class PostResponse(BaseModel):
    id: UUID
    title: str
    content: str
    sub_forum_id: UUID
    sub_forum_slug: str
    category_slug: str
    author: PostAuthor
    is_pinned: bool
    is_guide: bool
    vote_count: int
    comment_count: int
    user_vote: Optional[VoteType] = None  # Current user's vote
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class PostListItem(BaseModel):
    """Lighter version for list views"""
    id: UUID
    title: str
    content_preview: str  # First 200 chars
    sub_forum_slug: str
    category_slug: str
    author: PostAuthor
    is_pinned: bool
    is_guide: bool
    vote_count: int
    comment_count: int
    user_vote: Optional[VoteType] = None
    created_at: datetime

    class Config:
        from_attributes = True


class PostListResponse(BaseModel):
    posts: List[PostListItem]
    total_count: int
    has_more: bool


# === CURSOR PAGINATION ===

class CursorInfo(BaseModel):
    """Cursor for keyset pagination - encodes (created_at, id) tuple"""
    created_at: datetime
    id: UUID


class CursorPaginatedPostListResponse(BaseModel):
    """Cursor-paginated response for forum posts"""
    posts: List[PostListItem]
    next_cursor: Optional[str] = None  # Base64 encoded cursor
    has_more: bool
    total_count: Optional[int] = None  # Optional - expensive to compute


# === COMMENT SCHEMAS ===

class CommentCreate(BaseModel):
    content: str = Field(..., min_length=1, max_length=5000)
    parent_id: Optional[UUID] = None

    @field_validator('content', mode='before')
    @classmethod
    def sanitize_content(cls, v: str) -> str:
        """Strip HTML tags to prevent XSS attacks."""
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class CommentUpdate(BaseModel):
    content: str = Field(..., min_length=1, max_length=5000)

    @field_validator('content', mode='before')
    @classmethod
    def sanitize_content(cls, v: str) -> str:
        """Strip HTML tags to prevent XSS attacks."""
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class CommentResponse(BaseModel):
    id: UUID
    content: str
    post_id: UUID
    author: PostAuthor
    parent_id: Optional[UUID]
    vote_count: int
    user_vote: Optional[VoteType] = None
    depth: int
    replies: List["CommentResponse"] = []
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# Needed for self-referential model
CommentResponse.model_rebuild()


class PaginatedCommentsResponse(BaseModel):
    """Paginated comments with limited depth for performance."""
    comments: List[CommentResponse]
    total_root_comments: int
    has_more: bool
    next_offset: Optional[int] = None


class CommentRepliesResponse(BaseModel):
    """Replies for a specific comment."""
    replies: List[CommentResponse]
    has_more: bool
    total_replies: int


# === VOTE SCHEMAS ===

class VoteRequest(BaseModel):
    vote_type: VoteType


class VoteResponse(BaseModel):
    success: bool
    new_vote_count: int
    user_vote: Optional[VoteType]


# === REPORT SCHEMAS ===

class ReportCreate(BaseModel):
    target_type: TargetType
    target_id: UUID
    reason: ReportReason
    details: Optional[str] = Field(None, max_length=1000)

    @field_validator('details', mode='before')
    @classmethod
    def sanitize_details(cls, v: Optional[str]) -> Optional[str]:
        """Strip HTML tags to prevent XSS attacks."""
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class ReportResponse(BaseModel):
    id: UUID
    target_type: TargetType
    target_id: UUID
    reason: ReportReason
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


# === GUIDE SECTION ===

class GuideSectionResponse(BaseModel):
    """Guides grouped by category for the top section"""
    category: CategoryListResponse
    guides: List[PostListItem]


# === RECOMMENDED FORUMS ===

class RecommendedForumResponse(BaseModel):
    """Forums recommended based on user's detected flaws"""
    category: CategoryListResponse
    matched_flaws: List[str]  # Which flaws matched this category
    priority: int  # 1 = primary, 2 = secondary


class ArchetypeForumRecommendation(BaseModel):
    """Forums recommended based on user's archetype"""
    category: CategoryListResponse
    archetype: str  # The archetype that triggered this recommendation
    reason: Optional[str]  # Why this forum is relevant
    priority: int  # Higher = more relevant


# === SEARCH SCHEMAS ===

class SearchResultType(str, Enum):
    POST = "post"
    COMMENT = "comment"


class ForumSearchResult(BaseModel):
    """A single search result (post or comment)"""
    id: UUID
    type: SearchResultType
    # For posts
    title: Optional[str] = None
    content_preview: str
    # For comments
    post_id: Optional[UUID] = None
    post_title: Optional[str] = None
    # Common fields
    author: PostAuthor
    vote_count: int
    category_slug: str
    sub_forum_slug: str
    created_at: datetime

    class Config:
        from_attributes = True


class ForumSearchResponse(BaseModel):
    """Search response with results and pagination info"""
    results: List[ForumSearchResult]
    total_count: int
    query: str
    search_type: str  # posts, comments, or all
    has_more: bool


# === ADMIN/MODERATION SCHEMAS ===

class ReportStatusEnum(str, Enum):
    PENDING = "pending"
    REVIEWED = "reviewed"
    RESOLVED = "resolved"
    DISMISSED = "dismissed"


class ActionTaken(str, Enum):
    CONTENT_REMOVED = "content_removed"
    USER_WARNED = "user_warned"
    USER_BANNED = "user_banned"
    NO_ACTION = "no_action"


class ReportDetailResponse(BaseModel):
    """Detailed report for admin view"""
    id: UUID
    target_type: TargetType
    target_id: UUID
    reason: ReportReason
    details: Optional[str]
    status: str
    reporter_id: UUID
    reporter_username: str
    reviewed_by: Optional[UUID]
    reviewed_at: Optional[datetime]
    resolution_notes: Optional[str]
    action_taken: Optional[str]
    created_at: datetime
    # Denormalized content for preview
    content_preview: Optional[str]
    content_author_id: Optional[UUID]
    content_author_username: Optional[str]

    class Config:
        from_attributes = True


class ReportListResponse(BaseModel):
    """Paginated list of reports"""
    reports: List[ReportDetailResponse]
    total_count: int
    has_more: bool


class ResolveReportRequest(BaseModel):
    """Request to resolve a report"""
    status: ReportStatusEnum
    resolution_notes: Optional[str] = Field(None, max_length=1000)
    action_taken: Optional[ActionTaken] = None

    @field_validator('resolution_notes', mode='before')
    @classmethod
    def sanitize_notes(cls, v: Optional[str]) -> Optional[str]:
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class ModerationStatsResponse(BaseModel):
    """Moderation dashboard stats"""
    pending_reports: int
    resolved_today: int
    resolved_this_week: int
    total_reports: int
    reports_by_reason: dict  # reason -> count
    reports_by_status: dict  # status -> count


class BanUserRequest(BaseModel):
    """Request to ban a user"""
    reason: Optional[str] = Field(None, max_length=500)

    @field_validator('reason', mode='before')
    @classmethod
    def sanitize_reason(cls, v: Optional[str]) -> Optional[str]:
        if isinstance(v, str):
            return sanitize_html(v)
        return v


class BanUserResponse(BaseModel):
    """Response after banning a user"""
    user_id: UUID
    username: str
    is_banned: bool
    message: str


# === BOOKMARK SCHEMAS ===

class BookmarkResponse(BaseModel):
    """Response for bookmark status"""
    id: UUID
    post_id: UUID
    is_bookmarked: bool
    created_at: datetime

    class Config:
        from_attributes = True


class BookmarkToggleResponse(BaseModel):
    """Response when toggling bookmark status"""
    is_bookmarked: bool
    message: str


class BookmarkedPostsResponse(BaseModel):
    """Paginated list of bookmarked posts"""
    posts: List[PostListItem]
    total_count: int
    has_more: bool


# === KARMA LEADERBOARD SCHEMAS ===

class KarmaLeaderboardEntry(BaseModel):
    """A single user entry on the karma leaderboard"""
    rank: int
    user_id: UUID
    username: str
    forum_karma: int
    forum_posts_count: int
    forum_comments_count: int

    class Config:
        from_attributes = True


class KarmaLeaderboardResponse(BaseModel):
    """Karma leaderboard response"""
    entries: List[KarmaLeaderboardEntry]
    total_count: int
    has_more: bool


# === QUOTA SCHEMAS ===

class ForumQuotaResponse(BaseModel):
    """User's current forum quota usage and limits"""
    posts_used: int
    posts_max: Optional[int] = None  # None = unlimited
    comments_used: int
    comments_max: Optional[int] = None  # None = unlimited
    resets_at: str  # ISO datetime string


# === ANALYTICS SCHEMAS ===

class DailyMetric(BaseModel):
    """A single day's metric data point"""
    date: str  # YYYY-MM-DD
    count: int


class TopContributor(BaseModel):
    """Top contributor by karma"""
    user_id: str
    username: str
    forum_karma: int
    posts_count: int
    comments_count: int


class CategoryEngagement(BaseModel):
    """Engagement metrics for a category"""
    category_id: str
    category_name: str
    category_slug: str
    posts_count: int
    comments_count: int
    total_votes: int


class ForumAnalyticsResponse(BaseModel):
    """Forum analytics dashboard data"""
    # Time-series data (last 30 days)
    posts_per_day: List[DailyMetric]
    comments_per_day: List[DailyMetric]

    # Aggregate metrics
    total_posts: int
    total_comments: int
    total_votes: int
    avg_votes_per_post: float
    avg_comments_per_post: float

    # User metrics
    active_users_today: int
    active_users_week: int
    active_users_month: int
    total_users: int

    # Top contributors
    top_contributors: List[TopContributor]

    # Category breakdown
    category_engagement: List[CategoryEngagement]

    # Generated timestamp
    generated_at: str
