/* global localStorage */
/**
 * Phase 4: Production Blockers E2E Tests
 *
 * Tests for:
 * 1. Login/Auth UI - customer ID storage and retrieval
 * 2. Auth headers - proper header injection in requests
 * 3. Rate limiting - requireCredits middleware on endpoints
 * 4. Error messages - user-friendly build error formatting
 */

// Simulate localStorage for Node.js testing
const storage = { data: {} };
global.localStorage = {
  getItem: (key) => storage.data[key] || null,
  setItem: (key, value) => { storage.data[key] = value; },
  removeItem: (key) => { delete storage.data[key]; },
  clear: () => { storage.data = {}; }
};

function resetLocalStorage() {
  storage.data = {};
}

// Suppress console noise
const originalWarn = console.warn;
const originalError = console.error;
console.warn = () => {};
console.error = () => {};

// =============================================================================
// COPY OF SETTINGS FUNCTIONS (for testing without UXP)
// =============================================================================

const DEFAULT_SETTINGS = {
  sensitivity: 50,
  audioSource: 'original',
  autoMarkBest: true,
  enableTakesDetection: true,
  rememberOptions: false,
  optionsExpanded: false,
  customerId: null,
  mediaFolderToken: null,
  mediaFolderPath: null,
  activePreset: 'custom'
};

let currentSettings = { ...DEFAULT_SETTINGS };

function loadSettings() {
  try {
    const saved = localStorage.getItem('spliceSettings');
    if (saved) {
      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
    }
  } catch (_e) {
    currentSettings = { ...DEFAULT_SETTINGS };
  }
  return currentSettings;
}

function saveSettings(settings) {
  try {
    currentSettings = { ...currentSettings, ...settings };
    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));
  } catch (_e) {
    // Silent fail
  }
}

function getSettings() {
  return { ...currentSettings };
}

function isLoggedIn() {
  const settings = getSettings();
  return !!settings.customerId;
}

function getCustomerId() {
  const settings = getSettings();
  return settings.customerId || null;
}

function logout() {
  saveSettings({ customerId: null });
}

// =============================================================================
// COPY OF AUTH HEADERS FUNCTION (from main.js)
// =============================================================================

function getAuthHeaders() {
  const headers = { 'Content-Type': 'application/json' };
  const settings = getSettings();
  if (settings.customerId) {
    headers['x-stripe-customer-id'] = settings.customerId;
  }
  return headers;
}

// =============================================================================
// COPY OF ERROR FORMATTING FUNCTION (from main.js)
// =============================================================================

function formatBuildError(error) {
  if (!error) return 'Unknown error occurred';

  const errorMap = {
    'Builder not initialized': 'Builder module failed to load. Try restarting the plugin.',
    'No active project': 'No project is open. Please open or create a project first.',
    'No media items found': 'No media files in project. Import media before building.',
    'No detection data': 'Run analysis first (click GO button).',
    'Failed to generate cut list': 'Server error generating cuts. Check your connection.',
    'Failed to build sequence': 'Premiere Pro sequence build failed. Try again.',
    'fetch failed': 'Network error. Check if backend server is running.',
    'NetworkError': 'Cannot connect to server. Check your internet connection.',
    'Insufficient credits': 'Out of credits. Upgrade your plan to continue.',
    'Authentication required': 'Login required. Click the credits badge to log in.'
  };

  for (const [pattern, friendly] of Object.entries(errorMap)) {
    if (error.includes(pattern)) {
      return friendly;
    }
  }

  return error;
}

// =============================================================================
// TEST FRAMEWORK
// =============================================================================

let passCount = 0;
let failCount = 0;

function test(name, fn) {
  try {
    fn();
    passCount++;
    console.log(`  ✓ ${name}`);
  } catch (err) {
    failCount++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${err.message}`);
  }
}

function assertEqual(actual, expected, message = '') {
  if (actual !== expected) {
    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

function assertTrue(condition, message = '') {
  if (!condition) {
    throw new Error(`${message}: Expected true, got false`);
  }
}

function assertFalse(condition, message = '') {
  if (condition) {
    throw new Error(`${message}: Expected false, got true`);
  }
}

// eslint-disable-next-line no-unused-vars -- available for tests
function assertNotNull(value, message = '') {
  if (value === null || value === undefined) {
    throw new Error(`${message}: Expected non-null value`);
  }
}

// eslint-disable-next-line no-unused-vars -- available for tests
function assertIncludes(arr, item, message = '') {
  if (!arr || !arr.includes) {
    throw new Error(`${message}: Not an array`);
  }
  if (!arr.includes(item)) {
    throw new Error(`${message}: Array does not include ${item}`);
  }
}

// =============================================================================
// TEST SUITES
// =============================================================================

console.log('\n=== Phase 4: Production Blockers E2E Tests ===\n');

// -----------------------------------------------------------------------------
// Test Suite 1: Login/Auth UI - Customer ID Storage
// -----------------------------------------------------------------------------

console.log('1. Login/Auth UI - Customer ID Storage');

test('should start with no customer ID', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };
  loadSettings();
  assertFalse(isLoggedIn(), 'Should not be logged in initially');
  assertEqual(getCustomerId(), null, 'Customer ID should be null');
});

test('should save customer ID via saveSettings', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };
  saveSettings({ customerId: 'cus_test123' });
  assertEqual(getCustomerId(), 'cus_test123', 'Customer ID should be saved');
  assertTrue(isLoggedIn(), 'Should be logged in after saving');
});

test('should persist customer ID across loadSettings', () => {
  // Keep existing localStorage from previous test
  currentSettings = { ...DEFAULT_SETTINGS };
  loadSettings();
  assertEqual(getCustomerId(), 'cus_test123', 'Customer ID should persist');
  assertTrue(isLoggedIn(), 'Should still be logged in');
});

test('should clear customer ID on logout', () => {
  logout();
  assertEqual(getCustomerId(), null, 'Customer ID should be cleared');
  assertFalse(isLoggedIn(), 'Should not be logged in after logout');
});

test('should validate customer ID format (starts with cus_)', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };
  saveSettings({ customerId: 'cus_valid123' });
  const customerId = getCustomerId();
  assertTrue(customerId.startsWith('cus_'), 'Valid ID starts with cus_');
});

// -----------------------------------------------------------------------------
// Test Suite 2: Auth Headers
// -----------------------------------------------------------------------------

console.log('\n2. Auth Headers');

test('should include Content-Type in headers', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };
  const headers = getAuthHeaders();
  assertEqual(headers['Content-Type'], 'application/json', 'Content-Type header');
});

test('should NOT include customer ID when not logged in', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };
  const headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], undefined, 'No customer ID header');
});

test('should include customer ID when logged in', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };
  saveSettings({ customerId: 'cus_auth_test' });
  const headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], 'cus_auth_test', 'Customer ID header');
});

test('should update headers after login', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };

  // Before login
  let headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], undefined, 'No header before login');

  // After login
  saveSettings({ customerId: 'cus_new_user' });
  headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], 'cus_new_user', 'Header after login');
});

test('should remove headers after logout', () => {
  saveSettings({ customerId: 'cus_will_logout' });
  let headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], 'cus_will_logout', 'Header before logout');

  logout();
  headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], undefined, 'No header after logout');
});

// -----------------------------------------------------------------------------
// Test Suite 3: Error Message Formatting
// -----------------------------------------------------------------------------

console.log('\n3. Error Message Formatting');

test('should format "Builder not initialized" error', () => {
  const result = formatBuildError('Builder not initialized');
  assertEqual(result, 'Builder module failed to load. Try restarting the plugin.', 'Builder error');
});

test('should format "No active project" error', () => {
  const result = formatBuildError('No active project');
  assertEqual(result, 'No project is open. Please open or create a project first.', 'Project error');
});

test('should format "No media items found" error', () => {
  const result = formatBuildError('No media items found in project');
  assertEqual(result, 'No media files in project. Import media before building.', 'Media error');
});

test('should format "No detection data" error', () => {
  const result = formatBuildError('No detection data found');
  assertEqual(result, 'Run analysis first (click GO button).', 'Detection error');
});

test('should format "Failed to generate cut list" error', () => {
  const result = formatBuildError('Failed to generate cut list: timeout');
  assertEqual(result, 'Server error generating cuts. Check your connection.', 'Cut list error');
});

test('should format "Failed to build sequence" error', () => {
  const result = formatBuildError('Failed to build sequence');
  assertEqual(result, 'Premiere Pro sequence build failed. Try again.', 'Build error');
});

test('should format network errors', () => {
  const result1 = formatBuildError('TypeError: fetch failed');
  assertEqual(result1, 'Network error. Check if backend server is running.', 'Fetch error');

  const result2 = formatBuildError('NetworkError when attempting to fetch');
  assertEqual(result2, 'Cannot connect to server. Check your internet connection.', 'Network error');
});

test('should format auth errors', () => {
  const result1 = formatBuildError('Insufficient credits');
  assertEqual(result1, 'Out of credits. Upgrade your plan to continue.', 'Credits error');

  const result2 = formatBuildError('Authentication required');
  assertEqual(result2, 'Login required. Click the credits badge to log in.', 'Auth error');
});

test('should return original error if no match', () => {
  const result = formatBuildError('Some random error message');
  assertEqual(result, 'Some random error message', 'Passthrough unknown error');
});

test('should handle null/undefined errors', () => {
  const result1 = formatBuildError(null);
  assertEqual(result1, 'Unknown error occurred', 'Null error');

  const result2 = formatBuildError(undefined);
  assertEqual(result2, 'Unknown error occurred', 'Undefined error');

  const result3 = formatBuildError('');
  assertEqual(result3, 'Unknown error occurred', 'Empty error');
});

// -----------------------------------------------------------------------------
// Test Suite 4: Rate Limiting Endpoints (verification)
// -----------------------------------------------------------------------------

console.log('\n4. Rate Limiting Verification');

// These tests verify that the endpoints have requireCredits middleware
// by checking the server.js and route module source code patterns

const fs = require('fs');
const path = require('path');

// Helper to safely read route file
function readRouteFile(name) {
  const filePath = path.join(__dirname, '../routes', name);
  try {
    return fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : '';
  } catch (_e) {
    return '';
  }
}

let serverSource = '';
try {
  serverSource = fs.readFileSync(path.join(__dirname, '../server.js'), 'utf8');
} catch (_e) {
  console.log('  [Warning: Could not read server.js for verification]');
}

// Load all route modules
const routeFiles = [
  'index.js', 'health.js', 'analyze.js', 'silences.js', 'detection.js',
  'export.js', 'multitrack.js', 'cutList.js', 'zoom.js', 'chapters.js',
  'youtube.js', 'captions.js', 'textEdit.js', 'reframe.js', 'batch.js',
  'billing.js', 'referral.js', 'license.js', 'music.js', 'auth.js'
];

const allBackendCode = serverSource + routeFiles.map(readRouteFile).join('');

if (allBackendCode) {
  // Check for requireCredits middleware - in modular architecture uses router.post instead of app.post
  const endpointsToCheck = [
    { path: '/silences-audio', patterns: ["app.post('/silences-audio', requireCredits", "router.post('/audio', requireCredits"] },
    { path: '/repetitions', patterns: ["app.post('/repetitions', requireCredits", "router.post('/repetitions', requireCredits"] },
    { path: '/fillers', patterns: ["app.post('/fillers', requireCredits", "router.post('/fillers', requireCredits"] },
    { path: '/stutters', patterns: ["app.post('/stutters', requireCredits", "router.post('/stutters', requireCredits"] },
    { path: '/export/captions', patterns: ["app.post('/export/captions', requireCredits", "router.post('/captions', requireCredits"] },
    { path: '/multitrack/auto-balance', patterns: ["app.post('/multitrack/auto-balance', requireCredits", "router.post('/auto-balance', requireCredits"] },
    { path: '/batch/silences', patterns: ["app.post('/batch/silences', requireCredits", "router.post('/silences', requireCredits"] },
    { path: '/isolate-vocals', patterns: ["app.post('/isolate-vocals', requireCredits", "router.post('/isolate', requireCredits", "router.post('/', requireCredits"] }
  ];

  for (const endpoint of endpointsToCheck) {
    test(`should have requireCredits on ${endpoint.path}`, () => {
      const hasRequireCredits = endpoint.patterns.some(pattern => allBackendCode.includes(pattern));
      assertTrue(
        hasRequireCredits,
        `${endpoint.path} should have requireCredits middleware`
      );
    });
  }
}

// -----------------------------------------------------------------------------
// Test Suite 4b: Usage Deduction Verification
// -----------------------------------------------------------------------------

console.log('\n4b. Usage Deduction Verification');

if (serverSource) {
  const endpointsWithDeduction = [
    { name: '/analyze', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/silences', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/silences-audio', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/silences-rms', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/profanity', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/repetitions', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/fillers', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/stutters', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/export/captions', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/multitrack', pattern: 'req.deductUsage(audioDuration)' },
    { name: '/multitrack/auto-balance', pattern: 'req.deductUsage(audioDuration)' },
    { name: 'batch processing', pattern: 'usageTracking.deductUsage(job.stripeCustomerId' }
  ];

  for (const endpoint of endpointsWithDeduction) {
    test(`should deduct usage in ${endpoint.name}`, () => {
      assertTrue(
        serverSource.includes(endpoint.pattern),
        `${endpoint.name} should call deductUsage`
      );
    });
  }
}

// -----------------------------------------------------------------------------
// Test Suite 5: Integration - Full Auth Flow
// -----------------------------------------------------------------------------

console.log('\n5. Integration - Full Auth Flow');

test('should handle complete login flow', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };

  // 1. Start logged out
  assertFalse(isLoggedIn(), 'Step 1: Not logged in');
  let headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], undefined, 'Step 1: No header');

  // 2. Login
  saveSettings({ customerId: 'cus_integration_test' });
  assertTrue(isLoggedIn(), 'Step 2: Now logged in');
  headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], 'cus_integration_test', 'Step 2: Has header');

  // 3. Persist across page reload (simulate)
  currentSettings = { ...DEFAULT_SETTINGS };
  loadSettings();
  assertTrue(isLoggedIn(), 'Step 3: Still logged in');
  assertEqual(getCustomerId(), 'cus_integration_test', 'Step 3: ID persisted');

  // 4. Logout
  logout();
  assertFalse(isLoggedIn(), 'Step 4: Logged out');
  headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], undefined, 'Step 4: No header');
});

test('should handle customer ID change', () => {
  resetLocalStorage();
  currentSettings = { ...DEFAULT_SETTINGS };

  // Login with first ID
  saveSettings({ customerId: 'cus_first_id' });
  assertEqual(getCustomerId(), 'cus_first_id', 'First ID set');

  // Change to new ID
  saveSettings({ customerId: 'cus_second_id' });
  assertEqual(getCustomerId(), 'cus_second_id', 'Second ID set');

  // Verify headers updated
  const headers = getAuthHeaders();
  assertEqual(headers['x-stripe-customer-id'], 'cus_second_id', 'Headers updated');
});

// =============================================================================
// SUMMARY
// =============================================================================

console.log('\n=== Test Summary ===');
console.log(`  Passed: ${passCount}`);
console.log(`  Failed: ${failCount}`);
console.log(`  Total: ${passCount + failCount}`);

// Restore console
console.warn = originalWarn;
console.error = originalError;

if (failCount > 0) {
  console.log('\n❌ Some tests failed');
  process.exit(1);
} else {
  console.log('\n✓ All Phase 4 tests passed');
  process.exit(0);
}
