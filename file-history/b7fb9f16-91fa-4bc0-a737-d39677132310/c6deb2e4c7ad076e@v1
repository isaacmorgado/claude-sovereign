import type { Request, Response, NextFunction } from 'express'
import * as userRepository from '../db/repositories/user-repository.js'
import type { AuthenticatedRequest, ApiResponse } from '../types/api.js'
import { TIER_LIMITS } from '../types/user.js'

export interface UsageStats {
  currentUsage: number
  limit: number
  remaining: number
  percentUsed: number
  tier: string
  resetAt: Date
}

type UsageResponse = ApiResponse<UsageStats>

export async function getUsage(
  req: Request,
  res: Response<UsageResponse>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const userId = authReq.user.id

    // Check and reset usage if billing cycle has renewed
    await userRepository.resetUsageIfNeeded(userId)

    // Fetch fresh user data
    const user = await userRepository.findById(userId)
    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
      })
      return
    }

    const limit = TIER_LIMITS[user.subscription_tier]
    const currentUsage = user.usage_minutes_used
    const remaining = Math.max(0, limit - currentUsage)
    const percentUsed = limit > 0 ? Math.round((currentUsage / limit) * 100) : 0

    res.json({
      success: true,
      data: {
        currentUsage,
        limit,
        remaining,
        percentUsed,
        tier: user.subscription_tier,
        resetAt: user.usage_reset_at,
      },
    })
  } catch (error) {
    next(error)
  }
}

export async function checkLimit(
  req: Request,
  res: Response<ApiResponse<{ allowed: boolean; remaining: number }>>,
  next: NextFunction
): Promise<void> {
  try {
    const authReq = req as AuthenticatedRequest
    const userId = authReq.user.id
    const minutesParam = req.query.minutes
    const requestedMinutes = minutesParam !== undefined ? Number(minutesParam) : 1

    // Validate minutes parameter
    if (isNaN(requestedMinutes) || requestedMinutes <= 0) {
      res.status(400).json({
        success: false,
        error: 'Invalid minutes parameter. Must be a positive number.',
      })
      return
    }

    // Check and reset usage if billing cycle has renewed
    await userRepository.resetUsageIfNeeded(userId)

    const user = await userRepository.findById(userId)
    if (!user) {
      res.status(404).json({
        success: false,
        error: 'User not found',
      })
      return
    }

    const limit = TIER_LIMITS[user.subscription_tier]
    const remaining = Math.max(0, limit - user.usage_minutes_used)
    const allowed = remaining >= requestedMinutes

    res.json({
      success: true,
      data: {
        allowed,
        remaining,
      },
    })
  } catch (error) {
    next(error)
  }
}
