#!/usr/bin/env node
/**
 * Patch Claude Code cli.js to inject custom models into the model picker
 * This directly modifies the minified cli.js to add GLM, Featherless, and Google models
 */

const fs = require('fs');
const path = require('path');

const CLI_PATH = '/opt/homebrew/lib/node_modules/@anthropic-ai/claude-code/cli.js';
const BACKUP_PATH = CLI_PATH + '.backup-before-model-patch';

console.log('ğŸ”§ Patching Claude Code to add custom models...\n');

// Step 1: Backup original file
if (!fs.existsSync(BACKUP_PATH)) {
    console.log('Creating backup...');
    fs.copyFileSync(CLI_PATH, BACKUP_PATH);
    console.log('âœ“ Backup created at:', BACKUP_PATH);
} else {
    console.log('âœ“ Backup already exists');
}

// Step 2: Read cli.js
console.log('\nReading cli.js...');
let content = fs.readFileSync(CLI_PATH, 'utf8');
console.log(`âœ“ Read ${Math.round(content.length / 1024 / 1024)}MB`);

// Step 3: Find the model list array
// Looking for the pattern where models are defined
// The model picker shows: "Opus 4.5", "Sonnet 4.5", "Haiku 4.5"
// These are defined in a hardcoded array

console.log('\nğŸ” Searching for model definitions...');

// Pattern 1: Find where display names are defined
// The vzQ() function returns display names
const displayNamePattern = /"Opus 4\.5"|"Sonnet 4\.5"|"Haiku 4\.5"/;
const match = content.match(displayNamePattern);

if (!match) {
    console.error('âŒ Could not find model display names in cli.js');
    console.error('The CLI structure may have changed. Manual patching required.');
    process.exit(1);
}

console.log('âœ“ Found model definitions at position:', match.index);

// Pattern 2: Find the model list that populates the picker
// This is likely in a function that returns available models
// Look for patterns like: [{id:"claude-opus-4-5",...},{id:"claude-sonnet-4-5",...}]

// The most reliable approach: Search for where model IDs are collected into an array
// and inject our custom models there

// Find the model constants
const opusPattern = /PqA\s*=\s*\{[^}]+claude-opus-4-5[^}]+\}/;
const sonnetPattern = /LT1\s*=\s*\{[^}]+claude-sonnet-4-5[^}]+\}/;

const opusMatch = content.match(opusPattern);
const sonnetMatch = content.match(sonnetPattern);

if (!opusMatch || !sonnetMatch) {
    console.error('âŒ Could not find model constant definitions');
    process.exit(1);
}

console.log('âœ“ Found model constants');

// Step 4: Inject custom model definitions after the existing ones
// Add our custom models as new constants

const customModelDefs = `
// Custom models injected by patch
,XqA={firstParty:"glm/glm-4",bedrock:"glm/glm-4",vertex:"glm/glm-4",foundry:"glm/glm-4"}
,YqA={firstParty:"glm/glm-4-flash",bedrock:"glm/glm-4-flash",vertex:"glm/glm-4-flash",foundry:"glm/glm-4-flash"}
,ZqA={firstParty:"featherless/Llama-3-8B-Instruct-abliterated",bedrock:"featherless/Llama-3-8B-Instruct-abliterated",vertex:"featherless/Llama-3-8B-Instruct-abliterated",foundry:"featherless/Llama-3-8B-Instruct-abliterated"}
,WqA={firstParty:"featherless/Llama-3-70B-Instruct-abliterated",bedrock:"featherless/Llama-3-70B-Instruct-abliterated",vertex:"featherless/Llama-3-70B-Instruct-abliterated",foundry:"featherless/Llama-3-70B-Instruct-abliterated"}
,VqA={firstParty:"google/gemini-2.0-flash",bedrock:"google/gemini-2.0-flash",vertex:"google/gemini-2.0-flash",foundry:"google/gemini-2.0-flash"}`;

// Insert after the last model constant (PqA for Opus 4.5)
const insertPosition = opusMatch.index + opusMatch[0].length;
content = content.slice(0, insertPosition) + customModelDefs + content.slice(insertPosition);

console.log('âœ“ Injected custom model definitions');

// Step 5: Find the itA() function that creates model structure
// and add our custom models to it

const itaPattern = /function itA\(A\)\{return\{([^}]+)\}\}/;
const itaMatch = content.match(itaPattern);

if (!itaMatch) {
    console.error('âŒ Could not find itA() function');
    process.exit(1);
}

// Add our models to the return object
const originalReturn = itaMatch[1];
const customModelsInReturn = `,glm4:XqA[A],glm4flash:YqA[A],llama8b:ZqA[A],llama70b:WqA[A],gemini2flash:VqA[A]`;

content = content.replace(
    itaPattern,
    `function itA(A){return{${originalReturn}${customModelsInReturn}}}`
);

console.log('âœ“ Added custom models to itA() function');

// Step 6: Add display names to vzQ() function
// This function maps model IDs to display names

// Find patterns in vzQ function and add our mappings
const vzqDisplayNames = `
if(A.includes("glm/glm-4-flash"))return"ğŸŒ GLM-4 Flash (Free)";
if(A.includes("glm/glm-4"))return"ğŸŒ GLM-4 (Free)";
if(A.includes("featherless/Llama-3-8B"))return"ğŸ”“ Llama 3 8B (Uncensored)";
if(A.includes("featherless/Llama-3-70B"))return"ğŸ”“ Llama 3 70B (Uncensored)";
if(A.includes("google/gemini-2.0-flash"))return"ğŸ”· Gemini 2.0 Flash";`;

// Find the vzQ function and inject our display names at the beginning
const vzqPattern = /function vzQ\(A\)\{/;
content = content.replace(vzqPattern, `function vzQ(A){${vzqDisplayNames}`);

console.log('âœ“ Added display names for custom models');

// Step 7: Write patched file
console.log('\nğŸ’¾ Writing patched cli.js...');
fs.writeFileSync(CLI_PATH, content, 'utf8');
console.log('âœ“ Patch applied successfully!');

console.log('\nâœ… Custom models added to Claude Code model picker!');
console.log('\nAdded models:');
console.log('  - ğŸŒ GLM-4 (Free)');
console.log('  - ğŸŒ GLM-4 Flash (Free)');
console.log('  - ğŸ”“ Llama 3 8B (Uncensored)');
console.log('  - ğŸ”“ Llama 3 70B (Uncensored)');
console.log('  - ğŸ”· Gemini 2.0 Flash');
console.log('\nRestart Claude Code to see the new models in /model picker');
console.log('\nTo restore original: sudo cp', BACKUP_PATH, CLI_PATH);
