// Custom patch for multi-provider models (GLM, Featherless, Google, Anthropic)
// Based on tweakcc's modelSelector.ts

import { escapeIdent, showDiff } from './index';

// Custom models for multi-provider setup
// prettier-ignore
export const CUSTOM_MODELS: { value: string; label: string; description: string }[] = [
  // Anthropic (native)
  { value: 'claude-opus-4-5-20251101',   label: 'Opus 4.5',             description: "Claude Opus 4.5 (November 2025)" },
  { value: 'claude-sonnet-4-5-20250929', label: 'Sonnet 4.5',           description: "Claude Sonnet 4.5 (September 2025)" },
  { value: 'claude-3-5-haiku-20241022',  label: 'Haiku 3.5',            description: "Claude 3.5 Haiku (October 2024)" },

  // GLM (ZhipuAI) - Free
  { value: 'glm/glm-4',                  label: 'ðŸŒ GLM-4',             description: "GLM-4 by ZhipuAI (free, most capable)" },
  { value: 'glm/glm-4-flash',            label: 'âš¡ GLM-4-Flash',       description: "GLM-4-Flash (free, fastest)" },
  { value: 'glm/glm-4-air',              label: 'â˜ï¸ GLM-4-Air',         description: "GLM-4-Air (free, balanced)" },

  // Featherless (Uncensored/Abliterated)
  { value: 'featherless/Llama-3-8B-Instruct-abliterated',  label: 'ðŸ”“ Llama-3-8B (Uncensored)',  description: "Llama 3 8B Instruct (abliterated, no restrictions)" },
  { value: 'featherless/Llama-3-70B-Instruct-abliterated', label: 'ðŸ”“ Llama-3-70B (Uncensored)', description: "Llama 3 70B Instruct (abliterated, larger model)" },

  // Google Gemini
  { value: 'google/gemini-pro',          label: 'ðŸ”· Gemini Pro',       description: "Google Gemini Pro" },
  { value: 'google/gemini-2.0-flash',    label: 'âš¡ Gemini 2.0 Flash', description: "Google Gemini 2.0 Flash (fast)" },
];

const findCustomModelListInsertionPoint = (
  fileContents: string
): { insertionIndex: number; modelListVar: string } | null => {
  // 1. Find the custom model push pattern
  const pushPattern =
    /\b([$\w]+)\.push\(\{value:[$\w]+,label:[$\w]+,description:"Custom model"\}\)/;
  const pushMatch = fileContents.match(pushPattern);
  if (!pushMatch || pushMatch.index === undefined) {
    console.error(
      'patch: findCustomModelListInsertionPoint: failed to find custom model push'
    );
    return null;
  }

  // 2. Extract the model list variable name
  const modelListVar = pushMatch[1];

  // 3. Look back 600 chars from the push match
  const searchStart = Math.max(0, pushMatch.index - 600);
  const chunk = fileContents.slice(searchStart, pushMatch.index);

  // 4. Find the LAST occurrence of the function with let modelListVar=...;
  const funcPattern = new RegExp(
    `function [$\\w]+\\(\\)\\{let ${escapeIdent(modelListVar)}=.+?;`,
    'g'
  );
  let lastMatch: RegExpExecArray | null = null;
  let match: RegExpExecArray | null;
  while ((match = funcPattern.exec(chunk)) !== null) {
    lastMatch = match;
  }

  if (!lastMatch) {
    console.error(
      `patch: findCustomModelListInsertionPoint: failed to find function with let ${modelListVar}`
    );
    return null;
  }

  // 5. Return index after the semicolon (end of the match), and the var name
  const insertionIndex = searchStart + lastMatch.index + lastMatch[0].length;
  return { insertionIndex, modelListVar };
};

export const writeModelCustomizations = (oldFile: string): string | null => {
  const found = findCustomModelListInsertionPoint(oldFile);
  if (!found) return null;

  const { insertionIndex, modelListVar } = found;

  // Build the injection: push each custom model onto the list
  const inject = CUSTOM_MODELS.map(
    model => `${modelListVar}.push(${JSON.stringify(model)});`
  ).join('');

  const newFile =
    oldFile.slice(0, insertionIndex) + inject + oldFile.slice(insertionIndex);
  showDiff(oldFile, newFile, inject, insertionIndex, insertionIndex);
  return newFile;
};
