// Custom status line patch
// Shows project directory and current model always visible

import { showDiff } from './index';

/**
 * Find the status line rendering code
 * Look for patterns like "Claude Max", "Sonnet", or version display
 */
const findStatusLineLocation = (oldFile: string): {
  startIndex: number;
  endIndex: number;
} | null => {
  // Look for the status line that shows model info
  // Pattern: search for text that contains model information
  const patterns = [
    // Look for concatenation of model name with dot separator
    /\s+\+\s*["']\s*Â·\s*["']\s*\+\s*/,
    // Look for "Claude Max" or similar tier text
    /["']Claude\s+(Max|Pro|Haiku|Sonnet|Opus)["']/i,
    // Look for the Sonnet/Opus/Haiku version pattern
    /(Sonnet|Opus|Haiku)\s+[\d.]+/i,
  ];

  for (const pattern of patterns) {
    const match = oldFile.match(pattern);
    if (match && match.index !== undefined) {
      // Found it, now find the surrounding function/component
      const lookbackStart = Math.max(0, match.index - 2000);
      const lookforwardEnd = Math.min(oldFile.length, match.index + 2000);

      return {
        startIndex: lookbackStart,
        endIndex: lookforwardEnd,
      };
    }
  }

  console.error('patch: customStatusLine: failed to find status line location');
  return null;
};

/**
 * Inject code to always show project directory and model
 * This modifies the status line component to include both pieces of information
 *
 * Approach: Find conditional rendering patterns and make them always truthy
 */
export const writeCustomStatusLine = (oldFile: string): string | null => {
  let modified = false;
  let newFile = oldFile;

  // Strategy 1: Find and modify conditional display of directory/model info
  // Look for patterns like: condition ? element : null or condition && element

  // Pattern 1: Directory path conditional rendering
  // Look for references to working directory or cwd in conditionals
  const cwdPatterns = [
    // Pattern: something like "cwd && jsx(..." or "showCwd && jsx(..."
    /(\w+)&&\w+\([^,]+,[^,]+,\{[^}]*cwd[^}]*\}\)/g,
    // Pattern: conditional with directory-like content
    /(\w+)\?\w+\([^,]+,[^,]+,\{[^}]*children:.*?~\/.*?\}\):null/g,
  ];

  for (const pattern of cwdPatterns) {
    const matches = newFile.match(pattern);
    if (matches && matches.length > 0) {
      console.log(
        `patch: customStatusLine: found ${matches.length} potential directory conditionals`
      );

      // Replace conditional checks with "true" to always show
      newFile = newFile.replace(pattern, (match) => {
        // Replace the condition variable with "true"
        const replaced = match.replace(/^(\w+)(&&|\?)/, 'true$2');
        if (replaced !== match) {
          modified = true;
          console.log(
            `patch: customStatusLine: modified conditional: ${match.substring(0, 50)}...`
          );
        }
        return replaced;
      });
    }
  }

  // Pattern 2: Model name display
  // Look for model tier (Claude Max, Sonnet, etc.) conditionals
  const modelPatterns = [
    // Pattern: conditional showing model name
    /(\w+)&&\w+\([^,]+,[^,]+,\{children:["'].*?(Sonnet|Opus|Haiku|Claude|Max).*?["']\}\)/g,
    /(\w+)\?\w+\([^,]+,[^,]+,\{children:["'].*?(Sonnet|Opus|Haiku|Claude|Max).*?["']\}\):null/g,
  ];

  for (const pattern of modelPatterns) {
    const matches = newFile.match(pattern);
    if (matches && matches.length > 0) {
      console.log(
        `patch: customStatusLine: found ${matches.length} potential model name conditionals`
      );

      newFile = newFile.replace(pattern, (match) => {
        const replaced = match.replace(/^(\w+)(&&|\?)/, 'true$2');
        if (replaced !== match) {
          modified = true;
          console.log(
            `patch: customStatusLine: modified model conditional: ${match.substring(0, 50)}...`
          );
        }
        return replaced;
      });
    }
  }

  // Pattern 3: Generic status bar item conditionals
  // Find status bar container and make all children always visible
  const statusBarPattern = /statusBar|StatusBar|status-bar/i;
  if (statusBarPattern.test(newFile)) {
    console.log('patch: customStatusLine: found status bar reference');

    // Look for common hiding patterns near status bar
    const hidePatterns = [
      /(![\w.]+|[\w.]+===false|!1)&&/g,  // Negative conditions
      /!([\w.]+)\?/g,  // Negated ternary
    ];

    for (const pattern of hidePatterns) {
      newFile = newFile.replace(pattern, (match) => {
        if (match.includes('statusBar') || match.includes('status')) {
          modified = true;
          console.log(
            `patch: customStatusLine: removed hiding condition: ${match}`
          );
          return 'true&&';
        }
        return match;
      });
    }
  }

  if (modified) {
    console.log('patch: customStatusLine: status line modifications applied');
    return newFile;
  }

  console.log(
    'patch: customStatusLine: no modifications made - patterns not found in minified code'
  );
  console.log(
    'patch: customStatusLine: status line may already be visible or uses different patterns'
  );

  // Return original file - don't break anything if we can't find the patterns
  return oldFile;
};

/**
 * Alternative approach: Inject custom status rendering by finding the StatusBar component
 */
export const writeAlwaysVisibleProjectInfo = (oldFile: string): string | null => {
  // Look for where project directory is conditionally shown
  // and make it always visible

  // Pattern: Look for conditional rendering of directory
  // Something like: condition ? directoryDisplay : null

  // This is a simplified version - actual implementation needs the extracted cli.js
  console.log('patch: alwaysVisibleProjectInfo: requires cli.js inspection');

  return oldFile;
};
