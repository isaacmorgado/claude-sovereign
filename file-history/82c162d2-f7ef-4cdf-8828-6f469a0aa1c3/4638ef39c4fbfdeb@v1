// Custom startup ASCII art patch
// Replaces the Clawd ASCII art with custom "CLAUDE" text with horns
// Changes orange colors to matrix green

import { showDiff } from './index';

/**
 * Custom CLAUDE ASCII art with horns coming from C and E
 * Matrix green theme
 */
const CUSTOM_ASCII_ART = `
     ▲                                        ▲
    ▐█▌                                      ▐█▌
   ▐███▌    ██████╗██╗      █████╗ ██╗   ██╗██████╗ ███████╗
  ▐█████▌  ██╔════╝██║     ██╔══██╗██║   ██║██╔══██╗██╔════╝
   ▐███▌   ██║     ██║     ███████║██║   ██║██║  ██║█████╗
    ▐█▌    ██║     ██║     ██╔══██║██║   ██║██║  ██║██╔══╝
     ▲     ╚██████╗███████╗██║  ██║╚██████╔╝██████╔╝███████╗
            ╚═════╝╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝
`;

/**
 * Find all Clawd component function body start indices and the ASCII art itself
 */
const findStartupClawdComponents = (oldFile: string): Array<{
  functionStart: number;
  artStart: number;
  artEnd: number;
}> => {
  const results: Array<{ functionStart: number; artStart: number; artEnd: number }> = [];

  // The original Clawd ASCII art header
  const clawdPattern = '▛███▜';

  let searchPos = 0;
  while (true) {
    const clawdIndex = oldFile.indexOf(clawdPattern, searchPos);
    if (clawdIndex === -1) {
      break;
    }

    // Get 2000 chars before this occurrence to find the function
    const lookbackStart = Math.max(0, clawdIndex - 2000);
    const beforeText = oldFile.slice(lookbackStart, clawdIndex);

    // Find the LAST occurrence of function pattern
    const functionPattern = /function [$\w]+\(\)\{/g;
    let lastFunctionMatch: RegExpExecArray | null = null;
    let match: RegExpExecArray | null;

    while ((match = functionPattern.exec(beforeText)) !== null) {
      lastFunctionMatch = match;
    }

    if (lastFunctionMatch) {
      const functionStartIndex =
        lookbackStart + lastFunctionMatch.index + lastFunctionMatch[0].length;

      // Find the end of the ASCII art section
      // Look for the end of the Clawd art (typically followed by more code)
      const artEndPattern = /\n\s+\*/g;
      let artEndMatch: RegExpExecArray | null = null;
      const searchText = oldFile.slice(clawdIndex, clawdIndex + 500);

      while ((match = artEndPattern.exec(searchText)) !== null) {
        artEndMatch = match;
      }

      const artEndIndex = artEndMatch
        ? clawdIndex + artEndMatch.index + artEndMatch[0].length
        : clawdIndex + 200; // fallback

      results.push({
        functionStart: functionStartIndex,
        artStart: clawdIndex - 50, // Include some context before
        artEnd: artEndIndex,
      });
    }

    searchPos = clawdIndex + clawdPattern.length;
  }

  return results;
};

/**
 * Replace Clawd ASCII art with custom CLAUDE art
 */
export const writeCustomStartupArt = (oldFile: string): string | null => {
  const components = findStartupClawdComponents(oldFile);

  if (components.length === 0) {
    console.error('patch: customStartupArt: no Clawd components found');
    return null;
  }

  let newFile = oldFile;

  // Replace in reverse order to avoid index shifting
  const sortedComponents = [...components].sort((a, b) => b.artStart - a.artStart);

  for (const component of sortedComponents) {
    // Replace the ASCII art section
    const replacement = CUSTOM_ASCII_ART;
    newFile =
      newFile.slice(0, component.artStart) +
      replacement +
      newFile.slice(component.artEnd);
  }

  // Show diff for the first replacement
  if (sortedComponents.length > 0) {
    const first = sortedComponents[sortedComponents.length - 1];
    showDiff(oldFile, newFile, CUSTOM_ASCII_ART, first.artStart, first.artEnd);
  }

  return newFile;
};

/**
 * Change orange colors (#FF8800, #FFA500, etc.) to matrix green (#00FF41)
 */
export const writeMatrixGreenColors = (oldFile: string): string | null => {
  let newFile = oldFile;

  // Common orange color codes to replace with matrix green
  const colorReplacements: Array<[RegExp, string]> = [
    // Hex colors
    [/#FF8800/gi, '#00FF41'],
    [/#FFA500/gi, '#00FF41'],
    [/#FF9900/gi, '#00FF41'],
    [/#F90/gi, '#0F4'],
    [/#FA0/gi, '#0F4'],

    // RGB colors (match rgb(255, 136, 0) style)
    [/rgb\s*\(\s*255\s*,\s*136\s*,\s*0\s*\)/gi, 'rgb(0, 255, 65)'],
    [/rgb\s*\(\s*255\s*,\s*165\s*,\s*0\s*\)/gi, 'rgb(0, 255, 65)'],
    [/rgb\s*\(\s*255\s*,\s*153\s*,\s*0\s*\)/gi, 'rgb(0, 255, 65)'],

    // Terminal color codes (likely in chalk/ansi)
    [/\\x1b\[38;5;208m/g, '\\x1b[38;5;46m'], // Bright orange to bright green
    [/\\x1b\[38;5;214m/g, '\\x1b[38;5;46m'], // Orange to bright green
    [/\\u001b\[38;5;208m/g, '\\u001b[38;5;46m'],
    [/\\u001b\[38;5;214m/g, '\\u001b[38;5;46m'],
  ];

  let changedCount = 0;
  for (const [pattern, replacement] of colorReplacements) {
    const matches = newFile.match(pattern);
    if (matches) {
      changedCount += matches.length;
      newFile = newFile.replace(pattern, replacement);
    }
  }

  if (changedCount > 0) {
    console.log(
      `patch: matrixGreenColors: replaced ${changedCount} orange color references with matrix green`
    );
    return newFile;
  }

  return oldFile;
};
