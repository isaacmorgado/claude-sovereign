// Please see the note about writing patches in ./index

import { escapeIdent, showDiff } from './index';

// Models to inject/make available - COMPREHENSIVE MULTI-PROVIDER VERSION
// All models support tool calling via native support or emulation
// prettier-ignore
export const CUSTOM_MODELS: { value: string; label: string; description: string }[] = [
  // Anthropic (native) - Native tool calling âœ“
  { value: 'claude-opus-4-5-20251101',       label: 'Opus 4.5',               description: "Architecture & planning (87.0% GPQA, 80.9% SWE-bench). Best for system design." },
  { value: 'claude-sonnet-4-5-20250929',     label: 'Sonnet 4.5',             description: "Debugging & DevOps (77% SWE-bench). Best for fixing & infrastructure." },
  { value: 'claude-3-5-haiku-20241022',      label: 'Haiku 3.5',              description: "Fast responses. Best for quick tasks & iteration." },

  // GLM (ZhipuAI) - Native tool calling âœ“
  { value: 'glm/glm-4',                      label: 'ðŸŒ GLM-4',               description: "Agentic coding (87.4% Ï„Â²-Bench). Best for orchestration & building features." },
  { value: 'glm/glm-4-flash',                label: 'âš¡ GLM-4-Flash',         description: "Fast agentic tasks. Best for quick multi-step workflows." },
  { value: 'glm/glm-4-air',                  label: 'â˜ï¸ GLM-4-Air',           description: "Balanced agentic model. Best for moderate complexity tasks." },

  // Google Gemini - Native tool calling âœ“
  { value: 'google/gemini-pro',              label: 'ðŸ”· Gemini Pro',          description: "Deep research (91.9% GPQA, 1M tokens). Best for analysis & exploration." },
  { value: 'google/gemini-2.0-flash',        label: 'âš¡ Gemini 2.0 Flash',    description: "UI/UX design (1487 Elo WebDev). Best for frontend & visual generation." },

  // Featherless - Uncensored/Abliterated (Tool calling via emulation âœ“)
  { value: 'featherless/dphn/Dolphin-Mistral-24B-Venice-Edition',                label: 'ðŸ”“ Dolphin-3 (24B)',         description: "Security & RE. Best for pentesting, exploits & uncensored analysis." },
  { value: 'featherless/huihui-ai/Qwen2.5-72B-Instruct-abliterated',             label: 'ðŸ”“ Qwen 2.5 (72B)',          description: "Unrestricted Q&A (128K context). Best for uncensored research & synthesis." },
  { value: 'featherless/WhiteRabbitNeo/Llama-3-WhiteRabbitNeo-8B-v2.0',          label: 'ðŸ”“ WhiteRabbitNeo (8B)',     description: "Cybersecurity specialist. Best for vulnerability analysis & red teaming." },
  { value: 'featherless/failspy/llama-3-70B-Instruct-abliterated',               label: 'ðŸ”“ Llama-3 (70B)',           description: "Unrestricted coding. Best for uncensored implementation & edge cases." },
  { value: 'featherless/failspy/Meta-Llama-3-8B-Instruct-abliterated-v3',        label: 'ðŸ”“ Llama-3 (8B)',            description: "Fast uncensored. Best for quick unrestricted tasks." },
  { value: 'featherless/cognitivecomputations/Llama-3-8B-Instruct-abliterated-v2', label: 'ðŸ”“ Llama-3 v2 (8B)',        description: "Alternative abliterated. Best for diverse uncensored approaches." },
];

const findCustomModelListInsertionPoint = (
  fileContents: string
): { insertionIndex: number; modelListVar: string } | null => {
  // 1. Find the custom model push pattern
  const pushPattern =
    /\b([$\w]+)\.push\(\{value:[$\w]+,label:[$\w]+,description:"Custom model"\}\)/;
  const pushMatch = fileContents.match(pushPattern);
  if (!pushMatch || pushMatch.index === undefined) {
    console.error(
      'patch: findCustomModelListInsertionPoint: failed to find custom model push'
    );
    return null;
  }

  // 2. Extract the model list variable name
  const modelListVar = pushMatch[1];

  // 3. Look back 600 chars from the push match
  const searchStart = Math.max(0, pushMatch.index - 600);
  const chunk = fileContents.slice(searchStart, pushMatch.index);

  // 4. Find the LAST occurrence of the function with let modelListVar=...;
  const funcPattern = new RegExp(
    `function [$\\w]+\\(\\)\\{let ${escapeIdent(modelListVar)}=.+?;`,
    'g'
  );
  let lastMatch: RegExpExecArray | null = null;
  let match: RegExpExecArray | null;
  while ((match = funcPattern.exec(chunk)) !== null) {
    lastMatch = match;
  }

  if (!lastMatch) {
    console.error(
      `patch: findCustomModelListInsertionPoint: failed to find function with let ${modelListVar}`
    );
    return null;
  }

  // 5. Return index after the semicolon (end of the match), and the var name
  const insertionIndex = searchStart + lastMatch.index + lastMatch[0].length;
  return { insertionIndex, modelListVar };
};

export const writeModelCustomizations = (oldFile: string): string | null => {
  const found = findCustomModelListInsertionPoint(oldFile);
  if (!found) return null;

  const { insertionIndex, modelListVar } = found;

  // Build the injection: push each custom model onto the list
  const inject = CUSTOM_MODELS.map(
    model => `${modelListVar}.push(${JSON.stringify(model)});`
  ).join('');

  const newFile =
    oldFile.slice(0, insertionIndex) + inject + oldFile.slice(insertionIndex);
  showDiff(oldFile, newFile, inject, insertionIndex, insertionIndex);
  return newFile;
};
