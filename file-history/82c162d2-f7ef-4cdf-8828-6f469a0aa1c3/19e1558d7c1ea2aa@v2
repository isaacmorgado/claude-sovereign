// Custom status line patch
// Shows project directory and current model always visible

import { showDiff } from './index';

/**
 * Find the status line rendering code
 * Look for patterns like "Claude Max", "Sonnet", or version display
 */
const findStatusLineLocation = (oldFile: string): {
  startIndex: number;
  endIndex: number;
} | null => {
  // Look for the status line that shows model info
  // Pattern: search for text that contains model information
  const patterns = [
    // Look for concatenation of model name with dot separator
    /\s+\+\s*["']\s*Â·\s*["']\s*\+\s*/,
    // Look for "Claude Max" or similar tier text
    /["']Claude\s+(Max|Pro|Haiku|Sonnet|Opus)["']/i,
    // Look for the Sonnet/Opus/Haiku version pattern
    /(Sonnet|Opus|Haiku)\s+[\d.]+/i,
  ];

  for (const pattern of patterns) {
    const match = oldFile.match(pattern);
    if (match && match.index !== undefined) {
      // Found it, now find the surrounding function/component
      const lookbackStart = Math.max(0, match.index - 2000);
      const lookforwardEnd = Math.min(oldFile.length, match.index + 2000);

      return {
        startIndex: lookbackStart,
        endIndex: lookforwardEnd,
      };
    }
  }

  console.error('patch: customStatusLine: failed to find status line location');
  return null;
};

/**
 * Inject code to always show project directory and model
 * This modifies the status line component to include both pieces of information
 */
export const writeCustomStatusLine = (oldFile: string): string | null => {
  // Strategy: Find where the status line is rendered and ensure it shows:
  // 1. Project directory (always visible)
  // 2. Current model name

  // Look for the status bar component rendering
  // This is tricky without exact code, so we'll use a pattern match approach

  // First, try to find the "Conversation compacted" text which appears in the status
  const compactedPattern = /["']Conversation\s+compacted["']/;
  const compactedMatch = oldFile.match(compactedPattern);

  if (!compactedMatch || compactedMatch.index === undefined) {
    console.error(
      'patch: customStatusLine: failed to find status line reference'
    );
    return null;
  }

  // Get surrounding context
  const contextStart = Math.max(0, compactedMatch.index - 500);
  const contextEnd = Math.min(oldFile.length, compactedMatch.index + 500);
  const context = oldFile.slice(contextStart, contextEnd);

  // Look for the component that renders this
  // Pattern: function XYZ(){...}
  const functionPattern = /function\s+([$\w]+)\s*\([^)]*\)\s*\{/g;
  let match: RegExpExecArray | null;
  let relevantFunction: { name: string; start: number } | null = null;

  while ((match = functionPattern.exec(context)) !== null) {
    const absoluteIndex = contextStart + match.index;
    relevantFunction = {
      name: match[1],
      start: absoluteIndex,
    };
  }

  if (!relevantFunction) {
    console.error(
      'patch: customStatusLine: failed to find status line component function'
    );
    return null;
  }

  // For now, we'll inject a modification that enhances the status display
  // This is a placeholder - in practice, we'd need to parse the actual React component structure
  console.log(
    `patch: customStatusLine: found status component at ${relevantFunction.start}, manual inspection recommended`
  );

  // Return oldFile unchanged for now - this needs manual inspection of the extracted code
  return oldFile;
};

/**
 * Alternative approach: Inject custom status rendering by finding the StatusBar component
 */
export const writeAlwaysVisibleProjectInfo = (oldFile: string): string | null => {
  // Look for where project directory is conditionally shown
  // and make it always visible

  // Pattern: Look for conditional rendering of directory
  // Something like: condition ? directoryDisplay : null

  // This is a simplified version - actual implementation needs the extracted cli.js
  console.log('patch: alwaysVisibleProjectInfo: requires cli.js inspection');

  return oldFile;
};
