/**
 * UXP Plugin Fixes Test Suite
 *
 * Tests for critical bug fixes in the UXP plugin:
 * 1. seekToTime async bug (crash prevention)
 * 2. Uncaught promise rejections (response.text() handling)
 * 3. Memory leak in repetition preview (event listener cleanup)
 * 4. Race condition in operation flags (flag before async)
 * 5. Waveform zoom state reset
 * 6. Project cache TTL invalidation
 * 7. formatTime negative values
 */

const fs = require('fs');
const path = require('path');

const pluginPath = path.join(__dirname, '../../splice-plugin/js');
const mainJsPath = path.join(pluginPath, 'main.js');
const builderJsPath = path.join(pluginPath, 'builder.js');
const utilsJsPath = path.join(pluginPath, 'utils.js');

let mainJs = '';
let builderJs = '';
let utilsJs = '';

// Load files
try {
  mainJs = fs.readFileSync(mainJsPath, 'utf8');
  builderJs = fs.readFileSync(builderJsPath, 'utf8');
  utilsJs = fs.readFileSync(utilsJsPath, 'utf8');
} catch (err) {
  console.error('Failed to load plugin files:', err.message);
  process.exit(1);
}

// Test results tracking
let passed = 0;
let failed = 0;

function test(name, condition) {
  if (condition) {
    console.log(`  \u2713 ${name}`);
    passed++;
  } else {
    console.log(`  \u2717 ${name}`);
    failed++;
  }
}

console.log('=== UXP Plugin Fixes Test Suite ===\n');

// ============================================================================
// FIX 1: seekToTime Async Bug (CRASH)
// ============================================================================
console.log('FIX 1: seekToTime Async Bug');

test('seekToTime is declared as async function',
  /async\s+function\s+seekToTime/.test(mainJs));

test('seekToTime awaits getActiveSequence()',
  /await\s+getActiveSequence\(\)/.test(mainJs));

test('seekToTime destructures sequence from context',
  mainJs.includes('const { sequence } = context') ||
  mainJs.includes('const {sequence} = context'));

test('seekToTime uses TickTime.createWithSeconds for position',
  mainJs.includes('TickTime.createWithSeconds(seconds)') ||
  mainJs.includes('ppro.TickTime.createWithSeconds(seconds)'));

test('seekToTime awaits setPlayerPosition call',
  /await\s+sequence\.setPlayerPosition\(position\)/.test(mainJs));

// ============================================================================
// FIX 2: Uncaught Promise Rejections
// ============================================================================
console.log('\nFIX 2: Uncaught Promise Rejections');

test('parseErrorResponse receives Response object, not response.text()',
  !mainJs.includes('parseErrorResponse(await response.text())'));

test('fetchZoomPoints uses await parseErrorResponse(response)',
  /await\s+parseErrorResponse\(response\)/.test(mainJs));

test('fetchChapters uses await parseErrorResponse(response)',
  mainJs.includes('Zoom generation failed') &&
  /const\s+errorMsg\s*=\s*await\s+parseErrorResponse\(response\)/.test(mainJs));

test('No direct response.text() passed to parseErrorResponse anywhere',
  (mainJs.match(/parseErrorResponse\(await\s+response\.text\(\)\)/g) || []).length === 0);

// ============================================================================
// FIX 3: Memory Leak in Repetition Preview
// ============================================================================
console.log('\nFIX 3: Memory Leak in Repetition Preview');

test('renderRepetitionPreview clones preview element to remove old listeners',
  mainJs.includes('cloneNode(false)'));

test('Uses replaceChild to swap old element with clean clone',
  mainJs.includes('parentNode.replaceChild'));

test('New event listeners added to newPreview (not old preview)',
  mainJs.includes('newPreview.querySelectorAll'));

test('newPreview.innerHTML is set (not preview.innerHTML)',
  mainJs.includes('newPreview.innerHTML = html'));

// ============================================================================
// FIX 4: Race Condition in Operation Flags
// ============================================================================
console.log('\nFIX 4: Race Condition in Operation Flags');

// Find the goBtn click handler section
const goBtnHandler = mainJs.substring(
  mainJs.indexOf("ui.goBtn.addEventListener('click'"),
  mainJs.indexOf("ui.goBtn.addEventListener('click'") + 800
);

test('isOperationInProgress check comes first in GO button handler',
  /if\s*\(\s*isOperationInProgress\s*\)/.test(goBtnHandler));

test('isOperationInProgress set to true BEFORE isOnline check',
  goBtnHandler.indexOf('isOperationInProgress = true') < goBtnHandler.indexOf('isOnline()'));

test('goBtn disabled BEFORE isOnline check',
  goBtnHandler.indexOf('ui.goBtn.disabled = true') < goBtnHandler.indexOf('isOnline()'));

test('isOperationInProgress reset in offline early return',
  /isOnline\(\).*isOperationInProgress\s*=\s*false/s.test(goBtnHandler));

test('goBtn re-enabled in offline early return',
  /isOnline\(\).*ui\.goBtn\.disabled\s*=\s*false/s.test(goBtnHandler));

// ============================================================================
// FIX 5: Waveform Zoom State Not Reset
// ============================================================================
console.log('\nFIX 5: Waveform Zoom State Reset');

// Find fetchWaveformData function
const fetchWaveformStart = mainJs.indexOf('async function fetchWaveformData');
const fetchWaveformEnd = mainJs.indexOf('async function', fetchWaveformStart + 1);
const fetchWaveformSection = mainJs.substring(fetchWaveformStart, fetchWaveformEnd > 0 ? fetchWaveformEnd : fetchWaveformStart + 500);

test('fetchWaveformData resets waveformZoom to 1',
  fetchWaveformSection.includes('waveformZoom = 1'));

test('fetchWaveformData resets waveformOffset to 0',
  fetchWaveformSection.includes('waveformOffset = 0'));

test('Zoom reset happens before try block',
  fetchWaveformSection.indexOf('waveformZoom = 1') < fetchWaveformSection.indexOf('try {'));

test('Offset reset happens before try block',
  fetchWaveformSection.indexOf('waveformOffset = 0') < fetchWaveformSection.indexOf('try {'));

// ============================================================================
// FIX 6: Project Cache TTL Invalidation
// ============================================================================
console.log('\nFIX 6: Project Cache TTL Invalidation');

test('PROJECT_CACHE_TTL_MS constant is defined',
  builderJs.includes('PROJECT_CACHE_TTL_MS'));

test('TTL is set to 5 minutes (300000ms)',
  builderJs.includes('5 * 60 * 1000') || builderJs.includes('300000'));

test('projectItemCache has buildTime property',
  builderJs.includes('buildTime:') || builderJs.includes('buildTime ='));

test('isCacheValid function exists',
  builderJs.includes('function isCacheValid()'));

test('isCacheValid checks buildTime exists',
  /isCacheValid[\s\S]*?buildTime/.test(builderJs));

test('isCacheValid compares age to TTL',
  /isCacheValid[\s\S]*?PROJECT_CACHE_TTL_MS/.test(builderJs));

test('buildProjectItemCache sets buildTime',
  /buildProjectItemCache[\s\S]*?buildTime\s*=\s*Date\.now\(\)/.test(builderJs));

test('clearProjectItemCache resets buildTime to 0',
  /clearProjectItemCache[\s\S]*?buildTime\s*=\s*0/.test(builderJs));

test('findProjectItemByName checks isCacheValid()',
  /findProjectItemByName[\s\S]*?isCacheValid\(\)/.test(builderJs));

test('findProjectItemByPath checks isCacheValid()',
  /findProjectItemByPath[\s\S]*?isCacheValid\(\)/.test(builderJs));

// ============================================================================
// FIX 7: formatTime Negative Values
// ============================================================================
console.log('\nFIX 7: formatTime Negative Values');

test('formatTime uses Math.abs for absolute seconds',
  utilsJs.includes('Math.abs'));

test('formatTime checks for negative values',
  utilsJs.includes('seconds < 0') || utilsJs.includes('isNegative'));

test('formatTime stores negative flag',
  utilsJs.includes('isNegative'));

test('formatTime calculates minutes from absolute value',
  utilsJs.includes('absSeconds') && utilsJs.includes('Math.floor'));

test('formatTime prepends minus sign for negative values',
  utilsJs.includes("-${formatted}") || utilsJs.includes("'-' + formatted"));

// Test the actual formatTime logic by parsing the function
const formatTimeMatch = utilsJs.match(/function formatTime\(seconds\)\s*\{([\s\S]*?)\n\}/);
if (formatTimeMatch) {
  const formatTimeBody = formatTimeMatch[1];

  test('formatTime handles negative values correctly (implementation)',
    formatTimeBody.includes('isNegative') &&
    formatTimeBody.includes('Math.abs') &&
    formatTimeBody.includes('isNegative ?'));
}

// ============================================================================
// Additional Robustness Tests
// ============================================================================
console.log('\nAdditional Robustness Tests');

test('main.js uses try-catch in seekToTime',
  mainJs.includes('function seekToTime') &&
  /seekToTime[\s\S]*?try\s*\{[\s\S]*?catch/.test(mainJs));

test('utils.js formatTime validates input type',
  utilsJs.includes("typeof seconds !== 'number'"));

test('utils.js formatTime handles NaN',
  utilsJs.includes('isNaN(seconds)'));

test('builder.js exports isCacheValid or TTL is internal only',
  builderJs.includes('isCacheValid') || builderJs.includes('PROJECT_CACHE_TTL_MS'));

test('builder.js clearProjectItemCache is exported',
  builderJs.includes('clearProjectItemCache'));

// ============================================================================
// Results Summary
// ============================================================================
console.log('\n=== Results ===');
console.log(`Passed: ${passed}`);
console.log(`Failed: ${failed}`);
console.log(`Total: ${passed + failed}`);

if (failed > 0) {
  console.log('\nSome tests failed. Please review the fixes.');
  process.exit(1);
} else {
  console.log('\nAll UXP plugin fixes verified successfully!');
  process.exit(0);
}
