import * as vscode from "vscode"
import * as path from "path"
import * as fs from "fs/promises"

import bundledServersConfig from "./bundled-servers.json"

/**
 * Extended server configuration that includes bundled server metadata
 */
export interface BundledServerConfig {
	type: "stdio" | "sse" | "streamable-http"
	command?: string
	args?: string[]
	env?: Record<string, string>
	url?: string
	headers?: Record<string, string>
	disabled: boolean
	description?: string
	documentation?: string
	alwaysAllow?: string[]
	disabledTools?: string[]
	timeout?: number
}

export interface BundledServersConfig {
	[serverName: string]: BundledServerConfig
}

/**
 * Manages bundled MCP servers that ship with the extension.
 * These servers are auto-registered but disabled by default.
 * Users can enable them through settings or the MCP panel.
 */
export class BundledMcpManager {
	private static instance: BundledMcpManager | null = null
	private context: vscode.ExtensionContext
	private bundledServers: BundledServersConfig

	private constructor(context: vscode.ExtensionContext) {
		this.context = context
		this.bundledServers = bundledServersConfig as BundledServersConfig
	}

	/**
	 * Get the singleton instance of BundledMcpManager
	 */
	static getInstance(context: vscode.ExtensionContext): BundledMcpManager {
		if (!BundledMcpManager.instance) {
			BundledMcpManager.instance = new BundledMcpManager(context)
		}
		return BundledMcpManager.instance
	}

	/**
	 * Check if BundledMcpManager has been initialized
	 */
	static hasInstance(): boolean {
		return BundledMcpManager.instance !== null
	}

	/**
	 * Get the bundled server configurations
	 * These are returned with bundled metadata stripped (description, documentation)
	 * to match the expected McpHub server config format
	 */
	getBundledServers(): Record<string, any> {
		const servers: Record<string, any> = {}

		for (const [name, config] of Object.entries(this.bundledServers)) {
			// Strip bundled-specific metadata that McpHub doesn't understand
			const { description, documentation, ...serverConfig } = config
			servers[name] = {
				...serverConfig,
				// Mark as bundled for identification
				_bundled: true,
			}
		}

		return servers
	}

	/**
	 * Get bundled server metadata (description, documentation URL)
	 */
	getBundledServerMetadata(serverName: string): { description?: string; documentation?: string } | null {
		const config = this.bundledServers[serverName]
		if (!config) return null

		return {
			description: config.description,
			documentation: config.documentation,
		}
	}

	/**
	 * Get all bundled server names
	 */
	getBundledServerNames(): string[] {
		return Object.keys(this.bundledServers)
	}

	/**
	 * Check if a server name is a bundled server
	 */
	isBundledServer(serverName: string): boolean {
		return serverName in this.bundledServers
	}

	/**
	 * Get secret key for a bundled server's environment variable
	 * This parses ${secret:key_name} patterns from the bundled config
	 */
	getRequiredSecrets(serverName: string): string[] {
		const config = this.bundledServers[serverName]
		if (!config || !config.env) return []

		const secrets: string[] = []
		const secretPattern = /\$\{secret:(\w+)\}/g

		for (const value of Object.values(config.env)) {
			let match
			while ((match = secretPattern.exec(value)) !== null) {
				secrets.push(match[1])
			}
		}

		return secrets
	}

	/**
	 * Store a secret for a bundled MCP server
	 */
	async storeSecret(key: string, value: string): Promise<void> {
		await this.context.secrets.store(key, value)
	}

	/**
	 * Get a secret for a bundled MCP server
	 */
	async getSecret(key: string): Promise<string | undefined> {
		return await this.context.secrets.get(key)
	}

	/**
	 * Delete a secret for a bundled MCP server
	 */
	async deleteSecret(key: string): Promise<void> {
		await this.context.secrets.delete(key)
	}

	/**
	 * Check if all required secrets for a server are configured
	 */
	async hasRequiredSecrets(serverName: string): Promise<boolean> {
		const requiredSecrets = this.getRequiredSecrets(serverName)
		for (const secretKey of requiredSecrets) {
			const secret = await this.getSecret(secretKey)
			if (!secret) return false
		}
		return true
	}

	/**
	 * Merge bundled servers with user servers
	 * User servers take precedence over bundled servers
	 */
	mergeBundledWithUserServers(userServers: Record<string, any>): Record<string, any> {
		const bundled = this.getBundledServers()
		const merged: Record<string, any> = {}

		// Add bundled servers first
		for (const [name, config] of Object.entries(bundled)) {
			merged[name] = config
		}

		// User servers override bundled servers
		for (const [name, config] of Object.entries(userServers)) {
			merged[name] = config
		}

		return merged
	}

	/**
	 * Get VS Code extension context
	 */
	getContext(): vscode.ExtensionContext {
		return this.context
	}

	/**
	 * Cleanup the singleton instance
	 */
	static cleanup(): void {
		BundledMcpManager.instance = null
	}
}
