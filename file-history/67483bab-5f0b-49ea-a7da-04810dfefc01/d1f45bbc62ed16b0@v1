import { EventEmitter } from "events"
import type { AutomationDefinition, AutomationTrigger, TriggerContext } from "@multi-agent/types"

export interface TriggerEventPayload {
	triggerId: string
	automationId: string
	context: Partial<TriggerContext>
}

export interface BaseTriggerOptions {
	automationId: string
	workspacePath: string
	trigger: AutomationTrigger
}

/**
 * Abstract base class for all automation triggers.
 * Subclasses implement specific trigger logic (file watcher, cron, git hooks).
 */
export abstract class BaseTrigger extends EventEmitter {
	protected readonly id: string
	protected readonly automationId: string
	protected readonly workspacePath: string
	protected readonly config: AutomationTrigger
	protected isRunning: boolean = false
	protected lastTriggered?: number

	constructor(options: BaseTriggerOptions) {
		super()
		this.id = `trigger-${options.automationId}-${Date.now()}`
		this.automationId = options.automationId
		this.workspacePath = options.workspacePath
		this.config = options.trigger
	}

	/**
	 * Start the trigger (begin watching for events)
	 */
	abstract start(): Promise<void>

	/**
	 * Stop the trigger (cleanup resources)
	 */
	abstract stop(): Promise<void>

	/**
	 * Get the trigger type
	 */
	abstract get type(): string

	/**
	 * Check if the trigger is currently active
	 */
	get isActive(): boolean {
		return this.isRunning
	}

	/**
	 * Get the trigger ID
	 */
	get triggerId(): string {
		return this.id
	}

	/**
	 * Get the last trigger time
	 */
	get lastTriggerTime(): number | undefined {
		return this.lastTriggered
	}

	/**
	 * Emit a trigger event
	 * Called by subclasses when their specific condition is met
	 */
	protected emitTrigger(context: Partial<TriggerContext>): void {
		this.lastTriggered = Date.now()
		const payload: TriggerEventPayload = {
			triggerId: this.id,
			automationId: this.automationId,
			context: {
				...context,
				triggerId: this.id,
				automationId: this.automationId,
				triggerType: this.config.type,
				timestamp: this.lastTriggered,
				workspacePath: this.workspacePath,
			},
		}
		this.emit("triggered", payload)
	}

	/**
	 * Dispose of the trigger (alias for stop)
	 */
	async dispose(): Promise<void> {
		await this.stop()
		this.removeAllListeners()
	}
}
