import type {
	AutomationDefinition,
	AutomationExecutionResult,
	TriggerContext,
	AutomationAction,
} from "@multi-agent/types"
import type { TaskProviderLike, MultiAgentSettings } from "@multi-agent/types"
import { TriggerEventPayload } from "./triggers/BaseTrigger"

/**
 * Executes automation actions by creating tasks via the TaskProvider.
 */
export class AutomationExecutor {
	private taskProvider: TaskProviderLike
	private executionHistory: Map<string, AutomationExecutionResult[]> = new Map()
	private maxHistoryPerAutomation = 100

	constructor(taskProvider: TaskProviderLike) {
		this.taskProvider = taskProvider
	}

	/**
	 * Update the task provider reference
	 */
	setTaskProvider(taskProvider: TaskProviderLike): void {
		this.taskProvider = taskProvider
	}

	/**
	 * Execute an automation action
	 */
	async execute(
		automation: AutomationDefinition,
		triggerPayload: TriggerEventPayload
	): Promise<AutomationExecutionResult> {
		const startTime = Date.now()
		const triggerContext: TriggerContext = {
			triggerId: triggerPayload.triggerId,
			automationId: automation.id,
			triggerType: automation.trigger.type,
			timestamp: triggerPayload.context.timestamp || startTime,
			workspacePath: triggerPayload.context.workspacePath || this.taskProvider.cwd,
			file: triggerPayload.context.file,
			event: triggerPayload.context.event,
			branch: triggerPayload.context.branch,
			commit: triggerPayload.context.commit,
		}

		try {
			// Interpolate variables in the prompt
			const prompt = this.interpolateVariables(automation.action.prompt, triggerContext)

			// Build configuration for the task
			const configuration: Partial<MultiAgentSettings> = {}

			if (automation.action.mode) {
				;(configuration as any).mode = automation.action.mode
			}

			if (automation.action.providerProfile) {
				;(configuration as any).currentApiConfigName = automation.action.providerProfile
			}

			if (automation.action.autoApprove !== undefined) {
				;(configuration as any).autoApprovalEnabled = automation.action.autoApprove
			}

			// Create the task with automation metadata
			const task = await this.taskProvider.createTask(
				prompt,
				undefined, // images
				undefined, // parentTask
				{
					automationId: automation.id,
					automationSource: automation.trigger.type,
					triggerContext,
				},
				configuration as MultiAgentSettings
			)

			const result: AutomationExecutionResult = {
				automationId: automation.id,
				taskId: task.taskId,
				success: true,
				startTime,
				endTime: Date.now(),
				triggerContext,
			}

			this.recordExecution(automation.id, result)
			return result
		} catch (error) {
			const result: AutomationExecutionResult = {
				automationId: automation.id,
				success: false,
				error: error instanceof Error ? error.message : String(error),
				startTime,
				endTime: Date.now(),
				triggerContext,
			}

			this.recordExecution(automation.id, result)
			return result
		}
	}

	/**
	 * Interpolate template variables in the prompt
	 */
	private interpolateVariables(prompt: string, context: TriggerContext): string {
		let result = prompt

		// Built-in variables
		const variables: Record<string, string> = {
			triggerFile: context.file || "",
			triggerEvent: context.event || "",
			triggerTime: new Date(context.timestamp).toISOString(),
			workspacePath: context.workspacePath,
			branch: context.branch || "",
			commit: context.commit || "",
		}

		// Replace all {{variable}} patterns
		for (const [key, value] of Object.entries(variables)) {
			const pattern = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`, "g")
			result = result.replace(pattern, value)
		}

		return result
	}

	/**
	 * Record an execution in history
	 */
	private recordExecution(automationId: string, result: AutomationExecutionResult): void {
		const history = this.executionHistory.get(automationId) || []
		history.push(result)

		// Keep only the last N executions
		if (history.length > this.maxHistoryPerAutomation) {
			history.shift()
		}

		this.executionHistory.set(automationId, history)
	}

	/**
	 * Get execution history for an automation
	 */
	getExecutionHistory(automationId: string): AutomationExecutionResult[] {
		return this.executionHistory.get(automationId) || []
	}

	/**
	 * Get the last execution result for an automation
	 */
	getLastExecution(automationId: string): AutomationExecutionResult | undefined {
		const history = this.executionHistory.get(automationId)
		return history ? history[history.length - 1] : undefined
	}

	/**
	 * Clear execution history
	 */
	clearHistory(automationId?: string): void {
		if (automationId) {
			this.executionHistory.delete(automationId)
		} else {
			this.executionHistory.clear()
		}
	}
}
