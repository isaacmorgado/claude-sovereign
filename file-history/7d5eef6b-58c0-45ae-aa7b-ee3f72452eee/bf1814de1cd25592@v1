/**
 * SPLICE CEP Text Editor Module
 *
 * Provides UI for text-based video editing.
 * Edit video by editing the transcript text.
 * Delete text to delete video, reorder paragraphs to reorder video.
 */

// ============================================================================
// STATE
// ============================================================================

const textEditorState = {
  originalTranscript: null,
  editableTranscript: null,
  currentText: '',
  undoStack: [],
  redoStack: [],
  searchResults: [],
  currentSearchIndex: -1,
  isDirty: false,
  isProcessing: false,
  previewChanges: null,
  lastCutList: null
};

// Maximum undo history size
const MAX_UNDO_STACK = 50;

// ============================================================================
// DOM ELEMENT CACHE
// ============================================================================

const textEditorElements = {
  panel: null,
  content: null,
  status: null,
  wordCount: null,
  dirtyIndicator: null,
  undoBtn: null,
  redoBtn: null,
  applyBtn: null,
  previewBtn: null,
  resetBtn: null,
  buildBtn: null,
  searchInput: null,
  searchBtn: null,
  searchNextBtn: null,
  searchPrevBtn: null,
  searchResults: null,
  replaceInput: null,
  replaceBtn: null,
  replaceAllBtn: null,
  previewContainer: null
};

/**
 * Cache DOM elements for text editor
 */
function cacheTextEditorElements() {
  textEditorElements.panel = document.getElementById('text-editor-panel');
  textEditorElements.content = document.getElementById('text-editor-content');
  textEditorElements.status = document.getElementById('text-editor-status');
  textEditorElements.wordCount = document.getElementById('text-editor-word-count');
  textEditorElements.dirtyIndicator = document.getElementById('text-editor-dirty');
  textEditorElements.undoBtn = document.getElementById('text-editor-undo-btn');
  textEditorElements.redoBtn = document.getElementById('text-editor-redo-btn');
  textEditorElements.applyBtn = document.getElementById('apply-text-edits-btn');
  textEditorElements.previewBtn = document.getElementById('preview-text-edits-btn');
  textEditorElements.resetBtn = document.getElementById('text-editor-reset-btn');
  textEditorElements.buildBtn = document.getElementById('text-editor-build-btn');
  textEditorElements.searchInput = document.getElementById('text-search-input');
  textEditorElements.searchBtn = document.getElementById('text-search-btn');
  textEditorElements.searchNextBtn = document.getElementById('text-search-next-btn');
  textEditorElements.searchPrevBtn = document.getElementById('text-search-prev-btn');
  textEditorElements.searchResults = document.getElementById('text-search-results');
  textEditorElements.replaceInput = document.getElementById('text-replace-input');
  textEditorElements.replaceBtn = document.getElementById('text-replace-btn');
  textEditorElements.replaceAllBtn = document.getElementById('text-replace-all-btn');
  textEditorElements.previewContainer = document.getElementById('text-editor-preview');
}

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize text editor module
 */
function initTextEditor() {
  console.log('[SPLICE] Initializing text editor module');

  // Cache elements
  cacheTextEditorElements();

  // Setup event listeners
  setupTextEditorListeners();

  // Setup keyboard shortcuts
  setupKeyboardShortcuts();

  console.log('[SPLICE] Text editor module initialized');
}

/**
 * Setup event listeners for text editor
 */
function setupTextEditorListeners() {
  // Text area input - using event delegation
  document.addEventListener('input', (e) => {
    if (e.target.id === 'text-editor-content') {
      handleTextChange(e.target.value);
    }
  });

  // Button clicks - using event delegation
  document.addEventListener('click', (e) => {
    const id = e.target.id;

    switch (id) {
      case 'apply-text-edits-btn':
        applyTextEdits();
        break;
      case 'preview-text-edits-btn':
        previewTextEdits();
        break;
      case 'text-editor-undo-btn':
        undoTextEdit();
        break;
      case 'text-editor-redo-btn':
        redoTextEdit();
        break;
      case 'text-search-btn':
        searchInTranscript();
        break;
      case 'text-search-next-btn':
        navigateSearchResult(1);
        break;
      case 'text-search-prev-btn':
        navigateSearchResult(-1);
        break;
      case 'text-replace-btn':
        replaceInTranscript();
        break;
      case 'text-replace-all-btn':
        replaceAllInTranscript();
        break;
      case 'text-editor-reset-btn':
        resetToOriginal();
        break;
      case 'text-editor-build-btn':
        buildSequenceFromEdits();
        break;
    }

    // Toggle panel collapse
    if (e.target.closest('.text-editor-header')) {
      const panel = document.getElementById('text-editor-panel');
      if (panel) {
        panel.classList.toggle('collapsed');
      }
    }
  });

  // Search input enter key
  document.addEventListener('keypress', (e) => {
    if (e.target.id === 'text-search-input' && e.key === 'Enter') {
      e.preventDefault();
      searchInTranscript();
    }
  });
}

/**
 * Setup keyboard shortcuts
 */
function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Only handle if text editor is focused
    const editorContent = textEditorElements.content || document.getElementById('text-editor-content');
    if (!editorContent || document.activeElement !== editorContent) return;

    // Ctrl/Cmd + Z = Undo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
      e.preventDefault();
      undoTextEdit();
    }

    // Ctrl/Cmd + Shift + Z or Ctrl/Cmd + Y = Redo
    if ((e.ctrlKey || e.metaKey) && (e.key === 'Z' || e.key === 'y')) {
      e.preventDefault();
      redoTextEdit();
    }

    // Ctrl/Cmd + F = Focus search
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
      e.preventDefault();
      const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
      if (searchInput) searchInput.focus();
    }
  });
}

// ============================================================================
// TRANSCRIPT LOADING
// ============================================================================

/**
 * Load transcript into text editor
 * @param {Object} transcript - Transcript from main module
 */
async function loadTranscriptIntoEditor(transcript) {
  if (!transcript) {
    showTextEditorStatus('No transcript available', 'error');
    return;
  }

  textEditorState.isProcessing = true;
  updateProcessingState(true);
  showTextEditorStatus('Preparing editable transcript...', 'info');

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const response = await fetchFn(`${backendUrl}/text-edit/prepare`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ transcript })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Failed to prepare transcript');
    }

    const data = await response.json();

    // Store original and editable transcripts
    textEditorState.originalTranscript = transcript;
    textEditorState.editableTranscript = data.editableTranscript;
    textEditorState.currentText = data.editableTranscript.plainText;
    textEditorState.isDirty = false;
    textEditorState.undoStack = [];
    textEditorState.redoStack = [];
    textEditorState.lastCutList = null;

    // Render editor
    renderTextEditor();

    showTextEditorStatus(`Loaded ${data.editableTranscript.totalWords} words`, 'success');

  } catch (err) {
    console.error('[SPLICE] Text editor load error:', err);
    showTextEditorStatus(err.message, 'error');
  } finally {
    textEditorState.isProcessing = false;
    updateProcessingState(false);
  }
}

// ============================================================================
// TEXT EDITING
// ============================================================================

/**
 * Handle text changes in editor
 */
function handleTextChange(newText) {
  // Save current state to undo stack
  if (textEditorState.currentText !== newText) {
    textEditorState.undoStack.push(textEditorState.currentText);
    textEditorState.redoStack = []; // Clear redo stack on new edit

    // Limit undo stack size
    if (textEditorState.undoStack.length > MAX_UNDO_STACK) {
      textEditorState.undoStack.shift();
    }
  }

  textEditorState.currentText = newText;
  textEditorState.isDirty = true;
  textEditorState.previewChanges = null; // Clear preview

  updateEditorStatus();
}

/**
 * Undo last text edit
 */
function undoTextEdit() {
  if (textEditorState.undoStack.length === 0) {
    showTextEditorStatus('Nothing to undo', 'info');
    return;
  }

  // Save current to redo stack
  textEditorState.redoStack.push(textEditorState.currentText);

  // Restore from undo stack
  textEditorState.currentText = textEditorState.undoStack.pop();

  // Update editor content
  const editor = textEditorElements.content || document.getElementById('text-editor-content');
  if (editor) {
    editor.value = textEditorState.currentText;
  }

  updateEditorStatus();
  showTextEditorStatus('Undo applied', 'info');
}

/**
 * Redo last undone edit
 */
function redoTextEdit() {
  if (textEditorState.redoStack.length === 0) {
    showTextEditorStatus('Nothing to redo', 'info');
    return;
  }

  // Save current to undo stack
  textEditorState.undoStack.push(textEditorState.currentText);

  // Restore from redo stack
  textEditorState.currentText = textEditorState.redoStack.pop();

  // Update editor content
  const editor = textEditorElements.content || document.getElementById('text-editor-content');
  if (editor) {
    editor.value = textEditorState.currentText;
  }

  updateEditorStatus();
  showTextEditorStatus('Redo applied', 'info');
}

/**
 * Reset to original transcript
 */
function resetToOriginal() {
  if (!textEditorState.editableTranscript) return;

  // Save current to undo
  if (textEditorState.isDirty) {
    textEditorState.undoStack.push(textEditorState.currentText);
  }

  textEditorState.currentText = textEditorState.editableTranscript.plainText;
  textEditorState.isDirty = false;
  textEditorState.previewChanges = null;

  const editor = textEditorElements.content || document.getElementById('text-editor-content');
  if (editor) {
    editor.value = textEditorState.currentText;
  }

  updateEditorStatus();
  showTextEditorStatus('Reset to original', 'success');
}

// ============================================================================
// PREVIEW AND APPLY
// ============================================================================

/**
 * Preview text edits without applying
 */
async function previewTextEdits() {
  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
    showTextEditorStatus('No changes to preview', 'info');
    return;
  }

  textEditorState.isProcessing = true;
  updateProcessingState(true);
  showTextEditorStatus('Generating preview...', 'info');

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const response = await fetchFn(`${backendUrl}/text-edit/preview`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        transcript: textEditorState.editableTranscript,
        editedText: textEditorState.currentText
      })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Preview failed');
    }

    const data = await response.json();
    textEditorState.previewChanges = data;

    renderPreview(data);
    showTextEditorStatus(`Preview: ${data.changes.length} changes`, 'success');

  } catch (err) {
    console.error('[SPLICE] Text edit preview error:', err);
    showTextEditorStatus(err.message, 'error');
  } finally {
    textEditorState.isProcessing = false;
    updateProcessingState(false);
  }
}

/**
 * Render preview of changes
 */
function renderPreview(preview) {
  const container = textEditorElements.previewContainer || document.getElementById('text-editor-preview');
  if (!container) return;

  if (!preview.changes || preview.changes.length === 0) {
    container.innerHTML = '<div class="preview-empty">No changes detected</div>';
    return;
  }

  // SECURITY: Escape user-provided content to prevent XSS
  const html = `
    <div class="preview-summary">
      <span class="preview-stat">${escapeHtml(preview.summary.deletions)} deletions</span>
      <span class="preview-stat">${escapeHtml(preview.summary.reorderings)} reorders</span>
      <span class="preview-stat">${escapeHtml(preview.impact.percentageRemoved)}% removed</span>
    </div>
    <div class="preview-changes">
      ${preview.changes.map(change => `
        <div class="preview-change preview-change-${escapeHtml(change.type)}">
          <span class="change-type">${escapeHtml(change.type)}</span>
          <span class="change-desc">${escapeHtml(change.description)}</span>
          <span class="change-time">${escapeHtml(change.timeRange)}</span>
        </div>
      `).join('')}
    </div>
  `;

  container.innerHTML = html;
}

/**
 * Apply text edits and generate cut list
 */
async function applyTextEdits() {
  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
    showTextEditorStatus('No changes to apply', 'info');
    return;
  }

  textEditorState.isProcessing = true;
  updateProcessingState(true);
  showTextEditorStatus('Applying edits...', 'info');

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    // Apply edits
    const applyResponse = await fetchFn(`${backendUrl}/text-edit/apply`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        transcript: textEditorState.editableTranscript,
        editedText: textEditorState.currentText
      })
    });

    if (!applyResponse.ok) {
      const err = await applyResponse.json();
      throw new Error(err.error || 'Apply failed');
    }

    const applyData = await applyResponse.json();

    // Generate cut list from operations
    const cutListResponse = await fetchFn(`${backendUrl}/text-edit/cut-list`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        operations: applyData.operations,
        sourceInfo: {
          sourceName: textEditorState.originalTranscript?.source?.name || 'source',
          duration: textEditorState.editableTranscript.duration
        }
      })
    });

    if (!cutListResponse.ok) {
      const err = await cutListResponse.json();
      throw new Error(err.error || 'Cut list generation failed');
    }

    const cutListData = await cutListResponse.json();

    // Store cut list for building
    textEditorState.lastCutList = cutListData.cutList;

    // Update state
    textEditorState.isDirty = false;

    showTextEditorStatus(
      `Applied ${applyData.stats.deletions} cuts, ${cutListData.summary.segmentCount} segments`,
      'success'
    );

    // Show build button
    updateBuildButtonState(true);

  } catch (err) {
    console.error('[SPLICE] Text edit apply error:', err);
    showTextEditorStatus(err.message, 'error');
  } finally {
    textEditorState.isProcessing = false;
    updateProcessingState(false);
  }
}

/**
 * Build sequence from applied edits
 */
async function buildSequenceFromEdits() {
  if (!textEditorState.lastCutList) {
    showTextEditorStatus('No edits to build. Apply edits first.', 'error');
    return;
  }

  showTextEditorStatus('Building sequence...', 'info');

  try {
    // Use builder to create sequence (CEP version via JSX)
    if (window.spliceBuilder?.buildSequenceFromCutList) {
      const result = await window.spliceBuilder.buildSequenceFromCutList(textEditorState.lastCutList);
      if (result && result.success) {
        showTextEditorStatus('Sequence built successfully', 'success');
      } else {
        throw new Error(result?.error || 'Build failed');
      }
    } else if (typeof jsx !== 'undefined' && jsx.call) {
      // Fallback to direct JSX call
      const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(textEditorState.lastCutList));
      if (result && result.success) {
        showTextEditorStatus('Sequence built successfully', 'success');
      } else {
        throw new Error(result?.error || 'Build failed');
      }
    } else {
      showTextEditorStatus('Builder not available', 'error');
    }
  } catch (err) {
    console.error('[SPLICE] Build sequence error:', err);
    showTextEditorStatus(err.message, 'error');
  }
}

// ============================================================================
// SEARCH AND REPLACE
// ============================================================================

/**
 * Search in transcript
 */
async function searchInTranscript() {
  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
  const searchText = searchInput?.value?.trim();

  if (!searchText) {
    showTextEditorStatus('Enter search text', 'info');
    return;
  }

  if (!textEditorState.editableTranscript) {
    showTextEditorStatus('No transcript loaded', 'error');
    return;
  }

  try {
    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;

    const response = await fetchFn(`${backendUrl}/text-edit/search`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        transcript: textEditorState.editableTranscript,
        searchText
      })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Search failed');
    }

    const data = await response.json();
    textEditorState.searchResults = data.matches || [];
    textEditorState.currentSearchIndex = data.matches.length > 0 ? 0 : -1;

    highlightSearchResults();
    showTextEditorStatus(`Found ${data.totalMatches} matches`, 'success');

  } catch (err) {
    console.error('[SPLICE] Search error:', err);
    showTextEditorStatus(err.message, 'error');
  }
}

/**
 * Navigate search results
 */
function navigateSearchResult(direction) {
  if (textEditorState.searchResults.length === 0) {
    showTextEditorStatus('No search results', 'info');
    return;
  }

  textEditorState.currentSearchIndex += direction;

  // Wrap around
  if (textEditorState.currentSearchIndex >= textEditorState.searchResults.length) {
    textEditorState.currentSearchIndex = 0;
  } else if (textEditorState.currentSearchIndex < 0) {
    textEditorState.currentSearchIndex = textEditorState.searchResults.length - 1;
  }

  highlightCurrentResult();
  updateSearchResultsDisplay();
}

/**
 * Highlight search results in editor
 */
function highlightSearchResults() {
  // Update counter
  updateSearchResultsDisplay();

  if (textEditorState.currentSearchIndex >= 0) {
    highlightCurrentResult();
  }
}

/**
 * Highlight current search result
 */
function highlightCurrentResult() {
  const result = textEditorState.searchResults[textEditorState.currentSearchIndex];
  if (!result) return;

  // Scroll to result position in textarea
  const editor = textEditorElements.content || document.getElementById('text-editor-content');
  if (editor) {
    // Find text position and scroll
    const text = editor.value;
    const searchPos = text.toLowerCase().indexOf(result.text.toLowerCase());
    if (searchPos >= 0) {
      editor.setSelectionRange(searchPos, searchPos + result.text.length);
      editor.focus();
    }
  }

  // Show time info - use formatTime from config.js
  const timeStr = typeof formatTime === 'function' ? formatTime(result.start) : `${Math.floor(result.start)}s`;
  showTextEditorStatus(
    `Match ${textEditorState.currentSearchIndex + 1}/${textEditorState.searchResults.length} at ${timeStr}`,
    'info'
  );
}

/**
 * Update search results display
 */
function updateSearchResultsDisplay() {
  const display = textEditorElements.searchResults || document.getElementById('text-search-results');
  if (display) {
    const current = textEditorState.currentSearchIndex + 1;
    const total = textEditorState.searchResults.length;
    display.textContent = total > 0 ? `${current}/${total}` : '0/0';
  }
}

/**
 * Replace in transcript
 */
function replaceInTranscript() {
  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
  const replaceInput = textEditorElements.replaceInput || document.getElementById('text-replace-input');
  const searchText = searchInput?.value?.trim();
  const replaceText = replaceInput?.value || '';

  if (!searchText) {
    showTextEditorStatus('Enter search text', 'info');
    return;
  }

  // Replace first occurrence in current text
  const newText = textEditorState.currentText.replace(
    new RegExp(escapeRegex(searchText), 'i'),
    replaceText
  );

  if (newText !== textEditorState.currentText) {
    handleTextChange(newText);
    const editor = textEditorElements.content || document.getElementById('text-editor-content');
    if (editor) editor.value = newText;
    showTextEditorStatus('Replaced 1 occurrence', 'success');
  } else {
    showTextEditorStatus('No match found', 'info');
  }
}

/**
 * Replace all occurrences in transcript
 */
function replaceAllInTranscript() {
  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
  const replaceInput = textEditorElements.replaceInput || document.getElementById('text-replace-input');
  const searchText = searchInput?.value?.trim();
  const replaceText = replaceInput?.value || '';

  if (!searchText) {
    showTextEditorStatus('Enter search text', 'info');
    return;
  }

  const regex = new RegExp(escapeRegex(searchText), 'gi');
  const matches = textEditorState.currentText.match(regex);
  const count = matches ? matches.length : 0;

  if (count > 0) {
    const newText = textEditorState.currentText.replace(regex, replaceText);
    handleTextChange(newText);
    const editor = textEditorElements.content || document.getElementById('text-editor-content');
    if (editor) editor.value = newText;
    showTextEditorStatus(`Replaced ${count} occurrences`, 'success');
  } else {
    showTextEditorStatus('No matches found', 'info');
  }
}

/**
 * Escape special regex characters
 */
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ============================================================================
// UI RENDERING
// ============================================================================

/**
 * Render text editor content
 */
function renderTextEditor() {
  const container = textEditorElements.content || document.getElementById('text-editor-content');
  if (!container) return;

  container.value = textEditorState.currentText;
  updateEditorStatus();
}

/**
 * Update editor status display
 */
function updateEditorStatus() {
  const wordCount = textEditorElements.wordCount || document.getElementById('text-editor-word-count');
  const dirtyIndicator = textEditorElements.dirtyIndicator || document.getElementById('text-editor-dirty');
  const undoBtn = textEditorElements.undoBtn || document.getElementById('text-editor-undo-btn');
  const redoBtn = textEditorElements.redoBtn || document.getElementById('text-editor-redo-btn');

  if (wordCount) {
    const words = textEditorState.currentText.split(/\s+/).filter(w => w.length > 0);
    wordCount.textContent = `${words.length} words`;
  }

  if (dirtyIndicator) {
    dirtyIndicator.style.display = textEditorState.isDirty ? 'inline' : 'none';
  }

  if (undoBtn) {
    undoBtn.disabled = textEditorState.undoStack.length === 0;
  }

  if (redoBtn) {
    redoBtn.disabled = textEditorState.redoStack.length === 0;
  }
}

/**
 * Update processing state UI
 */
function updateProcessingState(isProcessing) {
  const panel = textEditorElements.panel || document.getElementById('text-editor-panel');
  if (panel) {
    const buttons = panel.querySelectorAll('button');
    buttons.forEach(btn => {
      if (!btn.classList.contains('always-enabled')) {
        btn.disabled = isProcessing;
      }
    });
  }

  const editor = textEditorElements.content || document.getElementById('text-editor-content');
  if (editor) {
    editor.disabled = isProcessing;
  }
}

/**
 * Update build button state
 */
function updateBuildButtonState(enabled) {
  const btn = textEditorElements.buildBtn || document.getElementById('text-editor-build-btn');
  if (btn) {
    btn.disabled = !enabled;
    if (enabled) {
      btn.classList.add('ready');
    } else {
      btn.classList.remove('ready');
    }
  }
}

/**
 * Show status message
 */
function showTextEditorStatus(message, type = 'info') {
  const statusEl = textEditorElements.status || document.getElementById('text-editor-status');
  if (!statusEl) return;

  statusEl.textContent = message;
  statusEl.className = `text-editor-status text-editor-status-${type}`;

  if (type !== 'error') {
    setTimeout(() => {
      statusEl.textContent = '';
      statusEl.className = 'text-editor-status';
    }, 5000);
  }
}

// ============================================================================
// EXPORTS
// ============================================================================

// Export for global access
window.spliceTextEditor = {
  init: initTextEditor,
  loadTranscript: loadTranscriptIntoEditor,
  applyEdits: applyTextEdits,
  previewEdits: previewTextEdits,
  undo: undoTextEdit,
  redo: redoTextEdit,
  reset: resetToOriginal,
  search: searchInTranscript,
  buildSequence: buildSequenceFromEdits,
  getState: () => ({ ...textEditorState })
};

// Also expose individual functions for direct access
window.initTextEditor = initTextEditor;
window.loadTranscriptIntoEditor = loadTranscriptIntoEditor;
