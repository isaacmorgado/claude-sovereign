/**
 * Security Test: Path Traversal Prevention
 *
 * Tests that path traversal vulnerabilities are properly mitigated
 * by using validatePath before file operations in xmlProcessor.js
 */

const fs = require('fs');
const path = require('path');
const assert = require('assert');

// Test counters
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

async function testAsync(name, fn) {
  try {
    await fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

function assertIncludes(source, pattern, message) {
  if (!source.includes(pattern)) {
    throw new Error(message || `Expected source to include: ${pattern}`);
  }
}

// Read source files
const xmlProcessorPath = path.join(__dirname, '../services/xmlProcessor.js');
const xmlProcessorSource = fs.readFileSync(xmlProcessorPath, 'utf8');

const securityUtilsPath = path.join(__dirname, '../services/securityUtils.js');
const securityUtilsSource = fs.readFileSync(securityUtilsPath, 'utf8');

console.log('\n╔═══════════════════════════════════════════════════════════════════╗');
console.log('║         SPLICE Security Test: Path Traversal Prevention          ║');
console.log('╚═══════════════════════════════════════════════════════════════════╝\n');

console.log('1. xmlProcessor.js Security Checks');
console.log('─'.repeat(50));

test('should import validatePath from securityUtils', () => {
  assertIncludes(xmlProcessorSource, "require('./securityUtils')", 'Should import from securityUtils');
  assertIncludes(xmlProcessorSource, 'validatePath', 'Should import validatePath');
});

test('loadFromFile should validate path before reading', () => {
  assertIncludes(xmlProcessorSource, 'async loadFromFile(filePath)', 'Should have loadFromFile method');
  // Check that validatePath is called in loadFromFile
  const loadFromFileMatch = xmlProcessorSource.match(/async loadFromFile\(filePath\)\s*\{[\s\S]*?^\s*\}/m);
  if (!loadFromFileMatch) {
    throw new Error('Could not find loadFromFile method');
  }
  assertIncludes(loadFromFileMatch[0], 'validatePath(filePath', 'Should call validatePath on input');
  assertIncludes(loadFromFileMatch[0], 'mustExist: true', 'Should require file to exist');
});

test('loadFromFile should restrict to XML extensions', () => {
  const loadFromFileMatch = xmlProcessorSource.match(/async loadFromFile\(filePath\)\s*\{[\s\S]*?^\s*\}/m);
  assertIncludes(loadFromFileMatch[0], "allowedExtensions:", 'Should have extension restriction');
  assertIncludes(loadFromFileMatch[0], "'.xml'", 'Should allow .xml extension');
  assertIncludes(loadFromFileMatch[0], "'.xmeml'", 'Should allow .xmeml extension');
});

test('loadFromFile should throw on invalid path', () => {
  const loadFromFileMatch = xmlProcessorSource.match(/async loadFromFile\(filePath\)\s*\{[\s\S]*?^\s*\}/m);
  assertIncludes(loadFromFileMatch[0], '!validation.valid', 'Should check validation result');
  assertIncludes(loadFromFileMatch[0], 'throw new Error', 'Should throw error on invalid path');
});

test('saveToFile should validate path before writing', () => {
  assertIncludes(xmlProcessorSource, 'async saveToFile(filePath)', 'Should have saveToFile method');
  // Check that validatePath is called in saveToFile
  const saveToFileMatch = xmlProcessorSource.match(/async saveToFile\(filePath\)\s*\{[\s\S]*?^\s*\}/m);
  if (!saveToFileMatch) {
    throw new Error('Could not find saveToFile method');
  }
  assertIncludes(saveToFileMatch[0], 'validatePath(filePath', 'Should call validatePath on output');
  assertIncludes(saveToFileMatch[0], 'mustExist: false', 'Should not require output file to exist');
});

test('saveToFile should restrict to XML extensions', () => {
  const saveToFileMatch = xmlProcessorSource.match(/async saveToFile\(filePath\)\s*\{[\s\S]*?^\s*\}/m);
  assertIncludes(saveToFileMatch[0], "allowedExtensions:", 'Should have extension restriction');
  assertIncludes(saveToFileMatch[0], "'.xml'", 'Should allow .xml extension');
});

test('should have security comments', () => {
  assertIncludes(xmlProcessorSource, 'SECURITY:', 'Should have security comments');
  assertIncludes(xmlProcessorSource, 'path traversal', 'Should mention path traversal prevention');
});

console.log('\n2. securityUtils.js Validation Checks');
console.log('─'.repeat(50));

test('validatePath should exist and be exported', () => {
  assertIncludes(securityUtilsSource, 'async function validatePath', 'Should have validatePath function');
  assertIncludes(securityUtilsSource, 'module.exports', 'Should have exports');
  const exportMatch = securityUtilsSource.match(/module\.exports\s*=\s*\{[\s\S]*?\}/);
  if (!exportMatch || !exportMatch[0].includes('validatePath')) {
    throw new Error('validatePath should be exported');
  }
});

test('validatePath should reject null bytes', () => {
  assertIncludes(securityUtilsSource, "'\\0'", 'Should check for null bytes');
  assertIncludes(securityUtilsSource, 'null bytes', 'Should have null byte error message');
});

test('validatePath should reject dangerous characters', () => {
  assertIncludes(securityUtilsSource, 'dangerousChars', 'Should have dangerous character check');
  assertIncludes(securityUtilsSource, /\[`\$\(\);|&<>\]/.source, 'Should reject shell metacharacters');
});

test('validatePath should normalize paths', () => {
  assertIncludes(securityUtilsSource, 'path.resolve', 'Should normalize paths');
});

test('validatePath should restrict to allowed directories', () => {
  assertIncludes(securityUtilsSource, 'ALLOWED_BASE_DIRS', 'Should have allowed directories list');
  assertIncludes(securityUtilsSource, 'isUnderAllowedDir', 'Should check if path is under allowed dir');
});

console.log('\n3. Path Traversal Attack Prevention');
console.log('─'.repeat(50));

// Import the module to test validation
const { validatePath } = require('../services/securityUtils');

async function runAsyncTests() {
  await testAsync('should reject path traversal with ../', async () => {
    const result = await validatePath('/tmp/../../../etc/passwd', { mustExist: false });
    if (result.valid) {
      throw new Error('Should reject path traversal attack');
    }
  });

  await testAsync('should reject null byte injection', async () => {
    const result = await validatePath('/tmp/test.xml\0.txt', { mustExist: false });
    if (result.valid) {
      throw new Error('Should reject null byte injection');
    }
  });

  await testAsync('should reject command injection characters', async () => {
    const attacks = [
      '/tmp/test;rm -rf /.xml',
      '/tmp/test`id`.xml',
      '/tmp/test$(whoami).xml',
      '/tmp/test|cat /etc/passwd.xml'
    ];

    for (const attack of attacks) {
      const result = await validatePath(attack, { mustExist: false });
      if (result.valid) {
        throw new Error(`Should reject: ${attack}`);
      }
    }
  });

  await testAsync('should accept valid paths in allowed directories', async () => {
    const validPaths = [
      '/tmp/test.xml',
      '/Users/test/video.xmeml'
    ];

    for (const validPath of validPaths) {
      const result = await validatePath(validPath, {
        mustExist: false,
        allowedExtensions: ['.xml', '.xmeml']
      });
      if (!result.valid) {
        throw new Error(`Should accept valid path: ${validPath} (error: ${result.error})`);
      }
    }
  });

  await testAsync('should reject paths outside allowed directories', async () => {
    // /etc is not in ALLOWED_BASE_DIRS
    const result = await validatePath('/etc/passwd', { mustExist: false });
    if (result.valid) {
      throw new Error('Should reject path outside allowed directories');
    }
  });

  await testAsync('should reject wrong file extensions', async () => {
    const result = await validatePath('/tmp/test.sh', {
      mustExist: false,
      allowedExtensions: ['.xml', '.xmeml']
    });
    if (result.valid) {
      throw new Error('Should reject wrong file extension');
    }
  });

  console.log('\n4. XMEMLProcessor Integration Tests');
  console.log('─'.repeat(50));

  const { XMEMLProcessor } = require('../services/xmlProcessor');

  await testAsync('XMEMLProcessor.loadFromFile should reject traversal attacks', async () => {
    const processor = new XMEMLProcessor();
    try {
      await processor.loadFromFile('/tmp/../../../etc/passwd');
      throw new Error('Should have thrown error');
    } catch (error) {
      if (!error.message.includes('Invalid file path')) {
        throw new Error(`Expected 'Invalid file path' error, got: ${error.message}`);
      }
    }
  });

  await testAsync('XMEMLProcessor.loadFromFile should reject wrong extensions', async () => {
    const processor = new XMEMLProcessor();
    try {
      await processor.loadFromFile('/tmp/malicious.sh');
      throw new Error('Should have thrown error');
    } catch (error) {
      if (!error.message.includes('not allowed')) {
        throw new Error(`Expected extension error, got: ${error.message}`);
      }
    }
  });

  await testAsync('XMEMLProcessor.saveToFile should reject traversal attacks', async () => {
    const processor = new XMEMLProcessor();
    processor.xmlContent = '<test/>';
    try {
      await processor.saveToFile('/tmp/../../../etc/cron.d/evil.xml');
      throw new Error('Should have thrown error');
    } catch (error) {
      if (!error.message.includes('Invalid output path')) {
        throw new Error(`Expected 'Invalid output path' error, got: ${error.message}`);
      }
    }
  });

  // Summary
  console.log('\n' + '═'.repeat(55));
  console.log(`Results: ${passed} passed, ${failed} failed`);
  console.log('═'.repeat(55));

  if (failed > 0) {
    console.log('\n❌ SECURITY TEST FAILED - Path traversal vulnerabilities may exist!\n');
    process.exit(1);
  } else {
    console.log('\n✅ SECURITY TEST PASSED - Path traversal protections verified!\n');
    process.exit(0);
  }
}

runAsyncTests();
