/**
 * Input Validation Middleware
 *
 * Provides type validation and sanitization for API request parameters
 * to prevent type confusion attacks and ensure data integrity.
 */

/**
 * Validate that a value is a non-empty string
 * @param {any} value - Value to validate
 * @param {string} fieldName - Name of the field for error messages
 * @returns {{valid: boolean, value?: string, error?: string}}
 */
function validateString(value, fieldName, options = {}) {
  const { maxLength = 10000, allowEmpty = false } = options;

  if (value === null || value === undefined) {
    return { valid: false, error: `${fieldName} is required` };
  }

  if (typeof value !== 'string') {
    return { valid: false, error: `${fieldName} must be a string` };
  }

  if (!allowEmpty && value.trim() === '') {
    return { valid: false, error: `${fieldName} cannot be empty` };
  }

  if (value.length > maxLength) {
    return { valid: false, error: `${fieldName} exceeds maximum length of ${maxLength}` };
  }

  return { valid: true, value: value.trim() };
}

/**
 * Validate that a value is a number within range
 * @param {any} value - Value to validate
 * @param {string} fieldName - Name of the field for error messages
 * @param {Object} options - Validation options
 * @returns {{valid: boolean, value?: number, error?: string}}
 */
function validateNumber(value, fieldName, options = {}) {
  const { min = -Infinity, max = Infinity, allowNegative = true } = options;

  if (value === null || value === undefined) {
    return { valid: false, error: `${fieldName} is required` };
  }

  const num = typeof value === 'string' ? parseFloat(value) : value;

  if (typeof num !== 'number' || isNaN(num)) {
    return { valid: false, error: `${fieldName} must be a valid number` };
  }

  if (!allowNegative && num < 0) {
    return { valid: false, error: `${fieldName} cannot be negative` };
  }

  if (num < min || num > max) {
    return { valid: false, error: `${fieldName} must be between ${min} and ${max}` };
  }

  return { valid: true, value: num };
}

/**
 * Validate that a value is a boolean
 * @param {any} value - Value to validate
 * @param {string} fieldName - Name of the field for error messages
 * @returns {{valid: boolean, value?: boolean, error?: string}}
 */
function validateBoolean(value, fieldName) {
  if (value === null || value === undefined) {
    return { valid: true, value: false }; // Default to false
  }

  if (typeof value === 'boolean') {
    return { valid: true, value };
  }

  if (value === 'true' || value === '1') {
    return { valid: true, value: true };
  }

  if (value === 'false' || value === '0') {
    return { valid: true, value: false };
  }

  return { valid: false, error: `${fieldName} must be a boolean` };
}

/**
 * Validate that a value is an array
 * @param {any} value - Value to validate
 * @param {string} fieldName - Name of the field for error messages
 * @param {Object} options - Validation options
 * @returns {{valid: boolean, value?: Array, error?: string}}
 */
function validateArray(value, fieldName, options = {}) {
  const { maxItems = 10000, minItems = 0 } = options;

  if (value === null || value === undefined) {
    if (minItems > 0) {
      return { valid: false, error: `${fieldName} is required` };
    }
    return { valid: true, value: [] };
  }

  if (!Array.isArray(value)) {
    return { valid: false, error: `${fieldName} must be an array` };
  }

  if (value.length < minItems) {
    return { valid: false, error: `${fieldName} must have at least ${minItems} items` };
  }

  if (value.length > maxItems) {
    return { valid: false, error: `${fieldName} exceeds maximum of ${maxItems} items` };
  }

  return { valid: true, value };
}

/**
 * Validate that a value is one of a set of allowed values
 * @param {any} value - Value to validate
 * @param {string} fieldName - Name of the field for error messages
 * @param {Array} allowedValues - Array of allowed values
 * @returns {{valid: boolean, value?: any, error?: string}}
 */
function validateEnum(value, fieldName, allowedValues) {
  if (value === null || value === undefined) {
    return { valid: false, error: `${fieldName} is required` };
  }

  if (!allowedValues.includes(value)) {
    return { valid: false, error: `${fieldName} must be one of: ${allowedValues.join(', ')}` };
  }

  return { valid: true, value };
}

/**
 * Create a validation middleware for a specific endpoint
 * @param {Object} schema - Validation schema
 * @returns {Function} Express middleware
 */
function createValidator(schema) {
  return (req, res, next) => {
    const errors = [];
    const validated = {};

    for (const [field, rules] of Object.entries(schema)) {
      const value = req.body[field];
      let result;

      switch (rules.type) {
        case 'string':
          result = validateString(value, field, rules);
          break;
        case 'number':
          result = validateNumber(value, field, rules);
          break;
        case 'boolean':
          result = validateBoolean(value, field);
          break;
        case 'array':
          result = validateArray(value, field, rules);
          break;
        case 'enum':
          result = validateEnum(value, field, rules.values);
          break;
        default:
          result = { valid: true, value };
      }

      if (!result.valid) {
        if (!rules.optional) {
          errors.push(result.error);
        }
      } else {
        validated[field] = result.value;
      }
    }

    if (errors.length > 0) {
      return res.status(400).json({
        error: 'Validation failed',
        details: errors
      });
    }

    // Attach validated data to request
    req.validatedBody = validated;
    next();
  };
}

/**
 * Common validation schemas for endpoints
 */
const validationSchemas = {
  analyze: {
    wavPath: { type: 'string', maxLength: 1000 },
    detectTakes: { type: 'boolean', optional: true }
  },
  silences: {
    wavPath: { type: 'string', maxLength: 1000 },
    sensitivity: { type: 'number', min: 0, max: 100, optional: true },
    minSilenceLength: { type: 'number', min: 0.1, max: 60, optional: true }
  },
  cutList: {
    sourceName: { type: 'string', maxLength: 500, optional: true },
    sourcePath: { type: 'string', maxLength: 1000, optional: true },
    duration: { type: 'number', min: 0, max: 86400 },
    silences: { type: 'array', maxItems: 10000 }
  },
  chapters: {
    wavPath: { type: 'string', maxLength: 1000 },
    transcript: { type: 'string', maxLength: 1000000, optional: true }
  },
  musicGenerate: {
    mood: { type: 'string', maxLength: 100 },
    duration: { type: 'number', min: 15, max: 600 },
    instruments: { type: 'array', maxItems: 20, optional: true }
  }
};

module.exports = {
  validateString,
  validateNumber,
  validateBoolean,
  validateArray,
  validateEnum,
  createValidator,
  validationSchemas
};
