#!/usr/bin/env node
/**
 * SPLICE Comprehensive Security Test Suite
 *
 * Runs all security tests in sequence to verify:
 * 1. Command injection prevention
 * 2. Authentication bypass protection
 * 3. Path traversal prevention
 * 4. Input validation
 * 5. Error message sanitization
 *
 * Usage: node tests/security-comprehensive-e2e.test.js
 */

const { execSync } = require('child_process');
const path = require('path');

const tests = [
  { name: 'Command Injection Prevention', file: 'security-command-injection.test.js' },
  { name: 'Auth Bypass Protection', file: 'security-auth-bypass.test.js' },
  { name: 'Path Traversal Prevention', file: 'security-path-traversal.test.js' },
  { name: 'Input Validation', file: 'security-input-validation.test.js' },
  { name: 'Error Message Sanitization', file: 'security-error-sanitization.test.js' }
];

console.log('\n' + '╔' + '═'.repeat(70) + '╗');
console.log('║' + ' '.repeat(10) + 'SPLICE COMPREHENSIVE SECURITY TEST SUITE' + ' '.repeat(19) + '║');
console.log('╚' + '═'.repeat(70) + '╝\n');

console.log('Running all security tests to verify protections are in place...\n');

let totalPassed = 0;
let totalFailed = 0;
const results = [];

for (const test of tests) {
  console.log(`\n${'─'.repeat(70)}`);
  console.log(`Running: ${test.name}`);
  console.log('─'.repeat(70));

  try {
    const testPath = path.join(__dirname, test.file);
    const output = execSync(`node "${testPath}"`, {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe'],
      timeout: 60000
    });

    // Parse results from output
    const passedMatch = output.match(/Results: (\d+) passed/);
    const failedMatch = output.match(/(\d+) failed/);

    const passed = passedMatch ? parseInt(passedMatch[1]) : 0;
    const failed = failedMatch ? parseInt(failedMatch[1]) : 0;

    totalPassed += passed;
    totalFailed += failed;

    results.push({
      name: test.name,
      status: failed === 0 ? 'PASSED' : 'FAILED',
      passed,
      failed
    });

    console.log(output);
  } catch (error) {
    totalFailed++;
    results.push({
      name: test.name,
      status: 'ERROR',
      passed: 0,
      failed: 1,
      error: error.message
    });

    console.log(`\n❌ Error running ${test.name}:`);
    if (error.stdout) console.log(error.stdout);
    if (error.stderr) console.log(error.stderr);
  }
}

// Summary
console.log('\n' + '═'.repeat(70));
console.log('                     SECURITY TEST SUMMARY');
console.log('═'.repeat(70));
console.log('\nTest Results:');
console.log('─'.repeat(50));

for (const result of results) {
  const statusIcon = result.status === 'PASSED' ? '✅' : '❌';
  console.log(`  ${statusIcon} ${result.name}: ${result.passed} passed, ${result.failed} failed`);
}

console.log('─'.repeat(50));
console.log(`\nTotal: ${totalPassed} passed, ${totalFailed} failed`);
console.log('═'.repeat(70));

if (totalFailed > 0) {
  console.log('\n❌ SECURITY AUDIT FAILED - Some vulnerabilities may still exist!\n');
  console.log('Please review and fix the failing tests before deploying.\n');
  process.exit(1);
} else {
  console.log('\n✅ SECURITY AUDIT PASSED - All protections verified!\n');
  console.log('The following security measures are in place:');
  console.log('  • Command injection protection (execFile with array args)');
  console.log('  • Auth bypass protection (production blocking, rate limiting)');
  console.log('  • Path traversal prevention (validatePath in file operations)');
  console.log('  • Input validation (type checking, size limits)');
  console.log('  • Error sanitization (production message hiding)');
  console.log('\n');
  process.exit(0);
}
