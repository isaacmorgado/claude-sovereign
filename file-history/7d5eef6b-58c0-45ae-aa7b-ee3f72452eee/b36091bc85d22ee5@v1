/**
 * Security Test: Error Message Sanitization
 *
 * Tests that error messages are properly sanitized in production
 * to prevent information leakage.
 */

const fs = require('fs');
const path = require('path');

// Test counters
let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    passed++;
    console.log(`  ✓ ${name}`);
  } catch (error) {
    failed++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${error.message}`);
  }
}

function assertIncludes(source, pattern, message) {
  if (!source.includes(pattern)) {
    throw new Error(message || `Expected source to include: ${pattern}`);
  }
}

function assertEqual(actual, expected, message) {
  if (actual !== expected) {
    throw new Error(message || `Expected "${expected}", got "${actual}"`);
  }
}

// Read source files
const errorHandlerPath = path.join(__dirname, '../middleware/errorHandler.js');
const errorHandlerSource = fs.readFileSync(errorHandlerPath, 'utf8');

const serverPath = path.join(__dirname, '../server.js');
const serverSource = fs.readFileSync(serverPath, 'utf8');

console.log('\n╔═══════════════════════════════════════════════════════════════════╗');
console.log('║         SPLICE Security Test: Error Message Sanitization         ║');
console.log('╚═══════════════════════════════════════════════════════════════════╝\n');

console.log('1. Error Handler Module');
console.log('─'.repeat(50));

test('should have sanitizeError function', () => {
  assertIncludes(errorHandlerSource, 'function sanitizeError(err, fallbackMessage', 'Should have sanitizeError');
});

test('sanitizeError should check production environment', () => {
  assertIncludes(errorHandlerSource, "process.env.NODE_ENV === 'production'", 'Should check NODE_ENV');
  assertIncludes(errorHandlerSource, 'RAILWAY_ENVIRONMENT', 'Should check Railway environment');
});

test('sanitizeError should return fallback message in production', () => {
  assertIncludes(errorHandlerSource, 'return fallbackMessage', 'Should return fallback in production');
});

test('should have createErrorResponse function', () => {
  assertIncludes(errorHandlerSource, 'function createErrorResponse(err, fallbackMessage', 'Should have createErrorResponse');
});

test('should export sanitization functions', () => {
  assertIncludes(errorHandlerSource, 'sanitizeError,', 'Should export sanitizeError');
  assertIncludes(errorHandlerSource, 'createErrorResponse', 'Should export createErrorResponse');
});

test('global error handler should sanitize in production', () => {
  assertIncludes(errorHandlerSource, 'isProduction ? \'An unexpected error occurred\' : err.message', 'Should hide messages in production');
});

test('global error handler should hide stack traces in production', () => {
  assertIncludes(errorHandlerSource, 'stack: isProduction ? undefined : err.stack', 'Should hide stack in production');
});

console.log('\n2. Sanitization Function Tests');
console.log('─'.repeat(50));

// Save original env
const originalNodeEnv = process.env.NODE_ENV;
const originalRailway = process.env.RAILWAY_ENVIRONMENT;

// Import after saving env
const { sanitizeError, createErrorResponse, AppError, ValidationError } = require('../middleware/errorHandler');

test('sanitizeError should show full message in development', () => {
  process.env.NODE_ENV = 'development';
  delete process.env.RAILWAY_ENVIRONMENT;

  const error = new Error('Database connection failed: ECONNREFUSED');
  const result = sanitizeError(error, 'Operation failed');

  assertEqual(result, 'Database connection failed: ECONNREFUSED', 'Should show full message in dev');
});

test('sanitizeError should hide internal errors in production', () => {
  process.env.NODE_ENV = 'production';

  const error = new Error('Database connection failed: ECONNREFUSED');
  const result = sanitizeError(error, 'Operation failed');

  assertEqual(result, 'Operation failed', 'Should hide internal error in production');
});

test('sanitizeError should show operational AppError messages in production', () => {
  process.env.NODE_ENV = 'production';

  const error = new ValidationError('Email is required');
  const result = sanitizeError(error, 'Validation failed');

  assertEqual(result, 'Email is required', 'Should show operational error messages');
});

test('sanitizeError should work with RAILWAY_ENVIRONMENT', () => {
  delete process.env.NODE_ENV;
  process.env.RAILWAY_ENVIRONMENT = 'production';

  const error = new Error('Internal stack trace details');
  const result = sanitizeError(error, 'Something went wrong');

  assertEqual(result, 'Something went wrong', 'Should detect Railway production');
});

test('createErrorResponse should return proper structure', () => {
  process.env.NODE_ENV = 'production';

  const error = new Error('Sensitive internal error');
  const result = createErrorResponse(error, 'An error occurred');

  if (!result.error || result.error !== 'An error occurred') {
    throw new Error('Should return object with sanitized error message');
  }
});

// Restore environment
process.env.NODE_ENV = originalNodeEnv;
if (originalRailway) {
  process.env.RAILWAY_ENVIRONMENT = originalRailway;
} else {
  delete process.env.RAILWAY_ENVIRONMENT;
}

console.log('\n3. Error Types That Should NOT Be Sanitized');
console.log('─'.repeat(50));

test('ValidationError messages should be shown in production', () => {
  process.env.NODE_ENV = 'production';
  const error = new ValidationError('wavPath is required');
  assertEqual(sanitizeError(error), 'wavPath is required');
});

// Restore environment
process.env.NODE_ENV = originalNodeEnv;

console.log('\n4. Server-Level Sanitization');
console.log('─'.repeat(50));

test('server should use JSON body limit for DoS prevention', () => {
  assertIncludes(serverSource, "express.json({ limit:", 'Should have JSON body limit');
});

// Summary
console.log('\n' + '═'.repeat(55));
console.log(`Results: ${passed} passed, ${failed} failed`);
console.log('═'.repeat(55));

if (failed > 0) {
  console.log('\n❌ SECURITY TEST FAILED - Error sanitization issues exist!\n');
  process.exit(1);
} else {
  console.log('\n✅ SECURITY TEST PASSED - Error sanitization verified!\n');
  process.exit(0);
}
