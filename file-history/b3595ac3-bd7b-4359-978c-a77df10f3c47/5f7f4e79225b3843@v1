"""
Process Watcher - CI/CD Resilience Module

Monitors target applications during nightly stability runs.
Designed to handle crashes gracefully without failing the test harness.
"""

import logging
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, List, Callable

import psutil


class ProcessState(Enum):
    WAITING = "waiting"
    RUNNING = "running"
    CRASHED = "crashed"
    TERMINATED = "terminated"


@dataclass
class ProcessEvent:
    """Records a process lifecycle event."""
    timestamp: datetime
    state: ProcessState
    pid: Optional[int] = None
    process_name: Optional[str] = None
    message: str = ""


@dataclass
class TargetMonitor:
    """
    Monitors target processes for CI/CD stability testing.

    Resilient to crashes - logs events and returns to waiting state
    rather than raising exceptions.
    """

    poll_interval: float = 0.5
    log_level: int = logging.INFO
    max_wait_time: Optional[float] = None  # None = wait indefinitely

    _logger: logging.Logger = field(init=False)
    _events: List[ProcessEvent] = field(default_factory=list, init=False)
    _current_state: ProcessState = field(default=ProcessState.WAITING, init=False)
    _tracked_pid: Optional[int] = field(default=None, init=False)

    def __post_init__(self):
        self._logger = logging.getLogger(f"{__name__}.TargetMonitor")
        self._logger.setLevel(self.log_level)

        if not self._logger.handlers:
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter(
                "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
            ))
            self._logger.addHandler(handler)

    def _log_event(
        self,
        state: ProcessState,
        pid: Optional[int] = None,
        process_name: Optional[str] = None,
        message: str = ""
    ) -> ProcessEvent:
        """Record and log a process event."""
        event = ProcessEvent(
            timestamp=datetime.now(),
            state=state,
            pid=pid,
            process_name=process_name,
            message=message
        )
        self._events.append(event)
        self._current_state = state

        log_msg = f"[{state.value.upper()}] {message}"
        if pid:
            log_msg += f" (PID: {pid})"

        if state == ProcessState.CRASHED:
            self._logger.warning(log_msg)
        else:
            self._logger.info(log_msg)

        return event

    def wait_for_process(
        self,
        process_name: str,
        on_found: Optional[Callable[[int], None]] = None
    ) -> Optional[int]:
        """
        Block until a process with the given name starts.

        Args:
            process_name: Name of the process to wait for (e.g., "myapp.exe")
            on_found: Optional callback invoked when process is found

        Returns:
            PID of the found process, or None if max_wait_time exceeded
        """
        self._log_event(
            ProcessState.WAITING,
            process_name=process_name,
            message=f"Waiting for process '{process_name}' to start"
        )

        start_time = time.time()

        while True:
            try:
                for proc in psutil.process_iter(['pid', 'name']):
                    try:
                        if proc.info['name'] and process_name.lower() in proc.info['name'].lower():
                            pid = proc.info['pid']
                            self._tracked_pid = pid

                            self._log_event(
                                ProcessState.RUNNING,
                                pid=pid,
                                process_name=process_name,
                                message=f"Process '{process_name}' detected"
                            )

                            if on_found:
                                on_found(pid)

                            return pid

                    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                        # Process disappeared or inaccessible during iteration
                        continue

            except psutil.Error as e:
                self._logger.debug(f"psutil error during scan: {e}")

            # Check timeout
            if self.max_wait_time is not None:
                elapsed = time.time() - start_time
                if elapsed >= self.max_wait_time:
                    self._log_event(
                        ProcessState.WAITING,
                        process_name=process_name,
                        message=f"Timeout waiting for '{process_name}' after {elapsed:.1f}s"
                    )
                    return None

            time.sleep(self.poll_interval)

    def is_active(self, pid: int) -> bool:
        """
        Check if a process is still running.

        Args:
            pid: Process ID to check

        Returns:
            True if process exists and is running, False otherwise
        """
        try:
            proc = psutil.Process(pid)
            status = proc.status()

            # Consider zombie processes as inactive
            if status == psutil.STATUS_ZOMBIE:
                self._logger.debug(f"PID {pid} is zombie")
                return False

            return True

        except psutil.NoSuchProcess:
            self._logger.debug(f"PID {pid} no longer exists")
            return False

        except psutil.AccessDenied:
            # Process exists but we can't access it - assume it's running
            self._logger.debug(f"PID {pid} access denied, assuming active")
            return True

        except psutil.ZombieProcess:
            self._logger.debug(f"PID {pid} is zombie")
            return False

    def monitor_until_exit(
        self,
        pid: int,
        on_crash: Optional[Callable[[int], None]] = None,
        on_exit: Optional[Callable[[int, Optional[int]], None]] = None
    ) -> ProcessState:
        """
        Monitor a process until it exits.

        Args:
            pid: Process ID to monitor
            on_crash: Callback if process crashes (non-zero exit)
            on_exit: Callback on any exit, receives (pid, exit_code)

        Returns:
            Final ProcessState (TERMINATED or CRASHED)
        """
        self._tracked_pid = pid
        self._log_event(
            ProcessState.RUNNING,
            pid=pid,
            message="Monitoring process"
        )

        exit_code = None
        final_state = ProcessState.TERMINATED

        while True:
            try:
                proc = psutil.Process(pid)
                status = proc.status()

                if status == psutil.STATUS_ZOMBIE:
                    # Try to get exit code from zombie
                    try:
                        exit_code = proc.wait(timeout=0)
                    except Exception:
                        pass
                    break

            except psutil.NoSuchProcess:
                # Process exited
                break

            except psutil.AccessDenied:
                # Lost access - might have elevated or exited
                if not self.is_active(pid):
                    break

            except psutil.ZombieProcess:
                break

            time.sleep(self.poll_interval)

        # Determine if it was a crash
        if exit_code is not None and exit_code != 0:
            final_state = ProcessState.CRASHED
            self._log_event(
                ProcessState.CRASHED,
                pid=pid,
                message=f"Process crashed with exit code {exit_code}"
            )
            if on_crash:
                on_crash(pid)
        else:
            self._log_event(
                ProcessState.TERMINATED,
                pid=pid,
                message="Process terminated normally"
            )

        if on_exit:
            on_exit(pid, exit_code)

        self._tracked_pid = None
        return final_state

    def run_stability_loop(
        self,
        process_name: str,
        max_crashes: Optional[int] = None,
        on_crash: Optional[Callable[[int, int], None]] = None
    ) -> int:
        """
        Main stability test loop - monitors process through multiple crash/restart cycles.

        Args:
            process_name: Name of process to monitor
            max_crashes: Stop after this many crashes (None = run forever)
            on_crash: Callback receiving (pid, crash_count)

        Returns:
            Total number of crashes observed
        """
        crash_count = 0

        self._logger.info(f"Starting stability monitoring for '{process_name}'")

        while True:
            # Wait for process to start
            pid = self.wait_for_process(process_name)

            if pid is None:
                # Timeout - continue waiting
                continue

            # Monitor until exit
            final_state = self.monitor_until_exit(pid)

            if final_state == ProcessState.CRASHED:
                crash_count += 1
                self._logger.warning(
                    f"Crash #{crash_count} detected, returning to waiting state"
                )

                if on_crash:
                    on_crash(pid, crash_count)

                if max_crashes is not None and crash_count >= max_crashes:
                    self._logger.info(
                        f"Reached max crashes ({max_crashes}), stopping monitor"
                    )
                    break

            # Return to waiting state
            self._log_event(
                ProcessState.WAITING,
                process_name=process_name,
                message="Returning to waiting state"
            )

        return crash_count

    @property
    def events(self) -> List[ProcessEvent]:
        """Get all recorded events."""
        return self._events.copy()

    @property
    def current_state(self) -> ProcessState:
        """Get current monitor state."""
        return self._current_state

    @property
    def tracked_pid(self) -> Optional[int]:
        """Get currently tracked PID, if any."""
        return self._tracked_pid


if __name__ == "__main__":
    # Example: Monitor a process for stability testing
    logging.basicConfig(level=logging.INFO)

    monitor = TargetMonitor(
        poll_interval=1.0,
        max_wait_time=300  # 5 minute timeout
    )

    # Example usage for nightly runs
    def on_crash(pid: int, count: int):
        print(f"STABILITY ALERT: Crash #{count} for PID {pid}")

    # Uncomment to run:
    # crash_count = monitor.run_stability_loop(
    #     "my_application",
    #     max_crashes=10,
    #     on_crash=on_crash
    # )
    # print(f"Stability run complete: {crash_count} crashes")

    print("TargetMonitor ready for CI/CD integration")
