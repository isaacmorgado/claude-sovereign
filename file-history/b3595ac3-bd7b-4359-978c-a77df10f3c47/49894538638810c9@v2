"""
Human Input Data Visualization Utilities

Bezier curve generation and Perlin noise perturbation
for creating smooth sample datasets.
"""

import math
import random
from typing import List, Tuple, Optional

Point = Tuple[float, float]


def calculate_bezier_points(
    start_xy: Point,
    end_xy: Point,
    control_points: int = 2,
    num_samples: int = 50,
    control_positions: Optional[List[Point]] = None
) -> List[Point]:
    """
    Generate points along a Bezier curve.

    Args:
        start_xy: Starting point (x, y)
        end_xy: Ending point (x, y)
        control_points: Number of control points (1=quadratic, 2=cubic, etc.)
        num_samples: Number of points to generate along the curve
        control_positions: Optional explicit control point positions.
                          If None, control points are auto-generated.

    Returns:
        List of (x, y) coordinates along the curve
    """
    if control_positions is None:
        control_positions = _generate_control_points(
            start_xy, end_xy, control_points
        )

    # Build full point list: start + controls + end
    all_points = [start_xy] + control_positions + [end_xy]

    # Generate curve points using De Casteljau's algorithm
    curve_points = []
    for i in range(num_samples + 1):
        t = i / num_samples
        point = _de_casteljau(all_points, t)
        curve_points.append(point)

    return curve_points


def _generate_control_points(
    start: Point,
    end: Point,
    count: int
) -> List[Point]:
    """Auto-generate control points between start and end."""
    controls = []
    dx = end[0] - start[0]
    dy = end[1] - start[1]

    for i in range(count):
        t = (i + 1) / (count + 1)
        # Base position along the line
        base_x = start[0] + dx * t
        base_y = start[1] + dy * t

        # Add perpendicular offset for curve shape
        perp_scale = 0.3 * min(abs(dx), abs(dy)) if min(abs(dx), abs(dy)) > 0 else 20
        offset = perp_scale * (1 if i % 2 == 0 else -1)

        # Perpendicular direction
        length = math.sqrt(dx**2 + dy**2)
        if length > 0:
            perp_x = -dy / length * offset
            perp_y = dx / length * offset
        else:
            perp_x, perp_y = offset, 0

        controls.append((base_x + perp_x, base_y + perp_y))

    return controls


def _de_casteljau(points: List[Point], t: float) -> Point:
    """Evaluate Bezier curve at parameter t using De Casteljau's algorithm."""
    if len(points) == 1:
        return points[0]

    new_points = []
    for i in range(len(points) - 1):
        x = (1 - t) * points[i][0] + t * points[i + 1][0]
        y = (1 - t) * points[i][1] + t * points[i + 1][1]
        new_points.append((x, y))

    return _de_casteljau(new_points, t)


# Perlin noise implementation
class _PerlinNoise:
    """Simple 1D/2D Perlin noise generator."""

    def __init__(self, seed: Optional[int] = None):
        self.seed = seed if seed is not None else random.randint(0, 2**31)
        self._perm = self._generate_permutation()

    def _generate_permutation(self) -> List[int]:
        """Generate permutation table."""
        rng = random.Random(self.seed)
        perm = list(range(256))
        rng.shuffle(perm)
        return perm + perm  # Duplicate for overflow handling

    def _fade(self, t: float) -> float:
        """Smoothstep fade function."""
        return t * t * t * (t * (t * 6 - 15) + 10)

    def _lerp(self, a: float, b: float, t: float) -> float:
        """Linear interpolation."""
        return a + t * (b - a)

    def _grad(self, hash_val: int, x: float, y: float = 0) -> float:
        """Calculate gradient."""
        h = hash_val & 15
        u = x if h < 8 else y
        v = y if h < 4 else (x if h in (12, 14) else 0)
        return (u if (h & 1) == 0 else -u) + (v if (h & 2) == 0 else -v)

    def noise_2d(self, x: float, y: float) -> float:
        """Generate 2D Perlin noise value in range [-1, 1]."""
        # Grid cell coordinates
        xi = int(math.floor(x)) & 255
        yi = int(math.floor(y)) & 255

        # Relative position in cell
        xf = x - math.floor(x)
        yf = y - math.floor(y)

        # Fade curves
        u = self._fade(xf)
        v = self._fade(yf)

        # Hash coordinates of corners
        p = self._perm
        aa = p[p[xi] + yi]
        ab = p[p[xi] + yi + 1]
        ba = p[p[xi + 1] + yi]
        bb = p[p[xi + 1] + yi + 1]

        # Blend gradients
        x1 = self._lerp(self._grad(aa, xf, yf), self._grad(ba, xf - 1, yf), u)
        x2 = self._lerp(self._grad(ab, xf, yf - 1), self._grad(bb, xf - 1, yf - 1), u)

        return self._lerp(x1, x2, v)


def add_perlin_noise(
    points: List[Point],
    magnitude: float = 0.5,
    scale: float = 0.1,
    seed: Optional[int] = None
) -> List[Point]:
    """
    Add Perlin noise perturbation to a list of points.

    Args:
        points: List of (x, y) coordinates
        magnitude: Maximum displacement magnitude
        scale: Noise frequency scale (smaller = smoother)
        seed: Random seed for reproducibility

    Returns:
        New list of perturbed points
    """
    noise = _PerlinNoise(seed)
    perturbed = []

    for i, (x, y) in enumerate(points):
        # Sample noise at different offsets for x and y
        noise_x = noise.noise_2d(i * scale, 0) * magnitude
        noise_y = noise.noise_2d(i * scale, 100) * magnitude

        perturbed.append((x + noise_x, y + noise_y))

    return perturbed


def generate_smooth_dataset(
    start_xy: Point,
    end_xy: Point,
    num_points: int = 100,
    noise_magnitude: float = 0.5,
    control_points: int = 2,
    seed: Optional[int] = None
) -> List[Point]:
    """
    Convenience function to generate a complete smooth dataset.

    Combines Bezier curve generation with Perlin noise perturbation.
    """
    curve = calculate_bezier_points(
        start_xy, end_xy,
        control_points=control_points,
        num_samples=num_points
    )
    return add_perlin_noise(curve, magnitude=noise_magnitude, seed=seed)


if __name__ == "__main__":
    # Example usage
    start = (0, 0)
    end = (100, 50)

    # Generate smooth Bezier curve
    curve = calculate_bezier_points(start, end, control_points=2, num_samples=30)
    print(f"Bezier curve ({len(curve)} points):")
    print(f"  Start: {curve[0]}")
    print(f"  End: {curve[-1]}")

    # Add noise for natural variation
    noisy = add_perlin_noise(curve, magnitude=2.0, seed=42)
    print(f"\nWith Perlin noise:")
    print(f"  Start: {noisy[0]}")
    print(f"  End: {noisy[-1]}")

    # Quick dataset generation
    dataset = generate_smooth_dataset((0, 0), (200, 100), num_points=50, seed=123)
    print(f"\nGenerated dataset: {len(dataset)} points")
