/**
 * Take Detection Service Tests
 *
 * Tests for:
 * 1. detectTakes - Main function with OpenAI API
 * 2. buildPrompt - Prompt construction
 * 3. formatSegments - Segment formatting
 * 4. createFallbackResponse - Fallback handling
 * 5. Error handling - API errors, parse failures
 */

const fs = require('fs');
const path = require('path');

// =============================================================================
// TEST FRAMEWORK
// =============================================================================

let passCount = 0;
let failCount = 0;

function test(name, fn) {
  try {
    const result = fn();
    if (result instanceof Promise) {
      return result.then(() => {
        passCount++;
        console.log(`  ✓ ${name}`);
      }).catch(err => {
        failCount++;
        console.log(`  ✗ ${name}`);
        console.log(`    Error: ${err.message}`);
      });
    }
    passCount++;
    console.log(`  ✓ ${name}`);
  } catch (err) {
    failCount++;
    console.log(`  ✗ ${name}`);
    console.log(`    Error: ${err.message}`);
  }
}

function assertEqual(actual, expected, message = '') {
  if (actual !== expected) {
    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

function assertTrue(condition, message = '') {
  if (!condition) {
    throw new Error(`${message}: Expected true, got false`);
  }
}

function assertFalse(condition, message = '') {
  if (condition) {
    throw new Error(`${message}: Expected false, got true`);
  }
}

function assertIncludes(str, substring, message = '') {
  if (!str.includes(substring)) {
    throw new Error(`${message}: Expected string to include "${substring}"`);
  }
}

// =============================================================================
// SOURCE CODE ANALYSIS TESTS
// =============================================================================

console.log('\n=== Take Detection Service Tests ===\n');

const takeDetectionSource = fs.readFileSync(
  path.join(__dirname, '../services/takeDetection.js'),
  'utf8'
);

console.log('1. Module Structure Tests');

test('should export detectTakes function', () => {
  assertTrue(takeDetectionSource.includes('module.exports = { detectTakes }'), 'Missing detectTakes export');
});

test('should use OpenAI SDK', () => {
  assertTrue(takeDetectionSource.includes("require('openai')"), 'Should require openai package');
  assertTrue(takeDetectionSource.includes('new OpenAI'), 'Should instantiate OpenAI client');
});

test('should use OPENAI_API_KEY environment variable', () => {
  assertTrue(takeDetectionSource.includes('process.env.OPENAI_API_KEY'), 'Should use OPENAI_API_KEY');
});

console.log('\n2. buildPrompt Function Tests');

test('should implement buildPrompt function', () => {
  assertTrue(takeDetectionSource.includes('function buildPrompt(segmentsText)'), 'Missing buildPrompt function');
});

test('should include take detection instructions', () => {
  assertIncludes(takeDetectionSource, 'Analyze this video transcript', 'Missing analysis instruction');
  assertIncludes(takeDetectionSource, 'identify distinct "takes"', 'Missing take identification');
});

test('should look for explicit markers', () => {
  assertIncludes(takeDetectionSource, 'take 1', 'Should detect take markers');
  assertIncludes(takeDetectionSource, 'take 2', 'Should detect take markers');
  assertIncludes(takeDetectionSource, 'again', 'Should detect restart markers');
  assertIncludes(takeDetectionSource, 'one more time', 'Should detect retry markers');
});

test('should specify JSON response format', () => {
  assertIncludes(takeDetectionSource, 'Respond with JSON only', 'Should request JSON response');
  assertIncludes(takeDetectionSource, '"takes":', 'Should specify takes array');
  assertIncludes(takeDetectionSource, '"takeNumber":', 'Should specify takeNumber');
  assertIncludes(takeDetectionSource, '"start":', 'Should specify start time');
  assertIncludes(takeDetectionSource, '"end":', 'Should specify end time');
  assertIncludes(takeDetectionSource, '"isBest":', 'Should specify best take flag');
});

test('should include shortLabel in response format', () => {
  assertIncludes(takeDetectionSource, '"shortLabel":', 'Should specify shortLabel');
  assertIncludes(takeDetectionSource, '2-5 word summary', 'Should describe shortLabel format');
});

console.log('\n3. formatSegments Function Tests');

test('should implement formatSegments function', () => {
  assertTrue(takeDetectionSource.includes('function formatSegments(segments)'), 'Missing formatSegments function');
});

test('should format timestamps with toFixed(2)', () => {
  assertIncludes(takeDetectionSource, 's.start.toFixed(2)', 'Should format start time');
  assertIncludes(takeDetectionSource, 's.end.toFixed(2)', 'Should format end time');
});

test('should format as [start-end] text', () => {
  assertIncludes(takeDetectionSource, '[${s.start', 'Should use bracket format');
  assertIncludes(takeDetectionSource, '${s.text}', 'Should include segment text');
});

console.log('\n4. createFallbackResponse Function Tests');

test('should implement createFallbackResponse function', () => {
  assertTrue(takeDetectionSource.includes('function createFallbackResponse(duration)'), 'Missing createFallbackResponse');
});

test('should return single take covering full duration', () => {
  assertIncludes(takeDetectionSource, 'takeNumber: 1', 'Should have takeNumber 1');
  assertIncludes(takeDetectionSource, 'start: 0', 'Should start at 0');
  assertIncludes(takeDetectionSource, 'end: duration', 'Should end at duration');
});

test('should mark fallback as best take', () => {
  assertIncludes(takeDetectionSource, 'isBest: true', 'Should mark as best take');
});

test('should indicate parsing failed', () => {
  assertIncludes(takeDetectionSource, 'parsing failed', 'Should indicate parsing failure');
});

console.log('\n5. detectTakes Function Tests');

test('should implement async detectTakes function', () => {
  assertTrue(takeDetectionSource.includes('async function detectTakes(transcript)'), 'Missing detectTakes function');
});

test('should use gpt-4o-mini model', () => {
  assertIncludes(takeDetectionSource, "model: 'gpt-4o-mini'", 'Should use gpt-4o-mini');
});

test('should use low temperature for consistent results', () => {
  assertIncludes(takeDetectionSource, 'temperature: 0.3', 'Should use temperature 0.3');
});

test('should call openai.chat.completions.create', () => {
  assertIncludes(takeDetectionSource, 'openai.chat.completions.create', 'Should call chat completions API');
});

test('should extract response content', () => {
  assertIncludes(takeDetectionSource, 'response.choices[0].message.content', 'Should extract message content');
});

console.log('\n6. Error Handling Tests');

test('should try to parse JSON response', () => {
  assertIncludes(takeDetectionSource, 'JSON.parse(content)', 'Should parse JSON');
});

test('should catch parse errors', () => {
  assertIncludes(takeDetectionSource, 'catch {', 'Should catch parse errors');
});

test('should log parse failures', () => {
  assertIncludes(takeDetectionSource, 'Failed to parse GPT response', 'Should log parse failure');
});

test('should return fallback on parse failure', () => {
  assertIncludes(takeDetectionSource, 'createFallbackResponse(transcript.duration)', 'Should return fallback');
});

console.log('\n7. Logging Tests');

test('should log start of take detection', () => {
  assertIncludes(takeDetectionSource, '[SPLICE] Starting GPT-4o-mini take detection', 'Should log start');
});

test('should log completion', () => {
  assertIncludes(takeDetectionSource, '[SPLICE] Take detection complete', 'Should log completion');
});

// =============================================================================
// UNIT TESTS - Testing formatSegments with mock data
// =============================================================================

console.log('\n8. Unit Tests with Mock Data');

// Extract and test formatSegments function
const formatSegmentsMatch = takeDetectionSource.match(/function formatSegments\(segments\) \{[\s\S]*?return segments[\s\S]*?\.join\('\\n'\);?\s*\}/);

test('formatSegments function should be extractable', () => {
  assertTrue(formatSegmentsMatch !== null, 'Should find formatSegments function');
});

// Create test function from extracted code
if (formatSegmentsMatch) {
  const formatSegmentsCode = formatSegmentsMatch[0];
  const formatSegments = eval(`(${formatSegmentsCode.replace('function formatSegments', 'function')})`);

  test('formatSegments formats single segment correctly', () => {
    const segments = [{ start: 0, end: 5.5, text: 'Hello world' }];
    const result = formatSegments(segments);
    assertEqual(result, '[0.00-5.50] Hello world', 'Should format segment');
  });

  test('formatSegments formats multiple segments with newlines', () => {
    const segments = [
      { start: 0, end: 5, text: 'First' },
      { start: 5, end: 10, text: 'Second' }
    ];
    const result = formatSegments(segments);
    assertIncludes(result, '[0.00-5.00] First', 'Should have first segment');
    assertIncludes(result, '[5.00-10.00] Second', 'Should have second segment');
    assertIncludes(result, '\n', 'Should have newline separator');
  });

  test('formatSegments handles empty segments array', () => {
    const segments = [];
    const result = formatSegments(segments);
    assertEqual(result, '', 'Should return empty string');
  });
}

// Extract and test createFallbackResponse function
const fallbackMatch = takeDetectionSource.match(/function createFallbackResponse\(duration\) \{[\s\S]*?return \{[\s\S]*?\};\s*\}/);

test('createFallbackResponse function should be extractable', () => {
  assertTrue(fallbackMatch !== null, 'Should find createFallbackResponse function');
});

if (fallbackMatch) {
  const fallbackCode = fallbackMatch[0];
  const createFallbackResponse = eval(`(${fallbackCode.replace('function createFallbackResponse', 'function')})`);

  test('createFallbackResponse returns correct structure', () => {
    const result = createFallbackResponse(60);
    assertTrue(result.takes !== undefined, 'Should have takes array');
    assertTrue(result.analysis !== undefined, 'Should have analysis');
    assertEqual(result.takes.length, 1, 'Should have one take');
  });

  test('createFallbackResponse uses provided duration', () => {
    const result = createFallbackResponse(120);
    assertEqual(result.takes[0].end, 120, 'Should use provided duration');
    assertEqual(result.takes[0].start, 0, 'Should start at 0');
  });

  test('createFallbackResponse handles undefined duration', () => {
    const result = createFallbackResponse(undefined);
    assertEqual(result.takes[0].end, 0, 'Should default to 0');
  });

  test('createFallbackResponse marks take as best', () => {
    const result = createFallbackResponse(60);
    assertTrue(result.takes[0].isBest, 'Should mark as best take');
  });
}

// =============================================================================
// INTEGRATION PATTERN TESTS
// =============================================================================

console.log('\n9. Integration Pattern Tests');

test('should follow service pattern (async function)', () => {
  assertTrue(takeDetectionSource.includes('async function detectTakes'), 'Should be async');
});

test('should accept transcript object parameter', () => {
  assertIncludes(takeDetectionSource, 'detectTakes(transcript)', 'Should accept transcript');
});

test('should access transcript.segments', () => {
  assertIncludes(takeDetectionSource, 'transcript.segments', 'Should access segments');
});

test('should access transcript.duration for fallback', () => {
  assertIncludes(takeDetectionSource, 'transcript.duration', 'Should access duration');
});

// =============================================================================
// SUMMARY
// =============================================================================

console.log('\n=== Test Summary ===');
console.log(`  Passed: ${passCount}`);
console.log(`  Failed: ${failCount}`);
console.log(`  Total: ${passCount + failCount}`);

if (failCount > 0) {
  console.log('\n[X] Some tests failed');
  process.exit(1);
} else {
  console.log('\n[OK] All Take Detection tests passed');
  process.exit(0);
}
