import type { FullAnalysisReport, MeasurementScore, AnalysisRecommendation } from '../types/scoring.js';
import { getPercentileDescription, formatPercentile } from '../scoring/percentile.js';
import { getScoreRating } from '../scoring/bellCurve.js';

/**
 * Generate analysis reports in various formats
 */
export class ReportGenerator {
  private analysis: FullAnalysisReport;

  constructor(analysis: FullAnalysisReport) {
    this.analysis = analysis;
  }

  /**
   * Export report as JSON string
   */
  toJSON(): string {
    return JSON.stringify(this.analysis, null, 2);
  }

  /**
   * Export report as Markdown
   */
  toMarkdown(): string {
    const lines: string[] = [];

    lines.push('# Facial Analysis Report');
    lines.push('');
    lines.push(`**Date:** ${this.analysis.timestamp.toISOString()}`);
    lines.push(`**Gender:** ${this.analysis.gender}`);
    lines.push('');

    // Overall Score
    lines.push('## Overall Harmony Score');
    lines.push('');
    lines.push(`**Score:** ${this.analysis.harmonyScore.toFixed(1)}/100`);
    lines.push(`**Rating:** ${getRatingEmoji(this.analysis.harmonyScore)} ${capitalizeFirst(getScoreRating(this.analysis.harmonyScore))}`);
    lines.push(`**Percentile:** ${formatPercentile(this.analysis.percentiles.overall)}`);
    lines.push('');

    // Measurements Section
    lines.push('## Measurements');
    lines.push('');

    if (this.analysis.measurements.front) {
      lines.push('### Front Face');
      lines.push('');
      lines.push(this.getMeasurementsTable('front'));
      lines.push('');
    }

    if (this.analysis.measurements.side) {
      lines.push('### Side Profile');
      lines.push('');
      lines.push(this.getMeasurementsTable('side'));
      lines.push('');
    }

    // Scores Section
    lines.push('## Scores');
    lines.push('');
    lines.push(this.getScoresTable());
    lines.push('');

    // Percentiles Section
    lines.push('## Population Comparison');
    lines.push('');
    lines.push(this.getPercentilesTable());
    lines.push('');

    // Recommendations Section
    if (this.analysis.recommendations.length > 0) {
      lines.push('## Recommendations');
      lines.push('');
      lines.push(this.getRecommendationsSection());
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Export report as HTML
   */
  toHTML(): string {
    const lines: string[] = [];

    lines.push('<!DOCTYPE html>');
    lines.push('<html lang="en">');
    lines.push('<head>');
    lines.push('  <meta charset="UTF-8">');
    lines.push('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
    lines.push('  <title>Facial Analysis Report</title>');
    lines.push('  <style>');
    lines.push(this.getStyles());
    lines.push('  </style>');
    lines.push('</head>');
    lines.push('<body>');
    lines.push('  <div class="container">');

    // Header
    lines.push('    <header>');
    lines.push('      <h1>Facial Analysis Report</h1>');
    lines.push(`      <p class="meta">Generated: ${this.analysis.timestamp.toLocaleDateString()} | Gender: ${this.analysis.gender}</p>`);
    lines.push('    </header>');

    // Harmony Score Card
    lines.push('    <section class="score-card">');
    lines.push('      <h2>Overall Harmony Score</h2>');
    lines.push(`      <div class="score-display">${this.analysis.harmonyScore.toFixed(1)}</div>`);
    lines.push(`      <div class="score-rating ${getScoreRating(this.analysis.harmonyScore)}">${capitalizeFirst(getScoreRating(this.analysis.harmonyScore))}</div>`);
    lines.push(`      <p>${getPercentileDescription(this.analysis.percentiles.overall)}</p>`);
    lines.push('    </section>');

    // Measurements
    if (this.analysis.measurements.front) {
      lines.push('    <section class="measurements">');
      lines.push('      <h2>Front Face Measurements</h2>');
      lines.push(this.getMeasurementsHTML('front'));
      lines.push('    </section>');
    }

    if (this.analysis.measurements.side) {
      lines.push('    <section class="measurements">');
      lines.push('      <h2>Side Profile Measurements</h2>');
      lines.push(this.getMeasurementsHTML('side'));
      lines.push('    </section>');
    }

    // Scores
    lines.push('    <section class="scores">');
    lines.push('      <h2>Detailed Scores</h2>');
    lines.push(this.getScoresHTML());
    lines.push('    </section>');

    // Recommendations
    if (this.analysis.recommendations.length > 0) {
      lines.push('    <section class="recommendations">');
      lines.push('      <h2>Recommendations</h2>');
      lines.push(this.getRecommendationsHTML());
      lines.push('    </section>');
    }

    lines.push('  </div>');
    lines.push('</body>');
    lines.push('</html>');

    return lines.join('\n');
  }

  /**
   * Get measurements section as Markdown table
   */
  getMeasurementsSection(): string {
    const sections: string[] = [];

    if (this.analysis.measurements.front) {
      sections.push('### Front Face Measurements\n');
      sections.push(this.getMeasurementsTable('front'));
    }

    if (this.analysis.measurements.side) {
      sections.push('### Side Profile Measurements\n');
      sections.push(this.getMeasurementsTable('side'));
    }

    return sections.join('\n\n');
  }

  /**
   * Get scores section as Markdown table
   */
  getScoresSection(): string {
    return this.getScoresTable();
  }

  /**
   * Get percentiles section as Markdown table
   */
  getPercentileSection(): string {
    return this.getPercentilesTable();
  }

  /**
   * Get recommendations section as Markdown
   */
  getRecommendationsSection(): string {
    const lines: string[] = [];

    for (const rec of this.analysis.recommendations) {
      const priorityIcon = rec.priority === 'high' ? 'üî¥' : rec.priority === 'medium' ? 'üü°' : 'üü¢';
      lines.push(`- ${priorityIcon} **${rec.measurement}**: ${rec.description}`);
    }

    return lines.join('\n');
  }

  // Private helper methods

  private getMeasurementsTable(type: 'front' | 'side'): string {
    const lines: string[] = [];
    lines.push('| Measurement | Value |');
    lines.push('|-------------|-------|');

    const measurements = type === 'front'
      ? this.analysis.measurements.front
      : this.analysis.measurements.side;

    if (!measurements) return '';

    const entries = Object.entries(measurements);
    for (const [key, value] of entries) {
      if (typeof value === 'number') {
        lines.push(`| ${formatKey(key)} | ${value.toFixed(2)} |`);
      } else if (typeof value === 'string') {
        lines.push(`| ${formatKey(key)} | ${value} |`);
      }
    }

    return lines.join('\n');
  }

  private getMeasurementsHTML(type: 'front' | 'side'): string {
    const lines: string[] = [];
    lines.push('      <table>');
    lines.push('        <thead><tr><th>Measurement</th><th>Value</th></tr></thead>');
    lines.push('        <tbody>');

    const measurements = type === 'front'
      ? this.analysis.measurements.front
      : this.analysis.measurements.side;

    if (measurements) {
      const entries = Object.entries(measurements);
      for (const [key, value] of entries) {
        if (typeof value === 'number') {
          lines.push(`          <tr><td>${formatKey(key)}</td><td>${value.toFixed(2)}</td></tr>`);
        } else if (typeof value === 'string') {
          lines.push(`          <tr><td>${formatKey(key)}</td><td>${value}</td></tr>`);
        }
      }
    }

    lines.push('        </tbody>');
    lines.push('      </table>');

    return lines.join('\n');
  }

  private getScoresTable(): string {
    const lines: string[] = [];
    lines.push('| Metric | Score | Rating | Percentile |');
    lines.push('|--------|-------|--------|------------|');

    const scores = this.analysis.scores;
    const percentiles = this.analysis.percentiles.byMeasurement;

    const scoreEntries: [string, MeasurementScore | undefined][] = [
      ['FWHR', scores.fwhr],
      ['Canthal Tilt', scores.canthalTilt],
      ['Facial Thirds', scores.facialThirds],
      ['Symmetry', scores.symmetry],
      ['Golden Ratio', scores.goldenRatio],
      ['Nasal Index', scores.nasalIndex],
      ['Lip Ratio', scores.lipRatio],
      ['Nasolabial Angle', scores.nasolabialAngle],
      ['Gonial Angle', scores.gonialAngle],
      ['Chin Projection', scores.chinProjection],
      ['Nose Projection', scores.noseProjection],
      ['Facial Convexity', scores.facialConvexity],
    ];

    for (const [name, score] of scoreEntries) {
      if (score) {
        const percentile = percentiles[name.toLowerCase().replace(/ /g, '')] ?? score.percentile;
        lines.push(`| ${name} | ${score.score.toFixed(1)} | ${capitalizeFirst(score.rating)} | ${percentile.toFixed(1)}% |`);
      }
    }

    return lines.join('\n');
  }

  private getScoresHTML(): string {
    const lines: string[] = [];
    lines.push('      <table>');
    lines.push('        <thead><tr><th>Metric</th><th>Score</th><th>Rating</th></tr></thead>');
    lines.push('        <tbody>');

    const scores = this.analysis.scores;
    const scoreEntries: [string, MeasurementScore | undefined][] = [
      ['FWHR', scores.fwhr],
      ['Canthal Tilt', scores.canthalTilt],
      ['Symmetry', scores.symmetry],
      ['Golden Ratio', scores.goldenRatio],
      ['Nasolabial Angle', scores.nasolabialAngle],
      ['Gonial Angle', scores.gonialAngle],
    ];

    for (const [name, score] of scoreEntries) {
      if (score) {
        lines.push(`          <tr><td>${name}</td><td>${score.score.toFixed(1)}</td><td class="${score.rating}">${capitalizeFirst(score.rating)}</td></tr>`);
      }
    }

    lines.push('        </tbody>');
    lines.push('      </table>');

    return lines.join('\n');
  }

  private getPercentilesTable(): string {
    const lines: string[] = [];
    lines.push('| Metric | Percentile | Description |');
    lines.push('|--------|------------|-------------|');

    lines.push(`| **Overall** | ${this.analysis.percentiles.overall.toFixed(1)}% | ${getPercentileDescription(this.analysis.percentiles.overall)} |`);

    for (const [key, value] of Object.entries(this.analysis.percentiles.byMeasurement)) {
      lines.push(`| ${formatKey(key)} | ${value.toFixed(1)}% | ${getPercentileDescription(value)} |`);
    }

    return lines.join('\n');
  }

  private getRecommendationsHTML(): string {
    const lines: string[] = [];
    lines.push('      <ul class="recommendations-list">');

    for (const rec of this.analysis.recommendations) {
      lines.push(`        <li class="priority-${rec.priority}">`);
      lines.push(`          <strong>${rec.measurement}</strong>: ${rec.description}`);
      lines.push('        </li>');
    }

    lines.push('      </ul>');

    return lines.join('\n');
  }

  private getStyles(): string {
    return `
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; }
    .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
    header { text-align: center; margin-bottom: 2rem; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    .meta { color: #666; }
    section { background: white; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h2 { font-size: 1.25rem; margin-bottom: 1rem; color: #444; }
    .score-card { text-align: center; }
    .score-display { font-size: 4rem; font-weight: bold; color: #2563eb; }
    .score-rating { font-size: 1.25rem; margin: 0.5rem 0; padding: 0.25rem 1rem; border-radius: 4px; display: inline-block; }
    .exceptional { background: #22c55e; color: white; }
    .excellent { background: #84cc16; color: white; }
    .good { background: #eab308; color: #333; }
    .average { background: #f97316; color: white; }
    .below_average { background: #ef4444; color: white; }
    .poor { background: #dc2626; color: white; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #eee; }
    th { font-weight: 600; color: #666; }
    .recommendations-list { list-style: none; }
    .recommendations-list li { padding: 0.75rem; margin-bottom: 0.5rem; border-radius: 4px; }
    .priority-high { background: #fee2e2; border-left: 4px solid #ef4444; }
    .priority-medium { background: #fef3c7; border-left: 4px solid #f59e0b; }
    .priority-low { background: #dcfce7; border-left: 4px solid #22c55e; }
    `;
  }
}

// Helper functions

function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).replace(/_/g, ' ');
}

function formatKey(key: string): string {
  return key
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (s) => s.toUpperCase())
    .trim();
}

function getRatingEmoji(score: number): string {
  if (score >= 90) return 'üåü';
  if (score >= 80) return '‚ú®';
  if (score >= 70) return 'üëç';
  if (score >= 50) return 'üìä';
  if (score >= 30) return 'üìâ';
  return '‚ö†Ô∏è';
}
