import type { Point, CropInfo, NamedSideLandmarks, NamedFrontLandmarks } from '../types/landmarks.js';
import { SIDE_LANDMARKS, FRONT_LANDMARKS } from '../constants/landmarkIndices.js';

/**
 * Normalize landmark coordinates to 0-1 range
 */
export function normalizeCoordinates(
  landmarks: Point[],
  imageWidth: number,
  imageHeight: number
): Point[] {
  return landmarks.map((p) => ({
    x: p.x / imageWidth,
    y: p.y / imageHeight,
  }));
}

/**
 * Denormalize coordinates from 0-1 range to pixel coordinates
 */
export function denormalizeCoordinates(
  landmarks: Point[],
  imageWidth: number,
  imageHeight: number
): Point[] {
  return landmarks.map((p) => ({
    x: p.x * imageWidth,
    y: p.y * imageHeight,
  }));
}

/**
 * Apply crop transformation to landmarks
 */
export function applyCropTransform(
  landmarks: Point[],
  crop: CropInfo
): Point[] {
  return landmarks.map((p) => ({
    x: (p.x - crop.x) * crop.scale,
    y: (p.y - crop.y) * crop.scale,
  }));
}

/**
 * Reverse crop transformation
 */
export function reverseCropTransform(
  landmarks: Point[],
  crop: CropInfo
): Point[] {
  return landmarks.map((p) => ({
    x: p.x / crop.scale + crop.x,
    y: p.y / crop.scale + crop.y,
  }));
}

/**
 * Flip landmarks horizontally (for left profile to right profile conversion)
 */
export function flipLandmarksHorizontal(
  landmarks: Point[],
  imageWidth: number
): Point[] {
  return landmarks.map((p) => ({
    x: imageWidth - p.x,
    y: p.y,
  }));
}

/**
 * Rotate landmarks around a center point
 */
export function rotateLandmarks(
  landmarks: Point[],
  center: Point,
  angleDegrees: number
): Point[] {
  const angleRad = angleDegrees * (Math.PI / 180);
  const cos = Math.cos(angleRad);
  const sin = Math.sin(angleRad);

  return landmarks.map((p) => {
    const dx = p.x - center.x;
    const dy = p.y - center.y;
    return {
      x: center.x + dx * cos - dy * sin,
      y: center.y + dx * sin + dy * cos,
    };
  });
}

/**
 * Get a safe point from landmarks array
 */
function getSafePoint(landmarks: Point[], index: number): Point {
  if (index >= 0 && index < landmarks.length) {
    return landmarks[index];
  }
  return { x: 0, y: 0 };
}

/**
 * Get multiple safe points from landmarks array
 */
function getSafePoints(landmarks: Point[], indices: readonly number[]): Point[] {
  return indices.map((i) => getSafePoint(landmarks, i));
}

/**
 * Extract named side profile landmarks from raw array
 */
export function extractNamedSideLandmarks(landmarks: Point[]): NamedSideLandmarks {
  return {
    // Face Contour
    menton: getSafePoint(landmarks, SIDE_LANDMARKS.MENTON),
    pogonion: getSafePoint(landmarks, SIDE_LANDMARKS.POGONION),
    gnathion: getSafePoint(landmarks, SIDE_LANDMARKS.GNATHION),
    mandibleContour: getSafePoints(landmarks, SIDE_LANDMARKS.MANDIBLE_CONTOUR),

    // Posterior Points
    tragion: getSafePoint(landmarks, SIDE_LANDMARKS.TRAGION),
    earContour: getSafePoints(landmarks, SIDE_LANDMARKS.EAR_CONTOUR),

    // Forehead
    trichion: getSafePoint(landmarks, SIDE_LANDMARKS.TRICHION),

    // Nose Profile
    nasion: getSafePoint(landmarks, SIDE_LANDMARKS.NASION),
    pronasale: getSafePoint(landmarks, SIDE_LANDMARKS.PRONASALE),
    subnasale: getSafePoint(landmarks, SIDE_LANDMARKS.SUBNASALE),
    columella: getSafePoint(landmarks, SIDE_LANDMARKS.COLUMELLA),
    noseBridge: getSafePoints(landmarks, SIDE_LANDMARKS.NOSE_BRIDGE),
    noseTipContour: getSafePoints(landmarks, SIDE_LANDMARKS.NOSE_TIP_CONTOUR),

    // Eye Region
    eyeLateralCanthus: getSafePoint(landmarks, SIDE_LANDMARKS.EYE_LATERAL_CANTHUS),
    eyeMedialCanthus: getSafePoint(landmarks, SIDE_LANDMARKS.EYE_MEDIAL_CANTHUS),
    upperEyelid: getSafePoints(landmarks, SIDE_LANDMARKS.UPPER_EYELID),
    lowerEyelid: getSafePoints(landmarks, SIDE_LANDMARKS.LOWER_EYELID),
    pupil: getSafePoint(landmarks, SIDE_LANDMARKS.PUPIL),
    browHead: getSafePoint(landmarks, SIDE_LANDMARKS.BROW_HEAD),
    browArch: getSafePoint(landmarks, SIDE_LANDMARKS.BROW_ARCH),
    browTail: getSafePoint(landmarks, SIDE_LANDMARKS.BROW_TAIL),

    // Lip Region
    labraleSuperius: getSafePoint(landmarks, SIDE_LANDMARKS.LABRALE_SUPERIUS),
    labraleInferius: getSafePoint(landmarks, SIDE_LANDMARKS.LABRALE_INFERIUS),
    stomion: getSafePoint(landmarks, SIDE_LANDMARKS.STOMION),
    upperLipContour: getSafePoints(landmarks, SIDE_LANDMARKS.UPPER_LIP_CONTOUR),
    lowerLipContour: getSafePoints(landmarks, SIDE_LANDMARKS.LOWER_LIP_CONTOUR),

    // Additional Profile Points
    glabella: getSafePoint(landmarks, SIDE_LANDMARKS.GLABELLA),
    sellion: getSafePoint(landmarks, SIDE_LANDMARKS.SELLION),
    softTissueNasion: getSafePoint(landmarks, SIDE_LANDMARKS.SOFT_TISSUE_NASION),
    orbitale: getSafePoint(landmarks, SIDE_LANDMARKS.ORBITALE),
    gonion: getSafePoint(landmarks, SIDE_LANDMARKS.GONION),
    condylion: getSafePoint(landmarks, SIDE_LANDMARKS.CONDYLION),
  };
}

/**
 * Extract named front face landmarks from MediaPipe array (478 points)
 */
export function extractNamedFrontLandmarks(landmarks: Point[]): NamedFrontLandmarks {
  return {
    // Nose
    noseTip: getSafePoint(landmarks, FRONT_LANDMARKS.NOSE_TIP),
    noseBridge: getSafePoint(landmarks, FRONT_LANDMARKS.NOSE_BRIDGE),
    leftNostril: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_NOSTRIL),
    rightNostril: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_NOSTRIL),

    // Eyes
    leftEyeInner: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_EYE_INNER),
    leftEyeOuter: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_EYE_OUTER),
    rightEyeInner: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_EYE_INNER),
    rightEyeOuter: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_EYE_OUTER),
    leftPupil: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_PUPIL),
    rightPupil: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_PUPIL),

    // Eyebrows
    leftBrowInner: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_BROW_INNER),
    leftBrowOuter: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_BROW_OUTER),
    rightBrowInner: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_BROW_INNER),
    rightBrowOuter: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_BROW_OUTER),

    // Cheeks
    leftCheek: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_CHEEK),
    rightCheek: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_CHEEK),
    leftZygion: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_ZYGION),
    rightZygion: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_ZYGION),

    // Lips
    upperLip: getSafePoint(landmarks, FRONT_LANDMARKS.UPPER_LIP),
    lowerLip: getSafePoint(landmarks, FRONT_LANDMARKS.LOWER_LIP),
    mouthLeft: getSafePoint(landmarks, FRONT_LANDMARKS.MOUTH_LEFT),
    mouthRight: getSafePoint(landmarks, FRONT_LANDMARKS.MOUTH_RIGHT),

    // Face Contour
    chin: getSafePoint(landmarks, FRONT_LANDMARKS.CHIN),
    forehead: getSafePoint(landmarks, FRONT_LANDMARKS.FOREHEAD),
    leftTemple: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_TEMPLE),
    rightTemple: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_TEMPLE),
    leftJaw: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_JAW),
    rightJaw: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_JAW),
    leftGonion: getSafePoint(landmarks, FRONT_LANDMARKS.LEFT_GONION),
    rightGonion: getSafePoint(landmarks, FRONT_LANDMARKS.RIGHT_GONION),

    // Additional
    glabella: getSafePoint(landmarks, FRONT_LANDMARKS.GLABELLA),
    subnasale: getSafePoint(landmarks, FRONT_LANDMARKS.SUBNASALE),
  };
}

/**
 * Validate landmark data
 */
export function validateLandmarks(
  landmarks: Point[],
  expectedCount: number
): { valid: boolean; message: string } {
  if (!Array.isArray(landmarks)) {
    return { valid: false, message: 'Landmarks must be an array' };
  }

  if (landmarks.length !== expectedCount) {
    return {
      valid: false,
      message: `Expected ${expectedCount} landmarks, got ${landmarks.length}`,
    };
  }

  for (let i = 0; i < landmarks.length; i++) {
    const p = landmarks[i];
    if (typeof p?.x !== 'number' || typeof p?.y !== 'number') {
      return {
        valid: false,
        message: `Invalid landmark at index ${i}: must have numeric x and y`,
      };
    }
    if (!isFinite(p.x) || !isFinite(p.y)) {
      return {
        valid: false,
        message: `Invalid landmark at index ${i}: x and y must be finite`,
      };
    }
  }

  return { valid: true, message: 'Valid' };
}

/**
 * Calculate face center from landmarks
 */
export function calculateFaceCenter(landmarks: Point[]): Point {
  if (landmarks.length === 0) {
    return { x: 0, y: 0 };
  }

  const sum = landmarks.reduce(
    (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }),
    { x: 0, y: 0 }
  );

  return {
    x: sum.x / landmarks.length,
    y: sum.y / landmarks.length,
  };
}

/**
 * Calculate face bounding box from landmarks
 */
export function calculateFaceBoundingBox(landmarks: Point[]): {
  x: number;
  y: number;
  width: number;
  height: number;
} {
  if (landmarks.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  for (const p of landmarks) {
    if (p.x < minX) minX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.x > maxX) maxX = p.x;
    if (p.y > maxY) maxY = p.y;
  }

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY,
  };
}
