import type { PopulationStats, BellCurveData, BellCurvePoint } from '../types/scoring.js';

/**
 * Standard Normal Cumulative Distribution Function (CDF)
 * Uses Abramowitz and Stegun approximation
 */
export function normalCDF(z: number): number {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;

  const sign = z < 0 ? -1 : 1;
  const absZ = Math.abs(z) / Math.sqrt(2);

  const t = 1.0 / (1.0 + p * absZ);
  const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);

  return 0.5 * (1.0 + sign * y);
}

/**
 * Calculate Z-score from value and statistics
 */
export function zScore(value: number, mean: number, stdDev: number): number {
  if (stdDev === 0) return 0;
  return (value - mean) / stdDev;
}

/**
 * Calculate percentile from a value given population statistics
 */
export function calculatePercentile(value: number, stats: PopulationStats): number {
  const z = zScore(value, stats.mean, stats.standardDeviation);
  return normalCDF(z) * 100;
}

/**
 * Calculate value from percentile given population statistics
 */
export function percentileToValue(percentile: number, stats: PopulationStats): number {
  const z = inverseNormalCDF(percentile / 100);
  return stats.mean + z * stats.standardDeviation;
}

/**
 * Inverse Normal CDF (quantile function)
 * Uses rational approximation
 */
export function inverseNormalCDF(p: number): number {
  if (p <= 0) return -Infinity;
  if (p >= 1) return Infinity;
  if (p === 0.5) return 0;

  // Coefficients for rational approximation
  const a = [
    -3.969683028665376e+01,
    2.209460984245205e+02,
    -2.759285104469687e+02,
    1.383577518672690e+02,
    -3.066479806614716e+01,
    2.506628277459239e+00,
  ];

  const b = [
    -5.447609879822406e+01,
    1.615858368580409e+02,
    -1.556989798598866e+02,
    6.680131188771972e+01,
    -1.328068155288572e+01,
  ];

  const c = [
    -7.784894002430293e-03,
    -3.223964580411365e-01,
    -2.400758277161838e+00,
    -2.549732539343734e+00,
    4.374664141464968e+00,
    2.938163982698783e+00,
  ];

  const d = [
    7.784695709041462e-03,
    3.224671290700398e-01,
    2.445134137142996e+00,
    3.754408661907416e+00,
  ];

  const pLow = 0.02425;
  const pHigh = 1 - pLow;

  let q: number;
  let r: number;

  if (p < pLow) {
    q = Math.sqrt(-2 * Math.log(p));
    return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
           ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
  } else if (p <= pHigh) {
    q = p - 0.5;
    r = q * q;
    return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
           (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
  } else {
    q = Math.sqrt(-2 * Math.log(1 - p));
    return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
            ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
  }
}

/**
 * Probability Density Function for normal distribution
 */
export function normalPDF(x: number, mean: number, stdDev: number): number {
  const coefficient = 1 / (stdDev * Math.sqrt(2 * Math.PI));
  const exponent = -0.5 * Math.pow((x - mean) / stdDev, 2);
  return coefficient * Math.exp(exponent);
}

/**
 * Generate bell curve data points for visualization
 */
export function generateBellCurveData(
  stats: PopulationStats,
  userValue: number,
  idealValue?: number,
  numPoints: number = 100
): BellCurveData {
  const points: BellCurvePoint[] = [];

  // Generate points from -4 to +4 standard deviations
  const minX = stats.mean - 4 * stats.standardDeviation;
  const maxX = stats.mean + 4 * stats.standardDeviation;
  const step = (maxX - minX) / numPoints;

  for (let x = minX; x <= maxX; x += step) {
    const y = normalPDF(x, stats.mean, stats.standardDeviation);
    points.push({ x, y });
  }

  return {
    points,
    userValue,
    userPercentile: calculatePercentile(userValue, stats),
    mean: stats.mean,
    standardDeviation: stats.standardDeviation,
    idealValue: idealValue ?? stats.mean,
  };
}

/**
 * Calculate bell curve score (how close to ideal)
 * Uses Gaussian scoring where ideal = 100, deviation reduces score
 */
export function bellCurveScore(
  value: number,
  idealValue: number,
  standardDeviation: number,
  minScore: number = 0,
  maxScore: number = 100
): number {
  const z = (value - idealValue) / standardDeviation;
  const bellCurve = Math.exp(-0.5 * z * z);
  return minScore + (maxScore - minScore) * bellCurve;
}

/**
 * Calculate weighted average
 */
export function weightedAverage(
  values: number[],
  weights: number[]
): number {
  if (values.length !== weights.length || values.length === 0) {
    return 0;
  }

  let totalWeight = 0;
  let weightedSum = 0;

  for (let i = 0; i < values.length; i++) {
    weightedSum += values[i] * weights[i];
    totalWeight += weights[i];
  }

  if (totalWeight === 0) return 0;

  return weightedSum / totalWeight;
}

/**
 * Calculate standard deviation of an array
 */
export function standardDeviation(values: number[]): number {
  if (values.length === 0) return 0;

  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  const squaredDiffs = values.map((v) => Math.pow(v - mean, 2));
  const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;

  return Math.sqrt(avgSquaredDiff);
}

/**
 * Calculate mean of an array
 */
export function mean(values: number[]): number {
  if (values.length === 0) return 0;
  return values.reduce((a, b) => a + b, 0) / values.length;
}

/**
 * Calculate median of an array
 */
export function median(values: number[]): number {
  if (values.length === 0) return 0;

  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);

  if (sorted.length % 2 === 0) {
    return (sorted[mid - 1] + sorted[mid]) / 2;
  }

  return sorted[mid];
}

/**
 * Clamp a value between min and max
 */
export function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

/**
 * Linear interpolation
 */
export function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

/**
 * Map a value from one range to another
 */
export function mapRange(
  value: number,
  inMin: number,
  inMax: number,
  outMin: number,
  outMax: number
): number {
  return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
}
