import type { Point } from '../types/landmarks.js';

/**
 * Calculate Euclidean distance between two points
 */
export function distance(p1: Point, p2: Point): number {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Calculate angle at vertex between two lines (in degrees)
 * The angle is formed by p1-vertex-p2
 */
export function angle(p1: Point, vertex: Point, p2: Point): number {
  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };

  const dot = v1.x * v2.x + v1.y * v2.y;
  const cross = v1.x * v2.y - v1.y * v2.x;

  const angleRad = Math.atan2(Math.abs(cross), dot);
  return angleRad * (180 / Math.PI);
}

/**
 * Calculate signed angle at vertex (considers direction)
 */
export function signedAngle(p1: Point, vertex: Point, p2: Point): number {
  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };

  const dot = v1.x * v2.x + v1.y * v2.y;
  const cross = v1.x * v2.y - v1.y * v2.x;

  return Math.atan2(cross, dot) * (180 / Math.PI);
}

/**
 * Calculate midpoint between two points
 */
export function midpoint(p1: Point, p2: Point): Point {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2,
  };
}

/**
 * Calculate slope between two points
 */
export function slope(p1: Point, p2: Point): number {
  if (p2.x - p1.x === 0) {
    return Infinity;
  }
  return (p2.y - p1.y) / (p2.x - p1.x);
}

/**
 * Calculate angle of line from horizontal (in degrees)
 */
export function lineAngle(p1: Point, p2: Point): number {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.atan2(dy, dx) * (180 / Math.PI);
}

/**
 * Calculate perpendicular distance from a point to a line defined by two points
 */
export function perpendicularDistance(
  point: Point,
  lineP1: Point,
  lineP2: Point
): number {
  const A = point.x - lineP1.x;
  const B = point.y - lineP1.y;
  const C = lineP2.x - lineP1.x;
  const D = lineP2.y - lineP1.y;

  const dot = A * C + B * D;
  const lenSq = C * C + D * D;

  if (lenSq === 0) {
    return distance(point, lineP1);
  }

  const param = dot / lenSq;

  let nearestX: number;
  let nearestY: number;

  if (param < 0) {
    nearestX = lineP1.x;
    nearestY = lineP1.y;
  } else if (param > 1) {
    nearestX = lineP2.x;
    nearestY = lineP2.y;
  } else {
    nearestX = lineP1.x + param * C;
    nearestY = lineP1.y + param * D;
  }

  return distance(point, { x: nearestX, y: nearestY });
}

/**
 * Calculate signed perpendicular distance (positive = right side, negative = left side)
 */
export function signedPerpendicularDistance(
  point: Point,
  lineP1: Point,
  lineP2: Point
): number {
  // Calculate the signed area of the triangle formed by the three points
  const area = (lineP2.x - lineP1.x) * (point.y - lineP1.y) -
               (lineP2.y - lineP1.y) * (point.x - lineP1.x);

  const lineLength = distance(lineP1, lineP2);

  if (lineLength === 0) return 0;

  return area / lineLength;
}

/**
 * Calculate centroid of multiple points
 */
export function centroid(points: Point[]): Point {
  if (points.length === 0) {
    return { x: 0, y: 0 };
  }

  const sum = points.reduce(
    (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }),
    { x: 0, y: 0 }
  );

  return {
    x: sum.x / points.length,
    y: sum.y / points.length,
  };
}

/**
 * Rotate a point around an origin
 */
export function rotatePoint(
  point: Point,
  origin: Point,
  angleDegrees: number
): Point {
  const angleRad = angleDegrees * (Math.PI / 180);
  const cos = Math.cos(angleRad);
  const sin = Math.sin(angleRad);

  const dx = point.x - origin.x;
  const dy = point.y - origin.y;

  return {
    x: origin.x + dx * cos - dy * sin,
    y: origin.y + dx * sin + dy * cos,
  };
}

/**
 * Calculate the bounding box of multiple points
 */
export function boundingBox(points: Point[]): {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
  width: number;
  height: number;
} {
  if (points.length === 0) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
  }

  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  for (const p of points) {
    if (p.x < minX) minX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.x > maxX) maxX = p.x;
    if (p.y > maxY) maxY = p.y;
  }

  return {
    minX,
    minY,
    maxX,
    maxY,
    width: maxX - minX,
    height: maxY - minY,
  };
}

/**
 * Calculate area of polygon defined by points (shoelace formula)
 */
export function polygonArea(points: Point[]): number {
  if (points.length < 3) return 0;

  let area = 0;
  const n = points.length;

  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    area += points[i].x * points[j].y;
    area -= points[j].x * points[i].y;
  }

  return Math.abs(area) / 2;
}

/**
 * Linear interpolation between two points
 */
export function lerp(p1: Point, p2: Point, t: number): Point {
  return {
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t,
  };
}

/**
 * Calculate the reflection of a point across a line
 */
export function reflectPoint(
  point: Point,
  lineP1: Point,
  lineP2: Point
): Point {
  const dx = lineP2.x - lineP1.x;
  const dy = lineP2.y - lineP1.y;
  const lenSq = dx * dx + dy * dy;

  if (lenSq === 0) return point;

  const t = ((point.x - lineP1.x) * dx + (point.y - lineP1.y) * dy) / lenSq;

  const closestX = lineP1.x + t * dx;
  const closestY = lineP1.y + t * dy;

  return {
    x: 2 * closestX - point.x,
    y: 2 * closestY - point.y,
  };
}

/**
 * Calculate symmetry score between two points across a vertical axis
 */
export function pointSymmetry(
  leftPoint: Point,
  rightPoint: Point,
  axisX: number
): number {
  // Distance from axis
  const leftDist = axisX - leftPoint.x;
  const rightDist = rightPoint.x - axisX;

  // Y difference
  const yDiff = Math.abs(leftPoint.y - rightPoint.y);

  // Calculate asymmetry
  const distDiff = Math.abs(leftDist - rightDist);
  const avgDist = (Math.abs(leftDist) + Math.abs(rightDist)) / 2;

  if (avgDist === 0) return 100;

  const horizontalAsymmetry = distDiff / avgDist;
  const verticalAsymmetry = yDiff / avgDist;

  // Combined asymmetry (weighted)
  const totalAsymmetry = horizontalAsymmetry * 0.7 + verticalAsymmetry * 0.3;

  // Convert to score (0-100)
  return Math.max(0, Math.min(100, (1 - totalAsymmetry) * 100));
}

/**
 * Calculate the angle between three points where the middle point is the vertex
 * Returns the interior angle in degrees
 */
export function interiorAngle(p1: Point, vertex: Point, p2: Point): number {
  const a = distance(vertex, p1);
  const b = distance(vertex, p2);
  const c = distance(p1, p2);

  if (a === 0 || b === 0) return 0;

  // Law of cosines
  const cosAngle = (a * a + b * b - c * c) / (2 * a * b);
  const clampedCos = Math.max(-1, Math.min(1, cosAngle));

  return Math.acos(clampedCos) * (180 / Math.PI);
}
