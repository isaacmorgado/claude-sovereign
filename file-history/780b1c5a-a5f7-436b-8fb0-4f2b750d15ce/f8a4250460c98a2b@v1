import type { Point, NamedFrontLandmarks } from '../types/landmarks.js';
import type { FrontFaceMeasurements, GoldenRatioScores } from '../types/measurements.js';
import { distance, lineAngle, pointSymmetry, midpoint } from '../utils/geometry.js';
import { PHI } from '../constants/idealValues.js';

/**
 * Calculate all front face measurements from named landmarks
 */
export function calculateFrontFaceMeasurements(
  landmarks: NamedFrontLandmarks
): FrontFaceMeasurements {
  return {
    // Ratios
    fwhr: calculateFWHR(landmarks),
    facialIndex: calculateFacialIndex(landmarks),
    jawWidth: calculateJawWidth(landmarks),
    cheekboneWidth: calculateCheekboneWidth(landmarks),

    // Thirds
    ...calculateFacialThirds(landmarks),

    // Fifths
    facialFifths: calculateFacialFifths(landmarks),

    // Symmetry
    ...calculateSymmetry(landmarks),

    // Eye Measurements
    canthalTilt: calculateCanthalTilt(landmarks),
    interpupillaryDistance: calculateInterpupillaryDistance(landmarks),
    palpebralFissureLength: calculatePalpebralFissureLength(landmarks),
    intercanthalWidth: calculateIntercanthalWidth(landmarks),

    // Nose Measurements
    nasalWidth: calculateNasalWidth(landmarks),
    nasalHeight: calculateNasalHeight(landmarks),
    nasalIndex: calculateNasalIndex(landmarks),

    // Mouth Measurements
    lipRatio: calculateLipRatio(landmarks),
    mouthWidth: calculateMouthWidth(landmarks),
    philtrumLength: calculatePhiltrumLength(landmarks),

    // Golden Ratio Scores
    goldenRatioScores: calculateGoldenRatioScores(landmarks),
  };
}

/**
 * Calculate FWHR (Facial Width-to-Height Ratio)
 * Width: Bizygomatic width (cheekbone to cheekbone)
 * Height: Upper face height (nasion/brow area to upper lip)
 */
export function calculateFWHR(landmarks: NamedFrontLandmarks): number {
  const width = distance(landmarks.leftZygion, landmarks.rightZygion);
  const height = distance(landmarks.glabella, landmarks.upperLip);

  if (height === 0) return 0;
  return width / height;
}

/**
 * Calculate Facial Index (face height / face width)
 */
export function calculateFacialIndex(landmarks: NamedFrontLandmarks): number {
  const width = distance(landmarks.leftZygion, landmarks.rightZygion);
  const height = distance(landmarks.forehead, landmarks.chin);

  if (width === 0) return 0;
  return height / width;
}

/**
 * Calculate jaw width (bigonial width)
 */
export function calculateJawWidth(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.leftGonion, landmarks.rightGonion);
}

/**
 * Calculate cheekbone width (bizygomatic width)
 */
export function calculateCheekboneWidth(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.leftZygion, landmarks.rightZygion);
}

/**
 * Calculate facial thirds percentages
 */
export function calculateFacialThirds(landmarks: NamedFrontLandmarks): {
  upperThird: number;
  middleThird: number;
  lowerThird: number;
} {
  const upperThirdDist = distance(landmarks.forehead, landmarks.glabella);
  const middleThirdDist = distance(landmarks.glabella, landmarks.subnasale);
  const lowerThirdDist = distance(landmarks.subnasale, landmarks.chin);

  const total = upperThirdDist + middleThirdDist + lowerThirdDist;

  if (total === 0) {
    return { upperThird: 33.33, middleThird: 33.33, lowerThird: 33.33 };
  }

  return {
    upperThird: (upperThirdDist / total) * 100,
    middleThird: (middleThirdDist / total) * 100,
    lowerThird: (lowerThirdDist / total) * 100,
  };
}

/**
 * Calculate facial fifths (5 vertical sections)
 */
export function calculateFacialFifths(landmarks: NamedFrontLandmarks): number[] {
  // From left to right: left ear edge, left eye outer, left eye inner,
  // right eye inner, right eye outer, right ear edge
  const points: Point[] = [
    landmarks.leftTemple,
    landmarks.leftEyeOuter,
    landmarks.leftEyeInner,
    landmarks.rightEyeInner,
    landmarks.rightEyeOuter,
    landmarks.rightTemple,
  ];

  const widths: number[] = [];
  for (let i = 0; i < points.length - 1; i++) {
    widths.push(Math.abs(points[i + 1].x - points[i].x));
  }

  const total = widths.reduce((a, b) => a + b, 0);
  if (total === 0) return [20, 20, 20, 20, 20];

  return widths.map((w) => (w / total) * 100);
}

/**
 * Calculate all symmetry measurements
 */
export function calculateSymmetry(landmarks: NamedFrontLandmarks): {
  overallSymmetry: number;
  eyeSymmetry: number;
  browSymmetry: number;
  lipSymmetry: number;
  jawSymmetry: number;
} {
  // Calculate face center X
  const faceCenterX = (landmarks.leftZygion.x + landmarks.rightZygion.x) / 2;

  // Eye symmetry
  const eyeSymmetry = pointSymmetry(
    landmarks.leftEyeInner,
    landmarks.rightEyeInner,
    faceCenterX
  );

  // Brow symmetry
  const browSymmetry = pointSymmetry(
    landmarks.leftBrowInner,
    landmarks.rightBrowInner,
    faceCenterX
  );

  // Lip symmetry (mouth corners)
  const lipSymmetry = pointSymmetry(
    landmarks.mouthLeft,
    landmarks.mouthRight,
    faceCenterX
  );

  // Jaw symmetry
  const jawSymmetry = pointSymmetry(
    landmarks.leftGonion,
    landmarks.rightGonion,
    faceCenterX
  );

  // Overall symmetry (weighted average)
  const overallSymmetry =
    eyeSymmetry * 0.3 +
    browSymmetry * 0.2 +
    lipSymmetry * 0.25 +
    jawSymmetry * 0.25;

  return {
    overallSymmetry,
    eyeSymmetry,
    browSymmetry,
    lipSymmetry,
    jawSymmetry,
  };
}

/**
 * Calculate canthal tilt (angle of eye from horizontal)
 */
export function calculateCanthalTilt(landmarks: NamedFrontLandmarks): number {
  // Left eye canthal tilt
  const leftTilt = lineAngle(landmarks.leftEyeInner, landmarks.leftEyeOuter);

  // Right eye canthal tilt (flip sign for right side)
  const rightTilt = -lineAngle(landmarks.rightEyeOuter, landmarks.rightEyeInner);

  // Average both eyes
  return (leftTilt + rightTilt) / 2;
}

/**
 * Calculate interpupillary distance
 */
export function calculateInterpupillaryDistance(landmarks: NamedFrontLandmarks): number {
  // Use eye centers as approximation for pupil positions
  const leftEyeCenter = midpoint(landmarks.leftEyeInner, landmarks.leftEyeOuter);
  const rightEyeCenter = midpoint(landmarks.rightEyeInner, landmarks.rightEyeOuter);

  return distance(leftEyeCenter, rightEyeCenter);
}

/**
 * Calculate palpebral fissure length (eye width)
 */
export function calculatePalpebralFissureLength(landmarks: NamedFrontLandmarks): number {
  const leftEyeWidth = distance(landmarks.leftEyeInner, landmarks.leftEyeOuter);
  const rightEyeWidth = distance(landmarks.rightEyeInner, landmarks.rightEyeOuter);

  return (leftEyeWidth + rightEyeWidth) / 2;
}

/**
 * Calculate intercanthal width (between inner eye corners)
 */
export function calculateIntercanthalWidth(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.leftEyeInner, landmarks.rightEyeInner);
}

/**
 * Calculate nasal width
 */
export function calculateNasalWidth(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.leftNostril, landmarks.rightNostril);
}

/**
 * Calculate nasal height
 */
export function calculateNasalHeight(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.noseBridge, landmarks.subnasale);
}

/**
 * Calculate nasal index (width / height)
 */
export function calculateNasalIndex(landmarks: NamedFrontLandmarks): number {
  const width = calculateNasalWidth(landmarks);
  const height = calculateNasalHeight(landmarks);

  if (height === 0) return 0;
  return width / height;
}

/**
 * Calculate lip ratio (upper lip height / lower lip height)
 */
export function calculateLipRatio(landmarks: NamedFrontLandmarks): number {
  // Approximate upper and lower lip heights
  const lipCenter = midpoint(landmarks.upperLip, landmarks.lowerLip);
  const upperLipHeight = distance(landmarks.subnasale, lipCenter);
  const lowerLipHeight = distance(lipCenter, landmarks.chin) * 0.4; // Approximate

  if (lowerLipHeight === 0) return 0;
  return upperLipHeight / lowerLipHeight;
}

/**
 * Calculate mouth width
 */
export function calculateMouthWidth(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.mouthLeft, landmarks.mouthRight);
}

/**
 * Calculate philtrum length (nose base to upper lip)
 */
export function calculatePhiltrumLength(landmarks: NamedFrontLandmarks): number {
  return distance(landmarks.subnasale, landmarks.upperLip);
}

/**
 * Calculate golden ratio scores for various facial proportions
 */
export function calculateGoldenRatioScores(landmarks: NamedFrontLandmarks): GoldenRatioScores {
  // Face height to width ratio
  const faceHeight = distance(landmarks.forehead, landmarks.chin);
  const faceWidth = distance(landmarks.leftZygion, landmarks.rightZygion);
  const faceHeightWidthRatio = faceWidth > 0 ? faceHeight / faceWidth : 0;
  const faceHeightWidthScore = goldenRatioScore(faceHeightWidthRatio);

  // Nose to mouth ratio
  const noseToLip = distance(landmarks.subnasale, landmarks.upperLip);
  const lipToChin = distance(landmarks.lowerLip, landmarks.chin);
  const noseMouthRatio = noseToLip > 0 ? lipToChin / noseToLip : 0;
  const noseMouthScore = goldenRatioScore(noseMouthRatio);

  // Eye spacing ratio
  const ipd = calculateInterpupillaryDistance(landmarks);
  const eyeWidth = calculatePalpebralFissureLength(landmarks);
  const eyeSpacingRatio = eyeWidth > 0 ? ipd / eyeWidth : 0;
  const eyeSpacingScore = goldenRatioScore(eyeSpacingRatio);

  // Lip to chin ratio
  const upperFace = distance(landmarks.forehead, landmarks.noseBridge);
  const lowerFace = distance(landmarks.noseBridge, landmarks.chin);
  const lipChinRatio = upperFace > 0 ? lowerFace / upperFace : 0;
  const lipChinScore = goldenRatioScore(lipChinRatio);

  // Overall score (weighted average)
  const overall =
    faceHeightWidthScore * 0.3 +
    noseMouthScore * 0.25 +
    eyeSpacingScore * 0.25 +
    lipChinScore * 0.2;

  return {
    faceHeightWidth: faceHeightWidthScore,
    noseMouth: noseMouthScore,
    eyeSpacing: eyeSpacingScore,
    lipChin: lipChinScore,
    overall,
  };
}

/**
 * Calculate score based on how close a ratio is to golden ratio
 */
function goldenRatioScore(ratio: number): number {
  if (ratio === 0) return 0;

  const deviation = Math.abs(ratio - PHI) / PHI;
  const score = Math.max(0, 1 - deviation) * 100;

  return Math.min(100, score);
}
