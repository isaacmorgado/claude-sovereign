#!/bin/bash
# Agent Loop - Autonomous execution with tool calling
# Based on patterns from: Roo-Code AgentLoopState, UI-TARS AgentComposer, PraisonAI, TanStack

set -uo pipefail

AGENT_DIR="${HOME}/.claude/agent"
AGENT_STATE="$AGENT_DIR/state.json"
TOOL_REGISTRY="$AGENT_DIR/tools.json"
EXECUTION_LOG="$AGENT_DIR/execution.log"
LOG_FILE="${HOME}/.claude/agent-loop.log"

# Loop control
MAX_ITERATIONS="${MAX_ITERATIONS:-50}"
MAX_CONSECUTIVE_FAILURES="${MAX_CONSECUTIVE_FAILURES:-3}"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

init_agent() {
    mkdir -p "$AGENT_DIR"

    # Initialize tool registry if not exists
    if [[ ! -f "$TOOL_REGISTRY" ]]; then
        cat > "$TOOL_REGISTRY" << 'EOF'
{
    "tools": {
        "read_file": {
            "description": "Read file contents",
            "command": "cat",
            "requiresPath": true
        },
        "write_file": {
            "description": "Write to file",
            "command": "tee",
            "requiresPath": true
        },
        "search_code": {
            "description": "Search in codebase",
            "command": "grep -r",
            "requiresPattern": true
        },
        "run_tests": {
            "description": "Run test suite",
            "command": "npm test || pytest || go test ./...",
            "requiresPath": false
        },
        "lint_code": {
            "description": "Run linter",
            "command": "npm run lint || ruff check . || go vet ./...",
            "requiresPath": false
        },
        "typecheck": {
            "description": "Run type checker",
            "command": "npm run typecheck || mypy . || go build ./...",
            "requiresPath": false
        },
        "shell": {
            "description": "Execute shell command",
            "command": "bash -c",
            "requiresCommand": true
        }
    }
}
EOF
    fi
}

# =============================================================================
# AGENT STATE MACHINE (from Roo-Code patterns)
# =============================================================================

# Agent states: idle, planning, executing, validating, reflecting, paused, completed, failed

start_agent() {
    local goal="$1"
    local context="${2:-}"

    init_agent

    local agent_id
    agent_id="agent_$(date +%s)"

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    cat > "$AGENT_STATE" << EOF
{
    "id": "$agent_id",
    "goal": "$goal",
    "context": "$context",
    "state": "planning",
    "iteration": 0,
    "maxIterations": $MAX_ITERATIONS,
    "consecutiveFailures": 0,
    "startedAt": "$timestamp",
    "plan": [],
    "currentStep": null,
    "executionHistory": [],
    "toolCalls": [],
    "pauseRequested": false,
    "stopRequested": false
}
EOF

    log "Started agent: $agent_id with goal: $goal"
    echo "$agent_id"
}

# Transition agent state
transition_state() {
    local new_state="$1"
    local reason="${2:-}"

    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    local old_state
    old_state=$(jq -r '.state' "$AGENT_STATE")

    jq --arg state "$new_state" \
       --arg reason "$reason" \
       --arg ts "$timestamp" \
       --arg old "$old_state" \
       '
       .state = $state |
       .lastTransition = {
           from: $old,
           to: $state,
           reason: $reason,
           timestamp: $ts
       }
       ' "$AGENT_STATE" > "$temp_file"

    mv "$temp_file" "$AGENT_STATE"

    log "State transition: $old_state -> $new_state (reason: $reason)"
}

# =============================================================================
# LOOP CONTROL (from TanStack patterns)
# =============================================================================

# Check if loop should continue
should_continue() {
    if [[ ! -f "$AGENT_STATE" ]]; then
        echo "false:no_agent"
        return 1
    fi

    local result
    result=$(jq -r '
        if .stopRequested then
            "false:stop_requested"
        elif .pauseRequested then
            "false:paused"
        elif .state == "completed" then
            "false:completed"
        elif .state == "failed" then
            "false:failed"
        elif .iteration >= .maxIterations then
            "false:max_iterations"
        elif .consecutiveFailures >= '"$MAX_CONSECUTIVE_FAILURES"' then
            "false:consecutive_failures"
        else
            "true:continue"
        end
    ' "$AGENT_STATE")

    echo "$result"
}

# Increment iteration
increment_iteration() {
    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    jq '.iteration += 1' "$AGENT_STATE" > "$temp_file"
    mv "$temp_file" "$AGENT_STATE"
}

# Record failure
record_failure() {
    local error="${1:-unknown}"

    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    jq --arg error "$error" \
       --arg ts "$timestamp" \
       '
       .consecutiveFailures += 1 |
       .lastError = {
           message: $error,
           timestamp: $ts,
           iteration: .iteration
       }
       ' "$AGENT_STATE" > "$temp_file"

    mv "$temp_file" "$AGENT_STATE"

    log "Recorded failure: $error"
}

# Record success (resets consecutive failures)
record_success() {
    local result="${1:-success}"

    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    jq --arg result "$result" \
       --arg ts "$timestamp" \
       '
       .consecutiveFailures = 0 |
       .lastSuccess = {
           result: $result,
           timestamp: $ts,
           iteration: .iteration
       }
       ' "$AGENT_STATE" > "$temp_file"

    mv "$temp_file" "$AGENT_STATE"
}

# =============================================================================
# TOOL EXECUTION (from UI-TARS patterns)
# =============================================================================

# Execute a tool call
execute_tool() {
    local tool_name="$1"
    shift
    local args=("$@")

    if [[ ! -f "$AGENT_STATE" ]]; then
        echo '{"success":false,"error":"no_active_agent"}'
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    local tool_call_id
    tool_call_id="tool_$(date +%s%N | cut -c1-13)"

    # Record tool call start
    jq --arg id "$tool_call_id" \
       --arg name "$tool_name" \
       --arg args "${args[*]}" \
       --arg ts "$timestamp" \
       '
       .toolCalls += [{
           id: $id,
           name: $name,
           args: $args,
           startedAt: $ts,
           status: "running"
       }]
       ' "$AGENT_STATE" > "$temp_file"

    mv "$temp_file" "$AGENT_STATE"

    log "Executing tool: $tool_name (id: $tool_call_id)"

    # Execute the tool
    local result
    local exit_code
    local start_time
    start_time=$(date +%s%N)

    case "$tool_name" in
        read_file)
            result=$(cat "${args[0]}" 2>&1)
            exit_code=$?
            ;;
        search_code)
            result=$(grep -r "${args[0]}" "${args[1]:-.}" 2>&1 | head -50)
            exit_code=$?
            ;;
        run_tests)
            result=$(npm test 2>&1 || pytest 2>&1 || go test ./... 2>&1)
            exit_code=$?
            ;;
        lint_code)
            result=$(npm run lint 2>&1 || ruff check . 2>&1 || go vet ./... 2>&1)
            exit_code=$?
            ;;
        typecheck)
            result=$(npm run typecheck 2>&1 || npx tsc --noEmit 2>&1 || mypy . 2>&1)
            exit_code=$?
            ;;
        shell)
            result=$(bash -c "${args[*]}" 2>&1)
            exit_code=$?
            ;;
        *)
            result="Unknown tool: $tool_name"
            exit_code=1
            ;;
    esac

    local end_time
    end_time=$(date +%s%N)
    local duration=$(( (end_time - start_time) / 1000000 ))  # ms

    # Update tool call with result
    temp_file=$(mktemp)
    local end_timestamp
    end_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    # Truncate result if too long
    if [[ ${#result} -gt 10000 ]]; then
        result="${result:0:10000}... (truncated)"
    fi

    jq --arg id "$tool_call_id" \
       --arg result "$result" \
       --argjson code "$exit_code" \
       --argjson duration "$duration" \
       --arg ts "$end_timestamp" \
       '
       .toolCalls = [.toolCalls[] |
           if .id == $id then
               . + {
                   result: $result,
                   exitCode: $code,
                   duration: $duration,
                   completedAt: $ts,
                   status: (if $code == 0 then "success" else "failed" end)
               }
           else . end
       ]
       ' "$AGENT_STATE" > "$temp_file"

    mv "$temp_file" "$AGENT_STATE"

    log "Tool completed: $tool_name (exit: $exit_code, duration: ${duration}ms)"

    # Return result as JSON
    jq -n \
        --arg id "$tool_call_id" \
        --arg name "$tool_name" \
        --argjson success "$([ $exit_code -eq 0 ] && echo true || echo false)" \
        --arg result "$result" \
        --argjson exitCode "$exit_code" \
        --argjson duration "$duration" \
        '{
            id: $id,
            name: $name,
            success: $success,
            result: $result,
            exitCode: $exitCode,
            durationMs: $duration
        }'
}

# =============================================================================
# LOOP LIFECYCLE HOOKS (from UI-TARS AgentComposer patterns)
# =============================================================================

# Called at start of each iteration
on_loop_start() {
    local iteration
    iteration=$(jq -r '.iteration' "$AGENT_STATE" 2>/dev/null || echo "0")

    log "Loop iteration $iteration starting"

    # Log to execution log
    echo "=== Iteration $iteration ===" >> "$EXECUTION_LOG"
    echo "Time: $(date '+%Y-%m-%d %H:%M:%S')" >> "$EXECUTION_LOG"

    # Check health
    if [[ -x "${HOME}/.claude/hooks/self-healing.sh" ]]; then
        local health
        health=$("${HOME}/.claude/hooks/self-healing.sh" health 2>/dev/null)
        if [[ "$health" != "healthy" ]]; then
            log "Health check: $health - attempting recovery"
            "${HOME}/.claude/hooks/self-healing.sh" recover 2>/dev/null
        fi
    fi
}

# Called at end of each iteration
on_loop_end() {
    local iteration
    iteration=$(jq -r '.iteration' "$AGENT_STATE" 2>/dev/null || echo "0")

    local state
    state=$(jq -r '.state' "$AGENT_STATE" 2>/dev/null || echo "unknown")

    log "Loop iteration $iteration ended (state: $state)"

    # Update metrics
    if [[ -x "${HOME}/.claude/hooks/metrics-collector.sh" ]]; then
        "${HOME}/.claude/hooks/metrics-collector.sh" tool "agent_loop" 0 2>/dev/null
    fi

    # Update progress
    if [[ -x "${HOME}/.claude/hooks/progress-tracker.sh" ]]; then
        "${HOME}/.claude/hooks/progress-tracker.sh" update "$iteration" "Iteration $iteration" "Processing..." 2>/dev/null
    fi
}

# =============================================================================
# CONTROL COMMANDS
# =============================================================================

# Request pause
request_pause() {
    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    jq '.pauseRequested = true' "$AGENT_STATE" > "$temp_file"
    mv "$temp_file" "$AGENT_STATE"

    log "Pause requested"
}

# Resume from pause
resume() {
    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    jq '.pauseRequested = false | .state = "executing"' "$AGENT_STATE" > "$temp_file"
    mv "$temp_file" "$AGENT_STATE"

    log "Resumed from pause"
}

# Request stop
request_stop() {
    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    jq '.stopRequested = true' "$AGENT_STATE" > "$temp_file"
    mv "$temp_file" "$AGENT_STATE"

    log "Stop requested"
}

# Complete agent
complete_agent() {
    local result="${1:-success}"
    local summary="${2:-}"

    if [[ ! -f "$AGENT_STATE" ]]; then
        return 1
    fi

    local temp_file
    temp_file=$(mktemp)

    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

    jq --arg result "$result" \
       --arg summary "$summary" \
       --arg ts "$timestamp" \
       '
       .state = "completed" |
       .result = $result |
       .summary = $summary |
       .completedAt = $ts |
       .totalDuration = (
           (($ts | fromdate) - (.startedAt | fromdate)) | floor
       )
       ' "$AGENT_STATE" > "$temp_file"

    mv "$temp_file" "$AGENT_STATE"

    log "Agent completed: $result"
}

# Get agent status
get_status() {
    if [[ -f "$AGENT_STATE" ]]; then
        jq '.' "$AGENT_STATE"
    else
        echo '{"state":"no_agent"}'
    fi
}

# Get execution summary
get_summary() {
    if [[ ! -f "$AGENT_STATE" ]]; then
        echo "No active agent"
        return
    fi

    jq -r '
        "=== Agent Status ===\n" +
        "Goal: \(.goal)\n" +
        "State: \(.state)\n" +
        "Iteration: \(.iteration)/\(.maxIterations)\n" +
        "Failures: \(.consecutiveFailures)\n" +
        "Tool Calls: \(.toolCalls | length)\n" +
        "Successful Tools: \([.toolCalls[] | select(.status == "success")] | length)\n" +
        "Duration: \(if .completedAt then .totalDuration else "running" end)\n"
    ' "$AGENT_STATE"
}

# =============================================================================
# COMMAND INTERFACE
# =============================================================================

case "${1:-help}" in
    start)
        start_agent "${2:-goal}" "${3:-}"
        ;;
    transition)
        transition_state "${2:-executing}" "${3:-}"
        ;;
    should-continue)
        should_continue
        ;;
    iterate)
        increment_iteration
        ;;
    failure)
        record_failure "${2:-unknown}"
        ;;
    success)
        record_success "${2:-success}"
        ;;
    execute)
        tool_name="${2:-shell}"
        shift 2 2>/dev/null || shift 1
        execute_tool "$tool_name" "$@"
        ;;
    on-start)
        on_loop_start
        ;;
    on-end)
        on_loop_end
        ;;
    pause)
        request_pause
        ;;
    resume)
        resume
        ;;
    stop)
        request_stop
        ;;
    complete)
        complete_agent "${2:-success}" "${3:-}"
        ;;
    status)
        get_status
        ;;
    summary)
        get_summary
        ;;
    help|*)
        echo "Agent Loop - Autonomous Execution System"
        echo ""
        echo "Usage: $0 <command> [args]"
        echo ""
        echo "Lifecycle Commands:"
        echo "  start <goal> [context]      - Start new agent"
        echo "  transition <state> [reason] - Change agent state"
        echo "  complete <result> [summary] - Complete agent"
        echo ""
        echo "Loop Control:"
        echo "  should-continue             - Check if loop should continue"
        echo "  iterate                     - Increment iteration counter"
        echo "  failure <error>             - Record a failure"
        echo "  success <result>            - Record a success"
        echo "  pause                       - Request pause"
        echo "  resume                      - Resume from pause"
        echo "  stop                        - Request stop"
        echo ""
        echo "Tool Execution:"
        echo "  execute <tool> [args...]    - Execute a tool"
        echo "    Tools: read_file, search_code, run_tests, lint_code, typecheck, shell"
        echo ""
        echo "Hooks:"
        echo "  on-start                    - Call at loop start"
        echo "  on-end                      - Call at loop end"
        echo ""
        echo "Status:"
        echo "  status                      - Get full status JSON"
        echo "  summary                     - Get human-readable summary"
        ;;
esac
