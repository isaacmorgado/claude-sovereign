/**
 * SPLICE CEP Panel Configuration
 * Backend URLs, paths, and utility functions
 */

// ============================================================================
// BACKEND CONFIGURATION
// ============================================================================
const SPLICE_CONFIG = {
    VERSION: '4.0.0',
    BACKEND_PROD: 'https://splice-api-production.up.railway.app',
    BACKEND_DEV: 'https://127.0.0.1:3847',
    FETCH_TIMEOUT: 120000, // 2 minutes
    RETRY_ATTEMPTS: 3,
    RETRY_DELAY: 1000
};

/**
 * Get the backend URL based on environment
 */
function getBackendUrl() {
    // Check for development mode
    const isDev = window.location.protocol === 'file:' ||
                  window.location.hostname === 'localhost' ||
                  window.location.hostname === '127.0.0.1';

    // Allow override via localStorage
    const customUrl = localStorage.getItem('spliceBackendUrl');
    if (customUrl) return customUrl;

    return isDev ? SPLICE_CONFIG.BACKEND_DEV : SPLICE_CONFIG.BACKEND_PROD;
}

// ============================================================================
// JSX BRIDGE - Communicate with Premiere Pro
// ============================================================================
const jsx = {
    cs: null,

    /**
     * Initialize the CSInterface
     */
    init: function() {
        if (typeof CSInterface !== 'undefined') {
            this.cs = new CSInterface();
        }
    },

    /**
     * Execute ExtendScript in Premiere Pro
     * @param {string} script - ExtendScript to execute
     * @returns {Promise<any>} - Parsed result
     */
    evalScript: function(script) {
        return new Promise((resolve, reject) => {
            if (!this.cs) {
                reject(new Error('CSInterface not initialized'));
                return;
            }

            this.cs.evalScript(script, (result) => {
                if (result === 'undefined' || result === undefined) {
                    resolve(null);
                    return;
                }

                // Check for EvalScript error
                if (typeof result === 'string' && result.indexOf('EvalScript error') !== -1) {
                    reject(new Error(result));
                    return;
                }

                // Try to parse JSON
                try {
                    const parsed = JSON.parse(result);
                    if (parsed.error) {
                        reject(new Error(parsed.error));
                    } else {
                        resolve(parsed);
                    }
                } catch (e) {
                    // Return as-is if not JSON
                    resolve(result);
                }
            });
        });
    },

    /**
     * Call a JSX function with arguments
     * @param {string} funcName - Function name
     * @param {...any} args - Arguments to pass
     * @returns {Promise<any>}
     */
    call: function(funcName, ...args) {
        const escapedArgs = args.map(arg => {
            if (arg === null || arg === undefined) return 'null';
            if (typeof arg === 'string') return `'${arg.replace(/'/g, "\\'").replace(/\n/g, '\\n')}'`;
            if (typeof arg === 'object') return `'${JSON.stringify(arg).replace(/'/g, "\\'")}'`;
            return String(arg);
        });

        const script = `${funcName}(${escapedArgs.join(', ')})`;
        return this.evalScript(script);
    }
};

// ============================================================================
// FETCH UTILITIES
// ============================================================================

/**
 * Fetch with timeout support
 * @param {string} url - URL to fetch
 * @param {object} options - Fetch options
 * @param {number} timeout - Timeout in ms
 */
async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error(`Request timeout after ${timeout}ms`);
        }
        throw error;
    }
}

/**
 * Parse error response from backend
 * @param {Response} response - Fetch response
 */
async function parseErrorResponse(response) {
    try {
        const data = await response.json();
        return data.error || data.message || `HTTP ${response.status}`;
    } catch {
        return `HTTP ${response.status}: ${response.statusText}`;
    }
}

/**
 * Get auth headers for API requests
 */
function getAuthHeaders() {
    const headers = { 'Content-Type': 'application/json' };
    const settings = getSettings();

    if (settings.customerId) {
        headers['x-stripe-customer-id'] = settings.customerId;
    }
    if (settings.licenseKey) {
        headers['x-license-key'] = settings.licenseKey;
    }

    return headers;
}

// ============================================================================
// SETTINGS MANAGEMENT
// ============================================================================

const DEFAULT_SETTINGS = {
    sensitivity: 50,
    minSilenceLength: 0.5,
    sourceIsolated: false,
    enableTakesDetection: true,
    enableJCut: false,
    jcutLeadIn: 0.3,
    jcutLeadOut: 0.2,
    enableZoom: false,
    zoomFrequency: 'medium',
    zoomPreset: 'medium',
    zoomPlacement: 'sentence_start',
    enableChapters: false,
    maxChapters: 10,
    minChapterLength: 60,
    enableProfanity: false,
    profanityLanguage: 'en',
    bleepType: 'standard',
    customerId: null,
    licenseKey: null,
    expandedOptions: false,
    activePreset: 'podcast'
};

/**
 * Get settings from localStorage
 */
function getSettings() {
    try {
        const stored = localStorage.getItem('spliceSettings');
        if (stored) {
            return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };
        }
    } catch (e) {
        console.warn('[Config] Error loading settings:', e);
    }
    return { ...DEFAULT_SETTINGS };
}

/**
 * Save settings to localStorage
 */
function saveSettings(settings) {
    try {
        const merged = { ...getSettings(), ...settings };
        localStorage.setItem('spliceSettings', JSON.stringify(merged));
        return true;
    } catch (e) {
        console.warn('[Config] Error saving settings:', e);
        return false;
    }
}

/**
 * Clear specific setting
 */
function clearSetting(key) {
    const settings = getSettings();
    delete settings[key];
    localStorage.setItem('spliceSettings', JSON.stringify(settings));
}

// ============================================================================
// OFFLINE DETECTION
// ============================================================================

let isOnlineState = true;
let offlineCheckInterval = null;

/**
 * Check if online
 */
function isOnline() {
    return isOnlineState && navigator.onLine;
}

/**
 * Initialize offline detection
 */
function initOfflineDetection() {
    // Browser events
    window.addEventListener('online', () => {
        isOnlineState = true;
        updateOfflineUI(true);
    });

    window.addEventListener('offline', () => {
        isOnlineState = false;
        updateOfflineUI(false);
    });

    // Periodic check
    offlineCheckInterval = setInterval(async () => {
        try {
            const response = await fetchWithTimeout(
                `${getBackendUrl()}/health`,
                { method: 'GET' },
                5000
            );
            isOnlineState = response.ok;
        } catch {
            isOnlineState = false;
        }
        updateOfflineUI(isOnlineState);
    }, 30000);
}

/**
 * Update UI based on online state
 */
function updateOfflineUI(online) {
    const goBtn = document.getElementById('goBtn');
    const status = document.getElementById('status');

    if (goBtn) {
        goBtn.disabled = !online;
    }

    if (status && !online) {
        status.textContent = 'Offline - Check your connection';
        status.style.color = '#dc3545';
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Format time in MM:SS or HH:MM:SS
 */
function formatTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return '0:00';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Set status message
 */
function setStatus(message, isError = false) {
    const status = document.getElementById('status');
    if (status) {
        status.textContent = message;
        status.style.color = isError ? '#dc3545' : '#888';
    }
}

/**
 * Debounce function calls
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Initialize JSX bridge when loaded
document.addEventListener('DOMContentLoaded', () => {
    jsx.init();
});

// Export for modules
window.SPLICE_CONFIG = SPLICE_CONFIG;
window.getBackendUrl = getBackendUrl;
window.fetchWithTimeout = fetchWithTimeout;
window.parseErrorResponse = parseErrorResponse;
window.getAuthHeaders = getAuthHeaders;
window.getSettings = getSettings;
window.saveSettings = saveSettings;
window.isOnline = isOnline;
window.initOfflineDetection = initOfflineDetection;
window.formatTime = formatTime;
window.setStatus = setStatus;
window.jsx = jsx;
