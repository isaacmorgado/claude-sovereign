/**
 * SPLICE Animated Captions Plugin Module
 *
 * Provides UI for generating word-by-word animated captions
 * with template gallery, style editor, and preview.
 */

// ============================================================================
// STATE
// ============================================================================

const animatedCaptionsState = {
  templates: [],
  selectedTemplate: 'mrbeast',
  captions: null,
  keywords: [],
  settings: {
    maxWordsPerLine: 4,
    highlightKeywords: true,
    insertEmojis: false,
    emojiFrequency: 'medium'
  },
  isGenerating: false,
  lastTranscript: null
};

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize animated captions module
 */
async function initAnimatedCaptions() {
  console.log('[SPLICE] Initializing animated captions module');

  // Load templates
  await loadCaptionTemplates();

  // Setup event listeners
  setupCaptionEventListeners();

  // Render template gallery
  renderTemplateGallery();

  console.log('[SPLICE] Animated captions module initialized');
}

/**
 * Load available templates from backend
 */
async function loadCaptionTemplates() {
  try {
    const { getBackendUrl, fetchWithTimeout } = window.spliceConfig || {};
    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';

    const response = await (fetchWithTimeout || fetch)(`${backendUrl}/captions/templates`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });

    if (response.ok) {
      const data = await response.json();
      animatedCaptionsState.templates = data.templates || [];
      console.log(`[SPLICE] Loaded ${animatedCaptionsState.templates.length} caption templates`);
    }
  } catch (err) {
    console.error('[SPLICE] Failed to load caption templates:', err);
    // Use fallback templates
    animatedCaptionsState.templates = [
      { id: 'mrbeast', name: 'MrBeast', description: 'Bold, uppercase, colorful' },
      { id: 'hormozi', name: 'Hormozi', description: 'Clean, yellow highlight' },
      { id: 'gaming', name: 'Gaming', description: 'Neon glow, glitch effects' },
      { id: 'corporate', name: 'Corporate', description: 'Subtle, professional' },
      { id: 'karaoke', name: 'Karaoke', description: 'Word-by-word highlight' }
    ];
  }
}

/**
 * Setup event listeners
 */
function setupCaptionEventListeners() {
  // Template selection
  document.addEventListener('click', (e) => {
    if (e.target.closest('.caption-template-card')) {
      const card = e.target.closest('.caption-template-card');
      const templateId = card.dataset.templateId;
      selectCaptionTemplate(templateId);
    }

    // Generate button
    if (e.target.id === 'generate-captions-btn') {
      generateCaptions();
    }

    // Export buttons
    if (e.target.id === 'export-captions-srt-btn') {
      exportCaptions('srt');
    }
    if (e.target.id === 'export-captions-mogrt-btn') {
      exportCaptions('mogrt');
    }
    if (e.target.id === 'apply-captions-timeline-btn') {
      applyCaptionsToTimeline();
    }

    // Copy captions
    if (e.target.id === 'copy-captions-btn') {
      copyCaptionsToClipboard();
    }
  });

  // Settings changes
  document.addEventListener('change', (e) => {
    if (e.target.id === 'caption-words-per-line') {
      animatedCaptionsState.settings.maxWordsPerLine = parseInt(e.target.value) || 4;
    }
    if (e.target.id === 'caption-highlight-keywords') {
      animatedCaptionsState.settings.highlightKeywords = e.target.checked;
    }
    if (e.target.id === 'caption-insert-emojis') {
      animatedCaptionsState.settings.insertEmojis = e.target.checked;
    }
    if (e.target.id === 'caption-emoji-frequency') {
      animatedCaptionsState.settings.emojiFrequency = e.target.value;
    }
  });
}

// ============================================================================
// TEMPLATE GALLERY
// ============================================================================

/**
 * Render template gallery
 */
function renderTemplateGallery() {
  const container = document.getElementById('caption-template-gallery');
  if (!container) return;

  const html = animatedCaptionsState.templates.map(template => `
    <div class="caption-template-card ${animatedCaptionsState.selectedTemplate === template.id ? 'selected' : ''}"
         data-template-id="${template.id}"
         role="button"
         tabindex="0"
         aria-label="Select ${template.name} template">
      <div class="template-preview template-preview-${template.id}">
        <span class="template-preview-text">Hello World</span>
      </div>
      <div class="template-info">
        <span class="template-name">${template.name}</span>
        <span class="template-desc">${template.description}</span>
      </div>
    </div>
  `).join('');

  container.innerHTML = html;
}

/**
 * Select a caption template
 */
function selectCaptionTemplate(templateId) {
  animatedCaptionsState.selectedTemplate = templateId;

  // Update UI
  document.querySelectorAll('.caption-template-card').forEach(card => {
    card.classList.toggle('selected', card.dataset.templateId === templateId);
  });

  console.log(`[SPLICE] Selected caption template: ${templateId}`);

  // Re-generate if we have captions
  if (animatedCaptionsState.captions) {
    applyTemplateToExisting(templateId);
  }
}

/**
 * Apply template to existing captions
 */
async function applyTemplateToExisting(templateId) {
  if (!animatedCaptionsState.captions) return;

  try {
    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };

    const response = await (fetchWithTimeout || fetch)(`${backendUrl}/captions/apply-template`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        captionData: { captions: animatedCaptionsState.captions },
        templateId
      })
    });

    if (response.ok) {
      const data = await response.json();
      animatedCaptionsState.captions = data.captions;
      renderCaptionPreview();
    }
  } catch (err) {
    console.error('[SPLICE] Failed to apply template:', err);
  }
}

// ============================================================================
// CAPTION GENERATION
// ============================================================================

/**
 * Generate animated captions from current transcript
 */
async function generateCaptions() {
  const transcript = getLastTranscript();
  if (!transcript) {
    showCaptionStatus('No transcript available. Run transcription first.', 'error');
    return;
  }

  animatedCaptionsState.isGenerating = true;
  updateGenerateButton(true);
  showCaptionStatus('Generating animated captions...', 'info');

  try {
    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };

    const response = await (fetchWithTimeout || fetch)(`${backendUrl}/captions/animate`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        transcript,
        template: animatedCaptionsState.selectedTemplate,
        settings: animatedCaptionsState.settings
      })
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Failed to generate captions');
    }

    const data = await response.json();
    animatedCaptionsState.captions = data.captions;
    animatedCaptionsState.keywords = data.keywords || [];

    // Update UI
    renderCaptionPreview();
    updateCaptionStats(data);
    showCaptionStatus(`Generated ${data.totalCaptions} caption lines`, 'success');

  } catch (err) {
    console.error('[SPLICE] Caption generation error:', err);
    showCaptionStatus(err.message, 'error');
  } finally {
    animatedCaptionsState.isGenerating = false;
    updateGenerateButton(false);
  }
}

/**
 * Get last transcript from main module
 */
function getLastTranscript() {
  // Try to get from main module state
  if (window.spliceState?.lastTranscript) {
    return window.spliceState.lastTranscript;
  }

  // Try to get from stored data
  if (animatedCaptionsState.lastTranscript) {
    return animatedCaptionsState.lastTranscript;
  }

  return null;
}

/**
 * Set transcript for caption generation
 */
function setCaptionTranscript(transcript) {
  animatedCaptionsState.lastTranscript = transcript;
}

// ============================================================================
// CAPTION PREVIEW
// ============================================================================

/**
 * Render caption preview
 */
function renderCaptionPreview() {
  const container = document.getElementById('caption-preview-container');
  if (!container || !animatedCaptionsState.captions) return;

  const captions = animatedCaptionsState.captions.slice(0, 10); // Show first 10

  const html = `
    <div class="caption-preview-list">
      ${captions.map((caption, i) => `
        <div class="caption-preview-item" data-index="${i}">
          <span class="caption-time">${formatCaptionTime(caption.start)}</span>
          <span class="caption-text ${caption.words?.some(w => w.isKeyword) ? 'has-keywords' : ''}">
            ${formatCaptionText(caption)}
          </span>
        </div>
      `).join('')}
      ${animatedCaptionsState.captions.length > 10 ? `
        <div class="caption-preview-more">
          + ${animatedCaptionsState.captions.length - 10} more captions
        </div>
      ` : ''}
    </div>
  `;

  container.innerHTML = html;
}

/**
 * Format caption text with keyword highlighting
 */
function formatCaptionText(caption) {
  if (!caption.words) return caption.text;

  return caption.words.map(word => {
    if (word.isKeyword) {
      return `<span class="caption-keyword">${word.word}</span>`;
    }
    if (word.emoji) {
      return `${word.word} ${word.emoji}`;
    }
    return word.word;
  }).join(' ');
}

/**
 * Format time for display
 */
function formatCaptionTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Update caption stats display
 */
function updateCaptionStats(data) {
  const statsEl = document.getElementById('caption-stats');
  if (!statsEl) return;

  statsEl.innerHTML = `
    <span class="stat-item">${data.totalCaptions} lines</span>
    <span class="stat-item">${data.totalWords} words</span>
    <span class="stat-item">${data.keywords?.length || 0} keywords</span>
    <span class="stat-item">${formatCaptionTime(data.duration)}</span>
  `;
}

// ============================================================================
// EXPORT FUNCTIONS
// ============================================================================

/**
 * Export captions in specified format
 */
async function exportCaptions(format) {
  if (!animatedCaptionsState.captions) {
    showCaptionStatus('No captions to export. Generate captions first.', 'error');
    return;
  }

  showCaptionStatus(`Exporting ${format.toUpperCase()}...`, 'info');

  try {
    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };

    let endpoint, body;

    if (format === 'mogrt') {
      endpoint = '/captions/export/mogrt';
      body = {
        captions: animatedCaptionsState.captions,
        settings: { frameRate: 30, width: 1920, height: 1080 }
      };
    } else {
      // Use standard caption export
      endpoint = '/export/captions';
      body = {
        transcript: { words: flattenCaptionWords() },
        format
      };
    }

    const response = await (fetchWithTimeout || fetch)(`${backendUrl}${endpoint}`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const err = await response.json();
      throw new Error(err.error || 'Export failed');
    }

    const data = await response.json();

    // Handle export result
    if (format === 'mogrt') {
      // Download MOGRT JSON
      downloadJSON(data.data, 'animated-captions-mogrt.json');
      showCaptionStatus('MOGRT data exported', 'success');
    } else {
      // Download subtitle file
      downloadText(data.content, `captions.${format}`);
      showCaptionStatus(`${format.toUpperCase()} exported`, 'success');
    }

  } catch (err) {
    console.error('[SPLICE] Caption export error:', err);
    showCaptionStatus(err.message, 'error');
  }
}

/**
 * Flatten caption words for standard export
 */
function flattenCaptionWords() {
  if (!animatedCaptionsState.captions) return [];

  const words = [];
  animatedCaptionsState.captions.forEach(caption => {
    if (caption.words) {
      caption.words.forEach(w => words.push(w));
    }
  });
  return words;
}

/**
 * Copy captions to clipboard
 */
async function copyCaptionsToClipboard() {
  if (!animatedCaptionsState.captions) {
    showCaptionStatus('No captions to copy', 'error');
    return;
  }

  const text = animatedCaptionsState.captions
    .map(c => `[${formatCaptionTime(c.start)}] ${c.text}`)
    .join('\n');

  try {
    await navigator.clipboard.writeText(text);
    showCaptionStatus('Captions copied to clipboard', 'success');
  } catch (err) {
    console.error('[SPLICE] Copy failed:', err);
    showCaptionStatus('Failed to copy', 'error');
  }
}

/**
 * Apply captions to Premiere timeline as markers
 */
async function applyCaptionsToTimeline() {
  if (!animatedCaptionsState.captions) {
    showCaptionStatus('No captions to apply', 'error');
    return;
  }

  showCaptionStatus('Applying captions to timeline...', 'info');

  try {
    // Use builder to create markers
    if (window.spliceBuilder?.createCaptionMarkers) {
      await window.spliceBuilder.createCaptionMarkers(animatedCaptionsState.captions);
      showCaptionStatus('Caption markers added to timeline', 'success');
    } else {
      showCaptionStatus('Builder not available', 'error');
    }
  } catch (err) {
    console.error('[SPLICE] Apply captions error:', err);
    showCaptionStatus(err.message, 'error');
  }
}

// ============================================================================
// UI HELPERS
// ============================================================================

/**
 * Show status message
 */
function showCaptionStatus(message, type = 'info') {
  const statusEl = document.getElementById('caption-status');
  if (!statusEl) return;

  statusEl.textContent = message;
  statusEl.className = `caption-status caption-status-${type}`;

  // Auto-clear after 5 seconds for success/info
  if (type !== 'error') {
    setTimeout(() => {
      statusEl.textContent = '';
      statusEl.className = 'caption-status';
    }, 5000);
  }
}

/**
 * Update generate button state
 */
function updateGenerateButton(isGenerating) {
  const btn = document.getElementById('generate-captions-btn');
  if (!btn) return;

  btn.disabled = isGenerating;
  btn.textContent = isGenerating ? 'Generating...' : 'Generate Captions';
}

/**
 * Download JSON file
 */
function downloadJSON(data, filename) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

/**
 * Download text file
 */
function downloadText(content, filename) {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// ============================================================================
// EXPORTS
// ============================================================================

// Export for global access
window.spliceAnimatedCaptions = {
  init: initAnimatedCaptions,
  generate: generateCaptions,
  setTranscript: setCaptionTranscript,
  selectTemplate: selectCaptionTemplate,
  export: exportCaptions,
  applyToTimeline: applyCaptionsToTimeline,
  getState: () => animatedCaptionsState
};
