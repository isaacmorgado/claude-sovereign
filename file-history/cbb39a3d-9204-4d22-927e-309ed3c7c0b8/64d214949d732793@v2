"""
Authentication router - register, login, profile, password reset
"""

import secrets
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from uuid import uuid4

from app.database import get_db
from app.models.user import User, ReferralCode, PlanType
from app.schemas.user import (
    UserCreate, UserLogin, UserResponse, Token,
    ForgotPasswordRequest, ResetPasswordRequest
)
from app.services.auth import AuthService, get_current_user
from app.services.email import email_service

router = APIRouter(prefix="/auth", tags=["auth"])


@router.post("/register", response_model=Token)
async def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)):
    """Register a new user"""
    # Check if email exists - only select id to avoid loading full model
    result = await db.execute(select(User.id).where(User.email == user_data.email))
    existing_user = result.scalar_one_or_none()

    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # Check if username already exists (case-insensitive) - only select id
    result = await db.execute(
        select(User.id).where(func.lower(User.username) == user_data.username.lower())
    )
    existing_username = result.scalar_one_or_none()

    if existing_username:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already taken"
        )

    # Validate referral code if provided
    stripe_promo_id = None
    if user_data.referral_code:
        result = await db.execute(
            select(ReferralCode).where(
                func.upper(ReferralCode.code) == user_data.referral_code.upper(),
                ReferralCode.is_active == True
            )
        )
        referral = result.scalar_one_or_none()
        if referral:
            stripe_promo_id = referral.stripe_promotion_code_id
            # Increment usage count
            referral.total_uses += 1

    # Create user with explicit defaults (avoid db.refresh which causes schema issues)
    hashed_password = AuthService.hash_password(user_data.password)
    now = datetime.utcnow()
    user = User(
        id=uuid4(),
        email=user_data.email,
        password_hash=hashed_password,
        name=user_data.name,
        username=user_data.username,
        terms_accepted_at=now if user_data.terms_accepted else None,
        referral_code=user_data.referral_code,
        referred_by=stripe_promo_id,
        plan=PlanType.FREE,
        created_at=now,
        updated_at=now,
    )

    db.add(user)
    await db.commit()

    # Send welcome email (non-blocking, don't fail registration if email fails)
    try:
        await email_service.send_welcome_email(user.email, user.username)
    except Exception as e:
        print(f"[AUTH] Failed to send welcome email: {e}")

    # Generate token
    access_token = AuthService.create_access_token(str(user.id))

    # Explicitly create UserResponse to avoid serialization issues
    user_response = UserResponse(
        id=user.id,
        email=user.email,
        name=user.name,
        username=user.username,
        plan=user.plan.value if hasattr(user.plan, 'value') else str(user.plan),
        created_at=user.created_at,
    )

    return Token(access_token=access_token, token_type="bearer", user=user_response)


@router.post("/login", response_model=Token)
async def login(credentials: UserLogin, db: AsyncSession = Depends(get_db)):
    """Login and get JWT token"""
    # Only select columns needed for authentication and response
    result = await db.execute(
        select(
            User.id, User.email, User.name, User.username,
            User.password_hash, User.plan, User.created_at
        ).where(User.email == credentials.email)
    )
    row = result.one_or_none()

    if not row or not AuthService.verify_password(credentials.password, row.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token = AuthService.create_access_token(str(row.id))

    # Explicitly create UserResponse
    user_response = UserResponse(
        id=row.id,
        email=row.email,
        name=row.name,
        username=row.username,
        plan=row.plan.value if hasattr(row.plan, 'value') else str(row.plan),
        created_at=row.created_at,
    )

    return Token(access_token=access_token, token_type="bearer", user=user_response)


@router.get("/me", response_model=UserResponse)
async def get_me(current_user: User = Depends(get_current_user)):
    """Get current user profile"""
    return UserResponse(
        id=current_user.id,
        email=current_user.email,
        name=current_user.name,
        username=current_user.username,
        plan=current_user.plan.value if hasattr(current_user.plan, 'value') else str(current_user.plan),
        created_at=current_user.created_at,
    )


@router.get("/check-username/{username}")
async def check_username(username: str, db: AsyncSession = Depends(get_db)):
    """Check if a username is available (no auth required)"""
    # Validate format
    if len(username) < 3:
        return {"available": False, "reason": "Too short"}
    if len(username) > 30:
        return {"available": False, "reason": "Too long"}
    if not all(c.isalnum() or c == '_' for c in username):
        return {"available": False, "reason": "Invalid characters"}
    if username.lower().startswith('user_'):
        return {"available": False, "reason": "Reserved prefix"}

    # Check database - only select id to avoid loading full model
    result = await db.execute(
        select(User.id).where(func.lower(User.username) == username.lower())
    )
    exists = result.scalar_one_or_none()

    return {
        "available": exists is None,
        "reason": "Username taken" if exists else None
    }


@router.get("/validate-referral/{code}")
async def validate_referral_code(code: str, db: AsyncSession = Depends(get_db)):
    """Validate a referral code (no auth required)"""
    if len(code) < 3:
        return {"valid": False, "message": "Invalid code format"}

    result = await db.execute(
        select(ReferralCode).where(
            func.upper(ReferralCode.code) == code.upper(),
            ReferralCode.is_active == True
        )
    )
    referral = result.scalar_one_or_none()

    if referral:
        discount_msg = f"{referral.discount_percent}% discount" if referral.discount_percent else "Special offer"
        return {
            "valid": True,
            "message": f"Code applied! {discount_msg} from {referral.influencer_name}"
        }

    return {"valid": False, "message": "Invalid or expired code"}


@router.post("/forgot-password")
async def forgot_password(data: ForgotPasswordRequest, db: AsyncSession = Depends(get_db)):
    """Request a password reset email"""
    # Always return success to prevent email enumeration
    result = await db.execute(select(User).where(User.email == data.email))
    user = result.scalar_one_or_none()

    if user:
        # Generate secure reset token
        reset_token = secrets.token_urlsafe(32)
        user.password_reset_token = reset_token
        user.password_reset_expires = datetime.utcnow() + timedelta(hours=1)
        await db.commit()

        # Send password reset email
        await email_service.send_password_reset_email(user.email, reset_token)

    return {"message": "If an account exists with this email, a reset link has been sent."}


@router.post("/reset-password")
async def reset_password(data: ResetPasswordRequest, db: AsyncSession = Depends(get_db)):
    """Reset password using token"""
    result = await db.execute(
        select(User).where(
            User.password_reset_token == data.token,
            User.password_reset_expires > datetime.utcnow()
        )
    )
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )

    # Update password
    user.password_hash = AuthService.hash_password(data.new_password)
    user.password_reset_token = None
    user.password_reset_expires = None
    await db.commit()

    return {"message": "Password has been reset successfully"}
