/**
 * Scene-Aware Music E2E Tests
 * Tests for Feature 2: Scene-Aware Music Generation
 */

const assert = require('assert');

// Test counters
let passed = 0;
let failed = 0;
const results = [];

function test(name, fn) {
  try {
    fn();
    passed++;
    results.push({ name, status: 'PASS' });
    console.log(`  âœ“ ${name}`);
  } catch (e) {
    failed++;
    results.push({ name, status: 'FAIL', error: e.message });
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${e.message}`);
  }
}

function describe(suiteName, fn) {
  console.log(`\n${suiteName}`);
  console.log('='.repeat(suiteName.length));
  fn();
}

// ============================================
// SCENE ANALYSIS SERVICE TESTS
// ============================================

describe('Scene Analysis Service', () => {
  let sceneAnalysis;

  try {
    sceneAnalysis = require('../services/sceneAnalysis');
  } catch (e) {
    console.log('  ! Could not load sceneAnalysis:', e.message);
  }

  test('exports required functions', () => {
    assert(sceneAnalysis, 'sceneAnalysis should be defined');
    assert(typeof sceneAnalysis.analyzeScenes === 'function', 'analyzeScenes should be a function');
    assert(typeof sceneAnalysis.buildSceneAwarePrompt === 'function', 'buildSceneAwarePrompt should be a function');
    assert(typeof sceneAnalysis.groupSegmentsIntoScenes === 'function', 'groupSegmentsIntoScenes should be a function');
    assert(typeof sceneAnalysis.estimateMoodFromText === 'function', 'estimateMoodFromText should be a function');
    assert(typeof sceneAnalysis.estimateEnergyFromText === 'function', 'estimateEnergyFromText should be a function');
    assert(typeof sceneAnalysis.extractKeywords === 'function', 'extractKeywords should be a function');
  });

  test('exports ENERGY_LEVELS constant', () => {
    assert(sceneAnalysis.ENERGY_LEVELS, 'ENERGY_LEVELS should be defined');
    assert(typeof sceneAnalysis.ENERGY_LEVELS.calm === 'number', 'calm energy level should be a number');
    assert(typeof sceneAnalysis.ENERGY_LEVELS.peak === 'number', 'peak energy level should be a number');
    assert(sceneAnalysis.ENERGY_LEVELS.calm < sceneAnalysis.ENERGY_LEVELS.peak, 'calm should be less than peak');
  });

  test('exports MOOD_PROMPTS constant', () => {
    assert(sceneAnalysis.MOOD_PROMPTS, 'MOOD_PROMPTS should be defined');
    assert(typeof sceneAnalysis.MOOD_PROMPTS.happy === 'string', 'happy mood prompt should be a string');
    assert(typeof sceneAnalysis.MOOD_PROMPTS.sad === 'string', 'sad mood prompt should be a string');
    assert(typeof sceneAnalysis.MOOD_PROMPTS.neutral === 'string', 'neutral mood prompt should be a string');
  });
});

describe('Scene Grouping', () => {
  let sceneAnalysis;

  try {
    sceneAnalysis = require('../services/sceneAnalysis');
  } catch (e) {
    return;
  }

  test('groups segments into scenes based on time window', () => {
    const segments = [
      { id: 1, start: 0, end: 10, text: 'Hello world' },
      { id: 2, start: 10, end: 20, text: 'This is a test' },
      { id: 3, start: 20, end: 35, text: 'Scene break' },
      { id: 4, start: 35, end: 45, text: 'New scene starts' }
    ];

    const scenes = sceneAnalysis.groupSegmentsIntoScenes(segments, 30);
    assert(Array.isArray(scenes), 'scenes should be an array');
    assert(scenes.length >= 1, 'should have at least one scene');
  });

  test('handles empty segments array', () => {
    const scenes = sceneAnalysis.groupSegmentsIntoScenes([], 30);
    assert(Array.isArray(scenes), 'scenes should be an array');
    assert(scenes.length === 0, 'should return empty array for empty segments');
  });

  test('single segment becomes one scene', () => {
    const segments = [{ id: 1, start: 0, end: 10, text: 'Only segment' }];
    const scenes = sceneAnalysis.groupSegmentsIntoScenes(segments, 30);
    assert(scenes.length === 1, 'should have exactly one scene');
    assert(scenes[0].segments.length === 1, 'scene should have one segment');
  });

  test('respects time window for scene boundaries', () => {
    const segments = [
      { id: 1, start: 0, end: 25, text: 'First chunk' },
      { id: 2, start: 25, end: 60, text: 'Second chunk exceeds window' },
      { id: 3, start: 60, end: 90, text: 'Third chunk' }
    ];

    const scenes = sceneAnalysis.groupSegmentsIntoScenes(segments, 30);
    assert(scenes.length >= 2, 'should split into multiple scenes');
  });
});

describe('Mood Estimation (Fallback)', () => {
  let sceneAnalysis;

  try {
    sceneAnalysis = require('../services/sceneAnalysis');
  } catch (e) {
    return;
  }

  test('detects happy mood from positive keywords', () => {
    const mood = sceneAnalysis.estimateMoodFromText('This is amazing and wonderful!');
    assert(mood === 'happy', `Expected happy, got ${mood}`);
  });

  test('detects sad mood from negative keywords', () => {
    const mood = sceneAnalysis.estimateMoodFromText('Unfortunately, I am so sad about this.');
    assert(mood === 'sad', `Expected sad, got ${mood}`);
  });

  test('detects angry mood from frustration keywords', () => {
    const mood = sceneAnalysis.estimateMoodFromText('I am so frustrated and angry!');
    assert(mood === 'angry', `Expected angry, got ${mood}`);
  });

  test('detects excited mood from energy keywords', () => {
    const mood = sceneAnalysis.estimateMoodFromText("Let's go! Action time, quick!");
    assert(mood === 'excited', `Expected excited, got ${mood}`);
  });

  test('returns neutral for ambiguous text', () => {
    const mood = sceneAnalysis.estimateMoodFromText('The weather is cloudy today.');
    assert(mood === 'neutral', `Expected neutral, got ${mood}`);
  });

  test('detects humorous mood', () => {
    const mood = sceneAnalysis.estimateMoodFromText('That was so funny and hilarious!');
    assert(mood === 'humorous', `Expected humorous, got ${mood}`);
  });
});

describe('Energy Estimation (Fallback)', () => {
  let sceneAnalysis;

  try {
    sceneAnalysis = require('../services/sceneAnalysis');
  } catch (e) {
    return;
  }

  test('returns higher energy for excited text', () => {
    const energy = sceneAnalysis.estimateEnergyFromText('Wow! Amazing! This is incredible!');
    assert(energy > 50, `Expected energy > 50, got ${energy}`);
  });

  test('returns lower energy for calm text', () => {
    const energy = sceneAnalysis.estimateEnergyFromText('This is calm and peaceful and quiet.');
    assert(energy < 50, `Expected energy < 50, got ${energy}`);
  });

  test('increases energy for exclamation marks', () => {
    const baseEnergy = sceneAnalysis.estimateEnergyFromText('Hello there');
    const excitedEnergy = sceneAnalysis.estimateEnergyFromText('Hello there!!!');
    assert(excitedEnergy > baseEnergy, 'Exclamation marks should increase energy');
  });

  test('energy is bounded 0-100', () => {
    const lowEnergy = sceneAnalysis.estimateEnergyFromText('calm peaceful quiet slow gentle relaxed subtle');
    const highEnergy = sceneAnalysis.estimateEnergyFromText('excited amazing incredible action fast wow!!!!!!');
    assert(lowEnergy >= 0, 'Energy should not go below 0');
    assert(highEnergy <= 100, 'Energy should not exceed 100');
  });
});

describe('Keyword Extraction', () => {
  let sceneAnalysis;

  try {
    sceneAnalysis = require('../services/sceneAnalysis');
  } catch (e) {
    return;
  }

  test('extracts meaningful keywords', () => {
    const text = 'The artificial intelligence system uses machine learning for video editing.';
    const keywords = sceneAnalysis.extractKeywords(text);
    assert(Array.isArray(keywords), 'keywords should be an array');
    assert(keywords.length <= 3, 'should return at most 3 keywords');
  });

  test('filters out stop words', () => {
    const text = 'The quick brown fox jumps over the lazy dog';
    const keywords = sceneAnalysis.extractKeywords(text);
    assert(!keywords.includes('the'), 'should not include "the"');
    assert(!keywords.includes('over'), 'should not include "over"');
  });

  test('handles short text gracefully', () => {
    const keywords = sceneAnalysis.extractKeywords('Hi');
    assert(Array.isArray(keywords), 'should return array even for short text');
  });

  test('handles empty text', () => {
    const keywords = sceneAnalysis.extractKeywords('');
    assert(Array.isArray(keywords), 'should return array for empty text');
    assert(keywords.length === 0, 'should return empty array for empty text');
  });
});

describe('Scene-Aware Prompt Building', () => {
  let sceneAnalysis;

  try {
    sceneAnalysis = require('../services/sceneAnalysis');
  } catch (e) {
    return;
  }

  test('builds prompt from scene analysis', () => {
    const sceneContext = {
      dominantMood: 'happy',
      averageEnergy: 75,
      scenes: [{ keywords: ['technology', 'innovation'] }],
      energyTimeline: [{ energy: 70 }, { energy: 80 }]
    };

    const prompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, { duration: 60 });
    assert(typeof prompt === 'string', 'prompt should be a string');
    assert(prompt.length > 0, 'prompt should not be empty');
  });

  test('includes mood description', () => {
    const sceneContext = {
      dominantMood: 'melancholic',
      averageEnergy: 30,
      scenes: []
    };

    const prompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, {});
    assert(prompt.toLowerCase().includes('mood'), 'prompt should mention mood');
  });

  test('includes energy guidance', () => {
    const sceneContext = {
      dominantMood: 'neutral',
      averageEnergy: 80,
      scenes: []
    };

    const prompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, {});
    assert(prompt.toLowerCase().includes('energy'), 'prompt should mention energy');
  });

  test('includes user custom prompt', () => {
    const sceneContext = {
      dominantMood: 'neutral',
      averageEnergy: 50,
      scenes: []
    };

    const prompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, {
      prompt: 'Epic cinematic score'
    });
    assert(prompt.includes('Epic cinematic score'), 'should include user prompt');
  });

  test('includes instruments when specified', () => {
    const sceneContext = {
      dominantMood: 'neutral',
      averageEnergy: 50,
      scenes: []
    };

    const prompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, {
      instruments: ['piano', 'strings']
    });
    assert(prompt.toLowerCase().includes('instrument'), 'should mention instruments');
  });

  test('includes duration', () => {
    const sceneContext = {
      dominantMood: 'neutral',
      averageEnergy: 50,
      scenes: []
    };

    const prompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, { duration: 120 });
    assert(prompt.includes('120'), 'should include duration');
  });
});

// ============================================
// USAGE TRACKING TESTS
// ============================================

describe('Scene-Aware Billing Constants', () => {
  let usageTracking;

  try {
    usageTracking = require('../services/usageTracking');
  } catch (e) {
    console.log('  ! Could not load usageTracking:', e.message);
    return;
  }

  test('exports SCENE_AWARE_CREDIT_COST constant', () => {
    assert(typeof usageTracking.SCENE_AWARE_CREDIT_COST === 'number', 'should export credit cost');
    assert(usageTracking.SCENE_AWARE_CREDIT_COST === 1.5, 'should be 1.5 credits');
  });

  test('exports SCENE_AWARE_OVERAGE_RATES constant', () => {
    assert(usageTracking.SCENE_AWARE_OVERAGE_RATES, 'should export overage rates');
    assert(typeof usageTracking.SCENE_AWARE_OVERAGE_RATES.starter === 'number', 'starter rate should be a number');
    assert(typeof usageTracking.SCENE_AWARE_OVERAGE_RATES.pro === 'number', 'pro rate should be a number');
    assert(typeof usageTracking.SCENE_AWARE_OVERAGE_RATES.team === 'number', 'team rate should be a number');
  });

  test('overage rates maintain 75% margin', () => {
    const rates = usageTracking.SCENE_AWARE_OVERAGE_RATES;
    // Starter: 1.5 * $0.50 = $0.75
    assert(rates.starter === 0.75, `Starter should be $0.75, got ${rates.starter}`);
    // Pro: 1.5 * $0.30 = $0.45
    assert(rates.pro === 0.45, `Pro should be $0.45, got ${rates.pro}`);
    // Team: 1.5 * $0.20 = $0.30
    assert(rates.team === 0.30, `Team should be $0.30, got ${rates.team}`);
  });

  test('exports checkSceneAwareCredits function', () => {
    assert(typeof usageTracking.checkSceneAwareCredits === 'function', 'should export check function');
  });

  test('exports deductSceneAwareCredit function', () => {
    assert(typeof usageTracking.deductSceneAwareCredit === 'function', 'should export deduct function');
  });
});

// ============================================
// MUSIC GENERATION TESTS
// ============================================

describe('Music Generation Scene-Aware Functions', () => {
  let musicGeneration;

  try {
    musicGeneration = require('../services/musicGeneration');
  } catch (e) {
    console.log('  ! Could not load musicGeneration:', e.message);
    return;
  }

  test('exports generateSceneAwareMusic function', () => {
    assert(typeof musicGeneration.generateSceneAwareMusic === 'function', 'should export function');
  });

  test('exports validateSceneAwareOptions function', () => {
    assert(typeof musicGeneration.validateSceneAwareOptions === 'function', 'should export validation function');
  });

  test('exports generateSceneAwareTitle function', () => {
    assert(typeof musicGeneration.generateSceneAwareTitle === 'function', 'should export title function');
  });
});

describe('Scene-Aware Options Validation', () => {
  let musicGeneration;

  try {
    musicGeneration = require('../services/musicGeneration');
  } catch (e) {
    return;
  }

  test('validates segments are required', () => {
    const result = musicGeneration.validateSceneAwareOptions(null, {});
    assert(!result.valid, 'should be invalid without segments');
    assert(result.errors.some(e => e.includes('segment')), 'should mention segments');
  });

  test('validates segments must be array', () => {
    const result = musicGeneration.validateSceneAwareOptions('not-array', {});
    assert(!result.valid, 'should be invalid with non-array segments');
  });

  test('validates segments must not be empty', () => {
    const result = musicGeneration.validateSceneAwareOptions([], {});
    assert(!result.valid, 'should be invalid with empty segments');
  });

  test('validates segment format', () => {
    const badSegments = [{ text: 'missing start/end' }];
    const result = musicGeneration.validateSceneAwareOptions(badSegments, {});
    assert(!result.valid, 'should be invalid with bad segment format');
  });

  test('passes with valid segments', () => {
    const validSegments = [
      { start: 0, end: 10, text: 'Hello world' }
    ];
    const result = musicGeneration.validateSceneAwareOptions(validSegments, {});
    assert(result.valid, `should be valid, got errors: ${result.errors.join(', ')}`);
  });

  test('inherits base option validation', () => {
    const validSegments = [{ start: 0, end: 10, text: 'Hello' }];
    const result = musicGeneration.validateSceneAwareOptions(validSegments, {
      duration: 10 // Below minimum
    });
    assert(!result.valid, 'should fail base validation');
  });
});

describe('Scene-Aware Title Generation', () => {
  let musicGeneration;

  try {
    musicGeneration = require('../services/musicGeneration');
  } catch (e) {
    return;
  }

  test('includes detected mood in title', () => {
    const title = musicGeneration.generateSceneAwareTitle({}, {
      dominantMood: 'happy',
      averageEnergy: 50
    });
    assert(title.includes('Happy'), `Title should include mood, got: ${title}`);
  });

  test('indicates high energy in title', () => {
    const title = musicGeneration.generateSceneAwareTitle({}, {
      dominantMood: 'neutral',
      averageEnergy: 85
    });
    assert(title.includes('High-Energy'), `Title should indicate high energy, got: ${title}`);
  });

  test('indicates ambient for low energy', () => {
    const title = musicGeneration.generateSceneAwareTitle({}, {
      dominantMood: 'neutral',
      averageEnergy: 25
    });
    assert(title.includes('Ambient'), `Title should indicate ambient, got: ${title}`);
  });

  test('includes reference song style if provided', () => {
    const title = musicGeneration.generateSceneAwareTitle({
      referenceSong: { title: 'Test Song' }
    }, {
      dominantMood: 'neutral',
      averageEnergy: 50
    });
    assert(title.includes('Test Song'), `Title should include reference, got: ${title}`);
  });

  test('uses Scene-Aware fallback for neutral content', () => {
    const title = musicGeneration.generateSceneAwareTitle({}, {
      dominantMood: 'neutral',
      averageEnergy: 50
    });
    assert(title.includes('Scene-Aware') || title.includes('Music'), `Title should have fallback, got: ${title}`);
  });
});

// ============================================
// MUSIC QUEUE TESTS
// ============================================

describe('Music Queue Scene-Aware Support', () => {
  let musicQueue;

  try {
    musicQueue = require('../services/musicQueue');
  } catch (e) {
    console.log('  ! Could not load musicQueue:', e.message);
    return;
  }

  test('exports ANALYZING status', () => {
    assert(musicQueue.JOB_STATUS.ANALYZING, 'should have ANALYZING status');
    assert(musicQueue.JOB_STATUS.ANALYZING === 'analyzing', 'ANALYZING should be "analyzing"');
  });

  test('ANALYZING has progress mapping', () => {
    assert(typeof musicQueue.PROGRESS_MAP[musicQueue.JOB_STATUS.ANALYZING] === 'number',
      'ANALYZING should have progress mapping');
    assert(musicQueue.PROGRESS_MAP[musicQueue.JOB_STATUS.ANALYZING] === 15,
      'ANALYZING progress should be 15%');
  });
});

// ============================================
// PLUGIN UI TESTS
// ============================================

describe('Plugin Music Module Scene-Aware UI', () => {
  // Mock browser environment
  const mockDocument = {
    getElementById: () => null,
    querySelectorAll: () => []
  };

  const pluginCode = `
    // Simulated plugin code check
    const musicState = {
      sceneAwareEnabled: false
    };

    function getCurrentTranscriptSegments() {
      if (typeof window !== 'undefined' && window.currentTranscript && window.currentTranscript.segments) {
        return window.currentTranscript.segments;
      }
      return null;
    }

    // Export for testing
    module.exports = { musicState, getCurrentTranscriptSegments };
  `;

  test('musicState includes sceneAwareEnabled flag', () => {
    // Check the actual plugin file
    const fs = require('fs');
    const pluginPath = require('path').join(__dirname, '../../splice-plugin/js/music.js');
    const content = fs.readFileSync(pluginPath, 'utf8');
    assert(content.includes('sceneAwareEnabled'), 'musicState should have sceneAwareEnabled');
  });

  test('exports generateSceneAwareRequest', () => {
    const fs = require('fs');
    const pluginPath = require('path').join(__dirname, '../../splice-plugin/js/music.js');
    const content = fs.readFileSync(pluginPath, 'utf8');
    assert(content.includes('generateSceneAwareRequest'), 'should export generateSceneAwareRequest');
  });

  test('exports getCurrentTranscriptSegments', () => {
    const fs = require('fs');
    const pluginPath = require('path').join(__dirname, '../../splice-plugin/js/music.js');
    const content = fs.readFileSync(pluginPath, 'utf8');
    assert(content.includes('getCurrentTranscriptSegments'), 'should export getCurrentTranscriptSegments');
  });

  test('handleGenerateMusic checks sceneAwareEnabled', () => {
    const fs = require('fs');
    const pluginPath = require('path').join(__dirname, '../../splice-plugin/js/music.js');
    const content = fs.readFileSync(pluginPath, 'utf8');
    assert(content.includes('musicState.sceneAwareEnabled'), 'handleGenerateMusic should check sceneAwareEnabled');
  });

  test('includes scene-aware toggle handler', () => {
    const fs = require('fs');
    const pluginPath = require('path').join(__dirname, '../../splice-plugin/js/music.js');
    const content = fs.readFileSync(pluginPath, 'utf8');
    assert(content.includes('handleSceneAwareToggle'), 'should have scene-aware toggle handler');
  });

  test('shows scene indicator emoji for scene-aware jobs', () => {
    const fs = require('fs');
    const pluginPath = require('path').join(__dirname, '../../splice-plugin/js/music.js');
    const content = fs.readFileSync(pluginPath, 'utf8');
    assert(content.includes("isSceneAware ? ' ðŸŽ¬'"), 'should show emoji for scene-aware jobs');
  });
});

// ============================================
// SERVER ENDPOINT TESTS
// ============================================

describe('Server Scene-Aware Endpoint', () => {
  test('/music/generate-scene-aware endpoint exists in server.js', () => {
    const fs = require('fs');
    const serverPath = require('path').join(__dirname, '../server.js');
    const content = fs.readFileSync(serverPath, 'utf8');
    assert(content.includes('/music/generate-scene-aware'), 'endpoint should exist');
    assert(content.includes("app.post('/music/generate-scene-aware'"), 'should be POST endpoint');
  });

  test('endpoint requires authentication', () => {
    const fs = require('fs');
    const serverPath = require('path').join(__dirname, '../server.js');
    const content = fs.readFileSync(serverPath, 'utf8');
    // Find the endpoint definition and check for requireCredits
    const endpointMatch = content.match(/app\.post\('\/music\/generate-scene-aware',\s*(\w+)/);
    assert(endpointMatch, 'should find endpoint definition');
    assert(endpointMatch[1] === 'requireCredits', 'should use requireCredits middleware');
  });

  test('endpoint validates segments', () => {
    const fs = require('fs');
    const serverPath = require('path').join(__dirname, '../server.js');
    const content = fs.readFileSync(serverPath, 'utf8');
    // Look for segment validation in the endpoint
    const endpointSection = content.split('/music/generate-scene-aware')[1]?.split('app.')[0] || '';
    assert(endpointSection.includes('segments'), 'should reference segments');
    assert(endpointSection.includes('Transcript segments are required'), 'should validate segments');
  });

  test('endpoint checks scene-aware credits', () => {
    const fs = require('fs');
    const serverPath = require('path').join(__dirname, '../server.js');
    const content = fs.readFileSync(serverPath, 'utf8');
    assert(content.includes('checkSceneAwareCredits'), 'should check scene-aware credits');
  });

  test('endpoint uses isSceneAware flag', () => {
    const fs = require('fs');
    const serverPath = require('path').join(__dirname, '../server.js');
    const content = fs.readFileSync(serverPath, 'utf8');
    assert(content.includes('isSceneAware: true'), 'should set isSceneAware flag');
  });
});

// ============================================
// WORKER TESTS
// ============================================

describe('Music Worker Scene-Aware Support', () => {
  test('worker imports sceneAnalysis service', () => {
    const fs = require('fs');
    const workerPath = require('path').join(__dirname, '../workers/musicWorker.js');
    const content = fs.readFileSync(workerPath, 'utf8');
    assert(content.includes("require('../services/sceneAnalysis')"), 'should import sceneAnalysis');
  });

  test('worker checks isSceneAware flag', () => {
    const fs = require('fs');
    const workerPath = require('path').join(__dirname, '../workers/musicWorker.js');
    const content = fs.readFileSync(workerPath, 'utf8');
    assert(content.includes('job.data.isSceneAware'), 'should check isSceneAware flag');
  });

  test('worker updates job step to ANALYZING', () => {
    const fs = require('fs');
    const workerPath = require('path').join(__dirname, '../workers/musicWorker.js');
    const content = fs.readFileSync(workerPath, 'utf8');
    assert(content.includes('JOB_STATUS.ANALYZING'), 'should use ANALYZING status');
  });

  test('worker calls generateSceneAwareMusic for scene-aware jobs', () => {
    const fs = require('fs');
    const workerPath = require('path').join(__dirname, '../workers/musicWorker.js');
    const content = fs.readFileSync(workerPath, 'utf8');
    assert(content.includes('generateSceneAwareMusic'), 'should call generateSceneAwareMusic');
  });

  test('worker stores sceneContext in job data', () => {
    const fs = require('fs');
    const workerPath = require('path').join(__dirname, '../workers/musicWorker.js');
    const content = fs.readFileSync(workerPath, 'utf8');
    assert(content.includes('sceneContext'), 'should store sceneContext');
  });

  test('worker includes sceneContext in metadata upload', () => {
    const fs = require('fs');
    const workerPath = require('path').join(__dirname, '../workers/musicWorker.js');
    const content = fs.readFileSync(workerPath, 'utf8');
    assert(content.includes('isSceneAware: job.data.isSceneAware'), 'should include isSceneAware in metadata');
    assert(content.includes('sceneContext: job.data.sceneContext'), 'should include sceneContext in metadata');
  });
});

// ============================================
// INTEGRATION TESTS
// ============================================

describe('Scene-Aware Integration', () => {
  test('sceneAnalysis can analyze real transcript format', async () => {
    const sceneAnalysis = require('../services/sceneAnalysis');

    // Real Whisper transcript format
    const segments = [
      { id: 0, start: 0.0, end: 5.5, text: "Hello everyone, welcome to today's tutorial." },
      { id: 1, start: 5.5, end: 12.0, text: "We're going to learn something amazing and exciting!" },
      { id: 2, start: 12.0, end: 20.0, text: "This will be calm and step by step." }
    ];

    const result = await sceneAnalysis.analyzeScenes(segments);
    assert(result, 'should return result');
    assert(result.scenes, 'should have scenes');
    assert(result.dominantMood, 'should have dominant mood');
    assert(typeof result.averageEnergy === 'number', 'should have average energy');
    assert(result.energyTimeline, 'should have energy timeline');
    assert(result.moodTimeline, 'should have mood timeline');
  });

  test('describeEnergyArc handles various patterns', () => {
    const sceneAnalysis = require('../services/sceneAnalysis');

    // Building arc
    const buildingTimeline = [{ energy: 30 }, { energy: 50 }, { energy: 80 }];
    const buildingDesc = sceneAnalysis.describeEnergyArc(buildingTimeline);
    assert(buildingDesc, 'should describe building arc');

    // Declining arc
    const decliningTimeline = [{ energy: 80 }, { energy: 50 }, { energy: 30 }];
    const decliningDesc = sceneAnalysis.describeEnergyArc(decliningTimeline);
    assert(decliningDesc, 'should describe declining arc');

    // Single point (no arc)
    const singleTimeline = [{ energy: 50 }];
    const singleDesc = sceneAnalysis.describeEnergyArc(singleTimeline);
    assert(singleDesc === null, 'should return null for single point');

    // Flat (no variation)
    const flatTimeline = [{ energy: 50 }, { energy: 52 }, { energy: 48 }];
    const flatDesc = sceneAnalysis.describeEnergyArc(flatTimeline);
    assert(flatDesc === null, 'should return null for minimal variation');
  });

  test('getSceneContextSummary returns readable string', () => {
    const sceneAnalysis = require('../services/sceneAnalysis');

    const context = {
      scenes: [1, 2, 3],
      dominantMood: 'happy',
      averageEnergy: 75
    };

    const summary = sceneAnalysis.getSceneContextSummary(context);
    assert(typeof summary === 'string', 'should return string');
    assert(summary.includes('3'), 'should include scene count');
    assert(summary.includes('happy'), 'should include mood');
    assert(summary.includes('75'), 'should include energy');
  });
});

// ============================================
// RUN TESTS
// ============================================

console.log('\n' + '='.repeat(50));
console.log('Scene-Aware Music E2E Test Results');
console.log('='.repeat(50));
console.log(`\nTotal: ${passed + failed} tests`);
console.log(`Passed: ${passed}`);
console.log(`Failed: ${failed}`);
console.log(`Pass Rate: ${((passed / (passed + failed)) * 100).toFixed(1)}%`);

if (failed > 0) {
  console.log('\nFailed tests:');
  results.filter(r => r.status === 'FAIL').forEach(r => {
    console.log(`  - ${r.name}: ${r.error}`);
  });
  process.exit(1);
}

console.log('\nAll tests passed!');
process.exit(0);
