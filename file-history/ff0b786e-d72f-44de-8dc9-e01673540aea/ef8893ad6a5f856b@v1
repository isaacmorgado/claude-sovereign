/**
 * FaceIQ Parity - Scoring Algorithm
 *
 * Exact implementation of FaceIQ's scoring formula for 100% parity.
 *
 * FaceIQ Scoring Formula (reverse-engineered):
 * - If value is within [idealMin, idealMax]: return maxScore (10)
 * - Otherwise: score = baseScore + (maxScore - baseScore) * exp(-decayRate * deviation)
 * - Where deviation = value < idealMin ? idealMin - value : value - idealMax
 * - Default decayRate = 0.2
 * - baseScore is usually 0 (can be negative for harsher penalties)
 *
 * Color Gradient (score 1-10):
 * 1: rgb(185, 28, 28)   - deep red
 * 2: rgb(220, 53, 53)   - red
 * 3: rgb(239, 88, 88)   - light red
 * 4: rgb(245, 130, 75)  - orange
 * 5: rgb(251, 175, 60)  - yellow-orange
 * 6: rgb(220, 200, 80)  - yellow
 * 7: rgb(140, 215, 100) - yellow-green
 * 8: rgb(74, 222, 128)  - green
 * 9: rgb(40, 205, 170)  - teal
 * 10: rgb(6, 182, 212)  - cyan
 */

export interface FaceIQScoringConfig {
  idealMin: number;
  idealMax: number;
  maxScore?: number;      // Default: 10
  baseScore?: number;     // Default: 0
  decayRate?: number;     // Default: 0.2
  customPoints?: FaceIQCurvePoint[];  // Custom Bezier curve
}

export interface FaceIQCurvePoint {
  x: number;
  y: number;
}

export interface FaceIQScoreResult {
  score: number;
  deviation: 'below' | 'above' | 'ideal';
  deviationAmount: number;
  idealRange: string;
  percentile?: number;
}

/**
 * FaceIQ color stops for score gradient
 */
export const FACEIQ_COLOR_STOPS = [
  { threshold: 1, color: [185, 28, 28] },
  { threshold: 2, color: [220, 53, 53] },
  { threshold: 3, color: [239, 88, 88] },
  { threshold: 4, color: [245, 130, 75] },
  { threshold: 5, color: [251, 175, 60] },
  { threshold: 6, color: [220, 200, 80] },
  { threshold: 7, color: [140, 215, 100] },
  { threshold: 8, color: [74, 222, 128] },
  { threshold: 9, color: [40, 205, 170] },
  { threshold: 10, color: [6, 182, 212] },
] as const;

/**
 * Calculate score using FaceIQ's exact algorithm
 *
 * FaceIQ formula:
 * ```javascript
 * if (value >= idealMin && value <= idealMax) return maxScore;
 * let deviation = value < idealMin ? idealMin - value : value - idealMax;
 * return baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);
 * ```
 */
export function calculateFaceIQScore(
  value: number,
  config: FaceIQScoringConfig
): FaceIQScoreResult {
  const {
    idealMin,
    idealMax,
    maxScore = 10,
    baseScore = 0,
    decayRate = 0.2,
    customPoints,
  } = config;

  // Check for custom curve first
  if (customPoints && customPoints.length > 0) {
    const score = interpolateFaceIQCurve(value, customPoints);
    return {
      score: Math.max(0, Math.min(maxScore, score)),
      deviation: value < idealMin ? 'below' : value > idealMax ? 'above' : 'ideal',
      deviationAmount: value < idealMin ? idealMin - value : value > idealMax ? value - idealMax : 0,
      idealRange: `${idealMin}-${idealMax}`,
    };
  }

  // Within ideal range - return max score
  if (value >= idealMin && value <= idealMax) {
    return {
      score: maxScore,
      deviation: 'ideal',
      deviationAmount: 0,
      idealRange: `${idealMin}-${idealMax}`,
    };
  }

  // Calculate deviation
  const deviation = value < idealMin ? idealMin - value : value - idealMax;

  // FaceIQ exponential decay formula
  const score = baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);

  return {
    score: Math.max(0, Math.min(maxScore, score)),
    deviation: value < idealMin ? 'below' : 'above',
    deviationAmount: deviation,
    idealRange: `${idealMin}-${idealMax}`,
  };
}

/**
 * Interpolate custom curve points (FaceIQ's Bezier interpolation)
 */
export function interpolateFaceIQCurve(
  value: number,
  points: FaceIQCurvePoint[]
): number {
  if (points.length === 0) return 0;

  // Sort points by x
  const sorted = [...points].sort((a, b) => a.x - b.x);

  // Handle out of range
  if (value <= sorted[0].x) return sorted[0].y;
  if (value >= sorted[sorted.length - 1].x) return sorted[sorted.length - 1].y;

  // Find bracketing points
  for (let i = 0; i < sorted.length - 1; i++) {
    if (value >= sorted[i].x && value <= sorted[i + 1].x) {
      const p0 = sorted[i];
      const p1 = sorted[i + 1];

      // Linear interpolation (FaceIQ uses this for simple curves)
      const t = (value - p0.x) / (p1.x - p0.x);
      return p0.y + t * (p1.y - p0.y);
    }
  }

  return 0;
}

/**
 * Get RGB color for a score using FaceIQ's color gradient
 */
export function getFaceIQScoreColor(score: number): string {
  const clampedScore = Math.max(1, Math.min(10, score));

  // Find the two color stops to interpolate between
  let lowerStop = FACEIQ_COLOR_STOPS[0];
  let upperStop = FACEIQ_COLOR_STOPS[FACEIQ_COLOR_STOPS.length - 1];

  for (let i = 0; i < FACEIQ_COLOR_STOPS.length - 1; i++) {
    if (clampedScore >= FACEIQ_COLOR_STOPS[i].threshold &&
        clampedScore <= FACEIQ_COLOR_STOPS[i + 1].threshold) {
      lowerStop = FACEIQ_COLOR_STOPS[i];
      upperStop = FACEIQ_COLOR_STOPS[i + 1];
      break;
    }
  }

  // Interpolate between the two colors
  const t = (clampedScore - lowerStop.threshold) / (upperStop.threshold - lowerStop.threshold);

  const r = Math.round(lowerStop.color[0] + t * (upperStop.color[0] - lowerStop.color[0]));
  const g = Math.round(lowerStop.color[1] + t * (upperStop.color[1] - lowerStop.color[1]));
  const b = Math.round(lowerStop.color[2] + t * (upperStop.color[2] - lowerStop.color[2]));

  return `rgb(${r}, ${g}, ${b})`;
}

/**
 * Calculate score boundaries for UI visualization
 * This determines the min/max display range for the slider
 *
 * FaceIQ formula:
 * - If using custom curve, use curve min/max
 * - Otherwise, calculate where score reaches ~0.1 (practically 0)
 */
export function calculateFaceIQScoreBoundaries(
  idealMin: number,
  idealMax: number,
  decayRate: number = 0.2,
  customPoints?: FaceIQCurvePoint[]
): { min: number; max: number } {
  // If custom curve, use curve boundaries
  if (customPoints && customPoints.length > 0) {
    const sorted = [...customPoints].sort((a, b) => a.x - b.x);
    return {
      min: sorted[0].x,
      max: sorted[sorted.length - 1].x,
    };
  }

  // Calculate deviation needed for score to drop to ~0.1
  // 0.1 = 10 * exp(-decayRate * deviation)
  // log(0.01) = -decayRate * deviation
  // deviation = -log(0.01) / decayRate = log(100) / decayRate
  const maxDeviation = Math.log(100) / decayRate;  // ≈ 23 for decayRate=0.2

  return {
    min: idealMin - maxDeviation,
    max: idealMax + maxDeviation,
  };
}

/**
 * Create a CSS gradient string for ratio visualization
 * Matches FaceIQ's slider gradient
 */
export function createFaceIQScoreGradient(
  displayMin: number,
  displayMax: number,
  idealMin: number,
  idealMax: number,
  decayRate: number = 0.2,
  customPoints?: FaceIQCurvePoint[]
): string {
  const stops: string[] = [];
  const numStops = 20;  // Number of gradient stops

  for (let i = 0; i <= numStops; i++) {
    const value = displayMin + (i / numStops) * (displayMax - displayMin);
    const result = calculateFaceIQScore(value, {
      idealMin,
      idealMax,
      decayRate,
      customPoints,
    });

    const color = getFaceIQScoreColor(result.score);
    const position = (i / numStops) * 100;
    stops.push(`${color} ${position.toFixed(1)}%`);
  }

  return `linear-gradient(to right, ${stops.join(', ')})`;
}

/**
 * Calculate deviation description for display
 * Matches FaceIQ's format: "X.XX° above ideal" / "X.XX° below ideal" / "within ideal range"
 */
export function getFaceIQDeviationDescription(
  result: FaceIQScoreResult,
  unit: string = ''
): string {
  if (result.deviation === 'ideal') {
    return 'within ideal range';
  }

  const amount = result.deviationAmount.toFixed(2);
  return `${amount}${unit} ${result.deviation} ideal`;
}

/**
 * Severity classification based on score
 * Matches FaceIQ's severity tiers
 */
export function getFaceIQSeverity(score: number): 'minor' | 'moderate' | 'severe' | 'extremely severe' {
  if (score >= 8) return 'minor';
  if (score >= 7) return 'moderate';
  if (score > 3) return 'severe';
  return 'extremely severe';
}

/**
 * FaceIQ's obfuscated slider position for locked ratios
 * Returns a semi-random position that looks plausible
 */
export function getObfuscatedSliderPosition(
  score: number | null,
  ratioName: string
): number | null {
  if (score === null) return null;

  // Use ratio name as seed for consistent "random" position
  const seed = ratioName.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  const pseudoRandom = (Math.sin(seed) + 1) / 2;  // 0-1 range

  // Return a position between 20% and 80%
  return 20 + pseudoRandom * 60;
}
