/**
 * FaceIQ Category Score Calculator
 *
 * Aggregates our 80+ metrics into FaceIQ's 4 categories:
 * - Harmony (35%): Proportions, balance, symmetry
 * - Angularity (25%): Jaw definition, bone structure, leanness
 * - Dimorphism (25%): Sex-specific features
 * - Miscellaneous (15%): Eyes, skin, other features
 */

import type { Ratio } from '@/types/results';
import type { FaceIQCategory, FaceIQCategoryScores } from './potential';
import { FACEIQ_CATEGORY_WEIGHTS } from './potential';

// ============================================
// METRIC TO CATEGORY MAPPING
// ============================================

/**
 * Maps our metric IDs to FaceIQ categories
 * Based on what each metric measures
 */
export const METRIC_TO_CATEGORY: Record<string, FaceIQCategory> = {
  // ============================================
  // HARMONY - Proportions, balance, thirds
  // ============================================
  'faceWidthToHeight': 'harmony',
  'totalFacialWidthToHeight': 'harmony',
  'lowerThirdProportion': 'harmony',
  'lowerThirdProportionAlt': 'harmony',
  'middleThirdProportion': 'harmony',
  'upperThirdProportion': 'harmony',
  'midfaceRatio': 'harmony',
  'midfaceLength': 'harmony',
  'facialConvexityGlabella': 'harmony',
  'facialConvexityNasion': 'harmony',
  'totalFacialConvexity': 'harmony',
  'nasalIndex': 'harmony',
  'nasalProjection': 'harmony',
  'nasofrontalAngle': 'harmony',
  'nasolabialAngle': 'harmony',
  'nasofacialAngle': 'harmony',
  'nasomentaAngle': 'harmony',
  'mouthWidthToNoseWidth': 'harmony',
  'interpupillaryMouthWidth': 'harmony',
  'lipThickness': 'harmony',
  'lowerLipToUpperLip': 'harmony',
  'cupidsBowDepth': 'harmony',
  'chinToPhiltrum': 'harmony',
  'noseToLipRatio': 'harmony',
  'facialDepthToHeight': 'harmony',

  // ============================================
  // ANGULARITY - Jaw, bone structure, definition
  // ============================================
  'gonialAngle': 'angularity',
  'bigonialWidth': 'angularity',
  'jawWidthRatio': 'angularity',
  'jawFrontalAngle': 'angularity',
  'jawSlope': 'angularity',
  'mandibularPlaneAngle': 'angularity',
  'ramusToMandible': 'angularity',
  'lowerJawProminence': 'angularity',
  'upperJawProminence': 'angularity',
  'submentalCervicalAngle': 'angularity',
  'neckWidth': 'angularity',
  'anteriorFacialDepth': 'angularity',
  'cheekboneHeight': 'angularity',
  'bitemporalWidth': 'angularity',
  'recessionRelativeToFrankfort': 'angularity',

  // ============================================
  // DIMORPHISM - Sex-specific features
  // ============================================
  'browridgeInclination': 'dimorphism',
  'upperForeheadSlope': 'dimorphism',
  'eyeAspectRatio': 'dimorphism',
  'lateralCanthalTilt': 'dimorphism',
  'upperEyelidExposure': 'dimorphism',
  'browThickness': 'dimorphism',
  'browTilt': 'dimorphism',
  'browLowSetedness': 'dimorphism',
  'browLengthToFaceWidth': 'dimorphism',
  'holdawayHLine': 'dimorphism',
  'burstoneUpperLip': 'dimorphism',
  'burstoneLowerLip': 'dimorphism',
  'upperLipELine': 'dimorphism',
  'lowerLipELine': 'dimorphism',
  'zAngle': 'dimorphism',
  'mentoLabialAngle': 'dimorphism',

  // ============================================
  // MISCELLANEOUS - Eyes, ears, other
  // ============================================
  'eyeSeparationRatio': 'miscellaneous',
  'oneEyeApartTest': 'miscellaneous',
  'eyeProtrusion': 'miscellaneous',
  'orbitalVector': 'miscellaneous',
  'earProtrusionAngle': 'miscellaneous',
  'earProtrusionRatio': 'miscellaneous',
  'noseBridgeToNoseWidth': 'miscellaneous',
  'noseTipPosition': 'miscellaneous',
  'intercanthalNasalWidth': 'miscellaneous',
  'ipsilateralAlarAngle': 'miscellaneous',
  'nasalTipAngle': 'miscellaneous',
  'noseTipRotation': 'miscellaneous',
  'frankfortTipAngle': 'miscellaneous',
  'interiorMidfaceProjection': 'miscellaneous',
  'midfaceProminence': 'miscellaneous',
  'gonionToMouthLine': 'miscellaneous',
  'mouthCornerPosition': 'miscellaneous',
  'iaaJfaDeviation': 'miscellaneous',
  'cheekFullness': 'miscellaneous',
};

// ============================================
// CATEGORY SCORE CALCULATION
// ============================================

export interface CategoryScoreResult {
  scores: FaceIQCategoryScores;
  metricCounts: Record<FaceIQCategory, number>;
  weakestCategory: FaceIQCategory;
  strongestCategory: FaceIQCategory;
  overallScore: number;
}

/**
 * Calculate category scores from ratio results
 */
export function calculateCategoryScores(ratios: Ratio[]): CategoryScoreResult {
  // Initialize accumulators
  const categoryTotals: Record<FaceIQCategory, number> = {
    harmony: 0,
    angularity: 0,
    dimorphism: 0,
    miscellaneous: 0,
  };

  const categoryCounts: Record<FaceIQCategory, number> = {
    harmony: 0,
    angularity: 0,
    dimorphism: 0,
    miscellaneous: 0,
  };

  // Aggregate scores by category
  for (const ratio of ratios) {
    const category = METRIC_TO_CATEGORY[ratio.id];
    if (!category) continue;

    // Handle obfuscated scores
    const score = typeof ratio.score === 'number' ? ratio.score : 5;

    categoryTotals[category] += score;
    categoryCounts[category]++;
  }

  // Calculate averages (default to 5 if no metrics)
  const scores: FaceIQCategoryScores = {
    harmony: categoryCounts.harmony > 0
      ? categoryTotals.harmony / categoryCounts.harmony
      : 5,
    angularity: categoryCounts.angularity > 0
      ? categoryTotals.angularity / categoryCounts.angularity
      : 5,
    dimorphism: categoryCounts.dimorphism > 0
      ? categoryTotals.dimorphism / categoryCounts.dimorphism
      : 5,
    miscellaneous: categoryCounts.miscellaneous > 0
      ? categoryTotals.miscellaneous / categoryCounts.miscellaneous
      : 5,
  };

  // Find weakest and strongest
  const categories = Object.keys(scores) as FaceIQCategory[];
  const weakestCategory = categories.reduce((a, b) =>
    scores[a] < scores[b] ? a : b
  );
  const strongestCategory = categories.reduce((a, b) =>
    scores[a] > scores[b] ? a : b
  );

  // Calculate weighted overall
  let overallScore = 0;
  for (const cat of categories) {
    overallScore += scores[cat] * FACEIQ_CATEGORY_WEIGHTS[cat];
  }

  return {
    scores,
    metricCounts: categoryCounts,
    weakestCategory,
    strongestCategory,
    overallScore,
  };
}

/**
 * Get improvement suggestions based on category scores
 */
export function getCategoryImprovementSuggestions(
  scores: FaceIQCategoryScores,
  gender: 'male' | 'female' = 'male'
): Array<{ category: FaceIQCategory; suggestion: string; priority: number }> {
  const suggestions: Array<{ category: FaceIQCategory; suggestion: string; priority: number }> = [];

  // Harmony suggestions
  if (scores.harmony < 7) {
    suggestions.push({
      category: 'harmony',
      suggestion: scores.harmony < 5
        ? 'Consider rhinoplasty or facial balancing procedures'
        : 'Minor proportion improvements possible with fillers',
      priority: 10 - scores.harmony,
    });
  }

  // Angularity suggestions
  if (scores.angularity < 7) {
    suggestions.push({
      category: 'angularity',
      suggestion: scores.angularity < 5
        ? 'Body recomposition and jaw enhancement recommended'
        : 'Lose body fat and consider jawline definition treatments',
      priority: 10 - scores.angularity,
    });
  }

  // Dimorphism suggestions (gender-specific)
  if (scores.dimorphism < 7) {
    const dimorphSuggestion = gender === 'male'
      ? scores.dimorphism < 5
        ? 'Significant masculinization procedures may help'
        : 'Brow and jaw masculinization treatments'
      : scores.dimorphism < 5
        ? 'Feminization procedures recommended'
        : 'Soft tissue feminization and lip enhancement';

    suggestions.push({
      category: 'dimorphism',
      suggestion: dimorphSuggestion,
      priority: 10 - scores.dimorphism,
    });
  }

  // Miscellaneous suggestions
  if (scores.miscellaneous < 7) {
    suggestions.push({
      category: 'miscellaneous',
      suggestion: 'Focus on skincare, eye area treatments, and grooming',
      priority: (10 - scores.miscellaneous) * 0.5, // Lower priority
    });
  }

  return suggestions.sort((a, b) => b.priority - a.priority);
}

/**
 * Get category label for display
 */
export function getCategoryLabel(category: FaceIQCategory): string {
  const labels: Record<FaceIQCategory, string> = {
    harmony: 'Harmony',
    angularity: 'Angularity',
    dimorphism: 'Dimorphism',
    miscellaneous: 'Features',
  };
  return labels[category];
}

/**
 * Get category icon name (for lucide-react)
 */
export function getCategoryIcon(category: FaceIQCategory): string {
  const icons: Record<FaceIQCategory, string> = {
    harmony: 'Scale',
    angularity: 'Triangle',
    dimorphism: 'Users',
    miscellaneous: 'Sparkles',
  };
  return icons[category];
}
