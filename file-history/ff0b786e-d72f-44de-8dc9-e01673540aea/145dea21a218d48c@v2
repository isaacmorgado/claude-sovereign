/**
 * Unified Color Utility Functions
 * Consolidates all color logic for scores, quality tiers, severity levels, and categories.
 */

import type { QualityTier, SeverityLevel } from '@/lib/scoring/types';

// =============================================================================
// FACEIQ PARITY - 10-POINT SCORE COLOR GRADIENT
// =============================================================================

/**
 * FaceIQ's exact color stops for score visualization.
 * Provides smooth 10-point gradient from deep red (1) to cyan (10).
 *
 * Reverse-engineered from FaceIQ's production JavaScript.
 */
export const FACEIQ_SCORE_COLORS: readonly { threshold: number; color: readonly [number, number, number] }[] = [
  { threshold: 1, color: [185, 28, 28] },    // Deep red
  { threshold: 2, color: [220, 53, 53] },    // Red
  { threshold: 3, color: [239, 88, 88] },    // Light red
  { threshold: 4, color: [245, 130, 75] },   // Orange
  { threshold: 5, color: [251, 175, 60] },   // Yellow-orange
  { threshold: 6, color: [220, 200, 80] },   // Yellow
  { threshold: 7, color: [140, 215, 100] },  // Yellow-green
  { threshold: 8, color: [74, 222, 128] },   // Green
  { threshold: 9, color: [40, 205, 170] },   // Teal
  { threshold: 10, color: [6, 182, 212] },   // Cyan
];

// =============================================================================
// COLOR PALETTE
// =============================================================================

/**
 * Centralized color palette for consistent UI theming.
 * All color values used throughout the application.
 */
export const COLOR_PALETTE = {
  // Score-based colors (0-10 scale) - Legacy, use getScoreColor() for FaceIQ parity
  score: {
    ideal: '#06b6d4',     // Cyan - 10 (FaceIQ)
    good: '#4ade80',      // Green - 8 (FaceIQ)
    fair: '#fbbf24',      // Yellow - 5 (close to FaceIQ)
    poor: 'rgb(185, 28, 28)', // Red - 1 (FaceIQ)
  },

  // Quality tier colors (QualityTier enum)
  quality: {
    ideal: '#67e8f9',         // Cyan
    excellent: '#22c55e',     // Green
    good: '#fbbf24',          // Yellow/Amber
    below_average: 'rgb(227, 67, 67)', // Red
    default: '#6b7280',       // Gray (fallback)
  },

  // Severity level colors (SeverityLevel enum)
  severity: {
    optimal: '#67e8f9',       // Cyan
    minor: '#22c55e',         // Green
    moderate: '#fbbf24',      // Yellow/Amber
    major: '#f97316',         // Orange
    severe: '#ef4444',        // Red
    extremely_severe: '#dc2626', // Dark red
    default: '#6b7280',       // Gray (fallback)
  },

  // Weight tier badge colors (Tailwind classes)
  weightTier: {
    high: 'bg-purple-500/20 text-purple-400 border-purple-500/30',
    medium: 'bg-blue-500/20 text-blue-400 border-blue-500/30',
    standard: 'bg-gray-500/20 text-gray-400 border-gray-500/30',
  },

  // Severity text color classes (Tailwind)
  severityText: {
    optimal: 'text-green-400',
    minor: 'text-lime-400',
    moderate: 'text-yellow-400',
    major: 'text-orange-400',
    severe: 'text-red-400',
    extremely_severe: 'text-red-600',
  },

  // Measurement category colors
  categories: {
    'midface': '#67e8f9',
    'midface/face shape': '#67e8f9',
    'jaw-growth': '#a78bfa',
    'occlusion/jaw growth': '#a78bfa',
    'jaw-shape': '#f97316',
    'jaw shape': '#f97316',
    'upper-third': '#84cc16',
    'upper third': '#84cc16',
    'eyes': '#06b6d4',
    'nose': '#fbbf24',
    'lips': '#ec4899',
    'chin': '#ef4444',
    'neck': '#14b8a6',
    'other': '#6b7280',
    'default': '#6b7280',
  },
} as const;

// =============================================================================
// COLOR UTILITY FUNCTIONS
// =============================================================================

/**
 * Get color based on a 0-10 score using FaceIQ's exact 10-point gradient.
 *
 * FaceIQ Parity: Uses smooth RGB interpolation between 10 color stops.
 * This provides much more granular color feedback than the old 4-tier system.
 *
 * @param score - Score value from 0-10
 * @returns RGB color string
 *
 * @example
 * getScoreColor(10.0) // 'rgb(6, 182, 212)' (cyan)
 * getScoreColor(8.0)  // 'rgb(74, 222, 128)' (green)
 * getScoreColor(5.0)  // 'rgb(251, 175, 60)' (yellow-orange)
 * getScoreColor(1.0)  // 'rgb(185, 28, 28)' (deep red)
 */
export function getScoreColor(score: number): string {
  // Clamp score to 1-10 range
  const clampedScore = Math.max(1, Math.min(10, score));

  // Find the two color stops to interpolate between
  let lowerStop = FACEIQ_SCORE_COLORS[0];
  let upperStop = FACEIQ_SCORE_COLORS[FACEIQ_SCORE_COLORS.length - 1];

  for (let i = 0; i < FACEIQ_SCORE_COLORS.length - 1; i++) {
    if (clampedScore >= FACEIQ_SCORE_COLORS[i].threshold &&
        clampedScore <= FACEIQ_SCORE_COLORS[i + 1].threshold) {
      lowerStop = FACEIQ_SCORE_COLORS[i];
      upperStop = FACEIQ_SCORE_COLORS[i + 1];
      break;
    }
  }

  // Interpolate between the two colors
  const t = (clampedScore - lowerStop.threshold) / (upperStop.threshold - lowerStop.threshold);

  const r = Math.round(lowerStop.color[0] + t * (upperStop.color[0] - lowerStop.color[0]));
  const g = Math.round(lowerStop.color[1] + t * (upperStop.color[1] - lowerStop.color[1]));
  const b = Math.round(lowerStop.color[2] + t * (upperStop.color[2] - lowerStop.color[2]));

  return `rgb(${r}, ${g}, ${b})`;
}

/**
 * Get FaceIQ score color as RGB array (for canvas/WebGL use).
 *
 * @param score - Score value from 0-10
 * @returns Array of [r, g, b] values (0-255)
 */
export function getScoreColorRGB(score: number): [number, number, number] {
  const clampedScore = Math.max(1, Math.min(10, score));

  let lowerStop = FACEIQ_SCORE_COLORS[0];
  let upperStop = FACEIQ_SCORE_COLORS[FACEIQ_SCORE_COLORS.length - 1];

  for (let i = 0; i < FACEIQ_SCORE_COLORS.length - 1; i++) {
    if (clampedScore >= FACEIQ_SCORE_COLORS[i].threshold &&
        clampedScore <= FACEIQ_SCORE_COLORS[i + 1].threshold) {
      lowerStop = FACEIQ_SCORE_COLORS[i];
      upperStop = FACEIQ_SCORE_COLORS[i + 1];
      break;
    }
  }

  const t = (clampedScore - lowerStop.threshold) / (upperStop.threshold - lowerStop.threshold);

  return [
    Math.round(lowerStop.color[0] + t * (upperStop.color[0] - lowerStop.color[0])),
    Math.round(lowerStop.color[1] + t * (upperStop.color[1] - lowerStop.color[1])),
    Math.round(lowerStop.color[2] + t * (upperStop.color[2] - lowerStop.color[2])),
  ];
}

/**
 * Create a CSS linear gradient for score range visualization.
 * Matches FaceIQ's slider gradient style.
 *
 * @param displayMin - Minimum display value
 * @param displayMax - Maximum display value
 * @param idealMin - Ideal range minimum
 * @param idealMax - Ideal range maximum
 * @param decayRate - Decay rate for scoring (default: 0.2)
 * @returns CSS linear-gradient string
 */
export function createScoreGradient(
  displayMin: number,
  displayMax: number,
  idealMin: number,
  idealMax: number,
  decayRate: number = 0.2
): string {
  const stops: string[] = [];
  const numStops = 20;

  for (let i = 0; i <= numStops; i++) {
    const value = displayMin + (i / numStops) * (displayMax - displayMin);

    // Calculate score using FaceIQ formula
    let score: number;
    if (value >= idealMin && value <= idealMax) {
      score = 10;
    } else {
      const deviation = value < idealMin ? idealMin - value : value - idealMax;
      score = 10 * Math.exp(-decayRate * deviation);
    }

    const color = getScoreColor(Math.max(1, Math.min(10, score)));
    const position = (i / numStops) * 100;
    stops.push(`${color} ${position.toFixed(1)}%`);
  }

  return `linear-gradient(to right, ${stops.join(', ')})`;
}

/**
 * Get color based on quality tier.
 *
 * @param quality - QualityTier enum value
 * @returns Hex color string
 *
 * @example
 * getQualityColor('ideal')     // '#67e8f9'
 * getQualityColor('excellent') // '#22c55e'
 * getQualityColor('good')      // '#fbbf24'
 * getQualityColor('below_average') // 'rgb(227, 67, 67)'
 */
export function getQualityColor(quality: QualityTier): string {
  switch (quality) {
    case 'ideal':
      return COLOR_PALETTE.quality.ideal;
    case 'excellent':
      return COLOR_PALETTE.quality.excellent;
    case 'good':
      return COLOR_PALETTE.quality.good;
    case 'below_average':
      return COLOR_PALETTE.quality.below_average;
    default:
      return COLOR_PALETTE.quality.default;
  }
}

/**
 * Get color based on severity level.
 *
 * @param severity - SeverityLevel enum value
 * @returns Hex color string
 *
 * @example
 * getSeverityColor('optimal')  // '#67e8f9'
 * getSeverityColor('minor')    // '#22c55e'
 * getSeverityColor('moderate') // '#fbbf24'
 * getSeverityColor('major')    // '#f97316'
 * getSeverityColor('severe')   // '#ef4444'
 * getSeverityColor('extremely_severe') // '#dc2626'
 */
export function getSeverityColor(severity: SeverityLevel): string {
  switch (severity) {
    case 'optimal':
      return COLOR_PALETTE.severity.optimal;
    case 'minor':
      return COLOR_PALETTE.severity.minor;
    case 'moderate':
      return COLOR_PALETTE.severity.moderate;
    case 'major':
      return COLOR_PALETTE.severity.major;
    case 'severe':
      return COLOR_PALETTE.severity.severe;
    case 'extremely_severe':
      return COLOR_PALETTE.severity.extremely_severe;
    default:
      return COLOR_PALETTE.severity.default;
  }
}

/**
 * Get Tailwind text color class based on severity level.
 * Used for text elements that need severity-based styling.
 *
 * @param severity - SeverityLevel enum value
 * @returns Tailwind CSS class string
 *
 * @example
 * getSeverityTextColor('optimal') // 'text-green-400'
 * getSeverityTextColor('severe')  // 'text-red-400'
 */
export function getSeverityTextColor(severity: SeverityLevel): string {
  switch (severity) {
    case 'optimal':
      return COLOR_PALETTE.severityText.optimal;
    case 'minor':
      return COLOR_PALETTE.severityText.minor;
    case 'moderate':
      return COLOR_PALETTE.severityText.moderate;
    case 'major':
      return COLOR_PALETTE.severityText.major;
    case 'severe':
      return COLOR_PALETTE.severityText.severe;
    case 'extremely_severe':
      return COLOR_PALETTE.severityText.extremely_severe;
    default:
      return 'text-gray-400';
  }
}

/**
 * Get color for a measurement category.
 * Matches category names case-insensitively and supports partial matches.
 *
 * @param categoryName - Name of the measurement category
 * @returns Hex color string
 *
 * @example
 * getCategoryColor('Eyes')           // '#06b6d4'
 * getCategoryColor('Midface')        // '#67e8f9'
 * getCategoryColor('Jaw Shape')      // '#f97316'
 * getCategoryColor('Unknown')        // '#6b7280' (default gray)
 */
export function getCategoryColor(categoryName: string): string {
  const normalized = categoryName.toLowerCase().trim();

  // Direct match in categories
  if (normalized in COLOR_PALETTE.categories) {
    return COLOR_PALETTE.categories[normalized as keyof typeof COLOR_PALETTE.categories];
  }

  // Partial match (category name contains or is contained in a known category)
  for (const [key, color] of Object.entries(COLOR_PALETTE.categories)) {
    if (key === 'default') continue;
    if (normalized.includes(key) || key.includes(normalized)) {
      return color;
    }
  }

  return COLOR_PALETTE.categories.default;
}

/**
 * Get Tailwind badge classes for weight tier display.
 * Returns combined background, text, and border color classes.
 *
 * @param tier - Weight tier: 'high', 'medium', or 'standard'
 * @returns Tailwind CSS class string for badge styling
 *
 * @example
 * getWeightTierColor('high')     // 'bg-purple-500/20 text-purple-400 border-purple-500/30'
 * getWeightTierColor('medium')   // 'bg-blue-500/20 text-blue-400 border-blue-500/30'
 * getWeightTierColor('standard') // 'bg-gray-500/20 text-gray-400 border-gray-500/30'
 */
export function getWeightTierColor(tier: 'high' | 'medium' | 'standard'): string {
  return COLOR_PALETTE.weightTier[tier];
}
