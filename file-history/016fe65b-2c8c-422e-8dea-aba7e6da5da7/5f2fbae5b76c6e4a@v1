import { NextResponse } from 'next/server';
import { analyzeHarmony, analyzeFrontProfile, analyzeSideProfile } from '@/lib/scoring/analyzer';
import { LandmarkPoint } from '@/lib/landmarks';

// Greek Substitution Cipher Map
const GREEK_MAP: Record<string, string> = {
    '0': 'θ',
    '1': 'ι',
    '2': 'κ',
    '3': 'λ',
    '4': 'μ',
    '5': 'ν',
    '6': 'ξ',
    '7': 'ο',
    '8': 'π',
    '9': 'ρ',
    '.': '·',
    '-': '–',
};

// Helper: Obfuscate a number or string value
function obfuscateValue(value: any): any {
    if (typeof value === 'number') {
        const str = value.toFixed(2); // Convert to string with precision
        return str.split('').map(char => GREEK_MAP[char] || char).join('');
    }
    if (typeof value === 'string') {
        // If it's already a string, maybe it's a category name or generic text.
        // We only want to obfuscate scores/numbers usually.
        // But for 'LOCKED' content, we might want to return Greek gibberish.
        return value; // Keep text readable for now, or apply map if it contains numbers
    }
    return value;
}

// Recursive function to walk through the JSON object and obfuscate numbers
function obfuscateObject(obj: any): any {
    if (Array.isArray(obj)) {
        return obj.map(item => obfuscateObject(item));
    }

    if (typeof obj === 'object' && obj !== null) {
        const newObj: any = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                // Obfuscate specific keys that hold sensitive scores
                // We generally obfuscate EVERYTHING numeric for free users
                if (typeof obj[key] === 'object') {
                    newObj[key] = obfuscateObject(obj[key]);
                } else if (typeof obj[key] === 'number') {
                    newObj[key] = obfuscateValue(obj[key]);
                } else {
                    newObj[key] = obj[key];
                }
            }
        }
        return newObj;
    }

    // Primitives
    return obj;
}

export async function POST(request: Request) {
    try {
        const body = await request.json();
        const { frontLandmarks, sideLandmarks, gender, ethnicity, isPaid } = body;

        if (!frontLandmarks || !sideLandmarks) {
            return NextResponse.json(
                { error: 'Missing landmarks' },
                { status: 400 }
            );
        }

        // 1. Calculate Harmony (Server-Side)
        // This runs the full proprietary logic securely on the server
        const analysis = analyzeHarmony(frontLandmarks, sideLandmarks, gender, ethnicity);

        // 2. Obfuscate if not paid
        let responseData = analysis;

        if (!isPaid) {
            // Apply Greek Cipher to scores
            responseData = obfuscateObject(analysis);
            // Add a flag so frontend knows it's obfuscated
            (responseData as any).isObfuscated = true;
        }

        return NextResponse.json(responseData);

    } catch (error) {
        console.error('Analysis API Error:', error);
        return NextResponse.json(
            { error: 'Internal Server Error' },
            { status: 500 }
        );
    }
}
