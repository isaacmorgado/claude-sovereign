/**
 * SPLICE Music Module
 * AI-powered music generation for video projects
 */

// ============================================
// STATE
// ============================================
const musicState = {
  jobs: [],
  selectedJob: null,
  isIdentifying: false,
  isGenerating: false,
  identifiedSong: null,
  audioPlayer: null,
  pollInterval: null,
  // Variations state
  variationsJob: null,
  variationsPollingInterval: null,
  selectedVariationIndex: null,
  variationPlayers: [null, null, null],  // Audio players for each variation
  // Scene-aware state
  sceneAwareEnabled: false,
  // Alignment state
  isAligning: false,
  alignmentOptions: null,
  beatAnalysis: null
};

// ============================================
// CONSTANTS
// ============================================
const MUSIC_POLL_INTERVAL = 5000; // 5 seconds

const MOOD_OPTIONS = [
  { id: 'energetic', name: 'Energetic', description: 'Upbeat, high energy' },
  { id: 'relaxed', name: 'Relaxed', description: 'Calm, peaceful' },
  { id: 'melancholic', name: 'Melancholic', description: 'Sad, emotional' },
  { id: 'intense', name: 'Intense', description: 'Powerful, dramatic' },
  { id: 'happy', name: 'Happy', description: 'Joyful, cheerful' },
  { id: 'mysterious', name: 'Mysterious', description: 'Dark, suspenseful' },
  { id: 'romantic', name: 'Romantic', description: 'Warm, intimate' },
  { id: 'epic', name: 'Epic', description: 'Grand, orchestral' },
  { id: 'chill', name: 'Chill', description: 'Lo-fi, laid-back' },
  { id: 'neutral', name: 'Neutral', description: 'Balanced, versatile' }
];

const INSTRUMENT_OPTIONS = [
  { id: 'acoustic', name: 'Acoustic', description: 'Guitar, piano, strings' },
  { id: 'electronic', name: 'Electronic', description: 'Synths, beats' },
  { id: 'rock', name: 'Rock', description: 'Electric guitars, drums' },
  { id: 'orchestral', name: 'Orchestral', description: 'Strings, brass, woodwinds' },
  { id: 'minimal', name: 'Minimal', description: 'Piano, ambient' },
  { id: 'hiphop', name: 'Hip-Hop', description: '808s, trap drums' }
];

const DURATION_OPTIONS = [
  { value: 30, label: '30 seconds' },
  { value: 60, label: '1 minute' },
  { value: 90, label: '1.5 minutes' },
  { value: 120, label: '2 minutes' },
  { value: 180, label: '3 minutes' }
];

// ============================================
// API FUNCTIONS
// ============================================

/**
 * Identify song from YouTube URL
 * @param {string} youtubeUrl - YouTube URL
 * @returns {Promise<Object>} Identification result
 */
async function identifySong(youtubeUrl) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/identify`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ youtubeUrl })
  }, 90000); // 90 second timeout for identification

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to identify song');
  }

  return response.json();
}

/**
 * Generate music
 * @param {Object} options - Generation options
 * @returns {Promise<Object>} Job info
 */
async function generateMusicRequest(options) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(options)
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start music generation');
  }

  return response.json();
}

/**
 * Get job status
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Job status
 */
async function getJobStatus(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/status/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get job status');
  }

  return response.json();
}

/**
 * Get user's music library
 * @returns {Promise<Object[]>} Array of music items
 */
async function getMusicLibrary() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/library`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to load music library');
  }

  return response.json();
}

/**
 * Get music file with download URL
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Music info with signed URL
 */
async function getMusicFile(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get music file');
  }

  return response.json();
}

/**
 * Delete music from library
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Result
 */
async function deleteMusicFile(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/${jobId}`, {
    method: 'DELETE',
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to delete music');
  }

  return response.json();
}

/**
 * Get music credits balance
 * @returns {Promise<Object>} Credits info
 */
async function getMusicCredits() {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/credits`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    return { remaining: 0, total: 0 };
  }

  return response.json();
}

// ============================================
// VARIATIONS API FUNCTIONS
// ============================================

/**
 * Generate 3 music variations
 * @param {Object} options - Generation options
 * @returns {Promise<Object>} Job info
 */
async function generateVariationsRequest(options) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-variations`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(options)
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start variations generation');
  }

  return response.json();
}

/**
 * Get variations job status
 * @param {string} jobId - Job ID
 * @returns {Promise<Object>} Job status with variations
 */
async function getVariationsStatus(jobId) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/variations/status/${jobId}`, {
    headers: getAuthHeaders()
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to get variations status');
  }

  return response.json();
}

/**
 * Select a variation from the generated options
 * @param {string} jobId - Job ID
 * @param {number} variationIndex - Index of variation to select (0-2)
 * @returns {Promise<Object>} Selection result
 */
async function selectVariation(jobId, variationIndex) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/variations/${jobId}/select`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ variationIndex })
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to select variation');
  }

  return response.json();
}

// ============================================
// SCENE-AWARE API FUNCTIONS
// ============================================

/**
 * Generate scene-aware music using transcript analysis
 * @param {Object} options - Generation options
 * @param {Object[]} segments - Transcript segments
 * @returns {Promise<Object>} Job info
 */
async function generateSceneAwareRequest(options, segments) {
  const response = await fetchWithTimeout(`${getBackendUrl()}/music/generate-scene-aware`, {
    method: 'POST',
    headers: {
      ...getAuthHeaders(),
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      ...options,
      segments
    })
  });

  if (!response.ok) {
    const error = await parseErrorResponse(response);
    throw new Error(error.message || 'Failed to start scene-aware music generation');
  }

  return response.json();
}

/**
 * Get transcript segments from the current session
 * @returns {Object[]|null} Transcript segments or null if not available
 */
function getCurrentTranscriptSegments() {
  // Check if transcript is available from main workflow
  if (window.currentTranscript && window.currentTranscript.segments) {
    return window.currentTranscript.segments;
  }
  return null;
}

// ============================================
// UI FUNCTIONS
// ============================================

/**
 * Initialize music module
 */
function initMusicModule() {
  // Set up event listeners
  setupMusicEventListeners();

  // Populate dropdowns
  populateMoodDropdown();
  populateInstrumentDropdown();
  populateDurationDropdown();

  // Load library on init
  loadMusicLibrary();

  // Update credits display
  updateMusicCreditsDisplay();
}

/**
 * Set up event listeners for music UI
 */
function setupMusicEventListeners() {
  // YouTube URL input
  const urlInput = document.getElementById('musicYoutubeUrl');
  if (urlInput) {
    urlInput.addEventListener('input', debounce(handleYoutubeUrlChange, 500));
  }

  // Identify button
  const identifyBtn = document.getElementById('musicIdentifyBtn');
  if (identifyBtn) {
    identifyBtn.addEventListener('click', handleIdentifySong);
  }

  // Generate button
  const generateBtn = document.getElementById('musicGenerateBtn');
  if (generateBtn) {
    generateBtn.addEventListener('click', handleGenerateMusic);
  }

  // Generate Variations button
  const variationsBtn = document.getElementById('musicGenerateVariationsBtn');
  if (variationsBtn) {
    variationsBtn.addEventListener('click', handleGenerateVariations);
  }

  // Scene-aware toggle
  const sceneAwareToggle = document.getElementById('musicSceneAwareToggle');
  if (sceneAwareToggle) {
    sceneAwareToggle.addEventListener('change', handleSceneAwareToggle);
  }

  // Clear reference button
  const clearRefBtn = document.getElementById('musicClearRefBtn');
  if (clearRefBtn) {
    clearRefBtn.addEventListener('click', handleClearReference);
  }

  // Library refresh
  const refreshBtn = document.getElementById('musicRefreshLibraryBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', loadMusicLibrary);
  }

  // Update scene-aware availability on init
  updateSceneAwareAvailability();
}

/**
 * Handle scene-aware toggle change
 */
function handleSceneAwareToggle() {
  const toggle = document.getElementById('musicSceneAwareToggle');
  musicState.sceneAwareEnabled = toggle?.checked || false;

  // Show/hide the scene-aware indicator
  const indicator = document.getElementById('sceneAwareIndicator');
  if (indicator) {
    indicator.style.display = musicState.sceneAwareEnabled ? 'block' : 'none';
  }

  // Update status
  if (musicState.sceneAwareEnabled) {
    const segments = getCurrentTranscriptSegments();
    if (segments) {
      setMusicStatus(`Scene-aware enabled: ${segments.length} segments detected`, 'info');
    } else {
      setMusicStatus('Scene-aware enabled: Run transcription first for best results', 'warning');
    }
  }
}

/**
 * Update scene-aware toggle availability based on transcript presence
 */
function updateSceneAwareAvailability() {
  const toggle = document.getElementById('musicSceneAwareToggle');
  const segments = getCurrentTranscriptSegments();

  if (toggle) {
    // Enable toggle if transcript is available
    toggle.disabled = !segments;

    // Update label to show availability
    const label = toggle.closest('label') || toggle.parentElement;
    if (label) {
      const statusSpan = label.querySelector('.scene-aware-status');
      if (statusSpan) {
        statusSpan.textContent = segments
          ? `(${segments.length} segments available)`
          : '(run transcription first)';
      }
    }
  }
}

/**
 * Populate mood dropdown
 */
function populateMoodDropdown() {
  const select = document.getElementById('musicMood');
  if (!select) return;

  select.innerHTML = MOOD_OPTIONS.map(mood =>
    `<option value="${mood.id}" title="${mood.description}">${mood.name}</option>`
  ).join('');
}

/**
 * Populate instrument dropdown
 */
function populateInstrumentDropdown() {
  const select = document.getElementById('musicInstruments');
  if (!select) return;

  select.innerHTML = INSTRUMENT_OPTIONS.map(inst =>
    `<option value="${inst.id}" title="${inst.description}">${inst.name}</option>`
  ).join('');
}

/**
 * Populate duration dropdown
 */
function populateDurationDropdown() {
  const select = document.getElementById('musicDuration');
  if (!select) return;

  select.innerHTML = DURATION_OPTIONS.map(dur =>
    `<option value="${dur.value}">${dur.label}</option>`
  ).join('');

  // Default to 60 seconds
  select.value = '60';
}

/**
 * Handle YouTube URL change
 */
function handleYoutubeUrlChange() {
  const urlInput = document.getElementById('musicYoutubeUrl');
  const identifyBtn = document.getElementById('musicIdentifyBtn');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  const isValidUrl = isValidYouTubeUrl(url);

  identifyBtn.disabled = !isValidUrl;

  // Clear previous identification if URL changed
  if (musicState.identifiedSong) {
    handleClearReference();
  }
}

/**
 * Validate YouTube URL
 * @param {string} url - URL to validate
 * @returns {boolean} Is valid
 */
function isValidYouTubeUrl(url) {
  if (!url) return false;
  const patterns = [
    /youtube\.com\/watch\?v=[\w-]{11}/,
    /youtu\.be\/[\w-]{11}/,
    /youtube\.com\/embed\/[\w-]{11}/
  ];
  return patterns.some(p => p.test(url));
}

/**
 * Handle identify song button click
 */
async function handleIdentifySong() {
  const urlInput = document.getElementById('musicYoutubeUrl');
  const identifyBtn = document.getElementById('musicIdentifyBtn');
  const refDisplay = document.getElementById('musicReferenceDisplay');

  if (!urlInput || !identifyBtn) return;

  const url = urlInput.value.trim();
  if (!isValidYouTubeUrl(url)) {
    setMusicStatus('Invalid YouTube URL', 'error');
    return;
  }

  try {
    musicState.isIdentifying = true;
    identifyBtn.disabled = true;
    identifyBtn.textContent = 'Identifying...';
    setMusicStatus('Identifying song...', 'info');

    const result = await identifySong(url);

    if (result.identified) {
      musicState.identifiedSong = result;
      displayIdentifiedSong(result);
      setMusicStatus(`Identified: ${result.title} by ${result.artist}`, 'success');
    } else {
      setMusicStatus('Could not identify song. You can still generate music.', 'warning');
    }

  } catch (error) {
    console.error('Identification error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isIdentifying = false;
    identifyBtn.disabled = false;
    identifyBtn.textContent = 'Identify';
  }
}

/**
 * Display identified song info
 * @param {Object} song - Song info
 */
function displayIdentifiedSong(song) {
  const display = document.getElementById('musicReferenceDisplay');
  if (!display) return;

  const details = [];
  if (song.bpm) details.push(`${song.bpm} BPM`);
  if (song.key) details.push(song.key);
  if (song.mood) details.push(song.mood);

  display.innerHTML = `
    <div class="music-reference-card">
      <div class="music-ref-title">${escapeHtml(song.title)}</div>
      <div class="music-ref-artist">${escapeHtml(song.artist)}</div>
      <div class="music-ref-details">${details.join(' â€¢ ')}</div>
      <button id="musicClearRefBtn" class="music-clear-ref-btn" title="Clear reference">Ã—</button>
    </div>
  `;

  display.style.display = 'block';

  // Re-attach clear button listener
  const clearBtn = document.getElementById('musicClearRefBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', handleClearReference);
  }
}

/**
 * Clear reference song
 */
function handleClearReference() {
  musicState.identifiedSong = null;

  const display = document.getElementById('musicReferenceDisplay');
  if (display) {
    display.innerHTML = '';
    display.style.display = 'none';
  }

  const urlInput = document.getElementById('musicYoutubeUrl');
  if (urlInput) {
    urlInput.value = '';
  }

  const identifyBtn = document.getElementById('musicIdentifyBtn');
  if (identifyBtn) {
    identifyBtn.disabled = true;
  }
}

/**
 * Handle generate music button click
 */
async function handleGenerateMusic() {
  const generateBtn = document.getElementById('musicGenerateBtn');
  const moodSelect = document.getElementById('musicMood');
  const instrumentSelect = document.getElementById('musicInstruments');
  const durationSelect = document.getElementById('musicDuration');
  const promptInput = document.getElementById('musicPrompt');

  if (!generateBtn) return;

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';

    const options = {
      mood: moodSelect?.value || 'neutral',
      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
      duration: parseInt(durationSelect?.value) || 60,
      prompt: promptInput?.value || '',
      youtubeUrl: musicState.identifiedSong?.sourceUrl || null,
      referenceSong: musicState.identifiedSong || null
    };

    let result;

    // Check if scene-aware is enabled and transcript is available
    if (musicState.sceneAwareEnabled) {
      const segments = getCurrentTranscriptSegments();
      if (segments && segments.length > 0) {
        setMusicStatus('Analyzing transcript and generating scene-aware music...', 'info');
        result = await generateSceneAwareRequest(options, segments);
        setMusicStatus(`Scene-aware generation started! Job ID: ${result.jobId}`, 'success');
      } else {
        // Fallback to regular generation if no transcript
        setMusicStatus('No transcript available, using regular generation...', 'warning');
        result = await generateMusicRequest(options);
        setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
      }
    } else {
      setMusicStatus('Submitting generation request...', 'info');
      result = await generateMusicRequest(options);
      setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
    }

    // Add to jobs list and start polling
    addJobToList(result.jobId, options, result.isSceneAware);
    startPollingJob(result.jobId);

    // Clear form
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Generation error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate Music';
  }
}

/**
 * Handle generate variations button click
 */
async function handleGenerateVariations() {
  const generateBtn = document.getElementById('musicGenerateVariationsBtn');
  const moodSelect = document.getElementById('musicMood');
  const instrumentSelect = document.getElementById('musicInstruments');
  const durationSelect = document.getElementById('musicDuration');
  const promptInput = document.getElementById('musicPrompt');

  if (!generateBtn) return;

  try {
    musicState.isGenerating = true;
    generateBtn.disabled = true;
    generateBtn.textContent = 'Starting...';
    setMusicStatus('Generating 3 variations... This may take 5-8 minutes.', 'info');

    const options = {
      mood: moodSelect?.value || 'neutral',
      instruments: instrumentSelect?.value ? [instrumentSelect.value] : [],
      duration: parseInt(durationSelect?.value) || 60,
      prompt: promptInput?.value || '',
      referenceSong: musicState.identifiedSong || null
    };

    const result = await generateVariationsRequest(options);

    setMusicStatus(`Variations generation started! Job ID: ${result.jobId}`, 'success');

    // Store variations job and start polling
    musicState.variationsJob = {
      jobId: result.jobId,
      status: 'pending',
      options
    };

    startPollingVariations(result.jobId);

    // Show variations panel
    showVariationsPanel();

    // Clear form
    handleClearReference();
    if (promptInput) promptInput.value = '';

  } catch (error) {
    console.error('Variations error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');
  } finally {
    musicState.isGenerating = false;
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate 3 Variations';
  }
}

/**
 * Start polling for variations job completion
 * @param {string} jobId - Job ID
 */
function startPollingVariations(jobId) {
  // Clear any existing poll
  if (musicState.variationsPollingInterval) {
    clearInterval(musicState.variationsPollingInterval);
  }

  musicState.variationsPollingInterval = setInterval(async () => {
    try {
      const status = await getVariationsStatus(jobId);

      // Update variations job state
      musicState.variationsJob = {
        ...musicState.variationsJob,
        ...status
      };

      // Update UI
      renderVariationsProgress(status);

      // Check if ready for selection or failed
      if (status.status === 'selecting' || status.status === 'completed') {
        clearInterval(musicState.variationsPollingInterval);
        musicState.variationsPollingInterval = null;

        if (status.variations && status.variations.length > 0) {
          setMusicStatus('Variations ready! Select your favorite.', 'success');
          renderVariationsSelection(status.variations);
        }
      } else if (status.status === 'failed') {
        clearInterval(musicState.variationsPollingInterval);
        musicState.variationsPollingInterval = null;
        setMusicStatus(`Variations failed: ${status.failedReason || 'Unknown error'}`, 'error');
      }

    } catch (error) {
      console.error('Variations polling error:', error);
    }
  }, MUSIC_POLL_INTERVAL);
}

/**
 * Show variations panel
 */
function showVariationsPanel() {
  const panel = document.getElementById('variationsPanel');
  if (panel) {
    panel.style.display = 'block';
    panel.innerHTML = `
      <div class="variations-header">
        <h4>Generating 3 Variations</h4>
        <button id="variationsCancelBtn" class="variations-cancel-btn" title="Cancel">Ã—</button>
      </div>
      <div class="variations-progress">
        <div class="variation-progress-item" data-index="0">
          <span class="variation-name">Version A</span>
          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
          <span class="progress-text">0%</span>
        </div>
        <div class="variation-progress-item" data-index="1">
          <span class="variation-name">Version B</span>
          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
          <span class="progress-text">0%</span>
        </div>
        <div class="variation-progress-item" data-index="2">
          <span class="variation-name">Version C</span>
          <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
          <span class="progress-text">0%</span>
        </div>
      </div>
      <div id="variationsSelection" class="variations-selection" style="display: none;"></div>
    `;

    // Add cancel button listener
    const cancelBtn = document.getElementById('variationsCancelBtn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', hideVariationsPanel);
    }
  }
}

/**
 * Hide variations panel
 */
function hideVariationsPanel() {
  const panel = document.getElementById('variationsPanel');
  if (panel) {
    panel.style.display = 'none';
    panel.innerHTML = '';
  }

  // Stop polling
  if (musicState.variationsPollingInterval) {
    clearInterval(musicState.variationsPollingInterval);
    musicState.variationsPollingInterval = null;
  }

  // Stop all variation audio players
  musicState.variationPlayers.forEach(player => {
    if (player) {
      player.pause();
      player.src = '';
    }
  });
  musicState.variationPlayers = [null, null, null];
  musicState.variationsJob = null;
  musicState.selectedVariationIndex = null;
}

/**
 * Render variations progress
 * @param {Object} status - Variations job status
 */
function renderVariationsProgress(status) {
  const progressItems = document.querySelectorAll('.variation-progress-item');
  const variationProgress = status.variationProgress || [0, 0, 0];

  progressItems.forEach((item, index) => {
    const progress = variationProgress[index] || 0;
    const fill = item.querySelector('.progress-fill');
    const text = item.querySelector('.progress-text');

    if (fill) {
      fill.style.width = `${progress}%`;
    }
    if (text) {
      text.textContent = `${progress}%`;
    }

    // Add completed class if done
    if (progress >= 100) {
      item.classList.add('completed');
    }
  });
}

/**
 * Render variations selection UI with 3 audio previews
 * @param {Object[]} variations - Array of variation objects
 */
function renderVariationsSelection(variations) {
  const container = document.getElementById('variationsSelection');
  if (!container) return;

  // Hide progress, show selection
  const progressContainer = document.querySelector('.variations-progress');
  if (progressContainer) {
    progressContainer.style.display = 'none';
  }

  container.style.display = 'block';
  container.innerHTML = `
    <div class="variations-header">
      <h4>Select Your Favorite</h4>
      <p class="variations-subtitle">Preview each variation and choose one to keep</p>
    </div>
    <div class="variations-cards">
      ${variations.map((v, index) => `
        <div class="variation-card ${v.status === 'failed' ? 'failed' : ''}"
             data-index="${index}"
             ${v.status === 'failed' ? 'data-failed="true"' : ''}>
          <div class="variation-card-header">
            <span class="variation-name">${escapeHtml(v.variationName)}</span>
            ${v.status === 'failed' ? '<span class="failed-badge">Failed</span>' : ''}
          </div>
          ${v.promptDescription ? `<div class="variation-description">${escapeHtml(v.promptDescription)}</div>` : ''}
          ${v.status !== 'failed' ? `
            <div class="variation-player" data-index="${index}">
              <button class="play-btn" data-action="play" data-index="${index}" data-url="${v.previewUrl || ''}">
                â–¶
              </button>
              <div class="waveform-placeholder"></div>
              <span class="duration">${v.duration ? `${v.duration}s` : '--'}</span>
            </div>
            <button class="select-variation-btn" data-index="${index}">
              Select This Version
            </button>
          ` : `
            <div class="variation-error">${escapeHtml(v.error || 'Generation failed')}</div>
          `}
        </div>
      `).join('')}
    </div>
  `;

  // Add event listeners for play buttons
  container.querySelectorAll('.play-btn').forEach(btn => {
    btn.addEventListener('click', handleVariationPlay);
  });

  // Add event listeners for select buttons
  container.querySelectorAll('.select-variation-btn').forEach(btn => {
    btn.addEventListener('click', handleVariationSelect);
  });
}

/**
 * Handle variation play button click
 * @param {Event} event - Click event
 */
async function handleVariationPlay(event) {
  const btn = event.target;
  const index = parseInt(btn.dataset.index);
  const url = btn.dataset.url;

  if (!url) {
    setMusicStatus('No preview available', 'warning');
    return;
  }

  // Stop all other variation players
  musicState.variationPlayers.forEach((player, i) => {
    if (player && i !== index) {
      player.pause();
      const otherBtn = document.querySelector(`.play-btn[data-index="${i}"]`);
      if (otherBtn) otherBtn.textContent = 'â–¶';
    }
  });

  // Create or get player for this variation
  if (!musicState.variationPlayers[index]) {
    musicState.variationPlayers[index] = new Audio();
    musicState.variationPlayers[index].addEventListener('ended', () => {
      btn.textContent = 'â–¶';
    });
  }

  const player = musicState.variationPlayers[index];

  if (player.paused || player.src !== url) {
    player.src = url;
    try {
      await player.play();
      btn.textContent = 'â¸';
    } catch (error) {
      console.error('Play error:', error);
      setMusicStatus('Could not play preview', 'error');
    }
  } else {
    player.pause();
    btn.textContent = 'â–¶';
  }
}

/**
 * Handle variation selection
 * @param {Event} event - Click event
 */
async function handleVariationSelect(event) {
  const btn = event.target;
  const index = parseInt(btn.dataset.index);
  const jobId = musicState.variationsJob?.jobId;

  if (!jobId) {
    setMusicStatus('No variations job found', 'error');
    return;
  }

  try {
    // Disable all select buttons
    document.querySelectorAll('.select-variation-btn').forEach(b => {
      b.disabled = true;
    });
    btn.textContent = 'Selecting...';

    setMusicStatus('Finalizing your selection...', 'info');

    const result = await selectVariation(jobId, index);

    setMusicStatus(`Selected ${result.variationName}! Music added to library.`, 'success');

    // Stop all players
    musicState.variationPlayers.forEach(player => {
      if (player) player.pause();
    });

    // Hide panel and refresh library
    hideVariationsPanel();
    loadMusicLibrary();
    updateMusicCreditsDisplay();

  } catch (error) {
    console.error('Selection error:', error);
    setMusicStatus(`Error: ${error.message}`, 'error');

    // Re-enable buttons
    document.querySelectorAll('.select-variation-btn').forEach(b => {
      b.disabled = false;
    });
    btn.textContent = 'Select This Version';
  }
}

/**
 * Add job to the jobs list
 * @param {string} jobId - Job ID
 * @param {Object} options - Job options
 * @param {boolean} isSceneAware - Whether this is a scene-aware job
 */
function addJobToList(jobId, options, isSceneAware = false) {
  const job = {
    jobId,
    status: 'pending',
    progress: 0,
    mood: options.mood,
    duration: options.duration,
    isSceneAware,
    createdAt: new Date().toISOString()
  };

  musicState.jobs.unshift(job);
  renderJobsList();
}

/**
 * Start polling for job completion
 * @param {string} jobId - Job ID
 */
function startPollingJob(jobId) {
  // Clear any existing poll
  if (musicState.pollInterval) {
    clearInterval(musicState.pollInterval);
  }

  musicState.pollInterval = setInterval(async () => {
    try {
      const status = await getJobStatus(jobId);

      // Update job in list
      const jobIndex = musicState.jobs.findIndex(j => j.jobId === jobId);
      if (jobIndex !== -1) {
        musicState.jobs[jobIndex] = {
          ...musicState.jobs[jobIndex],
          ...status
        };
        renderJobsList();
      }

      // Check if complete or failed
      if (status.status === 'completed' || status.status === 'failed') {
        clearInterval(musicState.pollInterval);
        musicState.pollInterval = null;

        if (status.status === 'completed') {
          setMusicStatus('Music generation completed!', 'success');
          loadMusicLibrary(); // Refresh library
        } else {
          setMusicStatus(`Generation failed: ${status.failedReason || 'Unknown error'}`, 'error');
        }
      }

    } catch (error) {
      console.error('Polling error:', error);
    }
  }, MUSIC_POLL_INTERVAL);
}

/**
 * Render jobs list UI
 */
function renderJobsList() {
  const container = document.getElementById('musicJobsList');
  if (!container) return;

  if (musicState.jobs.length === 0) {
    container.innerHTML = '<div class="music-empty">No generation jobs yet</div>';
    return;
  }

  container.innerHTML = musicState.jobs.map(job => `
    <div class="music-job-item ${job.status}" data-job-id="${job.jobId}">
      <div class="music-job-status ${job.status}"></div>
      <div class="music-job-info">
        <span class="music-job-mood">${job.mood || 'Music'}${job.isSceneAware ? ' ðŸŽ¬' : ''}</span>
        <span class="music-job-duration">${job.duration}s</span>
      </div>
      <div class="music-job-progress">
        ${job.status === 'completed' ? 'âœ“' : job.status === 'failed' ? 'âœ—' : `${job.progress}%`}
      </div>
    </div>
  `).join('');
}

/**
 * Load and display music library
 */
async function loadMusicLibrary() {
  const container = document.getElementById('musicLibrary');
  if (!container) return;

  try {
    container.innerHTML = '<div class="music-loading">Loading library...</div>';

    const library = await getMusicLibrary();

    if (library.length === 0) {
      container.innerHTML = '<div class="music-empty">Your music library is empty</div>';
      return;
    }

    container.innerHTML = library.map(item => `
      <div class="music-library-item" data-job-id="${item.jobId}">
        <div class="music-item-info">
          <div class="music-item-title">${escapeHtml(item.title || 'Untitled')}</div>
          <div class="music-item-meta">${item.duration}s â€¢ ${item.mood || 'Music'}</div>
        </div>
        <div class="music-item-actions">
          <button class="music-action-btn" data-action="preview" data-job-id="${item.jobId}" title="Preview">â–¶</button>
          <button class="music-action-btn" data-action="import" data-job-id="${item.jobId}" title="Import to Timeline">+</button>
          <button class="music-action-btn danger" data-action="delete" data-job-id="${item.jobId}" title="Delete">Ã—</button>
        </div>
      </div>
    `).join('');

    // Add event listeners
    container.querySelectorAll('.music-action-btn').forEach(btn => {
      btn.addEventListener('click', handleLibraryAction);
    });

  } catch (error) {
    console.error('Library load error:', error);
    container.innerHTML = '<div class="music-error">Failed to load library</div>';
  }
}

/**
 * Handle library action (preview, import, delete)
 * @param {Event} event - Click event
 */
async function handleLibraryAction(event) {
  const btn = event.target;
  const action = btn.dataset.action;
  const jobId = btn.dataset.jobId;

  switch (action) {
    case 'preview':
      await previewMusic(jobId);
      break;
    case 'import':
      await importMusicToTimeline(jobId);
      break;
    case 'delete':
      await confirmDeleteMusic(jobId);
      break;
  }
}

/**
 * Preview music file
 * @param {string} jobId - Job ID
 */
async function previewMusic(jobId) {
  try {
    setMusicStatus('Loading preview...', 'info');

    const music = await getMusicFile(jobId);

    if (!music.previewUrl && !music.downloadUrl) {
      setMusicStatus('No preview available', 'warning');
      return;
    }

    // Create or update audio player
    if (!musicState.audioPlayer) {
      musicState.audioPlayer = new Audio();
      musicState.audioPlayer.addEventListener('ended', () => {
        setMusicStatus('Preview finished', 'info');
      });
    }

    musicState.audioPlayer.src = music.previewUrl || music.downloadUrl;
    musicState.audioPlayer.play();

    setMusicStatus('Playing preview...', 'success');

  } catch (error) {
    console.error('Preview error:', error);
    setMusicStatus(`Preview error: ${error.message}`, 'error');
  }
}

/**
 * Import music to Premiere Pro timeline
 * @param {string} jobId - Job ID
 */
async function importMusicToTimeline(jobId) {
  try {
    setMusicStatus('Downloading music...', 'info');

    const music = await getMusicFile(jobId);

    if (!music.downloadUrl) {
      setMusicStatus('Download URL not available', 'error');
      return;
    }

    setMusicStatus('Importing to timeline...', 'info');

    // Download file
    const response = await fetch(music.downloadUrl);
    const blob = await response.blob();

    // Get temp folder access
    const tempFolder = await getTempFolder();
    if (!tempFolder) {
      setMusicStatus('Could not access temp folder', 'error');
      return;
    }

    // Save to temp file
    const fileName = `splice_music_${jobId}.wav`;
    const tempFile = await tempFolder.createFile(fileName, { overwrite: true });
    const arrayBuffer = await blob.arrayBuffer();
    await tempFile.write(arrayBuffer);

    // Import to project
    const pproBuilder = require('premierepro').pproBuilder;
    const project = await pproBuilder.Project.getActiveProject();

    if (!project) {
      setMusicStatus('No active project', 'error');
      return;
    }

    // Import file
    const imported = await project.importFiles([tempFile.nativePath]);

    if (imported && imported.length > 0) {
      setMusicStatus('Music imported to project!', 'success');

      // Optionally insert at playhead
      const sequence = await pproBuilder.Sequence.getActiveSequence();
      if (sequence) {
        // TODO: Insert clip at playhead position
        setMusicStatus('Music imported and ready to use!', 'success');
      }
    } else {
      setMusicStatus('Import failed', 'error');
    }

  } catch (error) {
    console.error('Import error:', error);
    setMusicStatus(`Import error: ${error.message}`, 'error');
  }
}

/**
 * Confirm and delete music
 * @param {string} jobId - Job ID
 */
async function confirmDeleteMusic(jobId) {
  const confirmed = await showConfirmModal(
    'Delete Music',
    'Are you sure you want to delete this music file?'
  );

  if (!confirmed) return;

  try {
    setMusicStatus('Deleting...', 'info');
    await deleteMusicFile(jobId);
    setMusicStatus('Music deleted', 'success');
    loadMusicLibrary();
  } catch (error) {
    console.error('Delete error:', error);
    setMusicStatus(`Delete error: ${error.message}`, 'error');
  }
}

/**
 * Update music credits display
 */
async function updateMusicCreditsDisplay() {
  const badge = document.getElementById('musicCreditsBadge');
  if (!badge) return;

  try {
    const credits = await getMusicCredits();
    badge.textContent = `${credits.remaining}/${credits.total} songs`;
    badge.className = 'music-credits-badge';

    if (credits.remaining === 0) {
      badge.classList.add('empty');
    } else if (credits.remaining <= 2) {
      badge.classList.add('low');
    }
  } catch (error) {
    badge.textContent = 'Credits: --';
  }
}

/**
 * Set music status message
 * @param {string} message - Status message
 * @param {string} type - Message type (info, success, warning, error)
 */
function setMusicStatus(message, type = 'info') {
  const status = document.getElementById('musicStatus');
  if (!status) return;

  status.textContent = message;
  status.className = `music-status ${type}`;
  status.style.display = 'block';

  // Auto-hide after delay for non-error messages
  if (type !== 'error') {
    setTimeout(() => {
      status.style.display = 'none';
    }, 5000);
  }
}

/**
 * Get temp folder for file operations
 * @returns {Promise<Folder|null>}
 */
async function getTempFolder() {
  try {
    const uxpFs = require('uxp').storage.localFileSystem;
    return await uxpFs.getTemporaryFolder();
  } catch (error) {
    console.error('Temp folder error:', error);
    return null;
  }
}

/**
 * Escape HTML special characters
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeHtml(str) {
  if (!str) return '';
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

/**
 * Simple debounce function
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in ms
 * @returns {Function} Debounced function
 */
function debounce(fn, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Export for use in other modules
window.musicModule = {
  init: initMusicModule,
  identifySong,
  generateMusicRequest,
  getMusicLibrary,
  getMusicCredits,
  loadMusicLibrary,
  previewMusic,
  importMusicToTimeline,
  // Variations exports
  generateVariationsRequest,
  getVariationsStatus,
  selectVariation,
  handleGenerateVariations,
  showVariationsPanel,
  hideVariationsPanel,
  // Scene-aware exports
  generateSceneAwareRequest,
  getCurrentTranscriptSegments,
  handleSceneAwareToggle,
  updateSceneAwareAvailability,
  MOOD_OPTIONS,
  INSTRUMENT_OPTIONS,
  DURATION_OPTIONS
};
