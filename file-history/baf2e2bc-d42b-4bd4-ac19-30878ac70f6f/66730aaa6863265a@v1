#!/bin/bash
# Autonomous Orchestrator V2 - Smart orchestration with learning and auto-execution
# Integrates: learning-engine, task-queue, agent-loop, plan-execute

set -e

CLAUDE_DIR="${HOME}/.claude"
MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
LEARNING_ENGINE="${CLAUDE_DIR}/hooks/learning-engine.sh"
TASK_QUEUE="${CLAUDE_DIR}/hooks/task-queue.sh"
AGENT_LOOP="${CLAUDE_DIR}/hooks/agent-loop.sh"
PLAN_EXECUTE="${CLAUDE_DIR}/hooks/plan-execute.sh"
SELF_HEALING="${CLAUDE_DIR}/hooks/self-healing.sh"
PROJECT_DIR="${PWD}"
LOG_FILE="${CLAUDE_DIR}/orchestrator.log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# =============================================================================
# STATE DETECTION (same as v1)
# =============================================================================

check_buildguide() {
    if [[ -f "${PROJECT_DIR}/buildguide.md" ]]; then
        if grep -q '^\s*- \[ \]' "${PROJECT_DIR}/buildguide.md" 2>/dev/null; then
            echo "buildguide_found"
            return 0
        fi
    fi
    echo "no_buildguide"
    return 1
}

check_current_build() {
    local build_file="${PROJECT_DIR}/.claude/current-build.local.md"
    if [[ -f "$build_file" ]]; then
        local phase=$(grep -o 'phase: [a-z]*' "$build_file" 2>/dev/null | cut -d' ' -f2)
        if [[ "$phase" != "complete" && -n "$phase" ]]; then
            echo "resume_build:${phase}"
            return 0
        fi
    fi
    echo "no_current_build"
    return 1
}

check_continuation() {
    local cont_file="${PROJECT_DIR}/.claude/continuation-prompt.md"
    if [[ -f "$cont_file" ]]; then
        echo "continuation_found"
        return 0
    fi

    if [[ -f "${CLAUDE_DIR}/continuation-prompt.md" ]]; then
        echo "global_continuation_found"
        return 0
    fi

    echo "no_continuation"
    return 1
}

check_active_task() {
    if [[ -x "$MEMORY_MANAGER" ]]; then
        local task=$("$MEMORY_MANAGER" get-working 2>/dev/null | jq -r '.currentTask // empty' 2>/dev/null)
        if [[ -n "$task" && "$task" != "null" ]]; then
            echo "active_task:${task}"
            return 0
        fi
    fi
    echo "no_active_task"
    return 1
}

# =============================================================================
# SMART TASK ANALYSIS (NEW)
# =============================================================================

# Extract tasks from buildguide and populate task queue
populate_task_queue() {
    if [[ ! -f "${PROJECT_DIR}/buildguide.md" ]]; then
        return
    fi

    if [[ ! -x "$TASK_QUEUE" ]]; then
        return
    fi

    # Extract unchecked sections
    local tasks
    tasks=$(grep '^\s*- \[ \]' "${PROJECT_DIR}/buildguide.md" | sed 's/- \[ \] //' || true)

    if [[ -z "$tasks" ]]; then
        return
    fi

    # Add each task to queue with priority
    local priority=2
    while IFS= read -r task; do
        # Check if task already in queue
        local existing
        existing=$("$TASK_QUEUE" list pending 2>/dev/null | jq -r --arg name "$task" '.[] | select(.name == $name) | .id' 2>/dev/null || echo "")

        if [[ -z "$existing" ]]; then
            "$TASK_QUEUE" add "$task" "$priority" "from buildguide.md" "" 2>/dev/null || true
            log "Added task to queue: $task"
        fi

        # Increment priority (lower number = higher priority)
        priority=$((priority + 1))
        [[ $priority -gt 5 ]] && priority=5
    done <<< "$tasks"
}

# Analyze task and get recommended strategy
analyze_task() {
    local task="$1"

    if [[ ! -x "$LEARNING_ENGINE" ]]; then
        echo '{"strategy":"default","confidence":0,"risk":10}'
        return
    fi

    # Determine task type
    local task_type="general"
    if echo "$task" | grep -qiE "implement|add|create|build"; then
        task_type="feature"
    elif echo "$task" | grep -qiE "fix|bug|error|issue"; then
        task_type="bugfix"
    elif echo "$task" | grep -qiE "refactor|clean|improve"; then
        task_type="refactor"
    elif echo "$task" | grep -qiE "test|spec|coverage"; then
        task_type="test"
    fi

    # Get recommendation from learning engine
    local recommendation
    recommendation=$("$LEARNING_ENGINE" recommend "$task_type" "$task" 2>/dev/null || echo '{"strategy":"default","confidence":0}')

    # Get risk assessment
    local strategy
    strategy=$(echo "$recommendation" | jq -r '.strategy')
    local risk
    risk=$("$LEARNING_ENGINE" predict-risk "$task_type" "$strategy" 2>/dev/null || echo '{"riskScore":10,"riskLevel":"low"}')

    # Combine
    echo "$recommendation" | jq --argjson risk "$risk" '. + {risk: $risk.riskScore, riskLevel: $risk.riskLevel, taskType: "'"$task_type"'"}'
}

# =============================================================================
# AUTO-EXECUTION (NEW)
# =============================================================================

# Start agent loop for a task
start_agent_loop() {
    local task="$1"
    local context="${2:-}"

    if [[ ! -x "$AGENT_LOOP" ]]; then
        log "Agent loop not available"
        return 1
    fi

    # Check system health first
    if [[ -x "$SELF_HEALING" ]]; then
        local health
        health=$("$SELF_HEALING" health 2>/dev/null || echo "unknown")
        if [[ "$health" == "unhealthy" ]]; then
            log "System unhealthy, attempting recovery before agent loop"
            "$SELF_HEALING" recover 2>/dev/null || true
        fi
    fi

    # Start agent loop
    log "Starting agent loop for: $task"
    local agent_id
    agent_id=$("$AGENT_LOOP" start "$task" "$context" 2>/dev/null)

    echo "$agent_id"
}

# Create execution plan for task
create_execution_plan() {
    local task="$1"
    local task_type="${2:-general}"

    if [[ ! -x "$PLAN_EXECUTE" ]]; then
        return
    fi

    # Create plan
    local plan_id
    plan_id=$("$PLAN_EXECUTE" create "$task" "autonomous execution" 2>/dev/null)

    # Decompose task into steps
    local steps
    steps=$("$PLAN_EXECUTE" decompose "$task" "$task_type" 2>/dev/null)

    # Add steps to plan
    while IFS= read -r step; do
        if [[ -n "$step" ]]; then
            local description
            description=$(echo "$step" | sed 's/^[0-9]*\. //')
            "$PLAN_EXECUTE" add-step "$description" "shell" "" "" 2>/dev/null || true
        fi
    done <<< "$steps"

    log "Created execution plan: $plan_id for $task"
    echo "$plan_id"
}

# =============================================================================
# SMART ORCHESTRATION (UPGRADED)
# =============================================================================

orchestrate_smart() {
    local decisions=()
    local actions=()
    local recommendations=()

    # Initialize learning engine
    [[ -x "$LEARNING_ENGINE" ]] && "$LEARNING_ENGINE" init 2>/dev/null || true

    # Priority 1: Check for continuation prompt
    local cont_status=$(check_continuation)
    if [[ "$cont_status" == "continuation_found" || "$cont_status" == "global_continuation_found" ]]; then
        decisions+=("RESUME_CONTINUATION")
        actions+=("execute_continuation")
    fi

    # Priority 2: Check for in-progress build
    local build_status=$(check_current_build)
    if [[ "$build_status" == resume_build:* ]]; then
        local phase="${build_status#resume_build:}"
        decisions+=("RESUME_BUILD:${phase}")
        actions+=("resume_build:$phase")
    fi

    # Priority 3: Check for buildguide with unchecked items
    local guide_status=$(check_buildguide)
    if [[ "$guide_status" == "buildguide_found" ]]; then
        decisions+=("START_BUILD")

        # Populate task queue from buildguide
        populate_task_queue

        # Get next task from queue
        if [[ -x "$TASK_QUEUE" ]]; then
            local next_task_id
            next_task_id=$("$TASK_QUEUE" next 2>/dev/null || echo "")
            if [[ -n "$next_task_id" ]]; then
                local task_info
                task_info=$("$TASK_QUEUE" get "$next_task_id" 2>/dev/null)
                local task_name
                task_name=$(echo "$task_info" | jq -r '.name' 2>/dev/null || echo "")

                if [[ -n "$task_name" ]]; then
                    # Analyze task
                    local analysis
                    analysis=$(analyze_task "$task_name")
                    recommendations+=("$analysis")

                    actions+=("start_task:$next_task_id:$task_name")
                fi
            fi
        fi
    fi

    # Priority 4: Check for active task in memory
    local task_status=$(check_active_task)
    if [[ "$task_status" == active_task:* ]]; then
        local task="${task_status#active_task:}"
        decisions+=("CONTINUE_TASK:${task}")
        actions+=("continue_task:$task")
    fi

    # Output comprehensive JSON
    local decisions_json="[]"
    if [[ ${#decisions[@]} -gt 0 ]]; then
        decisions_json=$(printf '%s\n' "${decisions[@]}" | jq -R . | jq -s .)
    fi

    local actions_json="[]"
    if [[ ${#actions[@]} -gt 0 ]]; then
        actions_json=$(printf '%s\n' "${actions[@]}" | jq -R . | jq -s .)
    fi

    local recommendations_json="[]"
    if [[ ${#recommendations[@]} -gt 0 ]]; then
        recommendations_json=$(printf '%s\n' "${recommendations[@]}" | jq -s .)
    fi

    jq -n \
        --argjson decisions "$decisions_json" \
        --argjson actions "$actions_json" \
        --argjson recommendations "$recommendations_json" \
        --arg project "$PROJECT_DIR" \
        --argjson has_guide "$([ "$guide_status" == "buildguide_found" ] && echo "true" || echo "false")" \
        --argjson has_cont "$([ "$cont_status" != "no_continuation" ] && echo "true" || echo "false")" \
        --argjson has_build "$([ "$build_status" != "no_current_build" ] && echo "true" || echo "false")" \
        '{
            decisions: $decisions,
            actions: $actions,
            recommendations: $recommendations,
            project_dir: $project,
            has_buildguide: $has_guide,
            has_continuation: $has_cont,
            has_active_build: $has_build,
            version: "2.0"
        }'
}

# Execute actions autonomously
execute_actions() {
    local actions_json="$1"

    # Parse and execute each action
    echo "$actions_json" | jq -r '.actions[]' | while read -r action; do
        case "$action" in
            start_task:*)
                # Extract task ID and name
                local task_id
                task_id=$(echo "$action" | cut -d: -f2)
                local task_name
                task_name=$(echo "$action" | cut -d: -f3-)

                # Mark task as started
                [[ -x "$TASK_QUEUE" ]] && "$TASK_QUEUE" start "$task_id" 2>/dev/null || true

                # Get task analysis
                local analysis
                analysis=$(analyze_task "$task_name")
                local task_type
                task_type=$(echo "$analysis" | jq -r '.taskType')

                # Create plan
                local plan_id
                plan_id=$(create_execution_plan "$task_name" "$task_type")

                # Start agent loop
                local agent_id
                agent_id=$(start_agent_loop "$task_name" "plan:$plan_id")

                log "Executed start_task: $task_name (agent: $agent_id, plan: $plan_id)"
                ;;

            resume_build:*)
                local phase="${action#resume_build:}"
                log "Resuming build at phase: $phase"
                # Agent loop will be started by Claude based on decision
                ;;

            continue_task:*)
                local task="${action#continue_task:}"
                log "Continuing task: $task"
                # Agent loop will be started by Claude based on decision
                ;;

            execute_continuation)
                log "Executing continuation prompt"
                # Handled by Claude
                ;;
        esac
    done
}

# =============================================================================
# COMMAND INTERFACE
# =============================================================================

case "${1:-orchestrate}" in
    orchestrate)
        # Original simple orchestration
        local decisions=()
        local cont_status=$(check_continuation)
        [[ "$cont_status" != "no_continuation" ]] && decisions+=("RESUME_CONTINUATION")

        local build_status=$(check_current_build)
        [[ "$build_status" == resume_build:* ]] && decisions+=("RESUME_BUILD:${build_status#resume_build:}")

        local guide_status=$(check_buildguide)
        [[ "$guide_status" == "buildguide_found" ]] && decisions+=("START_BUILD")

        local task_status=$(check_active_task)
        [[ "$task_status" == active_task:* ]] && decisions+=("CONTINUE_TASK:${task_status#active_task:}")

        # Simple JSON output for backward compatibility
        local decisions_json="[]"
        if [[ ${#decisions[@]} -gt 0 ]]; then
            decisions_json=$(printf '%s\n' "${decisions[@]}" | jq -R . | jq -s .)
        fi

        jq -n --argjson decisions "$decisions_json" \
            --arg project "$PROJECT_DIR" \
            '{decisions: $decisions, project_dir: $project}'
        ;;

    smart)
        # New smart orchestration with learning
        orchestrate_smart
        ;;

    execute)
        # Auto-execute actions
        local orchestration
        orchestration=$(orchestrate_smart)
        execute_actions "$orchestration"
        echo "$orchestration"
        ;;

    populate-queue)
        # Populate task queue from buildguide
        populate_task_queue
        [[ -x "$TASK_QUEUE" ]] && "$TASK_QUEUE" status
        ;;

    analyze)
        # Analyze a specific task
        analyze_task "${2:-task}"
        ;;

    help|*)
        echo "Autonomous Orchestrator V2 - Smart Orchestration"
        echo ""
        echo "Usage: $0 <command> [args]"
        echo ""
        echo "Commands:"
        echo "  orchestrate           - Simple orchestration (v1 compatible)"
        echo "  smart                 - Smart orchestration with learning"
        echo "  execute               - Auto-execute orchestrated actions"
        echo "  populate-queue        - Populate task queue from buildguide"
        echo "  analyze <task>        - Analyze task and get recommendations"
        echo ""
        echo "Examples:"
        echo "  $0 smart              # Get smart orchestration with recommendations"
        echo "  $0 execute            # Orchestrate and auto-execute"
        echo "  $0 analyze 'implement auth'  # Get strategy recommendation"
        ;;
esac
