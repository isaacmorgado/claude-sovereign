/**
 * Usage Tracking Service
 *
 * Tracks user credit balances and usage for billing.
 * Uses PostgreSQL for persistence.
 */

const { Pool } = require('pg');

// PostgreSQL connection pool
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Hours per tier (regular processing)
const TIER_HOURS = {
  starter: 15,
  pro: 50,
  team: 150,
  cancelled: 0
};

// Isolation hours per tier (vocal isolation is expensive)
const TIER_ISOLATION_HOURS = {
  starter: 0,    // No isolation access
  pro: 2,        // 2 hours included
  team: 5,       // 5 hours included
  cancelled: 0
};

// Overage rate for isolation beyond included hours
const ISOLATION_OVERAGE_RATE = 0.08; // $0.08 per minute

/**
 * Initialize database tables
 */
async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,
        email VARCHAR(255),
        tier VARCHAR(50) DEFAULT 'starter',
        hours_remaining DECIMAL(10,4) DEFAULT 15,
        hours_total DECIMAL(10,4) DEFAULT 15,
        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,
        isolation_hours_total DECIMAL(10,4) DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add isolation columns if they don't exist (for existing databases)
    await client.query(`
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN
          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN
          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;
        END IF;
      END $$;
    `);

    await client.query(`
      CREATE TABLE IF NOT EXISTS usage_log (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        stripe_customer_id VARCHAR(255),
        audio_duration_seconds DECIMAL(10,2),
        hours_used DECIMAL(10,6),
        endpoint VARCHAR(100),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)
    `);

    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)
    `);

    // Webhook events table for idempotency
    await client.query(`
      CREATE TABLE IF NOT EXISTS webhook_events (
        id SERIAL PRIMARY KEY,
        event_id VARCHAR(255) UNIQUE NOT NULL,
        event_type VARCHAR(100),
        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)
    `);

    console.log('[UsageTracking] Database initialized');
  } finally {
    client.release();
  }
}

/**
 * Get or create a user by Stripe customer ID
 */
async function getOrCreateUser(stripeCustomerId, email = null) {
  const client = await pool.connect();
  try {
    // Try to find existing user
    let result = await client.query(
      'SELECT * FROM users WHERE stripe_customer_id = $1',
      [stripeCustomerId]
    );

    if (result.rows.length > 0) {
      return result.rows[0];
    }

    // Create new user with starter tier (no isolation hours)
    result = await client.query(
      `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)
       VALUES ($1, $2, 'starter', $3, $3, $4, $4)
       RETURNING *`,
      [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]
    );

    return result.rows[0];
  } finally {
    client.release();
  }
}

/**
 * Get user's current credit balance
 */
async function getBalance(stripeCustomerId) {
  const user = await getOrCreateUser(stripeCustomerId);
  const hoursTotal = parseFloat(user.hours_total);
  const hoursRemaining = parseFloat(user.hours_remaining);
  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);

  // Tier display names
  const tierNames = {
    starter: 'Starter',
    pro: 'Pro',
    team: 'Team',
    cancelled: 'Cancelled'
  };

  return {
    hoursRemaining,
    hoursTotal,
    isolationHoursRemaining,
    isolationHoursTotal,
    tier: user.tier,
    tierName: tierNames[user.tier] || user.tier,
    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
    isolationOverageRate: ISOLATION_OVERAGE_RATE
  };
}

/**
 * Check if user has enough credits for estimated duration
 */
async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {
  const balance = await getBalance(stripeCustomerId);
  const estimatedHours = estimatedSeconds / 3600;
  return balance.hoursRemaining >= estimatedHours;
}

/**
 * Check if user can use vocal isolation
 * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }
 */
async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {
  const balance = await getBalance(stripeCustomerId);

  // Starter tier has no isolation access
  if (!balance.hasIsolationAccess) {
    return {
      allowed: false,
      reason: 'upgrade_required',
      message: 'Vocal isolation requires Pro or Team tier',
      hasIncludedHours: false,
      overageRequired: false,
      overageCost: 0
    };
  }

  const estimatedHours = estimatedMinutes / 60;
  const remainingIncluded = balance.isolationHoursRemaining;

  // Check if within included hours
  if (remainingIncluded >= estimatedHours) {
    return {
      allowed: true,
      reason: 'included',
      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
      hasIncludedHours: true,
      overageRequired: false,
      overageCost: 0,
      isolationHoursRemaining: remainingIncluded - estimatedHours
    };
  }

  // Calculate overage
  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);
  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;

  return {
    allowed: true,
    reason: 'overage',
    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,
    hasIncludedHours: remainingIncluded > 0,
    overageRequired: true,
    overageMinutes,
    overageCost,
    isolationHoursRemaining: 0
  };
}

/**
 * Deduct isolation usage from user's balance
 * Returns overage cost if beyond included hours
 */
async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {
  const durationMinutes = audioDurationSeconds / 60;
  const durationHours = audioDurationSeconds / 3600;

  const client = await pool.connect();
  try {
    // Get user
    const userResult = await client.query(
      'SELECT * FROM users WHERE stripe_customer_id = $1',
      [stripeCustomerId]
    );

    if (userResult.rows.length === 0) {
      throw new Error('User not found');
    }

    const user = userResult.rows[0];
    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);

    let overageCost = 0;
    let hoursFromIncluded = 0;
    let overageMinutes = 0;

    if (remainingIncluded >= durationHours) {
      // Fully covered by included hours
      hoursFromIncluded = durationHours;
    } else {
      // Partial or full overage
      hoursFromIncluded = remainingIncluded;
      overageMinutes = durationMinutes - (remainingIncluded * 60);
      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;
    }

    // Update isolation balance
    await client.query(
      `UPDATE users
       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),
           updated_at = CURRENT_TIMESTAMP
       WHERE stripe_customer_id = $2`,
      [durationHours, stripeCustomerId]
    );

    // Log usage (mark as isolation)
    await client.query(
      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
       VALUES ($1, $2, $3, $4, $5)`,
      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]
    );

    // Return updated balance and overage info
    const newBalance = await getBalance(stripeCustomerId);
    return {
      ...newBalance,
      isolationUsed: {
        durationMinutes,
        hoursFromIncluded,
        overageMinutes,
        overageCost
      }
    };
  } finally {
    client.release();
  }
}

/**
 * Deduct usage from user's balance
 */
async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {
  const hoursUsed = audioDurationSeconds / 3600;

  const client = await pool.connect();
  try {
    // Get user
    const userResult = await client.query(
      'SELECT * FROM users WHERE stripe_customer_id = $1',
      [stripeCustomerId]
    );

    if (userResult.rows.length === 0) {
      throw new Error('User not found');
    }

    const user = userResult.rows[0];

    // Update balance
    await client.query(
      `UPDATE users
       SET hours_remaining = GREATEST(0, hours_remaining - $1),
           updated_at = CURRENT_TIMESTAMP
       WHERE stripe_customer_id = $2`,
      [hoursUsed, stripeCustomerId]
    );

    // Log usage
    await client.query(
      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
       VALUES ($1, $2, $3, $4, $5)`,
      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]
    );

    // Return updated balance
    return await getBalance(stripeCustomerId);
  } finally {
    client.release();
  }
}

/**
 * Reset user's hours for new billing period
 */
async function resetHours(stripeCustomerId, tier) {
  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;
  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;

  await pool.query(
    `UPDATE users
     SET hours_remaining = $1, hours_total = $1,
         isolation_hours_remaining = $2, isolation_hours_total = $2,
         tier = $3, updated_at = CURRENT_TIMESTAMP
     WHERE stripe_customer_id = $4`,
    [hours, isolationHours, tier, stripeCustomerId]
  );

  return await getBalance(stripeCustomerId);
}

/**
 * Update user's tier (from Stripe webhook)
 */
async function updateTier(stripeCustomerId, tier, email = null) {
  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;
  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;

  const client = await pool.connect();
  try {
    // Check if user exists
    const result = await client.query(
      'SELECT * FROM users WHERE stripe_customer_id = $1',
      [stripeCustomerId]
    );

    if (result.rows.length === 0) {
      // Create new user with this tier
      await client.query(
        `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)
         VALUES ($1, $2, $3, $4, $4, $5, $5)`,
        [stripeCustomerId, email, tier, hours, isolationHours]
      );
    } else {
      // Update existing user
      await client.query(
        `UPDATE users
         SET tier = $1, hours_remaining = $2, hours_total = $2,
             isolation_hours_remaining = $3, isolation_hours_total = $3,
             updated_at = CURRENT_TIMESTAMP
         WHERE stripe_customer_id = $4`,
        [tier, hours, isolationHours, stripeCustomerId]
      );
    }

    return await getBalance(stripeCustomerId);
  } finally {
    client.release();
  }
}

/**
 * Get usage history for a user
 */
async function getUsageHistory(stripeCustomerId, limit = 50) {
  const result = await pool.query(
    `SELECT * FROM usage_log
     WHERE stripe_customer_id = $1
     ORDER BY created_at DESC
     LIMIT $2`,
    [stripeCustomerId, limit]
  );
  return result.rows;
}

/**
 * Check if webhook event has already been processed (idempotency)
 */
async function isEventProcessed(eventId) {
  const result = await pool.query(
    'SELECT id FROM webhook_events WHERE event_id = $1',
    [eventId]
  );
  return result.rows.length > 0;
}

/**
 * Record a processed webhook event
 */
async function recordWebhookEvent(eventId, eventType) {
  try {
    await pool.query(
      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',
      [eventId, eventType]
    );
  } catch (err) {
    // Ignore duplicate key errors (race condition safety)
    if (err.code !== '23505') throw err;
  }
}

module.exports = {
  initDatabase,
  getOrCreateUser,
  getBalance,
  hasCredits,
  checkIsolationAccess,
  deductUsage,
  deductIsolationUsage,
  resetHours,
  updateTier,
  getUsageHistory,
  isEventProcessed,
  recordWebhookEvent,
  TIER_HOURS,
  TIER_ISOLATION_HOURS,
  ISOLATION_OVERAGE_RATE
};
