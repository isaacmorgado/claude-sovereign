/**
 * SPLICE Plugin Main Entry Point
 *
 * Initializes all functionality when the plugin loads.
 * v3.2 - Performance optimized with preview mode for silences and takes.
 */

// Initialize Premiere Pro API
const ppro = require('premierepro');

// ============================================================================
// CACHED DOM ELEMENTS (Performance: avoid repeated getElementById calls)
// ============================================================================
const ui = {};

function cacheUIElements() {
  ui.status = document.getElementById('status');
  ui.silenceGoBtn = document.getElementById('silenceGoBtn');
  ui.takesGoBtn = document.getElementById('takesGoBtn');
  ui.sensitivitySlider = document.getElementById('sensitivitySlider');
  ui.sourceOriginal = document.getElementById('sourceOriginal');
  ui.sourceIsolated = document.getElementById('sourceIsolated');
  ui.autoMarkBest = document.getElementById('autoMarkBest');

  // Progress
  ui.progressContainer = document.getElementById('progressContainer');
  ui.progressText = document.getElementById('progressText');
  ui.resultsEmpty = document.getElementById('resultsEmpty');

  // Silence Preview
  ui.silencePreview = document.getElementById('silencePreview');
  ui.previewList = document.getElementById('previewList');
  ui.previewCount = document.getElementById('previewCount');
  ui.previewTime = document.getElementById('previewTime');
  ui.selectedCount = document.getElementById('selectedCount');
  ui.selectAllSilences = document.getElementById('selectAllSilences');
  ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
  ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
  ui.invertSelectionBtn = document.getElementById('invertSelectionBtn');
  ui.reRunDetectionBtn = document.getElementById('reRunDetectionBtn');

  // Takes Preview
  ui.takesPreview = document.getElementById('takesPreview');
  ui.takesPreviewList = document.getElementById('takesPreviewList');
  ui.takesPreviewCount = document.getElementById('takesPreviewCount');
  ui.selectedTakesCount = document.getElementById('selectedTakesCount');
  ui.selectAllTakes = document.getElementById('selectAllTakes');
  ui.applyTakesPreviewBtn = document.getElementById('applyTakesPreviewBtn');
  ui.cancelTakesPreviewBtn = document.getElementById('cancelTakesPreviewBtn');

  // Results
  ui.silenceResults = document.getElementById('silenceResults');
  ui.silenceCount = document.getElementById('silenceCount');
  ui.timeSaved = document.getElementById('timeSaved');
  ui.clipsModified = document.getElementById('clipsModified');
  ui.takesResults = document.getElementById('takesResults');
  ui.takesList = document.getElementById('takesList');

  // Buttons
  ui.undoBtn = document.getElementById('undoBtn');
  ui.undoTakesBtn = document.getElementById('undoTakesBtn');
  ui.keepBestBtn = document.getElementById('keepBestBtn');
  ui.labelAllBtn = document.getElementById('labelAllBtn');
  ui.advancedSection = document.getElementById('advancedSection');

  // Settings
  ui.settingsBtn = document.getElementById('settingsBtn');
  ui.settingsModal = document.getElementById('settingsModal');
  ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
  ui.silenceOptionsToggle = document.getElementById('silenceOptionsToggle');
  ui.silenceOptions = document.getElementById('silenceOptions');
  ui.takesOptionsToggle = document.getElementById('takesOptionsToggle');
  ui.takesOptions = document.getElementById('takesOptions');
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================
let previewSilences = [];
let selectedSilenceIndices = new Set();
let previewTakes = [];
let selectedTakeIndices = new Set();
let isOperationInProgress = false;
let pendingUIUpdate = null;

// Export preview state for other modules (Razor integration)
window.splicePreviewState = {
  getSelectedSilences: () => previewSilences.filter((_, i) => selectedSilenceIndices.has(i)),
  getSelectedTakes: () => previewTakes.filter((_, i) => selectedTakeIndices.has(i)),
  hasPreview: () => previewSilences.length > 0 || previewTakes.length > 0
};

// ============================================================================
// INITIALIZATION
// ============================================================================
document.addEventListener('DOMContentLoaded', () => {
  // Cache all DOM elements first
  cacheUIElements();

  // Settings & UI
  initSettingsUI();
  initSettingsModal();
  initOptionsToggles();
  initHelpButton();

  // Credits display
  initCredits();

  // Main workflows
  initSilenceWorkflow();
  initTakesWorkflow();

  // Preview handlers (event delegation)
  initPreviewHandlers();
  initTakesPreviewHandlers();

  // Undo handlers
  initUndoHandlers();

  // Keyboard shortcuts
  initKeyboardShortcuts();

  // Advanced features (Razor)
  initSlice9();

  console.log('[SPLICE] Plugin initialized v3.2 (Performance Optimized)');
});

// ============================================================================
// DEBOUNCED UI UPDATES (Performance: batch DOM updates)
// ============================================================================
function scheduleUIUpdate(callback) {
  if (pendingUIUpdate) {
    cancelAnimationFrame(pendingUIUpdate);
  }
  pendingUIUpdate = requestAnimationFrame(() => {
    callback();
    pendingUIUpdate = null;
  });
}

function updateSelectionCounts() {
  scheduleUIUpdate(() => {
    if (ui.selectedCount) {
      ui.selectedCount.textContent = selectedSilenceIndices.size;
    }
    if (ui.selectedTakesCount) {
      ui.selectedTakesCount.textContent = selectedTakeIndices.size;
    }
    updateApplyButton();
    updateSelectAllCheckbox();
  });
}

// ============================================================================
// KEYBOARD SHORTCUTS
// ============================================================================
function initKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Only handle when preview is visible
    const silencePreviewVisible = ui.silencePreview?.style.display !== 'none' &&
                                   ui.silencePreview?.style.display !== '';
    const takesPreviewVisible = ui.takesPreview?.style.display !== 'none' &&
                                 ui.takesPreview?.style.display !== '';

    if (!silencePreviewVisible && !takesPreviewVisible) return;

    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const cmdKey = isMac ? e.metaKey : e.ctrlKey;

    // Enter - Apply selected
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (silencePreviewVisible && selectedSilenceIndices.size > 0) {
        ui.applyPreviewBtn?.click();
      } else if (takesPreviewVisible && selectedTakeIndices.size > 0) {
        ui.applyTakesPreviewBtn?.click();
      }
    }

    // Escape - Cancel
    if (e.key === 'Escape') {
      e.preventDefault();
      if (silencePreviewVisible) {
        ui.cancelPreviewBtn?.click();
      } else if (takesPreviewVisible) {
        ui.cancelTakesPreviewBtn?.click();
      }
    }

    // Cmd/Ctrl+A - Select all
    if (e.key === 'a' && cmdKey) {
      e.preventDefault();
      if (silencePreviewVisible) {
        ui.selectAllSilences.checked = true;
        selectAllSilences(true);
      } else if (takesPreviewVisible) {
        ui.selectAllTakes.checked = true;
        selectAllTakes(true);
      }
    }

    // Cmd/Ctrl+D - Deselect all
    if (e.key === 'd' && cmdKey) {
      e.preventDefault();
      if (silencePreviewVisible) {
        ui.selectAllSilences.checked = false;
        selectAllSilences(false);
      } else if (takesPreviewVisible) {
        ui.selectAllTakes.checked = false;
        selectAllTakes(false);
      }
    }

    // Cmd/Ctrl+I - Invert selection
    if (e.key === 'i' && cmdKey) {
      e.preventDefault();
      if (silencePreviewVisible) {
        invertSilenceSelection();
      }
    }
  });
}

// ============================================================================
// SILENCE WORKFLOW
// ============================================================================
function initSilenceWorkflow() {
  if (!ui.silenceGoBtn) return;

  ui.silenceGoBtn.addEventListener('click', async () => {
    // Prevent double-click
    if (isOperationInProgress) {
      setStatus('Operation in progress...');
      return;
    }

    isOperationInProgress = true;
    ui.silenceGoBtn.disabled = true;

    try {
      showProgress('Preparing audio...');

      // Step 1: Export audio
      const exportSuccess = await exportAudioInternal();
      if (!exportSuccess) {
        throw new Error('Audio export failed');
      }

      // Step 2: Get settings
      const sensitivity = parseInt(ui.sensitivitySlider?.value || 50);
      const useIsolated = ui.sourceIsolated?.checked ?? false;

      // Step 3: Vocal isolation if needed
      let audioPath = WAV_PATH;
      if (useIsolated) {
        showProgress('Isolating vocals (this may take a few minutes)...');
        const isolateResult = await isolateVocals();
        if (isolateResult.success) {
          audioPath = isolateResult.outputPath;
        } else {
          throw new Error(isolateResult.error || 'Vocal isolation failed');
        }
      }

      // Step 4: Detect silences
      showProgress('Detecting silences...');
      const params = mapSensitivity(sensitivity);
      const silences = await detectSilences(audioPath, params);

      if (silences.length === 0) {
        showEmptyState();
        setStatus('No silences detected. Try increasing sensitivity.');
        return;
      }

      // Step 5: Show preview
      showSilencePreview(silences);
      setStatus(`Found ${silences.length} silence(s) - review and apply`);

    } catch (err) {
      showEmptyState();
      setStatus('Error: ' + err.message);
      console.error('[SPLICE] Silence workflow error:', err);
    } finally {
      isOperationInProgress = false;
      ui.silenceGoBtn.disabled = false;
    }
  });
}

// ============================================================================
// TAKES WORKFLOW
// ============================================================================
function initTakesWorkflow() {
  if (!ui.takesGoBtn) return;

  ui.takesGoBtn.addEventListener('click', async () => {
    // Prevent double-click
    if (isOperationInProgress) {
      setStatus('Operation in progress...');
      return;
    }

    isOperationInProgress = true;
    ui.takesGoBtn.disabled = true;

    try {
      showProgress('Preparing audio...');

      // Step 1: Export audio
      const exportSuccess = await exportAudioInternal();
      if (!exportSuccess) {
        throw new Error('Audio export failed');
      }

      // Step 2: Transcribe and analyze
      showProgress('Transcribing and analyzing...');
      const result = await transcribeAudio();

      if (!result.success) {
        throw new Error(result.error || 'Transcription failed');
      }

      // Extract takes
      let takes = [];
      if (result.takes && result.takes.takes) {
        takes = result.takes.takes;
      } else if (result.takes && Array.isArray(result.takes)) {
        takes = result.takes;
      }

      if (takes.length === 0) {
        showEmptyState();
        setStatus('No takes detected in this audio');
        return;
      }

      // Step 3: Show preview (instead of applying immediately)
      showTakesPreview(takes, result.transcript);
      setStatus(`Found ${takes.length} take(s) - review and apply`);

    } catch (err) {
      showEmptyState();
      setStatus('Error: ' + err.message);
      console.error('[SPLICE] Takes workflow error:', err);
    } finally {
      isOperationInProgress = false;
      ui.takesGoBtn.disabled = false;
    }
  });
}

// ============================================================================
// SILENCE PREVIEW (Event Delegation Pattern)
// ============================================================================
function showSilencePreview(silences) {
  previewSilences = silences;
  selectedSilenceIndices = new Set(silences.map((_, i) => i));

  // Hide other views
  hideAllViews();

  // Update summary
  const totalTime = silences.reduce((sum, s) => sum + (s.end - s.start), 0);
  if (ui.previewCount) ui.previewCount.textContent = silences.length;
  if (ui.previewTime) ui.previewTime.textContent = totalTime.toFixed(1) + 's';
  if (ui.selectedCount) ui.selectedCount.textContent = silences.length;

  // Build preview list using DocumentFragment (Performance: single reflow)
  const fragment = document.createDocumentFragment();
  silences.forEach((silence, index) => {
    const duration = silence.end - silence.start;
    const div = document.createElement('div');
    div.className = 'preview-item';
    div.dataset.index = index;
    div.innerHTML = `
      <input type="checkbox" class="preview-item-check" checked data-index="${index}">
      <div class="preview-item-info">
        <div class="preview-item-time">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>
        <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
      </div>
      <button class="preview-item-seek" data-time="${silence.start}" title="Seek to this silence">&gt;</button>
    `;
    fragment.appendChild(div);
  });

  if (ui.previewList) {
    ui.previewList.textContent = ''; // Clear
    ui.previewList.appendChild(fragment);
  }

  // Reset UI state
  if (ui.selectAllSilences) ui.selectAllSilences.checked = true;
  updateApplyButton();

  // Show preview section
  if (ui.silencePreview) ui.silencePreview.style.display = 'block';
}

function initPreviewHandlers() {
  // EVENT DELEGATION: Single listener on parent instead of many on children
  if (ui.previewList) {
    // Handle checkbox changes
    ui.previewList.addEventListener('change', (e) => {
      if (e.target.classList.contains('preview-item-check')) {
        const index = parseInt(e.target.dataset.index);
        const item = e.target.closest('.preview-item');

        if (e.target.checked) {
          selectedSilenceIndices.add(index);
          item?.classList.remove('excluded');
        } else {
          selectedSilenceIndices.delete(index);
          item?.classList.add('excluded');
        }
        updateSelectionCounts();
      }
    });

    // Handle seek button clicks
    ui.previewList.addEventListener('click', async (e) => {
      if (e.target.classList.contains('preview-item-seek')) {
        e.stopPropagation();
        const btn = e.target;
        const time = parseFloat(btn.dataset.time);

        // Show loading state
        btn.classList.add('loading');
        btn.textContent = '...';

        try {
          await seekToTime(time);
        } finally {
          btn.classList.remove('loading');
          btn.textContent = '>';
        }
      }
    });
  }

  // Apply button
  if (ui.applyPreviewBtn) {
    ui.applyPreviewBtn.addEventListener('click', async () => {
      if (isOperationInProgress) return;
      isOperationInProgress = true;
      ui.applyPreviewBtn.disabled = true;

      const originalText = ui.applyPreviewBtn.textContent;
      ui.applyPreviewBtn.textContent = 'Applying...';

      try {
        await applySelectedSilences();
      } catch (err) {
        setStatus('Error: ' + err.message);
        console.error('[SPLICE] Apply error:', err);
      } finally {
        ui.applyPreviewBtn.textContent = originalText;
        ui.applyPreviewBtn.disabled = false;
        isOperationInProgress = false;
      }
    });
  }

  // Cancel button
  if (ui.cancelPreviewBtn) {
    ui.cancelPreviewBtn.addEventListener('click', () => {
      cancelSilencePreview();
    });
  }

  // Select all checkbox
  if (ui.selectAllSilences) {
    ui.selectAllSilences.addEventListener('change', (e) => {
      selectAllSilences(e.target.checked);
    });
  }

  // Invert selection button
  if (ui.invertSelectionBtn) {
    ui.invertSelectionBtn.addEventListener('click', () => {
      invertSilenceSelection();
    });
  }

  // Duration filter buttons
  document.querySelectorAll('.preview-filters .filter-btn[data-min]').forEach(btn => {
    btn.addEventListener('click', () => {
      const min = parseFloat(btn.dataset.min);
      const max = parseFloat(btn.dataset.max);
      selectByDuration(min, max);
    });
  });

  // Re-run detection button
  if (ui.reRunDetectionBtn) {
    ui.reRunDetectionBtn.addEventListener('click', () => {
      // Hide preview, show options, let user adjust sensitivity
      if (ui.silencePreview) ui.silencePreview.style.display = 'none';
      if (ui.silenceOptions) ui.silenceOptions.classList.remove('collapsed');
      if (ui.silenceOptionsToggle) ui.silenceOptionsToggle.classList.add('expanded');
      showEmptyState();
      setStatus('Adjust sensitivity and click GO again');
    });
  }
}

function selectAllSilences(checked) {
  selectedSilenceIndices.clear();

  if (checked) {
    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
  }

  // Batch update DOM
  document.querySelectorAll('.preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    checkbox.checked = checked;
    const item = checkbox.closest('.preview-item');
    if (checked) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
}

function invertSilenceSelection() {
  const allIndices = new Set(previewSilences.map((_, i) => i));
  const newSelection = new Set([...allIndices].filter(i => !selectedSilenceIndices.has(i)));
  selectedSilenceIndices = newSelection;

  // Update DOM
  document.querySelectorAll('.preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    const isSelected = selectedSilenceIndices.has(index);
    checkbox.checked = isSelected;
    const item = checkbox.closest('.preview-item');
    if (isSelected) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
}

function selectByDuration(minSec, maxSec) {
  selectedSilenceIndices.clear();

  previewSilences.forEach((silence, index) => {
    const duration = silence.end - silence.start;
    if (duration >= minSec && duration < maxSec) {
      selectedSilenceIndices.add(index);
    }
  });

  // Update DOM
  document.querySelectorAll('.preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    const isSelected = selectedSilenceIndices.has(index);
    checkbox.checked = isSelected;
    const item = checkbox.closest('.preview-item');
    if (isSelected) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
  setStatus(`Selected ${selectedSilenceIndices.size} silences (${minSec}s - ${maxSec}s)`);
}

function cancelSilencePreview() {
  // Keep silences available for Razor if detected
  const hadSilences = previewSilences.length > 0;

  previewSilences = [];
  selectedSilenceIndices.clear();
  showEmptyState();
  setStatus('Preview cancelled');

  // Show Razor section if silences were detected
  if (hadSilences && ui.advancedSection) {
    ui.advancedSection.classList.remove('hidden');
  }
}

async function applySelectedSilences() {
  if (selectedSilenceIndices.size === 0) {
    setStatus('No silences selected');
    return;
  }

  // Get selected silences
  const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));

  // Update global silences for the apply function
  setCurrentSilences(selectedSilences);

  showProgress('Applying changes...');

  // Apply to timeline
  const result = await removeSilencesFromTimeline();

  // Hide preview
  if (ui.silencePreview) ui.silencePreview.style.display = 'none';

  // Show results
  showSilenceResults({
    count: selectedSilences.length,
    timeSaved: selectedSilences.reduce((sum, s) => sum + (s.end - s.start), 0),
    clipsModified: result
  });

  // Show advanced section
  if (ui.advancedSection) ui.advancedSection.classList.remove('hidden');

  setStatus(`Removed ${selectedSilences.length} silence(s) - ${result} clip(s) modified`);

  // Refresh credits (await to prevent race conditions)
  try {
    await refreshCredits();
  } catch (err) {
    console.warn('[SPLICE] Credits refresh failed:', err);
  }

  // Clear preview state
  previewSilences = [];
  selectedSilenceIndices.clear();
}

// ============================================================================
// TAKES PREVIEW
// ============================================================================
function showTakesPreview(takes, transcript) {
  previewTakes = takes;
  selectedTakeIndices = new Set(takes.map((_, i) => i));

  // Store transcript
  window.currentTranscript = transcript;

  hideAllViews();

  // Update summary
  if (ui.takesPreviewCount) ui.takesPreviewCount.textContent = takes.length;
  if (ui.selectedTakesCount) ui.selectedTakesCount.textContent = takes.length;

  // Build preview list using DocumentFragment
  const fragment = document.createDocumentFragment();
  takes.forEach((take, index) => {
    const div = document.createElement('div');
    div.className = 'preview-item' + (take.isBest ? ' best' : '');
    div.dataset.index = index;
    const textPreview = take.text?.substring(0, 60) || '';
    div.innerHTML = `
      <input type="checkbox" class="preview-item-check" checked data-index="${index}">
      <div class="preview-item-info">
        <div class="preview-item-time">Take ${index + 1}: ${formatTime(take.startTime)} - ${formatTime(take.endTime)}${take.isBest ? ' *' : ''}</div>
        <div class="preview-item-duration">${textPreview}${take.text?.length > 60 ? '...' : ''}</div>
      </div>
      <button class="preview-item-seek" data-time="${take.startTime}" title="Seek to this take">&gt;</button>
    `;
    fragment.appendChild(div);
  });

  if (ui.takesPreviewList) {
    ui.takesPreviewList.textContent = '';
    ui.takesPreviewList.appendChild(fragment);
  }

  if (ui.selectAllTakes) ui.selectAllTakes.checked = true;
  updateTakesApplyButton();

  if (ui.takesPreview) ui.takesPreview.style.display = 'block';
}

function initTakesPreviewHandlers() {
  // Event delegation for takes preview
  if (ui.takesPreviewList) {
    ui.takesPreviewList.addEventListener('change', (e) => {
      if (e.target.classList.contains('preview-item-check')) {
        const index = parseInt(e.target.dataset.index);
        const item = e.target.closest('.preview-item');

        if (e.target.checked) {
          selectedTakeIndices.add(index);
          item?.classList.remove('excluded');
        } else {
          selectedTakeIndices.delete(index);
          item?.classList.add('excluded');
        }
        updateSelectionCounts();
        updateTakesApplyButton();
      }
    });

    ui.takesPreviewList.addEventListener('click', async (e) => {
      if (e.target.classList.contains('preview-item-seek')) {
        e.stopPropagation();
        const btn = e.target;
        const time = parseFloat(btn.dataset.time);

        btn.classList.add('loading');
        btn.textContent = '...';

        try {
          await seekToTime(time);
        } finally {
          btn.classList.remove('loading');
          btn.textContent = '>';
        }
      }
    });
  }

  // Apply takes button
  if (ui.applyTakesPreviewBtn) {
    ui.applyTakesPreviewBtn.addEventListener('click', async () => {
      if (isOperationInProgress) return;
      isOperationInProgress = true;
      ui.applyTakesPreviewBtn.disabled = true;

      try {
        await applySelectedTakes();
      } catch (err) {
        setStatus('Error: ' + err.message);
      } finally {
        ui.applyTakesPreviewBtn.disabled = false;
        isOperationInProgress = false;
      }
    });
  }

  // Cancel takes preview button
  if (ui.cancelTakesPreviewBtn) {
    ui.cancelTakesPreviewBtn.addEventListener('click', () => {
      previewTakes = [];
      selectedTakeIndices.clear();
      showEmptyState();
      setStatus('Preview cancelled');
    });
  }

  // Select all takes
  if (ui.selectAllTakes) {
    ui.selectAllTakes.addEventListener('change', (e) => {
      selectAllTakes(e.target.checked);
    });
  }
}

function selectAllTakes(checked) {
  selectedTakeIndices.clear();

  if (checked) {
    previewTakes.forEach((_, i) => selectedTakeIndices.add(i));
  }

  document.querySelectorAll('#takesPreviewList .preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    checkbox.checked = checked;
    const item = checkbox.closest('.preview-item');
    if (checked) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
  updateTakesApplyButton();
}

async function applySelectedTakes() {
  if (selectedTakeIndices.size === 0) {
    setStatus('No takes selected');
    return;
  }

  const selectedTakes = previewTakes.filter((_, i) => selectedTakeIndices.has(i));

  // Mark selected takes as best
  selectedTakes.forEach(take => {
    take.userMarkedBest = true;
  });

  // Store for legacy workflow
  window.currentTakes = selectedTakes;

  showProgress('Applying takes...');

  // Apply to timeline (keep selected, remove others)
  try {
    await applyBestTakes();
  } catch (err) {
    console.error('[SPLICE] Apply takes error:', err);
  }

  // Hide preview, show results
  if (ui.takesPreview) ui.takesPreview.style.display = 'none';
  showTakesResults(selectedTakes, window.currentTranscript);

  setStatus(`Kept ${selectedTakes.length} take(s)`);

  // Refresh credits
  try {
    await refreshCredits();
  } catch (err) {
    console.warn('[SPLICE] Credits refresh failed:', err);
  }

  previewTakes = [];
  selectedTakeIndices.clear();
}

function updateTakesApplyButton() {
  if (ui.applyTakesPreviewBtn) {
    const count = selectedTakeIndices.size;
    ui.applyTakesPreviewBtn.disabled = count === 0;
    ui.applyTakesPreviewBtn.textContent = count === 0 ? 'Select takes' : `Keep ${count} Selected`;
  }
}

// ============================================================================
// UI HELPERS
// ============================================================================
function updateApplyButton() {
  if (ui.applyPreviewBtn) {
    const count = selectedSilenceIndices.size;
    ui.applyPreviewBtn.disabled = count === 0;
    ui.applyPreviewBtn.textContent = count === 0 ? 'Select silences' : `Apply ${count} Selected`;
  }
}

function updateSelectAllCheckbox() {
  if (ui.selectAllSilences) {
    ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length && previewSilences.length > 0;
  }
  if (ui.selectAllTakes) {
    ui.selectAllTakes.checked = selectedTakeIndices.size === previewTakes.length && previewTakes.length > 0;
  }
}

function hideAllViews() {
  if (ui.progressContainer) ui.progressContainer.style.display = 'none';
  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'none';
  if (ui.silenceResults) ui.silenceResults.style.display = 'none';
  if (ui.takesResults) ui.takesResults.style.display = 'none';
  if (ui.silencePreview) ui.silencePreview.style.display = 'none';
  if (ui.takesPreview) ui.takesPreview.style.display = 'none';
}

function showProgress(message) {
  hideAllViews();
  if (ui.progressContainer) ui.progressContainer.style.display = 'block';
  if (ui.progressText) ui.progressText.textContent = message;
}

function showEmptyState() {
  hideAllViews();
  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'block';
  if (ui.advancedSection) ui.advancedSection.classList.add('hidden');
}

function showSilenceResults({ count, timeSaved, clipsModified }) {
  hideAllViews();

  if (ui.silenceCount) ui.silenceCount.textContent = count;
  if (ui.timeSaved) ui.timeSaved.textContent = timeSaved.toFixed(1) + 's';
  if (ui.clipsModified) ui.clipsModified.textContent = clipsModified;

  if (ui.silenceResults) ui.silenceResults.style.display = 'block';
}

function showTakesResults(takes, transcript) {
  hideAllViews();

  window.currentTakes = takes;

  if (ui.takesList) {
    ui.takesList.innerHTML = takes.map((take, index) => `
      <div class="take-item ${take.userMarkedBest || take.isBest ? 'best' : ''}" data-index="${index}">
        <div class="take-header">
          <span class="take-label">Take ${index + 1}</span>
          <span class="take-star">${take.userMarkedBest || take.isBest ? '*' : 'o'}</span>
        </div>
        <div class="take-time">${formatTime(take.startTime)} - ${formatTime(take.endTime)}</div>
        <div class="take-text">${take.text?.substring(0, 80) || ''}${take.text?.length > 80 ? '...' : ''}</div>
      </div>
    `).join('');

    // Add click handlers for toggling best
    ui.takesList.querySelectorAll('.take-item').forEach(item => {
      item.addEventListener('click', () => {
        const index = parseInt(item.dataset.index);
        const take = takes[index];
        take.userMarkedBest = !take.userMarkedBest;
        item.classList.toggle('best');
        item.querySelector('.take-star').textContent = take.userMarkedBest ? '*' : 'o';
      });
    });
  }

  if (ui.takesResults) ui.takesResults.style.display = 'block';
}

function formatTime(seconds) {
  if (typeof seconds !== 'number' || isNaN(seconds)) return '0:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function setStatus(message) {
  if (ui.status) ui.status.textContent = message;
}

// ============================================================================
// UNDO HANDLERS
// ============================================================================
function initUndoHandlers() {
  if (ui.undoBtn) {
    ui.undoBtn.addEventListener('click', () => {
      try {
        ppro.app.executeCommand('Edit.Undo');
        showEmptyState();
        setStatus('Changes undone');
      } catch (e) {
        setStatus('Undo failed - use Cmd+Z');
      }
    });
  }

  if (ui.undoTakesBtn) {
    ui.undoTakesBtn.addEventListener('click', () => {
      try {
        ppro.app.executeCommand('Edit.Undo');
        showEmptyState();
        setStatus('Changes undone');
      } catch (e) {
        setStatus('Undo failed - use Cmd+Z');
      }
    });
  }

  if (ui.keepBestBtn) {
    ui.keepBestBtn.addEventListener('click', async () => {
      if (isOperationInProgress) return;
      isOperationInProgress = true;

      try {
        await applyBestTakes();
        setStatus('Kept best takes only');
      } catch (e) {
        setStatus('Error applying takes: ' + e.message);
      } finally {
        isOperationInProgress = false;
      }
    });
  }

  if (ui.labelAllBtn) {
    ui.labelAllBtn.addEventListener('click', async () => {
      if (isOperationInProgress) return;
      isOperationInProgress = true;

      try {
        await labelTakesOnTimeline();
        setStatus('Takes labeled on timeline');
      } catch (e) {
        setStatus('Error labeling takes: ' + e.message);
      } finally {
        isOperationInProgress = false;
      }
    });
  }
}

// ============================================================================
// TIMELINE SEEK (with proper error handling)
// ============================================================================
async function seekToTime(seconds) {
  // Validate input
  if (typeof seconds !== 'number' || isNaN(seconds) || !isFinite(seconds)) {
    setStatus('Invalid seek time');
    return;
  }

  if (seconds < 0) {
    seconds = 0;
  }

  try {
    const context = await getActiveSequence();
    if (!context) {
      setStatus('No sequence available');
      return;
    }

    const { sequence } = context;
    const ticks = Math.floor(seconds * TICKS_PER_SECOND);

    await sequence.setPlayerPosition(ticks);
    setStatus(`Seeked to ${formatTime(seconds)}`);
  } catch (err) {
    console.error('[SPLICE] Seek error:', err);
    setStatus('Seek failed: ' + (err.message || 'Unknown error'));
  }
}

// ============================================================================
// AUDIO EXPORT & BACKEND CALLS
// ============================================================================
async function exportAudioInternal() {
  try {
    const context = await getActiveSequence();
    if (!context) {
      throw new Error('No project or sequence open');
    }

    const { sequence } = context;
    const encoderManager = ppro.EncoderManager.getManager();
    if (!encoderManager) {
      throw new Error('EncoderManager not available');
    }

    const result = await encoderManager.exportSequence(
      sequence,
      ppro.EncoderManager.EXPORT_IMMEDIATELY,
      WAV_PATH,
      WAV_PRESET_PATH,
      true
    );

    return result;
  } catch (err) {
    console.error('[SPLICE] Export error:', err);
    return false;
  }
}

async function isolateVocals() {
  const response = await fetch(`${BACKEND_URL}/isolate-vocals`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ audioPath: WAV_PATH })
  });

  if (!response.ok) {
    const err = await response.json();
    return { success: false, error: err.error || 'Isolation request failed' };
  }

  return await response.json();
}

async function detectSilences(audioPath, params) {
  const response = await fetch(`${BACKEND_URL}/silences-audio`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      wavPath: audioPath,
      threshold: params.dbThreshold,
      minDuration: params.minDuration,
      padding: params.padding
    })
  });

  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error || 'Silence detection failed');
  }

  const data = await response.json();
  if (!data.success) {
    throw new Error(data.error || 'Silence detection failed');
  }

  // Store silences globally for razor workflow
  currentSilences = data.silences;

  return data.silences;
}

async function transcribeAudio() {
  const response = await fetch(`${BACKEND_URL}/analyze`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ wavPath: WAV_PATH })
  });

  if (!response.ok) {
    const err = await response.json();
    return { success: false, error: err.error || 'Transcription failed' };
  }

  const data = await response.json();
  return {
    success: data.success,
    transcript: data.transcript,
    takes: data.takes,
    error: data.error
  };
}
