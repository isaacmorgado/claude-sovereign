/**
 * SPLICE Plugin Main Entry Point
 *
 * Initializes all functionality when the plugin loads.
 * v3.3 - Unified Take-Aware Workflow with combined preview.
 */

// Initialize Premiere Pro API
const ppro = require('premierepro');

// ============================================================================
// CACHED DOM ELEMENTS (Performance: avoid repeated getElementById calls)
// ============================================================================
const ui = {};

function cacheUIElements() {
  ui.status = document.getElementById('status');

  // Main GO button (unified workflow)
  ui.goBtn = document.getElementById('goBtn');
  ui.optionsToggle = document.getElementById('optionsToggle');
  ui.optionsPanel = document.getElementById('optionsPanel');

  // Sliders and options
  ui.sensitivitySlider = document.getElementById('sensitivitySlider');
  ui.sourceOriginal = document.getElementById('sourceOriginal');
  ui.sourceIsolated = document.getElementById('sourceIsolated');

  // Settings checkboxes
  ui.enableTakesDetection = document.getElementById('enableTakesDetection');
  ui.autoMarkBest = document.getElementById('autoMarkBest');

  // Progress
  ui.progressContainer = document.getElementById('progressContainer');
  ui.progressText = document.getElementById('progressText');
  ui.resultsEmpty = document.getElementById('resultsEmpty');

  // Combined Preview
  ui.combinedPreview = document.getElementById('combinedPreview');
  ui.previewList = document.getElementById('previewList');
  ui.silenceCountDisplay = document.getElementById('silenceCount');
  ui.takeCountDisplay = document.getElementById('takeCount');
  ui.selectedCount = document.getElementById('selectedCount');
  ui.selectAllSilences = document.getElementById('selectAllSilences');
  ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
  ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
  ui.invertSelectionBtn = document.getElementById('invertSelectionBtn');
  ui.reRunDetectionBtn = document.getElementById('reRunDetectionBtn');

  // Results
  ui.silenceResults = document.getElementById('silenceResults');
  ui.resultsCount = document.getElementById('resultsCount');
  ui.timeSaved = document.getElementById('timeSaved');
  ui.clipsModified = document.getElementById('clipsModified');

  // Buttons
  ui.undoBtn = document.getElementById('undoBtn');
  ui.advancedSection = document.getElementById('advancedSection');

  // Settings modal
  ui.settingsBtn = document.getElementById('settingsBtn');
  ui.settingsModal = document.getElementById('settingsModal');
  ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
}

// ============================================================================
// STATE MANAGEMENT
// ============================================================================
let previewSilences = [];         // All detected silences
let safeSilences = [];            // Silences that don't overlap takes (safe to remove)
let protectedSilences = [];       // Silences that overlap takes (protected)
let previewTakes = [];            // Detected takes (for display)
let selectedSilenceIndices = new Set();
let isOperationInProgress = false;
let pendingUIUpdate = null;

// Export preview state for other modules (Razor integration)
window.splicePreviewState = {
  getSelectedSilences: () => safeSilences.filter((_, i) => selectedSilenceIndices.has(i)),
  getSelectedTakes: () => previewTakes,
  hasPreview: () => safeSilences.length > 0 || previewTakes.length > 0
};

// ============================================================================
// INITIALIZATION
// ============================================================================
document.addEventListener('DOMContentLoaded', () => {
  // Cache all DOM elements first
  cacheUIElements();

  // Settings & UI
  initSettingsUI();
  initSettingsModal();
  initOptionsToggles();
  initHelpButton();

  // Credits display
  initCredits();

  // Unified workflow (silences + takes)
  initUnifiedWorkflow();

  // Preview handlers (event delegation)
  initPreviewHandlers();

  // Undo handlers
  initUndoHandlers();

  // Keyboard shortcuts
  initKeyboardShortcuts();

  // Advanced features (Razor)
  initSlice9();

  console.log('[SPLICE] Plugin initialized v3.3 (Unified Take-Aware Workflow)');
});

// ============================================================================
// DEBOUNCED UI UPDATES (Performance: batch DOM updates)
// ============================================================================
function scheduleUIUpdate(callback) {
  if (pendingUIUpdate) {
    cancelAnimationFrame(pendingUIUpdate);
  }
  pendingUIUpdate = requestAnimationFrame(() => {
    callback();
    pendingUIUpdate = null;
  });
}

function updateSelectionCounts() {
  scheduleUIUpdate(() => {
    if (ui.selectedCount) {
      ui.selectedCount.textContent = selectedSilenceIndices.size;
    }
    updateApplyButton();
    updateSelectAllCheckbox();
  });
}

// ============================================================================
// KEYBOARD SHORTCUTS
// ============================================================================
function initKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Only handle when combined preview is visible
    const previewVisible = ui.combinedPreview?.style.display !== 'none' &&
                           ui.combinedPreview?.style.display !== '';

    if (!previewVisible) return;

    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const cmdKey = isMac ? e.metaKey : e.ctrlKey;

    // Enter - Apply selected
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (selectedSilenceIndices.size > 0) {
        ui.applyPreviewBtn?.click();
      }
    }

    // Escape - Cancel
    if (e.key === 'Escape') {
      e.preventDefault();
      ui.cancelPreviewBtn?.click();
    }

    // Cmd/Ctrl+A - Select all
    if (e.key === 'a' && cmdKey) {
      e.preventDefault();
      if (ui.selectAllSilences) {
        ui.selectAllSilences.checked = true;
        selectAllSilences(true);
      }
    }

    // Cmd/Ctrl+D - Deselect all
    if (e.key === 'd' && cmdKey) {
      e.preventDefault();
      if (ui.selectAllSilences) {
        ui.selectAllSilences.checked = false;
        selectAllSilences(false);
      }
    }

    // Cmd/Ctrl+I - Invert selection
    if (e.key === 'i' && cmdKey) {
      e.preventDefault();
      invertSilenceSelection();
    }
  });
}

// ============================================================================
// UNIFIED WORKFLOW (Silence Detection + Takes Detection)
// ============================================================================
function initUnifiedWorkflow() {
  if (!ui.goBtn) return;

  ui.goBtn.addEventListener('click', async () => {
    // Prevent double-click
    if (isOperationInProgress) {
      setStatus('Operation in progress...');
      return;
    }

    isOperationInProgress = true;
    ui.goBtn.disabled = true;

    try {
      showProgress('Preparing audio...');

      // Step 1: Export audio
      const exportSuccess = await exportAudioInternal();
      if (!exportSuccess) {
        throw new Error('Audio export failed');
      }

      // Step 2: Get settings
      const sensitivity = parseInt(ui.sensitivitySlider?.value || 50);
      const useIsolated = ui.sourceIsolated?.checked ?? false;
      const detectTakes = ui.enableTakesDetection?.checked ?? true;

      // Step 3: Vocal isolation if needed
      let audioPath = WAV_PATH;
      if (useIsolated) {
        showProgress('Isolating vocals (this may take a few minutes)...');
        const isolateResult = await isolateVocals();
        if (isolateResult.success) {
          audioPath = isolateResult.outputPath;
        } else {
          throw new Error(isolateResult.error || 'Vocal isolation failed');
        }
      }

      // Step 4: Run detection (parallel if takes enabled)
      const params = mapSensitivity(sensitivity);
      let silences = [];
      let takes = [];

      if (detectTakes) {
        // Parallel detection for performance
        showProgress('Detecting silences and analyzing takes...');
        const [silenceResult, transcriptResult] = await Promise.all([
          detectSilences(audioPath, params),
          transcribeAudio()
        ]);

        silences = silenceResult;

        // Extract takes from transcript result
        if (transcriptResult.success && transcriptResult.takes) {
          if (transcriptResult.takes.takes) {
            takes = transcriptResult.takes.takes;
          } else if (Array.isArray(transcriptResult.takes)) {
            takes = transcriptResult.takes;
          }
        }

        // Store transcript for reference
        window.currentTranscript = transcriptResult.transcript;
      } else {
        // Just detect silences
        showProgress('Detecting silences...');
        silences = await detectSilences(audioPath, params);
      }

      if (silences.length === 0) {
        showEmptyState();
        setStatus('No silences detected. Try increasing sensitivity.');
        return;
      }

      // Step 5: Filter silences by takes (protect speech)
      const filtered = filterSilencesByTakes(silences, takes);

      // Step 6: Show combined preview
      showCombinedPreview(filtered.safe, filtered.protected, takes);

      const statusMsg = takes.length > 0
        ? `Found ${silences.length} silences, ${filtered.protected.length} protected by ${takes.length} takes`
        : `Found ${silences.length} silence(s) - review and apply`;
      setStatus(statusMsg);

    } catch (err) {
      showEmptyState();
      setStatus('Error: ' + err.message);
      console.error('[SPLICE] Unified workflow error:', err);
    } finally {
      isOperationInProgress = false;
      ui.goBtn.disabled = false;
    }
  });
}

// ============================================================================
// TAKE-AWARE SILENCE FILTERING
// ============================================================================
/**
 * Filter silences to protect those that overlap with takes (speech segments).
 * Returns { safe: [], protected: [] }
 */
function filterSilencesByTakes(silences, takes) {
  if (!takes || takes.length === 0) {
    // No takes = all silences are safe to remove
    return { safe: silences, protected: [] };
  }

  const safe = [];
  const protected_ = [];

  silences.forEach(silence => {
    // Check if this silence overlaps with any take
    const overlaps = takes.some(take => {
      const takeStart = take.startTime || take.start;
      const takeEnd = take.endTime || take.end;
      // Overlap exists if silence starts before take ends AND silence ends after take starts
      return silence.start < takeEnd && silence.end > takeStart;
    });

    if (overlaps) {
      protected_.push(silence);
    } else {
      safe.push(silence);
    }
  });

  console.log(`[SPLICE] Filtered silences: ${safe.length} safe, ${protected_.length} protected`);
  return { safe, protected: protected_ };
}

// ============================================================================
// COMBINED PREVIEW (Silences + Takes with colored markers)
// ============================================================================
/**
 * Show combined preview with:
 * - Red markers: silences safe to remove
 * - Yellow markers: silences protected by takes (won't be removed)
 * - Blue markers: takes (for reference)
 */
function showCombinedPreview(safeToRemove, protectedSilences, takes) {
  // Update global state
  safeSilences = safeToRemove;
  previewSilences = [...safeToRemove, ...protectedSilences];
  previewTakes = takes;
  selectedSilenceIndices = new Set(safeToRemove.map((_, i) => i));

  // Hide other views
  hideAllViews();

  // Update summary counts
  if (ui.silenceCountDisplay) ui.silenceCountDisplay.textContent = safeToRemove.length;
  if (ui.takeCountDisplay) ui.takeCountDisplay.textContent = takes.length;
  if (ui.selectedCount) ui.selectedCount.textContent = safeToRemove.length;

  // Build combined items list (sorted by time)
  const items = [
    ...safeToRemove.map((s, i) => ({ type: 'silence', index: i, start: s.start, end: s.end, data: s })),
    ...protectedSilences.map(s => ({ type: 'protected', start: s.start, end: s.end, data: s })),
    ...takes.map(t => ({ type: 'take', start: t.startTime || t.start, end: t.endTime || t.end, data: t }))
  ].sort((a, b) => a.start - b.start);

  // Build preview list using DocumentFragment
  const fragment = document.createDocumentFragment();

  items.forEach((item) => {
    const duration = item.end - item.start;
    const div = document.createElement('div');

    if (item.type === 'silence') {
      // Safe to remove - red marker with checkbox
      div.className = 'preview-item silence-marker';
      div.dataset.index = item.index;
      div.innerHTML = `
        <input type="checkbox" class="preview-item-check" checked data-index="${item.index}">
        <div class="preview-item-info">
          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
          <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
        </div>
        <button class="preview-item-seek" data-time="${item.start}" title="Seek to this silence">&gt;</button>
      `;
    } else if (item.type === 'protected') {
      // Protected by take - yellow marker, no checkbox
      div.className = 'preview-item protected-silence';
      div.innerHTML = `
        <div style="width: 20px; margin-right: 10px;"></div>
        <div class="preview-item-info">
          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
          <div class="preview-item-duration">${duration.toFixed(2)}s (overlaps speech)</div>
        </div>
        <button class="preview-item-seek" data-time="${item.start}" title="Seek">&gt;</button>
      `;
    } else if (item.type === 'take') {
      // Take (speech segment) - blue marker, no checkbox
      div.className = 'preview-item take-marker';
      const textPreview = item.data.text?.substring(0, 40) || 'Speech segment';
      div.innerHTML = `
        <div style="width: 20px; margin-right: 10px;"></div>
        <div class="preview-item-info">
          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
          <div class="preview-item-duration">${textPreview}${item.data.text?.length > 40 ? '...' : ''}</div>
        </div>
        <button class="preview-item-seek" data-time="${item.start}" title="Seek to take">&gt;</button>
      `;
    }

    fragment.appendChild(div);
  });

  if (ui.previewList) {
    ui.previewList.textContent = '';
    ui.previewList.appendChild(fragment);
  }

  // Reset UI state
  if (ui.selectAllSilences) ui.selectAllSilences.checked = true;
  updateApplyButton();

  // Show combined preview section
  if (ui.combinedPreview) ui.combinedPreview.style.display = 'block';
}

function initPreviewHandlers() {
  // EVENT DELEGATION: Single listener on parent instead of many on children
  if (ui.previewList) {
    // Handle checkbox changes
    ui.previewList.addEventListener('change', (e) => {
      if (e.target.classList.contains('preview-item-check')) {
        const index = parseInt(e.target.dataset.index);
        const item = e.target.closest('.preview-item');

        if (e.target.checked) {
          selectedSilenceIndices.add(index);
          item?.classList.remove('excluded');
        } else {
          selectedSilenceIndices.delete(index);
          item?.classList.add('excluded');
        }
        updateSelectionCounts();
      }
    });

    // Handle seek button clicks
    ui.previewList.addEventListener('click', async (e) => {
      if (e.target.classList.contains('preview-item-seek')) {
        e.stopPropagation();
        const btn = e.target;
        const time = parseFloat(btn.dataset.time);

        // Show loading state
        btn.classList.add('loading');
        btn.textContent = '...';

        try {
          await seekToTime(time);
        } finally {
          btn.classList.remove('loading');
          btn.textContent = '>';
        }
      }
    });
  }

  // Apply button
  if (ui.applyPreviewBtn) {
    ui.applyPreviewBtn.addEventListener('click', async () => {
      if (isOperationInProgress) return;
      isOperationInProgress = true;
      ui.applyPreviewBtn.disabled = true;

      const originalText = ui.applyPreviewBtn.textContent;
      ui.applyPreviewBtn.textContent = 'Applying...';

      try {
        await applySelectedSilences();
      } catch (err) {
        setStatus('Error: ' + err.message);
        console.error('[SPLICE] Apply error:', err);
      } finally {
        ui.applyPreviewBtn.textContent = originalText;
        ui.applyPreviewBtn.disabled = false;
        isOperationInProgress = false;
      }
    });
  }

  // Cancel button
  if (ui.cancelPreviewBtn) {
    ui.cancelPreviewBtn.addEventListener('click', () => {
      cancelPreview();
    });
  }

  // Select all checkbox
  if (ui.selectAllSilences) {
    ui.selectAllSilences.addEventListener('change', (e) => {
      selectAllSilences(e.target.checked);
    });
  }

  // Invert selection button
  if (ui.invertSelectionBtn) {
    ui.invertSelectionBtn.addEventListener('click', () => {
      invertSilenceSelection();
    });
  }

  // Duration filter buttons
  document.querySelectorAll('.preview-filters .filter-btn[data-min]').forEach(btn => {
    btn.addEventListener('click', () => {
      const min = parseFloat(btn.dataset.min);
      const max = parseFloat(btn.dataset.max);
      selectByDuration(min, max);
    });
  });

  // Re-run detection button
  if (ui.reRunDetectionBtn) {
    ui.reRunDetectionBtn.addEventListener('click', () => {
      // Hide preview, show options, let user adjust sensitivity
      if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
      if (ui.optionsPanel) ui.optionsPanel.classList.remove('collapsed');
      if (ui.optionsToggle) ui.optionsToggle.classList.add('expanded');
      showEmptyState();
      setStatus('Adjust sensitivity and click GO again');
    });
  }
}

function selectAllSilences(checked) {
  selectedSilenceIndices.clear();

  if (checked) {
    safeSilences.forEach((_, i) => selectedSilenceIndices.add(i));
  }

  // Batch update DOM (only silence-marker items have checkboxes)
  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    checkbox.checked = checked;
    const item = checkbox.closest('.preview-item');
    if (checked) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
}

function invertSilenceSelection() {
  const allIndices = new Set(safeSilences.map((_, i) => i));
  const newSelection = new Set([...allIndices].filter(i => !selectedSilenceIndices.has(i)));
  selectedSilenceIndices = newSelection;

  // Update DOM
  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    const isSelected = selectedSilenceIndices.has(index);
    checkbox.checked = isSelected;
    const item = checkbox.closest('.preview-item');
    if (isSelected) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
}

function selectByDuration(minSec, maxSec) {
  selectedSilenceIndices.clear();

  safeSilences.forEach((silence, index) => {
    const duration = silence.end - silence.start;
    if (duration >= minSec && duration < maxSec) {
      selectedSilenceIndices.add(index);
    }
  });

  // Update DOM
  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
    const index = parseInt(checkbox.dataset.index);
    const isSelected = selectedSilenceIndices.has(index);
    checkbox.checked = isSelected;
    const item = checkbox.closest('.preview-item');
    if (isSelected) {
      item?.classList.remove('excluded');
    } else {
      item?.classList.add('excluded');
    }
  });

  updateSelectionCounts();
  setStatus(`Selected ${selectedSilenceIndices.size} silences (${minSec}s - ${maxSec}s)`);
}

function cancelPreview() {
  // Keep silences available for Razor if detected
  const hadSilences = safeSilences.length > 0;

  previewSilences = [];
  safeSilences = [];
  protectedSilences = [];
  previewTakes = [];
  selectedSilenceIndices.clear();
  showEmptyState();
  setStatus('Preview cancelled');

  // Show Razor section if silences were detected
  if (hadSilences && ui.advancedSection) {
    ui.advancedSection.classList.remove('hidden');
  }
}

async function applySelectedSilences() {
  if (selectedSilenceIndices.size === 0) {
    setStatus('No silences selected');
    return;
  }

  // Get selected silences from safe silences only
  const selectedSilences = safeSilences.filter((_, i) => selectedSilenceIndices.has(i));

  // Update global silences for the apply function
  setCurrentSilences(selectedSilences);

  showProgress('Applying changes...');

  // Apply to timeline
  const result = await removeSilencesFromTimeline();

  // Hide preview
  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';

  // Show results
  showSilenceResults({
    count: selectedSilences.length,
    timeSaved: selectedSilences.reduce((sum, s) => sum + (s.end - s.start), 0),
    clipsModified: result
  });

  // Show advanced section
  if (ui.advancedSection) ui.advancedSection.classList.remove('hidden');

  setStatus(`Removed ${selectedSilences.length} silence(s) - ${result} clip(s) modified`);

  // Refresh credits (await to prevent race conditions)
  try {
    await refreshCredits();
  } catch (err) {
    console.warn('[SPLICE] Credits refresh failed:', err);
  }

  // Clear preview state
  previewSilences = [];
  safeSilences = [];
  protectedSilences = [];
  previewTakes = [];
  selectedSilenceIndices.clear();
}

// ============================================================================
// UI HELPERS
// ============================================================================
function updateApplyButton() {
  if (ui.applyPreviewBtn) {
    const count = selectedSilenceIndices.size;
    ui.applyPreviewBtn.disabled = count === 0;
    ui.applyPreviewBtn.textContent = count === 0 ? 'Select silences' : `Apply ${count} Selected`;
  }
}

function updateSelectAllCheckbox() {
  if (ui.selectAllSilences) {
    ui.selectAllSilences.checked = selectedSilenceIndices.size === safeSilences.length && safeSilences.length > 0;
  }
}

function hideAllViews() {
  if (ui.progressContainer) ui.progressContainer.style.display = 'none';
  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'none';
  if (ui.silenceResults) ui.silenceResults.style.display = 'none';
  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
}

function showProgress(message) {
  hideAllViews();
  if (ui.progressContainer) ui.progressContainer.style.display = 'block';
  if (ui.progressText) ui.progressText.textContent = message;
}

function showEmptyState() {
  hideAllViews();
  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'block';
  if (ui.advancedSection) ui.advancedSection.classList.add('hidden');
}

function showSilenceResults({ count, timeSaved, clipsModified }) {
  hideAllViews();

  // Update the results display
  if (ui.resultsCount) ui.resultsCount.textContent = count;
  if (ui.timeSaved) ui.timeSaved.textContent = timeSaved.toFixed(1) + 's';
  if (ui.clipsModified) ui.clipsModified.textContent = clipsModified;

  if (ui.silenceResults) ui.silenceResults.style.display = 'block';
}

function formatTime(seconds) {
  if (typeof seconds !== 'number' || isNaN(seconds)) return '0:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function setStatus(message) {
  if (ui.status) ui.status.textContent = message;
}

// ============================================================================
// UNDO HANDLERS
// ============================================================================
function initUndoHandlers() {
  if (ui.undoBtn) {
    ui.undoBtn.addEventListener('click', () => {
      try {
        ppro.app.executeCommand('Edit.Undo');
        showEmptyState();
        setStatus('Changes undone');
      } catch (e) {
        setStatus('Undo failed - use Cmd+Z');
      }
    });
  }
}

// ============================================================================
// TIMELINE SEEK (with proper error handling)
// ============================================================================
async function seekToTime(seconds) {
  // Validate input
  if (typeof seconds !== 'number' || isNaN(seconds) || !isFinite(seconds)) {
    setStatus('Invalid seek time');
    return;
  }

  if (seconds < 0) {
    seconds = 0;
  }

  try {
    const context = await getActiveSequence();
    if (!context) {
      setStatus('No sequence available');
      return;
    }

    const { sequence } = context;
    const ticks = Math.floor(seconds * TICKS_PER_SECOND);

    await sequence.setPlayerPosition(ticks);
    setStatus(`Seeked to ${formatTime(seconds)}`);
  } catch (err) {
    console.error('[SPLICE] Seek error:', err);
    setStatus('Seek failed: ' + (err.message || 'Unknown error'));
  }
}

// ============================================================================
// AUDIO EXPORT & BACKEND CALLS
// ============================================================================
async function exportAudioInternal() {
  try {
    const context = await getActiveSequence();
    if (!context) {
      throw new Error('No project or sequence open');
    }

    const { sequence } = context;
    const encoderManager = ppro.EncoderManager.getManager();
    if (!encoderManager) {
      throw new Error('EncoderManager not available');
    }

    const result = await encoderManager.exportSequence(
      sequence,
      ppro.EncoderManager.EXPORT_IMMEDIATELY,
      WAV_PATH,
      WAV_PRESET_PATH,
      true
    );

    return result;
  } catch (err) {
    console.error('[SPLICE] Export error:', err);
    return false;
  }
}

async function isolateVocals() {
  const response = await fetch(`${BACKEND_URL}/isolate-vocals`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ audioPath: WAV_PATH })
  });

  if (!response.ok) {
    const err = await response.json();
    return { success: false, error: err.error || 'Isolation request failed' };
  }

  return await response.json();
}

async function detectSilences(audioPath, params) {
  const response = await fetch(`${BACKEND_URL}/silences-audio`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      wavPath: audioPath,
      threshold: params.dbThreshold,
      minDuration: params.minDuration,
      padding: params.padding
    })
  });

  if (!response.ok) {
    const err = await response.json();
    throw new Error(err.error || 'Silence detection failed');
  }

  const data = await response.json();
  if (!data.success) {
    throw new Error(data.error || 'Silence detection failed');
  }

  // Store silences globally for razor workflow
  currentSilences = data.silences;

  return data.silences;
}

async function transcribeAudio() {
  const response = await fetch(`${BACKEND_URL}/analyze`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ wavPath: WAV_PATH })
  });

  if (!response.ok) {
    const err = await response.json();
    return { success: false, error: err.error || 'Transcription failed' };
  }

  const data = await response.json();
  return {
    success: data.success,
    transcript: data.transcript,
    takes: data.takes,
    error: data.error
  };
}
