/**
 * SPLICE Backend Server
 *
 * Main entry point for the SPLICE backend API.
 * Orchestrates the audio analysis pipeline.
 *
 * Slices:
 * - Slice 4: Transcription (services/transcription.js)
 * - Slice 5: Take Detection (services/takeDetection.js)
 */

require('dotenv').config();

const express = require('express');
const cors = require('cors');
const fs = require('fs');
const https = require('https');
const http = require('http');
const path = require('path');

// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;

// Import slice services
const { transcribeAudio } = require('./services/transcription');
const { detectTakes } = require('./services/takeDetection');
const { detectSilences } = require('./services/silenceDetection');
const { detectAudioSilences, isFFprobeInstalled, getAudioDuration } = require('./services/ffprobeSilence');
const { processXMLFile } = require('./services/xmlProcessor');
const { isolateVocals, isReplicateConfigured } = require('./services/vocalIsolation');

// Usage tracking and billing
const usageTracking = require('./services/usageTracking');
// Rate limiter available for future use
// const { requireCredits } = require('./middleware/rateLimiter');

// Stripe for webhooks
const Stripe = require('stripe');
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// =============================================================================
// Server Configuration
// =============================================================================

const app = express();
const PORT = process.env.PORT || 3847;

// HTTPS certificates (generated by mkcert) - only for local development
let httpsOptions = null;
if (!isProduction) {
  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
  const certPath = path.join(__dirname, 'localhost+1.pem');
  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
    httpsOptions = {
      key: fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath)
    };
  }
}

app.use(cors());

// Helper to determine tier from price ID with logging
function getTierFromPriceId(priceId) {
  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';

  // Log unknown price ID for debugging
  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
  return 'starter';
}

// Stripe webhook needs raw body - must be before express.json()
app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  let event;

  try {
    if (webhookSecret) {
      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
    } else {
      // For testing without webhook secret
      event = JSON.parse(req.body);
      console.warn('[SPLICE] Warning: Processing webhook without signature verification');
    }
  } catch (err) {
    console.error('[SPLICE] Webhook signature verification failed:', err.message);
    return res.status(400).json({ error: 'Webhook signature verification failed' });
  }

  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);

  // Idempotency check - skip if already processed
  if (await usageTracking.isEventProcessed(event.id)) {
    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
    return res.json({ received: true, skipped: true });
  }

  try {
    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated': {
        const subscription = event.data.object;
        const customerId = subscription.customer;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in subscription event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Get tier from price ID
        const priceId = subscription.items?.data?.[0]?.price?.id;
        const tier = getTierFromPriceId(priceId);

        // Update user tier and reset hours
        await usageTracking.updateTier(customerId, tier);
        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        const customerId = subscription.customer;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Downgrade to cancelled (0 hours)
        await usageTracking.updateTier(customerId, 'cancelled');
        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
        break;
      }

      case 'invoice.payment_succeeded': {
        const invoice = event.data.object;
        const customerId = invoice.customer;
        const subscriptionId = invoice.subscription;

        // Validate customerId
        if (!customerId) {
          console.error('[SPLICE] Missing customer ID in invoice event');
          return res.status(400).json({ error: 'Missing customer ID' });
        }

        // Reset hours on successful payment (new billing period)
        if (subscriptionId) {
          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
          const priceId = subscription.items?.data?.[0]?.price?.id;
          const tier = getTierFromPriceId(priceId);

          await usageTracking.resetHours(customerId, tier);
          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);
        }
        break;
      }

      default:
        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
    }

    // Record event as processed (idempotency)
    await usageTracking.recordWebhookEvent(event.id, event.type);

    res.json({ received: true });
  } catch (err) {
    console.error('[SPLICE] Webhook handler error:', err);
    res.status(500).json({ error: err.message });
  }
});

app.use(express.json());

// =============================================================================
// Routes
// =============================================================================

/**
 * GET / - API information
 */
app.get('/', (req, res) => {
  res.json({
    service: 'splice-backend',
    version: '0.3.0',
    endpoints: {
      'GET /': 'This info',
      'GET /health': 'Health check',
      'GET /ffprobe-check': 'Check if FFprobe is installed',
      'GET /replicate-check': 'Check if Replicate API is configured',
      'POST /analyze': 'Analyze WAV file { wavPath }',
      'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',
      'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',
      'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',
      'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',
      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',
      'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',
      'POST /webhooks/stripe': 'Stripe webhook endpoint'
    }
  });
});

/**
 * GET /health - Health check
 */
app.get('/health', (req, res) => {
  res.json({ status: 'ok', service: 'splice-backend' });
});

/**
 * POST /analyze - Main analysis endpoint
 *
 * Pipeline:
 * 1. Validate input (wavPath)
 * 2. Slice 4: Transcribe audio with Groq Whisper
 * 3. Slice 5: Detect takes with GPT-4o-mini
 * 4. Return combined results
 */
app.post('/analyze', async (req, res) => {
  const { wavPath } = req.body;

  // Validate input
  if (!wavPath) {
    return res.status(400).json({ error: 'wavPath is required' });
  }

  if (!fs.existsSync(wavPath)) {
    return res.status(404).json({ error: `File not found: ${wavPath}` });
  }

  console.log(`[SPLICE] Analyzing: ${wavPath}`);

  try {
    // Slice 4 - GPT-4o-mini transcription
    const transcript = await transcribeAudio(wavPath);

    // Slice 5 - GPT-4o-mini take detection
    const takes = await detectTakes(transcript);

    res.json({
      success: true,
      wavPath,
      transcript,
      takes
    });
  } catch (err) {
    console.error('[SPLICE] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * POST /silences - Detect silent gaps in audio
 *
 * Pipeline:
 * 1. Transcribe audio with Whisper (reuses transcription)
 * 2. Analyze gaps between segments
 * 3. Return silence regions
 */
app.post('/silences', async (req, res) => {
  const { wavPath, threshold = 0.5 } = req.body;

  if (!wavPath) {
    return res.status(400).json({ error: 'wavPath is required' });
  }

  if (!fs.existsSync(wavPath)) {
    return res.status(404).json({ error: `File not found: ${wavPath}` });
  }

  console.log(`[SPLICE] Detecting silences: ${wavPath} (threshold: ${threshold}s)`);

  try {
    const transcript = await transcribeAudio(wavPath);
    const silences = detectSilences(transcript.segments, threshold);

    res.json({
      success: true,
      wavPath,
      threshold,
      silences,
      count: silences.length,
      totalSilenceDuration: silences.reduce((sum, s) => sum + s.duration, 0).toFixed(2)
    });
  } catch (err) {
    console.error('[SPLICE] Silence detection error:', err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * POST /silences-audio - Detect silences using FFprobe audio analysis
 *
 * Uses actual audio levels (dB threshold) instead of transcript gaps.
 * More accurate for detecting silence vs background noise.
 */
app.post('/silences-audio', async (req, res) => {
  const {
    wavPath,
    threshold = -30,
    minDuration = 0.5,
    padding = 0.1
  } = req.body;

  if (!wavPath) {
    return res.status(400).json({ error: 'wavPath is required' });
  }

  if (!fs.existsSync(wavPath)) {
    return res.status(404).json({ error: `File not found: ${wavPath}` });
  }

  // Check FFprobe availability
  const ffprobeAvailable = await isFFprobeInstalled();
  if (!ffprobeAvailable) {
    return res.status(500).json({
      error: 'FFprobe not installed. Run: brew install ffmpeg'
    });
  }

  console.log(`[SPLICE] FFprobe silence detection: ${wavPath} (threshold: ${threshold}dB, min: ${minDuration}s)`);

  try {
    const silences = await detectAudioSilences(wavPath, {
      threshold,
      minDuration,
      padding
    });

    const totalDuration = silences.reduce((sum, s) => sum + s.duration, 0);

    res.json({
      success: true,
      wavPath,
      threshold,
      minDuration,
      padding,
      silences,
      count: silences.length,
      totalSilenceDuration: totalDuration.toFixed(2)
    });
  } catch (err) {
    console.error('[SPLICE] FFprobe silence detection error:', err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * POST /process-xml - Process FCP XML to split clips at silences
 *
 * Takes an FCP XML file and silence timestamps, splits clips
 * at silence boundaries, and optionally removes gaps.
 */
app.post('/process-xml', async (req, res) => {
  const {
    xmlPath,
    silences,
    removeGaps = true,
    outputPath = null
  } = req.body;

  if (!xmlPath) {
    return res.status(400).json({ error: 'xmlPath is required' });
  }

  if (!silences || !Array.isArray(silences)) {
    return res.status(400).json({ error: 'silences array is required' });
  }

  if (!fs.existsSync(xmlPath)) {
    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
  }

  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);

  try {
    const result = await processXMLFile(xmlPath, silences, {
      outputPath,
      removeGaps
    });

    res.json({
      success: true,
      inputPath: xmlPath,
      outputPath: result.outputPath,
      stats: result.stats
    });
  } catch (err) {
    console.error('[SPLICE] XML processing error:', err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /ffprobe-check - Check if FFprobe is installed
 */
app.get('/ffprobe-check', async (req, res) => {
  const installed = await isFFprobeInstalled();
  res.json({
    installed,
    message: installed
      ? 'FFprobe is available'
      : 'FFprobe not found. Install with: brew install ffmpeg'
  });
});

/**
 * GET /replicate-check - Check if Replicate API is configured
 */
app.get('/replicate-check', async (req, res) => {
  const configured = isReplicateConfigured();
  res.json({
    configured,
    message: configured
      ? 'Replicate API is configured'
      : 'REPLICATE_API_TOKEN not set. Add to .env file.'
  });
});

/**
 * POST /isolate-vocals - Isolate vocals from audio using Demucs
 *
 * Uses Replicate's Demucs model to separate vocals from background audio.
 * Cost: ~$0.015/min of audio
 *
 * Tier access:
 * - Starter: No access (upgrade required)
 * - Pro: 2 hours included, then $0.08/min overage
 * - Team: 5 hours included, then $0.08/min overage
 */
app.post('/isolate-vocals', async (req, res) => {
  const { audioPath, stem = 'vocals', outputDir = null } = req.body;
  const stripeCustomerId = req.headers['x-stripe-customer-id'];

  if (!audioPath) {
    return res.status(400).json({ error: 'audioPath is required' });
  }

  if (!fs.existsSync(audioPath)) {
    return res.status(404).json({ error: `File not found: ${audioPath}` });
  }

  // Check Replicate configuration
  if (!isReplicateConfigured()) {
    return res.status(500).json({
      error: 'Replicate API not configured. Set REPLICATE_API_TOKEN in .env'
    });
  }

  // Get audio duration for billing
  let audioDurationSeconds = 0;
  try {
    audioDurationSeconds = await getAudioDuration(audioPath);
  } catch (err) {
    console.warn('[SPLICE] Could not get audio duration:', err.message);
  }

  const audioDurationMinutes = audioDurationSeconds / 60;

  // Check isolation access if customer ID provided
  if (stripeCustomerId) {
    const accessCheck = await usageTracking.checkIsolationAccess(stripeCustomerId, audioDurationMinutes);

    if (!accessCheck.allowed) {
      return res.status(403).json({
        error: accessCheck.message,
        reason: accessCheck.reason,
        upgradeRequired: accessCheck.reason === 'upgrade_required'
      });
    }

    console.log(`[SPLICE] Isolation access: ${accessCheck.message}`);
  }

  console.log(`[SPLICE] Isolating vocals: ${audioPath} (${audioDurationMinutes.toFixed(1)} min)`);

  try {
    const result = await isolateVocals(audioPath, {
      stem,
      outputDir: outputDir || undefined
    });

    // Deduct isolation usage if customer ID provided
    let usageInfo = null;
    if (stripeCustomerId) {
      usageInfo = await usageTracking.deductIsolationUsage(
        stripeCustomerId,
        audioDurationSeconds,
        'isolate-vocals'
      );
      console.log(`[SPLICE] Isolation usage deducted: ${audioDurationMinutes.toFixed(1)} min`);
      if (usageInfo.isolationUsed?.overageCost > 0) {
        console.log(`[SPLICE] Overage cost: $${usageInfo.isolationUsed.overageCost.toFixed(2)}`);
      }
    }

    res.json({
      success: true,
      inputPath: audioPath,
      outputPath: result.outputPath,
      stem: result.stem,
      processingTime: result.processingTime,
      availableStems: result.allStems,
      audioDurationMinutes,
      usage: usageInfo ? {
        isolationHoursRemaining: usageInfo.isolationHoursRemaining,
        overageCost: usageInfo.isolationUsed?.overageCost || 0
      } : null
    });
  } catch (err) {
    console.error('[SPLICE] Vocal isolation error:', err);
    res.status(500).json({ error: err.message });
  }
});

// =============================================================================
// Billing & Credits Routes
// =============================================================================

/**
 * GET /credits - Get user's credit balance
 *
 * Requires x-stripe-customer-id header
 */
app.get('/credits', async (req, res) => {
  const stripeCustomerId = req.headers['x-stripe-customer-id'];

  if (!stripeCustomerId) {
    return res.status(401).json({
      error: 'Authentication required',
      message: 'Missing x-stripe-customer-id header'
    });
  }

  try {
    const balance = await usageTracking.getBalance(stripeCustomerId);
    res.json({
      success: true,
      ...balance
    });
  } catch (err) {
    console.error('[SPLICE] Credits error:', err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /usage-history - Get user's usage history
 */
app.get('/usage-history', async (req, res) => {
  const stripeCustomerId = req.headers['x-stripe-customer-id'];

  if (!stripeCustomerId) {
    return res.status(401).json({
      error: 'Authentication required',
      message: 'Missing x-stripe-customer-id header'
    });
  }

  try {
    const history = await usageTracking.getUsageHistory(stripeCustomerId);
    res.json({
      success: true,
      history
    });
  } catch (err) {
    console.error('[SPLICE] Usage history error:', err);
    res.status(500).json({ error: err.message });
  }
});

// =============================================================================
// Start Server
// =============================================================================

// Initialize database and start server
async function startServer() {
  try {
    await usageTracking.initDatabase();
    console.log('[SPLICE] Database initialized');

    if (isProduction || !httpsOptions) {
      // Production: Railway provides TLS termination, use HTTP
      http.createServer(app).listen(PORT, () => {
        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
      });
    } else {
      // Development: Use HTTPS with local certificates
      https.createServer(httpsOptions, app).listen(PORT, () => {
        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
      });
    }
  } catch (err) {
    console.error('[SPLICE] Failed to start server:', err);
    process.exit(1);
  }
}

startServer();
