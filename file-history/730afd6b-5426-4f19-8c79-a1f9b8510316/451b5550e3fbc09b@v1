/**
 * E2E Test: Builder UXP Runtime Compatibility
 *
 * Static analysis tests that verify builder.js is UXP-compatible:
 * - Uses correct UXP/ppro API patterns
 * - Has proper fallbacks for undefined constants
 * - Uses TickTime.createWithSeconds (not TICKS_PER_SECOND math)
 * - Uses executeTransaction for batch operations
 * - Uses lockedAccess for thread safety
 */

const assert = require('assert');
const fs = require('fs');

let passed = 0;
let failed = 0;

function test(name, fn) {
  try {
    fn();
    console.log(`✓ ${name}`);
    passed++;
  } catch (err) {
    console.log(`✗ ${name}`);
    console.log(`  Error: ${err.message}`);
    failed++;
  }
}

// ============================================================================
// Static Code Analysis Tests
// ============================================================================

console.log('\n=== Builder UXP Runtime Compatibility Tests ===\n');

// Read builder.js
const builderCode = fs.readFileSync(__dirname + '/../../splice-plugin/js/builder.js', 'utf8');

// === API Import Tests ===
test('builder.js imports premierepro', () => {
  assert.ok(builderCode.includes("require('premierepro')"), 'Missing premierepro import');
});

// === Constant Fallbacks ===
test('ProjectItemType has fallback for undefined Constants', () => {
  assert.ok(builderCode.includes('pproBuilder?.Constants?.ProjectItemType'), 'Missing optional chaining for ProjectItemType');
});

test('TrackItemType has fallback for undefined Constants', () => {
  assert.ok(builderCode.includes('pproBuilder?.Constants?.TrackItemType'), 'Missing optional chaining for TrackItemType');
});

test('ProjectItemType fallback defines CLIP type', () => {
  assert.ok(builderCode.includes('CLIP: 1'), 'Missing CLIP type in fallback');
});

test('ProjectItemType fallback defines BIN type', () => {
  assert.ok(builderCode.includes('BIN: 2'), 'Missing BIN type in fallback');
});

// === TickTime API (No TICKS_PER_SECOND Math) ===
test('Uses TickTime.createWithSeconds (not manual conversion)', () => {
  assert.ok(builderCode.includes('TickTime.createWithSeconds'), 'Missing TickTime.createWithSeconds');
});

test('Does not use TICKS_PER_SECOND multiplication', () => {
  // Should not have patterns like "* TICKS_PER_SECOND" or "TICKS_PER_SECOND *"
  const hasManualConversion = /\*\s*TICKS_PER_SECOND|\bTICKS_PER_SECOND\s*\*/.test(builderCode);
  assert.ok(!hasManualConversion, 'Should not use manual TICKS_PER_SECOND conversion');
});

test('Avoids hardcoded tick math', () => {
  // Should not have hardcoded tick values like * 254016000000
  const hasHardcodedTicks = /\*\s*254016000000|254016000000\s*\*/.test(builderCode);
  assert.ok(!hasHardcodedTicks, 'Should not use hardcoded tick values');
});

// === Transaction API ===
test('Uses executeTransaction for batch operations', () => {
  const count = (builderCode.match(/executeTransaction/g) || []).length;
  assert.ok(count >= 3, `Expected at least 3 executeTransaction calls, got ${count}`);
});

test('Uses lockedAccess for thread safety', () => {
  const count = (builderCode.match(/lockedAccess/g) || []).length;
  assert.ok(count >= 3, `Expected at least 3 lockedAccess calls, got ${count}`);
});

test('Transaction has proper callback structure', () => {
  assert.ok(builderCode.includes('(compoundAction)'), 'Missing compoundAction parameter');
  assert.ok(builderCode.includes('compoundAction.addAction'), 'Missing addAction call');
});

// === Sequence Operations ===
test('Uses SequenceEditor.getEditor for clip insertion', () => {
  assert.ok(builderCode.includes('SequenceEditor.getEditor'), 'Missing SequenceEditor.getEditor');
});

test('Uses createInsertProjectItemAction for inserting clips', () => {
  assert.ok(builderCode.includes('createInsertProjectItemAction'), 'Missing createInsertProjectItemAction');
});

test('Uses createCloneAction for sequence cloning', () => {
  assert.ok(builderCode.includes('createCloneAction'), 'Missing createCloneAction');
});

test('Uses createSetNameAction for renaming', () => {
  assert.ok(builderCode.includes('createSetNameAction'), 'Missing createSetNameAction');
});

// === Track Item Operations ===
test('Uses createSetInPointAction for in points', () => {
  assert.ok(builderCode.includes('createSetInPointAction'), 'Missing createSetInPointAction');
});

test('Uses createSetOutPointAction for out points', () => {
  assert.ok(builderCode.includes('createSetOutPointAction'), 'Missing createSetOutPointAction');
});

test('Uses createRemoveAction for deleting clips', () => {
  assert.ok(builderCode.includes('createRemoveAction'), 'Missing createRemoveAction');
});

// === Color Labels ===
test('Uses createSetColorLabelAction for coloring clips', () => {
  assert.ok(builderCode.includes('createSetColorLabelAction'), 'Missing createSetColorLabelAction');
});

test('Defines COLOR_LABELS constant', () => {
  assert.ok(builderCode.includes('COLOR_LABELS'), 'Missing COLOR_LABELS');
});

test('Defines SPLICE_COLORS for semantic coloring', () => {
  assert.ok(builderCode.includes('SPLICE_COLORS'), 'Missing SPLICE_COLORS');
});

// === Track Access ===
test('Uses getVideoTrack for video track access', () => {
  assert.ok(builderCode.includes('getVideoTrack'), 'Missing getVideoTrack');
});

test('Uses getAudioTrack for audio track access', () => {
  assert.ok(builderCode.includes('getAudioTrack'), 'Missing getAudioTrack');
});

test('Uses getTrackItems for getting clips', () => {
  assert.ok(builderCode.includes('getTrackItems'), 'Missing getTrackItems');
});

// === Error Handling ===
test('Has try-catch for transaction operations', () => {
  const tryCatchCount = (builderCode.match(/try\s*{/g) || []).length;
  assert.ok(tryCatchCount >= 5, `Expected at least 5 try blocks, got ${tryCatchCount}`);
});

test('Logs errors with console.error', () => {
  const errorLogCount = (builderCode.match(/console\.error/g) || []).length;
  assert.ok(errorLogCount >= 4, `Expected at least 4 console.error calls, got ${errorLogCount}`);
});

// === J-cut/L-cut Support ===
test('Supports audio offset for J-cut/L-cut', () => {
  assert.ok(builderCode.includes('audioInPoint'), 'Missing audioInPoint');
  assert.ok(builderCode.includes('audioOutPoint'), 'Missing audioOutPoint');
  assert.ok(builderCode.includes('hasAudioOffset'), 'Missing hasAudioOffset');
});

// === Export ===
test('Exports functions via window.spliceBuilder', () => {
  assert.ok(builderCode.includes('window.spliceBuilder'), 'Missing window.spliceBuilder export');
  assert.ok(builderCode.includes('buildSequenceFromCutList'), 'Missing buildSequenceFromCutList export');
  assert.ok(builderCode.includes('buildSequenceFromDetection'), 'Missing buildSequenceFromDetection export');
});

// === Property Access (UXP compatible) ===
test('Uses property access (not getter methods) for name', () => {
  // Should use item.name not await item.getName()
  const propertyPattern = /child\.name|sourceClip\.name|sequence\.name/;
  const getterPattern = /getName\(\)/g;
  assert.ok(propertyPattern.test(builderCode), 'Should use .name property access');
});

test('Uses property access for treePath', () => {
  assert.ok(builderCode.includes('.treePath'), 'Should use .treePath property access');
});

// === Async/Await Pattern ===
test('All async functions use async keyword', () => {
  const asyncFunctions = [
    'buildSequenceFromCutList',
    'buildSequenceFromDetection',
    'findProjectItemByName',
    'findProjectItemByPath',
    'clearSequence',
    'setTrackItemInOutPoints'
  ];

  for (const fn of asyncFunctions) {
    const pattern = new RegExp(`async\\s+function\\s+${fn}`);
    assert.ok(pattern.test(builderCode), `${fn} should be async`);
  }
});

// Summary
console.log(`\n=== Results ===`);
console.log(`Passed: ${passed}`);
console.log(`Failed: ${failed}`);
console.log(`Total: ${passed + failed}`);

process.exit(failed > 0 ? 1 : 0);
