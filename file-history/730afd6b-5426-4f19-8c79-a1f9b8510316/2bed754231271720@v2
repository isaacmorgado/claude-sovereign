/**
 * Credits Display Module
 *
 * Fetches and displays user's remaining hours from the billing backend.
 * Requires customerId to be set in settings.
 *
 * Uses getBackendUrl() from config.js for consistent URL handling.
 */

// Track fetch error state for retry UI
let lastCreditsError = null;
let creditsRetryCount = 0;
const MAX_CREDITS_RETRIES = 3;

/**
 * Fetch user's credit balance from backend
 * @returns {Promise<Object | null>} Credit data including isolation hours, or error object
 */
async function fetchCredits() {
  const settings = getSettings();
  const customerId = settings.customerId;

  if (!customerId) {
    console.log('[SPLICE] No customerId configured - credits display disabled');
    lastCreditsError = null;
    return null;
  }

  try {
    const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {
      method: 'GET',
      headers: {
        'x-stripe-customer-id': customerId
      }
    }, FETCH_TIMEOUT_DEFAULT);

    if (!response.ok) {
      const errorMsg = await parseErrorResponse(response);
      console.error('[SPLICE] Credits fetch failed:', errorMsg);
      lastCreditsError = errorMsg;
      return { _error: true, message: errorMsg };
    }

    const data = await response.json();
    lastCreditsError = null;
    creditsRetryCount = 0;
    return {
      hoursRemaining: data.hoursRemaining || 0,
      hoursTotal: data.hoursTotal || 0,
      tierName: data.tierName || 'Free',
      tier: data.tier || 'starter',
      // Isolation hours
      isolationHoursRemaining: data.isolationHoursRemaining || 0,
      isolationHoursTotal: data.isolationHoursTotal || 0,
      hasIsolationAccess: data.hasIsolationAccess || false,
      isolationOverageRate: data.isolationOverageRate || 0.08
    };
  } catch (err) {
    console.error('[SPLICE] Credits fetch error:', err);
    lastCreditsError = err.message || 'Connection failed';
    return { _error: true, message: lastCreditsError };
  }
}

// Store current credits globally for access checks
let currentCredits = null;

/**
 * Clear the credits cache (call on logout)
 * Exported for use by settings.js logout function
 */
function clearCreditsCache() {
  currentCredits = null;
  lastCreditsError = null;
  creditsRetryCount = 0;
  console.log('[SPLICE] Credits cache cleared');
}

/**
 * Update the credit display in the UI
 * @param {Object|null} credits - Credit data, error object, or null if unavailable
 */
function updateCreditDisplay(credits) {
  const creditBadge = document.getElementById('creditBadge');
  if (!creditBadge) return;

  // Handle no customer ID configured
  if (!credits) {
    currentCredits = null;
    creditBadge.style.display = 'flex';
    creditBadge.textContent = 'Login';
    creditBadge.title = 'Click to enter license key';
    creditBadge.classList.remove('ok', 'low');
    creditBadge.classList.add('login');
    return;
  }

  // Handle error state - show error badge with retry
  if (credits._error) {
    currentCredits = null;
    creditBadge.style.display = 'flex';
    creditBadge.textContent = 'âš  Retry';
    creditBadge.title = `Error: ${credits.message}\nClick to retry`;
    creditBadge.classList.remove('ok', 'low', 'login');
    creditBadge.classList.add('error');
    return;
  }

  // Normal credit display
  currentCredits = credits;
  creditBadge.style.display = 'flex';
  creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;
  creditBadge.classList.remove('error', 'login');

  // Build tooltip with isolation info if available
  let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;
  if (credits.hasIsolationAccess) {
    tooltip += `\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;
  }
  creditBadge.title = tooltip;

  // Color based on remaining hours
  if (credits.hoursRemaining <= 1) {
    creditBadge.classList.add('low');
    creditBadge.classList.remove('ok');
  } else {
    creditBadge.classList.add('ok');
    creditBadge.classList.remove('low');
  }

  // Update isolation checkbox state based on tier access
  updateIsolationCheckboxState(credits);
}

/**
 * Update the isolation checkbox based on tier access
 */
function updateIsolationCheckboxState(credits) {
  const isolatedCheckbox = document.getElementById('sourceIsolated');
  const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');

  if (!isolatedCheckbox) return;

  if (!credits || !credits.hasIsolationAccess) {
    // Disable isolation for non-Pro/Team users
    isolatedCheckbox.disabled = true;
    isolatedCheckbox.checked = false;
    if (tierBadge) {
      tierBadge.textContent = 'Pro+';
      tierBadge.style.opacity = '1';
    }
  } else {
    // Enable isolation for Pro/Team users
    isolatedCheckbox.disabled = false;
    if (tierBadge) {
      // Show remaining isolation time
      const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);
      tierBadge.textContent = `${minsRemaining} min`;
      tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';
    }
  }
}

/**
 * Check if user can use isolation and get cost estimate
 * @param {number} estimatedMinutes - Estimated audio duration in minutes
 * @returns {Object} Access info with allowed, message, overageCost
 */
function checkIsolationAccess(estimatedMinutes = 0) {
  if (!currentCredits) {
    return { allowed: false, message: 'Credits not loaded', overageCost: 0 };
  }

  if (!currentCredits.hasIsolationAccess) {
    return {
      allowed: false,
      message: 'Vocal isolation requires Pro or Team tier',
      upgradeRequired: true,
      overageCost: 0
    };
  }

  const estimatedHours = estimatedMinutes / 60;
  const remaining = currentCredits.isolationHoursRemaining;

  if (remaining >= estimatedHours) {
    return {
      allowed: true,
      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
      overageCost: 0
    };
  }

  // Calculate overage
  const overageMinutes = estimatedMinutes - (remaining * 60);
  const overageCost = overageMinutes * currentCredits.isolationOverageRate;

  return {
    allowed: true,
    message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,
    overageCost,
    overageMinutes
  };
}

/**
 * Get current credits (for access checks)
 */
function getCurrentCredits() {
  return currentCredits;
}

// Store interval reference for cleanup
let creditsRefreshInterval = null;

/**
 * Initialize credits display
 * Fetches credits on load and sets up periodic refresh
 */
async function initCredits() {
  // Clear any existing interval to prevent duplicates
  if (creditsRefreshInterval) {
    clearInterval(creditsRefreshInterval);
  }

  // Initial fetch
  const credits = await fetchCredits();
  updateCreditDisplay(credits);

  // Refresh credits every 5 minutes
  creditsRefreshInterval = setInterval(async () => {
    const refreshedCredits = await fetchCredits();
    updateCreditDisplay(refreshedCredits);
  }, 5 * 60 * 1000);
}

/**
 * Cleanup credits module - call on plugin unload
 */
function cleanupCredits() {
  if (creditsRefreshInterval) {
    clearInterval(creditsRefreshInterval);
    creditsRefreshInterval = null;
  }
}

/**
 * Manually refresh credits (e.g., after a processing operation)
 */
async function refreshCredits() {
  const credits = await fetchCredits();
  updateCreditDisplay(credits);
  return credits;
}
