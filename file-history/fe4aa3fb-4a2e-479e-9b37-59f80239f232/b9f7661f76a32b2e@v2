/**
 * Advice Engine - Client-side implementation matching the Python AdviceEngine
 * Processes plans.json trigger rules against user metrics
 */

import { Plan } from '@/components/results/cards/PlanActionCard';

// ============================================
// TYPES
// ============================================

interface Threshold {
  operator: '<' | '>';
  value: number;
}

interface TriggerRules {
  metrics: string[];
  condition: 'OR' | 'AND';
  thresholds: Record<string, Threshold>;
}

interface PlanContent {
  description: string;
  cost_min: number;
  cost_max: number;
  time_min?: string;
  time_max?: string;
  risks?: string;
  citations?: string[];
  tags?: string[];
}

interface RawPlan {
  id: string;
  title: string;
  trigger_rules: TriggerRules;
  content: PlanContent;
}

interface TriggerResult {
  metric: string;
  value: number;
  threshold: number;
  operator: '<' | '>';
}

// ============================================
// PLANS DATA (from plans.json)
// ============================================

export const PLANS: RawPlan[] = [
  {
    id: "jaw_fillers",
    title: "Jaw Fillers",
    trigger_rules: {
      metrics: ["Gonial Angle", "Bigonial Width", "Ramus to Mandible Ratio"],
      condition: "OR",
      thresholds: {
        "Gonial Angle": { operator: ">", value: 128.0 },
        "Bigonial Width": { operator: "<", value: 90.0 },
        "Ramus to Mandible Ratio": { operator: "<", value: 0.5 }
      }
    },
    content: {
      description: "Injectable dermal fillers (hyaluronic acid or hydroxyapatite) to enhance jawline definition, gonial angle sharpness, and mandibular border projection. Common products: Radiesse, Sculptra, Juvederm Voluma. Targets masseter hollow, prejowl sulcus, and mandibular angle.",
      cost_min: 600,
      cost_max: 2500,
      time_min: "6 months",
      time_max: "18 months",
      risks: "Vascular occlusion, asymmetry, swelling.",
      citations: ["Al-Khafaji et al., 2023"],
      tags: ["Minimally Invasive"]
    }
  },
  {
    id: "cheekbone_fillers",
    title: "Cheekbone Fillers",
    trigger_rules: {
      metrics: ["Cheekbone Height", "Face Width to Height Ratio"],
      condition: "OR",
      thresholds: {
        "Cheekbone Height": { operator: "<", value: 60.0 },
        "Face Width to Height Ratio": { operator: "<", value: 1.75 }
      }
    },
    content: {
      description: "Malar augmentation via hyaluronic acid fillers placed at the zygomatic arch and submalar region. Products: Juvederm Voluma, Restylane Lyft. Enhances ogee curve, anterior cheek projection, and lateral zygomatic width for improved facial angularity.",
      cost_min: 650,
      cost_max: 2500,
      time_min: "6 months",
      time_max: "18 months",
      risks: "Asymmetry, filler migration.",
      citations: ["Trinh & Gupta, 2021"],
      tags: ["Minimally Invasive"]
    }
  },
  {
    id: "beard_growth",
    title: "Beard / Stubble Growth",
    trigger_rules: {
      metrics: ["Chin to Philtrum Ratio", "Gonial Angle"],
      condition: "OR",
      thresholds: {
        "Chin to Philtrum Ratio": { operator: "<", value: 1.8 },
        "Gonial Angle": { operator: ">", value: 126.0 }
      }
    },
    content: {
      description: "Strategic facial hair growth (5-10mm stubble or full beard) to optically enhance jawline definition, camouflage gonial angle softness, and create visual chin projection. Consider minoxidil 5% foam if low coverage. Trim to maintain sharp mandibular border.",
      cost_min: 0,
      cost_max: 20,
      time_min: "1 month",
      time_max: "3 months",
      risks: "None",
      citations: ["Dixson et al., 2016"],
      tags: ["Foundational", "Free"]
    }
  },
  {
    id: "lip_filler",
    title: "Lip Filler",
    trigger_rules: {
      metrics: ["Lower Lip to Upper Lip Ratio"],
      condition: "OR",
      thresholds: {
        "Lower Lip to Upper Lip Ratio": { operator: "<", value: 1.0 }
      }
    },
    content: {
      description: "Lip augmentation via hyaluronic acid fillers (Restylane, Juvederm) to enhance vermillion border, cupid's bow definition, and lip ratio balance. Can target vermillion height, philtral columns, or tubercles. Alternative: surgical lip lift (bullhorn or corner lift) for permanent results.",
      cost_min: 500,
      cost_max: 1200,
      time_min: "6 months",
      time_max: "12 months",
      risks: "Migration, bruising.",
      citations: ["Hernandez et al., 2023"],
      tags: ["Minimally Invasive"]
    }
  },
  {
    id: "weight_loss_protocol",
    title: "Fat Loss Protocol (High Protein + Cardio)",
    trigger_rules: {
      metrics: ["Cheekbone Height", "Jaw Slope"],
      condition: "OR",
      thresholds: {
        "Cheekbone Height": { operator: "<", value: 65.0 },
        "Jaw Slope": { operator: ">", value: 140.0 }
      }
    },
    content: {
      description: "Caloric deficit protocol targeting 8-12% body fat to debloat buccal fat pads and reveal zygomatic, mandibular, and maxillary bone structure. High-protein intake (1.6-2.2g/kg), fasted cardio, and sodium/water management. Consider buccal fat removal surgery if structure remains obscured at low body fat.",
      cost_min: 200,
      cost_max: 1000,
      time_min: "3 months",
      time_max: "12 months",
      risks: "None",
      citations: ["Moon & Koh, 2020"],
      tags: ["Foundational"]
    }
  },
  {
    id: "mewing_posture",
    title: "Mewing & Posture Correction",
    trigger_rules: {
      metrics: ["Midface Ratio", "Nasolabial Angle"],
      condition: "OR",
      thresholds: {
        "Midface Ratio": { operator: ">", value: 1.05 },
        "Nasolabial Angle": { operator: "<", value: 90.0 }
      }
    },
    content: {
      description: "Orthotropic tongue posture: entire tongue (posterior third critical) pressed against palate, teeth in light contact, nasal breathing. Aims to stimulate maxillary protraction, improve mandibular posture, and enhance gonial angle over time. Combine with proper head/neck alignment and chin tucks.",
      cost_min: 0,
      cost_max: 0,
      time_min: "12 months",
      time_max: "Lifetime",
      risks: "None if performed correctly.",
      citations: ["Mew J. et al., 2014"],
      tags: ["Foundational", "Free"]
    }
  },
  {
    id: "rhinoplasty",
    title: "Rhinoplasty",
    trigger_rules: {
      metrics: ["Nasal Projection", "Nasal W to H Ratio", "Nasolabial Angle"],
      condition: "OR",
      thresholds: {
        "Nasal Projection": { operator: ">", value: 0.75 },
        "Nasal W to H Ratio": { operator: ">", value: 0.85 },
        "Nasolabial Angle": { operator: "<", value: 85.0 }
      }
    },
    content: {
      description: "Comprehensive nasal surgery: dorsal hump reduction, osteotomies for width correction, tip plasty for bulbous refinement, alarplasty for alar base narrowing, cephalic trim for tip rotation, septoplasty for deviation. Can address nasal index, nasolabial angle, nasofrontal angle, and tip projection.",
      cost_min: 5000,
      cost_max: 15000,
      time_min: "6 months",
      time_max: "12 months",
      risks: "Infection, asymmetry, breathing issues, revision surgery.",
      citations: ["Rohrich RJ et al., 2010", "Foda HM, 2008"],
      tags: ["Surgical"]
    }
  },
  {
    id: "genioplasty",
    title: "Sliding Genioplasty (Chin Surgery)",
    trigger_rules: {
      metrics: ["Chin to Philtrum Ratio", "Recession Relative to Frankfort Plane"],
      condition: "OR",
      thresholds: {
        "Chin to Philtrum Ratio": { operator: "<", value: 1.5 },
        "Recession Relative to Frankfort Plane": { operator: ">", value: 15.0 }
      }
    },
    content: {
      description: "Osseous genioplasty: horizontal advancement or setback of the chin via osteotomy and titanium plate fixation. Can also adjust vertical height (reduction/augmentation) and transverse width. Alternative: alloplastic chin implant (silicone/Medpor) for pure augmentation. Improves chin-philtrum ratio and profile convexity.",
      cost_min: 4000,
      cost_max: 12000,
      time_min: "3 months",
      time_max: "12 months",
      risks: "Numbness, infection, asymmetry.",
      citations: ["Park JH et al., 2018"],
      tags: ["Surgical"]
    }
  },
  {
    id: "canthoplasty",
    title: "Canthoplasty (Eye Corner Surgery)",
    trigger_rules: {
      metrics: ["Lateral Canthal Tilt", "Eye Aspect Ratio"],
      condition: "AND",
      thresholds: {
        "Lateral Canthal Tilt": { operator: "<", value: 4.0 },
        "Eye Aspect Ratio": { operator: "<", value: 2.8 }
      }
    },
    content: {
      description: "Lateral canthoplasty or canthopexy: surgical elevation and fixation of the lateral canthal tendon to increase positive canthal tilt angle. Techniques include tarsal strip, lateral canthal suspension, or almond eye surgery. Can be combined with lower blepharoplasty. Addresses negative canthal tilt and downturned eye appearance.",
      cost_min: 3000,
      cost_max: 8000,
      time_min: "2 months",
      time_max: "6 months",
      risks: "Scarring, asymmetry, dry eyes.",
      citations: ["Rhee SC et al., 2017", "Chen WP, 2016"],
      tags: ["Surgical"]
    }
  },
  {
    id: "brow_lift",
    title: "Brow Lift / Browridge Enhancement",
    trigger_rules: {
      metrics: ["Eyebrow Low Setedness", "Browridge Inclination Angle"],
      condition: "OR",
      thresholds: {
        "Eyebrow Low Setedness": { operator: ">", value: 2.0 },
        "Browridge Inclination Angle": { operator: "<", value: 10.0 }
      }
    },
    content: {
      description: "Brow elevation via endoscopic browlift, temporal lift, or direct browplasty to reduce hooding and increase eyebrow height. For browridge: supraorbital rim augmentation with PMMA, hydroxyapatite paste, or custom implants. Botox for brow arch shaping. Addresses low-set brows and flat browridge inclination.",
      cost_min: 1500,
      cost_max: 10000,
      time_min: "1 month",
      time_max: "6 months",
      risks: "Asymmetry, numbness, unnatural appearance.",
      citations: ["Mendelson B et al., 2015"],
      tags: ["Surgical", "Minimally Invasive"]
    }
  }
];

// ============================================
// ADVICE ENGINE CLASS
// ============================================

export class AdviceEngine {
  private plans: RawPlan[];

  constructor(customPlans?: RawPlan[]) {
    this.plans = customPlans || PLANS;
  }

  /**
   * Check if a single threshold condition is met
   */
  private checkThreshold(userValue: number, operator: '<' | '>', thresholdValue: number): boolean {
    if (operator === '<') {
      return userValue < thresholdValue;
    }
    return userValue > thresholdValue;
  }

  /**
   * Evaluate trigger rules against user metrics
   */
  private evaluateTriggerRules(
    triggerRules: TriggerRules,
    metricsDict: Record<string, number>
  ): { isTriggered: boolean; triggeredMetrics: TriggerResult[] } {
    const { metrics, thresholds, condition } = triggerRules;
    const triggeredMetrics: TriggerResult[] = [];
    const results: boolean[] = [];

    for (const metricName of metrics) {
      if (!(metricName in metricsDict)) continue;
      if (!(metricName in thresholds)) continue;

      const userValue = metricsDict[metricName];
      const { operator, value: thresholdValue } = thresholds[metricName];
      const isMet = this.checkThreshold(userValue, operator, thresholdValue);

      if (isMet) {
        triggeredMetrics.push({
          metric: metricName,
          value: userValue,
          threshold: thresholdValue,
          operator
        });
      }

      results.push(isMet);
    }

    const isTriggered = condition === 'AND'
      ? results.length > 0 && results.every(r => r)
      : results.some(r => r);

    return { isTriggered, triggeredMetrics };
  }

  /**
   * Get all recommendations that match the user's metrics
   *
   * @param metricsDict - Raw metric values
   * @param severityDict - Severity classifications (ideal/good/moderate/severe) for each metric
   *                       If a metric is 'ideal', it will NOT trigger remediation plans
   */
  getRecommendations(
    metricsDict: Record<string, number>,
    severityDict?: Record<string, string>
  ): Plan[] {
    const recommendations: Plan[] = [];

    for (const rawPlan of this.plans) {
      const { isTriggered, triggeredMetrics } = this.evaluateTriggerRules(
        rawPlan.trigger_rules,
        metricsDict
      );

      // If severity data is provided, filter out metrics that are already ideal
      if (isTriggered && severityDict) {
        // Check if ALL triggered metrics are outside ideal range
        const hasActualFlaw = triggeredMetrics.some(tm => {
          const severity = severityDict[tm.metric];
          // Only trigger if severity is NOT ideal (i.e., it's good/moderate/severe)
          return severity && severity !== 'ideal';
        });

        // Skip this plan if all triggered metrics are already ideal
        if (!hasActualFlaw) {
          continue;
        }
      }

      if (isTriggered) {
        recommendations.push({
          id: rawPlan.id,
          title: rawPlan.title,
          content: {
            description: rawPlan.content.description,
            cost_min: rawPlan.content.cost_min,
            cost_max: rawPlan.content.cost_max,
            time_min: rawPlan.content.time_min || 'Unknown',
            time_max: rawPlan.content.time_max || 'Unknown',
            risks: rawPlan.content.risks || 'Consult a professional.',
            citations: rawPlan.content.citations || [],
            tags: rawPlan.content.tags
          },
          trigger_reason: triggeredMetrics
        });
      }
    }

    return recommendations;
  }

  /**
   * Get recommendations sorted by cost (cheapest first)
   */
  getRecommendationsByCost(
    metricsDict: Record<string, number>,
    severityDict?: Record<string, string>
  ): Plan[] {
    return this.getRecommendations(metricsDict, severityDict).sort(
      (a, b) => a.content.cost_min - b.content.cost_min
    );
  }

  /**
   * Get recommendations grouped by phase/tag
   */
  getRecommendationsByPhase(
    metricsDict: Record<string, number>,
    severityDict?: Record<string, string>
  ): Record<string, Plan[]> {
    const recommendations = this.getRecommendations(metricsDict, severityDict);
    const grouped: Record<string, Plan[]> = {
      'Foundational': [],
      'Minimally Invasive': [],
      'Surgical': []
    };

    for (const rec of recommendations) {
      const tags = rec.content.tags || [];
      if (tags.includes('Foundational')) {
        grouped['Foundational'].push(rec);
      } else if (tags.includes('Surgical')) {
        grouped['Surgical'].push(rec);
      } else if (tags.includes('Minimally Invasive')) {
        grouped['Minimally Invasive'].push(rec);
      } else {
        grouped['Minimally Invasive'].push(rec); // Default
      }
    }

    return grouped;
  }
}

// ============================================
// SINGLETON INSTANCE
// ============================================

export const adviceEngine = new AdviceEngine();
