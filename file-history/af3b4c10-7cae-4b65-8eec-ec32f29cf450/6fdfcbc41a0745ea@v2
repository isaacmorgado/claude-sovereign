/**
 * Comprehensive UI E2E Tests
 *
 * Simulates full UI workflow to verify:
 * 1. All UI elements are correctly wired
 * 2. Event handlers fire correctly
 * 3. State management is consistent
 * 4. No performance bottlenecks
 * 5. Error handling works properly
 */

// =============================================================================
// MOCK ENVIRONMENT SETUP
// =============================================================================

// Simulate localStorage
const storage = { data: {} };
global.localStorage = {
  getItem: (key) => storage.data[key] || null,
  setItem: (key, value) => { storage.data[key] = value; },
  removeItem: (key) => { delete storage.data[key]; },
  clear: () => { storage.data = {}; }
};

// Mock DOM elements
const mockElements = {};
function createMockElement(id, type = 'div') {
  return {
    id,
    type,
    value: '',
    textContent: '',
    innerHTML: '',
    style: { display: '' },
    classList: {
      _classes: new Set(),
      add: function(c) { this._classes.add(c); },
      remove: function(c) { this._classes.delete(c); },
      contains: function(c) { return this._classes.has(c); },
      toggle: function(c) { this._classes.has(c) ? this._classes.delete(c) : this._classes.add(c); }
    },
    dataset: {},
    disabled: false,
    checked: false,
    _eventListeners: {},
    addEventListener: function(event, handler) {
      if (!this._eventListeners[event]) this._eventListeners[event] = [];
      this._eventListeners[event].push(handler);
    },
    dispatchEvent: function(event) {
      const handlers = this._eventListeners[event.type] || [];
      handlers.forEach(h => h(event));
    },
    click: function() {
      this.dispatchEvent({ type: 'click', target: this });
    },
    focus: function() {},
    blur: function() {},
    appendChild: function(child) {},
    removeChild: function(child) {},
    closest: function(selector) {
      // Simple mock - check if this element matches
      if (selector.startsWith('.') && this.classList.contains(selector.slice(1))) {
        return this;
      }
      return null;
    },
    querySelectorAll: function() { return []; }
  };
}

global.document = {
  getElementById: (id) => {
    if (!mockElements[id]) {
      mockElements[id] = createMockElement(id);
    }
    return mockElements[id];
  },
  createElement: (type) => createMockElement('dynamic-' + Date.now(), type),
  createDocumentFragment: () => ({
    appendChild: function() {}
  }),
  querySelectorAll: () => []
};

global.confirm = () => true;
global.alert = () => {};
global.FileReader = class {
  constructor() {
    this.onload = null;
    this.onerror = null;
  }
  readAsText(file) {
    setTimeout(() => {
      if (this.onload) {
        this.onload({ target: { result: file._content || '{}' } });
      }
    }, 0);
  }
};

// Mock console.warn
const originalWarn = console.warn;
console.warn = () => {};

// =============================================================================
// COPY CORE FUNCTIONS FROM settings.js
// =============================================================================

const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';

const PRESETS = {
  custom: { name: 'Custom', description: 'Your custom settings', icon: 'settings', settings: null },
  podcast: { name: 'Podcast', description: 'Natural pauses', icon: 'mic', settings: { sensitivity: 35, threshold: -32 } },
  interview: { name: 'Interview', description: 'Q&A rhythm', icon: 'people', settings: { sensitivity: 50, threshold: -30 } },
  reaction: { name: 'Reaction', description: 'Fast-paced', icon: 'bolt', settings: { sensitivity: 70, threshold: -28 } },
  tutorial: { name: 'Tutorial', description: 'Teaching pace', icon: 'school', settings: { sensitivity: 30, threshold: -35 } },
  vlog: { name: 'Vlog', description: 'Punchy edits', icon: 'videocam', settings: { sensitivity: 65, threshold: -30 } }
};

const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];

function loadCustomPresets() {
  try {
    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {
        return { version: parsed.version || 1, presets: { ...parsed.presets } || {}, order: [...(parsed.order || [])] };
      }
    }
  } catch (e) {}
  return { version: 1, presets: {}, order: [] };
}

function saveCustomPresets(data) {
  try {
    if (!data || typeof data !== 'object') return false;
    const toSave = { version: data.version || 1, presets: data.presets || {}, order: data.order || [] };
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));
    return true;
  } catch (e) { return false; }
}

function slugifyPresetName(name) {
  return name.toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').substring(0, 50) || 'preset';
}

function generateUniquePresetId(baseName, existingPresets) {
  const baseId = slugifyPresetName(baseName);
  let id = baseId;
  let counter = 1;
  while (existingPresets[id]) { id = `${baseId}-${counter}`; counter++; }
  return id;
}

function getCurrentPresetSettings() {
  return { sensitivity: 50, threshold: -32, minSilenceLength: 0.5, paddingStart: 0.1, paddingEnd: 0.1, autoMarkBest: true, enableTakesDetection: true };
}

function createCustomPreset(preset) {
  if (!preset || typeof preset !== 'object') return { success: false, error: 'Invalid preset data' };
  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) return { success: false, error: 'Preset name is required' };
  const name = preset.name.trim();
  const data = loadCustomPresets();
  const id = generateUniquePresetId(name, data.presets);
  const settings = preset.settings && typeof preset.settings === 'object' ? { ...preset.settings } : getCurrentPresetSettings();
  const newPreset = { id, name, description: preset.description || '', icon: preset.icon || 'settings', createdAt: new Date().toISOString(), settings };
  data.presets[id] = newPreset;
  data.order.push(id);
  const saved = saveCustomPresets(data);
  if (!saved) return { success: false, error: 'Failed to save preset' };
  return { success: true, id };
}

function updateCustomPreset(id, updates) {
  if (!id || typeof id !== 'string') return { success: false, error: 'Preset ID is required' };
  if (!updates || typeof updates !== 'object') return { success: false, error: 'Updates must be an object' };
  const data = loadCustomPresets();
  if (!data.presets[id]) return { success: false, error: 'Preset not found' };
  const existing = data.presets[id];
  const updated = { ...existing, updatedAt: new Date().toISOString() };
  if (updates.name !== undefined) {
    if (typeof updates.name !== 'string' || !updates.name.trim()) return { success: false, error: 'Name must be a non-empty string' };
    updated.name = updates.name.trim();
  }
  if (updates.description !== undefined) updated.description = String(updates.description);
  if (updates.icon !== undefined) updated.icon = String(updates.icon);
  if (updates.settings !== undefined) {
    if (typeof updates.settings !== 'object') return { success: false, error: 'Settings must be an object' };
    updated.settings = { ...existing.settings, ...updates.settings };
  }
  data.presets[id] = updated;
  const saved = saveCustomPresets(data);
  if (!saved) return { success: false, error: 'Failed to save preset' };
  return { success: true };
}

function deleteCustomPreset(id) {
  if (!id || typeof id !== 'string') return { success: false, error: 'Preset ID is required' };
  const data = loadCustomPresets();
  if (!data.presets[id]) return { success: false, error: 'Preset not found' };
  delete data.presets[id];
  const orderIndex = data.order.indexOf(id);
  if (orderIndex !== -1) data.order.splice(orderIndex, 1);
  const saved = saveCustomPresets(data);
  if (!saved) return { success: false, error: 'Failed to save after deletion' };
  return { success: true };
}

function getCustomPreset(id) {
  if (!id || typeof id !== 'string') return null;
  const data = loadCustomPresets();
  return data.presets[id] || null;
}

function isBuiltInPreset(id) { return BUILT_IN_PRESET_IDS.includes(id); }

function getAllPresets() {
  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {
    const preset = PRESETS[id];
    return { id, name: preset.name, description: preset.description, icon: preset.icon, settings: preset.settings, isBuiltIn: true };
  });
  const customData = loadCustomPresets();
  const customPresets = customData.order.map(id => {
    const preset = customData.presets[id];
    if (!preset) return null;
    return { ...preset, isBuiltIn: false };
  }).filter(Boolean);
  return [...builtInPresets, ...customPresets];
}

function getPresetById(id) {
  if (!id || typeof id !== 'string') return null;
  if (isBuiltInPreset(id)) {
    const preset = PRESETS[id];
    return { id, name: preset.name, description: preset.description, icon: preset.icon, settings: preset.settings, isBuiltIn: true };
  }
  const custom = getCustomPreset(id);
  if (custom) return { ...custom, isBuiltIn: false };
  return null;
}

function duplicatePreset(id) {
  if (!id || typeof id !== 'string') return { success: false, error: 'Preset ID is required' };
  const original = getPresetById(id);
  if (!original) return { success: false, error: 'Preset not found' };
  let copyName = `${original.name} (Copy)`;
  const data = loadCustomPresets();
  let copyNumber = 1;
  let testId = slugifyPresetName(copyName);
  while (data.presets[testId]) { copyNumber++; copyName = `${original.name} (Copy ${copyNumber})`; testId = slugifyPresetName(copyName); }
  return createCustomPreset({ name: copyName, description: original.description || '', icon: original.icon || 'settings', settings: original.settings ? { ...original.settings } : getCurrentPresetSettings() });
}

function exportPresets() {
  try {
    const data = loadCustomPresets();
    const customPresets = data.order.map(id => data.presets[id]).filter(Boolean);
    if (customPresets.length === 0) return { success: false, error: 'No custom presets to export' };
    const exportData = { version: 1, exportedAt: new Date().toISOString(), presets: customPresets };
    return { success: true, data: JSON.stringify(exportData, null, 2), count: customPresets.length };
  } catch (e) { return { success: false, error: 'Failed to export presets: ' + e.message }; }
}

function importPresets(jsonString, merge = true) {
  try {
    const imported = JSON.parse(jsonString);
    if (!imported || !imported.presets || !Array.isArray(imported.presets)) return { success: false, error: 'Invalid preset file format' };
    let importedCount = 0, skippedCount = 0;
    for (const preset of imported.presets) {
      if (!preset.name || typeof preset.name !== 'string') { skippedCount++; continue; }
      const existingId = slugifyPresetName(preset.name);
      const existing = getCustomPreset(existingId);
      if (existing && !merge) { skippedCount++; continue; }
      if (existing && merge) {
        let newName = `${preset.name} (Imported)`;
        let counter = 1;
        while (getCustomPreset(slugifyPresetName(newName))) { counter++; newName = `${preset.name} (Imported ${counter})`; }
        preset.name = newName;
      }
      const result = createCustomPreset({ name: preset.name, description: preset.description || '', icon: preset.icon || 'settings', settings: preset.settings || getCurrentPresetSettings() });
      if (result.success) importedCount++; else skippedCount++;
    }
    if (importedCount === 0 && skippedCount > 0) return { success: false, error: 'All presets already exist or were invalid', skipped: skippedCount };
    return { success: true, imported: importedCount, skipped: skippedCount };
  } catch (e) {
    if (e instanceof SyntaxError) return { success: false, error: 'Invalid JSON format' };
    return { success: false, error: 'Failed to import presets: ' + e.message };
  }
}

// =============================================================================
// SIMULATE UI STATE & FUNCTIONS
// =============================================================================

const PRESET_ICON_MAP = {
  'settings': '*', 'mic': 'M', 'people': 'P', 'bolt': '!',
  'school': 'E', 'videocam': 'V', 'star': 'S', 'heart': 'H'
};

// Simulated UI state
const ui = {
  presetModal: null,
  presetNameInput: null,
  presetDescInput: null,
  presetEditId: null,
  presetSelectedIcon: null,
  presetModalTitle: null,
  savePresetConfirmBtn: null,
  presetModalError: null,
  managePresetsModal: null,
  presetsList: null,
  noCustomPresets: null,
  presetSelector: null,
  presetSensitivity: null,
  presetSensitivityValue: null,
  presetThreshold: null,
  sensitivitySlider: null,
  status: null
};

let statusMessages = [];

function initUI() {
  // Initialize mock UI elements
  ui.presetModal = document.getElementById('presetModal');
  ui.presetNameInput = document.getElementById('presetNameInput');
  ui.presetDescInput = document.getElementById('presetDescInput');
  ui.presetEditId = document.getElementById('presetEditId');
  ui.presetSelectedIcon = document.getElementById('presetSelectedIcon');
  ui.presetModalTitle = document.getElementById('presetModalTitle');
  ui.savePresetConfirmBtn = document.getElementById('savePresetConfirmBtn');
  ui.presetModalError = document.getElementById('presetModalError');
  ui.managePresetsModal = document.getElementById('managePresetsModal');
  ui.presetsList = document.getElementById('presetsList');
  ui.noCustomPresets = document.getElementById('noCustomPresets');
  ui.presetSelector = document.getElementById('presetSelector');
  ui.presetSensitivity = document.getElementById('presetSensitivity');
  ui.presetSensitivityValue = document.getElementById('presetSensitivityValue');
  ui.presetThreshold = document.getElementById('presetThreshold');
  ui.sensitivitySlider = document.getElementById('sensitivitySlider');
  ui.status = document.getElementById('status');

  // Set defaults
  ui.presetSensitivity.value = 50;
  ui.presetThreshold.value = -32;
  ui.sensitivitySlider.value = 50;
}

function setStatus(msg) {
  statusMessages.push(msg);
  if (ui.status) ui.status.textContent = msg;
}

function showPresetModal(editId = null) {
  if (!ui.presetModal) return;
  ui.presetNameInput.value = '';
  ui.presetDescInput.value = '';
  ui.presetEditId.value = '';
  ui.presetSelectedIcon.value = 'settings';
  ui.presetModalError.style.display = 'none';

  const defaultSensitivity = 50;
  const defaultThreshold = -32;

  if (editId) {
    const preset = getPresetById(editId);
    if (preset && !preset.isBuiltIn) {
      ui.presetModalTitle.textContent = 'Edit Preset';
      ui.presetNameInput.value = preset.name;
      ui.presetDescInput.value = preset.description || '';
      ui.presetEditId.value = editId;
      ui.presetSelectedIcon.value = preset.icon || 'settings';
      ui.savePresetConfirmBtn.textContent = 'Update Preset';

      const presetSensitivity = preset.settings?.sensitivity ?? defaultSensitivity;
      const presetThreshold = preset.settings?.threshold ?? defaultThreshold;
      ui.presetSensitivity.value = presetSensitivity;
      ui.presetSensitivityValue.textContent = presetSensitivity;
      ui.presetThreshold.value = presetThreshold;
    }
  } else {
    ui.presetModalTitle.textContent = 'Save Preset';
    ui.savePresetConfirmBtn.textContent = 'Save Preset';
    const mainSensitivity = ui.sensitivitySlider?.value ?? defaultSensitivity;
    ui.presetSensitivity.value = mainSensitivity;
    ui.presetSensitivityValue.textContent = mainSensitivity;
    ui.presetThreshold.value = defaultThreshold;
  }

  ui.presetModal.classList.remove('hidden');
}

function hidePresetModal() {
  if (ui.presetModal) ui.presetModal.classList.add('hidden');
}

function showPresetError(msg) {
  if (ui.presetModalError) {
    ui.presetModalError.textContent = msg;
    ui.presetModalError.style.display = 'block';
  }
}

function savePresetFromModal() {
  const name = ui.presetNameInput?.value?.trim();
  const description = ui.presetDescInput?.value?.trim() || '';
  const icon = ui.presetSelectedIcon?.value || 'settings';
  const editId = ui.presetEditId?.value;

  if (!name) {
    showPresetError('Please enter a preset name');
    return { success: false, error: 'Please enter a preset name' };
  }

  const sensitivityRaw = parseInt(ui.presetSensitivity?.value);
  const thresholdRaw = parseInt(ui.presetThreshold?.value);
  const sensitivity = isNaN(sensitivityRaw) ? 50 : sensitivityRaw;
  const threshold = isNaN(thresholdRaw) ? -32 : thresholdRaw;
  const baseSettings = getCurrentPresetSettings();
  const settings = { ...baseSettings, sensitivity, threshold };

  let result;
  if (editId) {
    result = updateCustomPreset(editId, { name, description, icon, settings });
    if (result.success) setStatus(`Preset "${name}" updated`);
  } else {
    result = createCustomPreset({ name, description, icon, settings });
    if (result.success) {
      setStatus(`Preset "${name}" saved`);
      refreshPresetDropdown();
      if (ui.presetSelector) ui.presetSelector.value = result.id;
    }
  }

  if (result.success) {
    hidePresetModal();
    refreshPresetDropdown();
  } else {
    showPresetError(result.error || 'Failed to save preset');
  }

  return result;
}

function refreshPresetDropdown() {
  if (!ui.presetSelector) return;
  const currentValue = ui.presetSelector.value;
  const presets = getAllPresets();
  ui.presetSelector.innerHTML = '';

  presets.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset.id;
    option.textContent = preset.name + (preset.description ? ` - ${preset.description}` : '');
    ui.presetSelector.appendChild(option);
  });

  const stillExists = presets.some(p => p.id === currentValue);
  if (stillExists) ui.presetSelector.value = currentValue;
  else ui.presetSelector.value = 'custom';
}

function renderPresetsList() {
  if (!ui.presetsList) return;
  const presets = getAllPresets();
  const customPresets = presets.filter(p => !p.isBuiltIn);

  if (ui.noCustomPresets) {
    ui.noCustomPresets.style.display = customPresets.length === 0 ? 'block' : 'none';
  }

  // Build HTML representation
  const items = presets.map(preset => {
    const iconChar = PRESET_ICON_MAP[preset.icon] || '*';
    const desc = preset.description || (preset.isBuiltIn ? 'Built-in preset' : 'Custom preset');
    return {
      id: preset.id,
      name: preset.name,
      description: desc,
      icon: iconChar,
      isBuiltIn: preset.isBuiltIn,
      hasDuplicate: true,
      hasEdit: !preset.isBuiltIn,
      hasDelete: !preset.isBuiltIn
    };
  });

  ui.presetsList._items = items;
  return items;
}

function duplicatePresetFromUI(presetId, presetName) {
  const result = duplicatePreset(presetId);
  if (result.success) {
    setStatus(`Created copy of "${presetName}"`);
    renderPresetsList();
    refreshPresetDropdown();
    if (ui.presetSelector && result.id) ui.presetSelector.value = result.id;
  } else {
    setStatus('Failed to duplicate preset: ' + (result.error || 'Unknown error'));
  }
  return result;
}

function deletePresetWithConfirm(presetId, presetName) {
  const result = deleteCustomPreset(presetId);
  if (result.success) {
    setStatus(`Preset "${presetName}" deleted`);
    renderPresetsList();
    refreshPresetDropdown();
  } else {
    setStatus('Failed to delete preset: ' + (result.error || 'Unknown error'));
  }
  return result;
}

function applyPresetAndUpdateUI(presetId) {
  const preset = getPresetById(presetId);
  if (!preset) return { success: false, error: 'Preset not found' };

  if (preset.settings) {
    if (preset.settings.sensitivity !== undefined && ui.sensitivitySlider) {
      ui.sensitivitySlider.value = preset.settings.sensitivity;
    }
  }

  setStatus(`Applied preset: ${preset.name}`);
  return { success: true, preset };
}

// =============================================================================
// TEST UTILITIES
// =============================================================================

let testsPassed = 0;
let testsFailed = 0;
const startTime = Date.now();
const performanceMetrics = [];

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

function assertEqual(actual, expected, message) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(`${message}\n  Expected: ${JSON.stringify(expected)}\n  Actual: ${JSON.stringify(actual)}`);
  }
}

function resetState() {
  storage.data = {};
  statusMessages = [];
  Object.keys(mockElements).forEach(k => delete mockElements[k]);
  initUI();
}

async function runTest(name, testFn) {
  const testStart = Date.now();
  try {
    resetState();
    await testFn();
    const elapsed = Date.now() - testStart;
    console.log(`  âœ“ ${name} (${elapsed}ms)`);
    testsPassed++;
    performanceMetrics.push({ name, elapsed, status: 'pass' });
    if (elapsed > 10) {
      console.log(`    âš  Slow test: ${elapsed}ms`);
    }
  } catch (err) {
    const elapsed = Date.now() - testStart;
    console.log(`  âœ— ${name}`);
    console.log(`    Error: ${err.message}`);
    testsFailed++;
    performanceMetrics.push({ name, elapsed, status: 'fail', error: err.message });
  }
}

// =============================================================================
// UI WIRING TESTS
// =============================================================================

async function testUIWiring() {
  console.log('\nðŸ”Œ UI Wiring Tests');
  console.log('=' .repeat(50));

  await runTest('All UI elements are initialized', async () => {
    assert(ui.presetModal, 'presetModal should exist');
    assert(ui.presetNameInput, 'presetNameInput should exist');
    assert(ui.presetDescInput, 'presetDescInput should exist');
    assert(ui.presetEditId, 'presetEditId should exist');
    assert(ui.presetSelectedIcon, 'presetSelectedIcon should exist');
    assert(ui.presetSensitivity, 'presetSensitivity should exist');
    assert(ui.presetThreshold, 'presetThreshold should exist');
    assert(ui.presetSelector, 'presetSelector should exist');
    assert(ui.status, 'status should exist');
  });

  await runTest('showPresetModal initializes form correctly for new preset', async () => {
    ui.sensitivitySlider.value = 75; // Set main UI sensitivity
    showPresetModal();

    assertEqual(ui.presetNameInput.value, '', 'Name should be empty');
    assertEqual(ui.presetDescInput.value, '', 'Description should be empty');
    assertEqual(ui.presetEditId.value, '', 'Edit ID should be empty');
    assertEqual(ui.presetSelectedIcon.value, 'settings', 'Icon should be settings');
    assertEqual(String(ui.presetSensitivity.value), '75', 'Sensitivity should match main UI');
    assertEqual(ui.presetModalTitle.textContent, 'Save Preset', 'Title should be Save Preset');
    assert(!ui.presetModal.classList.contains('hidden'), 'Modal should be visible');
  });

  await runTest('showPresetModal populates form for edit mode', async () => {
    // Create a preset first
    createCustomPreset({
      name: 'Edit Test',
      description: 'For editing',
      icon: 'mic',
      settings: { sensitivity: 80, threshold: -25 }
    });

    showPresetModal('edit-test');

    assertEqual(ui.presetNameInput.value, 'Edit Test', 'Name should be populated');
    assertEqual(ui.presetDescInput.value, 'For editing', 'Description should be populated');
    assertEqual(ui.presetEditId.value, 'edit-test', 'Edit ID should be set');
    assertEqual(ui.presetSelectedIcon.value, 'mic', 'Icon should be mic');
    assertEqual(String(ui.presetSensitivity.value), '80', 'Sensitivity should be from preset');
    assertEqual(String(ui.presetThreshold.value), '-25', 'Threshold should be from preset');
    assertEqual(ui.presetModalTitle.textContent, 'Edit Preset', 'Title should be Edit Preset');
  });

  await runTest('hidePresetModal adds hidden class', async () => {
    showPresetModal();
    assert(!ui.presetModal.classList.contains('hidden'), 'Should be visible');
    hidePresetModal();
    assert(ui.presetModal.classList.contains('hidden'), 'Should be hidden');
  });

  await runTest('savePresetFromModal validates empty name', async () => {
    showPresetModal();
    ui.presetNameInput.value = '';

    const result = savePresetFromModal();

    assert(!result.success, 'Should fail');
    assertEqual(result.error, 'Please enter a preset name', 'Should have correct error');
    assertEqual(ui.presetModalError.style.display, 'block', 'Error should be visible');
  });

  await runTest('savePresetFromModal creates new preset with modal settings', async () => {
    showPresetModal();
    ui.presetNameInput.value = 'New Preset';
    ui.presetDescInput.value = 'Description';
    ui.presetSelectedIcon.value = 'star';
    ui.presetSensitivity.value = '85';
    ui.presetThreshold.value = '-20';

    const result = savePresetFromModal();

    assert(result.success, 'Should succeed');
    const preset = getPresetById(result.id);
    assertEqual(preset.name, 'New Preset', 'Name should match');
    assertEqual(preset.description, 'Description', 'Description should match');
    assertEqual(preset.icon, 'star', 'Icon should match');
    assertEqual(preset.settings.sensitivity, 85, 'Sensitivity should be from modal');
    assertEqual(preset.settings.threshold, -20, 'Threshold should be from modal');
  });

  await runTest('savePresetFromModal updates existing preset', async () => {
    createCustomPreset({ name: 'Update Me', settings: { sensitivity: 50 } });

    showPresetModal('update-me');
    ui.presetNameInput.value = 'Updated Name';
    ui.presetSensitivity.value = '90';

    const result = savePresetFromModal();

    assert(result.success, 'Should succeed');
    const preset = getPresetById('update-me');
    assertEqual(preset.name, 'Updated Name', 'Name should be updated');
    assertEqual(preset.settings.sensitivity, 90, 'Sensitivity should be updated');
  });

  await runTest('refreshPresetDropdown includes all presets', async () => {
    createCustomPreset({ name: 'Custom A' });
    createCustomPreset({ name: 'Custom B' });

    refreshPresetDropdown();

    const presets = getAllPresets();
    assertEqual(presets.length, 8, 'Should have 6 built-in + 2 custom');
  });

  await runTest('renderPresetsList shows correct buttons', async () => {
    createCustomPreset({ name: 'Render Test' });

    const items = renderPresetsList();

    const builtIn = items.find(i => i.id === 'podcast');
    assert(builtIn.hasDuplicate, 'Built-in should have duplicate');
    assert(!builtIn.hasEdit, 'Built-in should not have edit');
    assert(!builtIn.hasDelete, 'Built-in should not have delete');

    const custom = items.find(i => i.id === 'render-test');
    assert(custom.hasDuplicate, 'Custom should have duplicate');
    assert(custom.hasEdit, 'Custom should have edit');
    assert(custom.hasDelete, 'Custom should have delete');
  });
}

// =============================================================================
// WORKFLOW TESTS
// =============================================================================

async function testWorkflows() {
  console.log('\nðŸ”„ Workflow Tests');
  console.log('=' .repeat(50));

  await runTest('Full create preset workflow', async () => {
    // 1. Open modal
    showPresetModal();

    // 2. Fill form
    ui.presetNameInput.value = 'Workflow Preset';
    ui.presetDescInput.value = 'Created via workflow';
    ui.presetSensitivity.value = '70';
    ui.presetThreshold.value = '-28';

    // 3. Save
    const result = savePresetFromModal();
    assert(result.success, 'Should create preset');

    // 4. Verify modal closed
    assert(ui.presetModal.classList.contains('hidden'), 'Modal should close');

    // 5. Verify preset exists
    const preset = getPresetById(result.id);
    assert(preset, 'Preset should exist');
    assertEqual(preset.settings.sensitivity, 70, 'Sensitivity should be saved');

    // 6. Verify status message
    assert(statusMessages.includes('Preset "Workflow Preset" saved'), 'Status should be set');
  });

  await runTest('Full edit preset workflow', async () => {
    // 1. Create preset
    const create = createCustomPreset({ name: 'Edit Workflow', settings: { sensitivity: 50 } });

    // 2. Open edit modal
    showPresetModal(create.id);
    assertEqual(ui.presetNameInput.value, 'Edit Workflow', 'Should populate name');

    // 3. Modify
    ui.presetNameInput.value = 'Edited Workflow';
    ui.presetSensitivity.value = '80';

    // 4. Save
    const result = savePresetFromModal();
    assert(result.success, 'Should update preset');

    // 5. Verify changes
    const preset = getPresetById(create.id);
    assertEqual(preset.name, 'Edited Workflow', 'Name should be updated');
    assertEqual(preset.settings.sensitivity, 80, 'Sensitivity should be updated');
  });

  await runTest('Full duplicate workflow', async () => {
    // 1. Create original
    const original = createCustomPreset({
      name: 'Original',
      description: 'To be copied',
      settings: { sensitivity: 65, threshold: -30 }
    });

    // 2. Duplicate
    const dup = duplicatePresetFromUI(original.id, 'Original');
    assert(dup.success, 'Should duplicate');

    // 3. Verify copy
    const copy = getPresetById(dup.id);
    assertEqual(copy.name, 'Original (Copy)', 'Should have copy suffix');
    assertEqual(copy.settings.sensitivity, 65, 'Should copy settings');
    assertEqual(copy.description, 'To be copied', 'Should copy description');

    // 4. Verify original unchanged
    const orig = getPresetById(original.id);
    assertEqual(orig.name, 'Original', 'Original should be unchanged');
  });

  await runTest('Full delete workflow', async () => {
    // 1. Create preset
    createCustomPreset({ name: 'To Delete' });
    const before = getAllPresets().length;

    // 2. Delete
    deletePresetWithConfirm('to-delete', 'To Delete');

    // 3. Verify deleted
    const after = getAllPresets().length;
    assertEqual(after, before - 1, 'Should have one less preset');
    assert(!getPresetById('to-delete'), 'Preset should not exist');
  });

  await runTest('Apply preset updates UI', async () => {
    createCustomPreset({ name: 'Apply Test', settings: { sensitivity: 75 } });

    applyPresetAndUpdateUI('apply-test');

    assertEqual(String(ui.sensitivitySlider.value), '75', 'Main UI should be updated');
    assert(statusMessages.some(m => m.includes('Applied preset')), 'Status should be set');
  });

  await runTest('Export then import workflow', async () => {
    // 1. Create presets
    createCustomPreset({ name: 'Export A', settings: { sensitivity: 55 } });
    createCustomPreset({ name: 'Export B', settings: { sensitivity: 65 } });

    // 2. Export
    const exported = exportPresets();
    assert(exported.success, 'Should export');
    assertEqual(exported.count, 2, 'Should have 2 presets');

    // 3. Clear and import
    storage.data = {};
    const imported = importPresets(exported.data);
    assert(imported.success, 'Should import');
    assertEqual(imported.imported, 2, 'Should import 2');

    // 4. Verify
    const presetA = getPresetById('export-a');
    assertEqual(presetA.settings.sensitivity, 55, 'Should preserve settings');
  });
}

// =============================================================================
// EDGE CASE TESTS
// =============================================================================

async function testEdgeCases() {
  console.log('\nâš ï¸ Edge Case Tests');
  console.log('=' .repeat(50));

  await runTest('Create preset with very long name', async () => {
    const longName = 'A'.repeat(100);
    showPresetModal();
    ui.presetNameInput.value = longName;

    const result = savePresetFromModal();
    assert(result.success, 'Should create with long name');

    const preset = getPresetById(result.id);
    assertEqual(preset.name, longName, 'Should preserve full name');
  });

  await runTest('Create preset with special characters', async () => {
    showPresetModal();
    ui.presetNameInput.value = 'SpÃ«cial Ch@racters! & More?';

    const result = savePresetFromModal();
    assert(result.success, 'Should create');
    assertEqual(result.id, 'sp-cial-ch-racters-more', 'ID should be slugified');
  });

  await runTest('Handle whitespace-only name', async () => {
    showPresetModal();
    ui.presetNameInput.value = '   ';

    const result = savePresetFromModal();
    assert(!result.success, 'Should fail');
  });

  await runTest('Duplicate same preset multiple times', async () => {
    createCustomPreset({ name: 'Multi Dup' });

    const dup1 = duplicatePreset('multi-dup');
    const dup2 = duplicatePreset('multi-dup');
    const dup3 = duplicatePreset('multi-dup');

    assert(dup1.success && dup2.success && dup3.success, 'All should succeed');

    const copy1 = getPresetById(dup1.id);
    const copy2 = getPresetById(dup2.id);
    const copy3 = getPresetById(dup3.id);

    assertEqual(copy1.name, 'Multi Dup (Copy)', 'First copy');
    assertEqual(copy2.name, 'Multi Dup (Copy 2)', 'Second copy');
    assertEqual(copy3.name, 'Multi Dup (Copy 3)', 'Third copy');
  });

  await runTest('Delete preset while editing', async () => {
    const create = createCustomPreset({ name: 'Delete While Edit' });

    // Open edit modal
    showPresetModal(create.id);

    // Delete the preset
    deleteCustomPreset(create.id);

    // Try to save
    ui.presetNameInput.value = 'Updated Name';
    const result = savePresetFromModal();

    // Should fail because preset no longer exists
    assert(!result.success, 'Should fail to update deleted preset');
  });

  await runTest('Import with invalid JSON shows error', async () => {
    const result = importPresets('not json {{{');
    assert(!result.success, 'Should fail');
    assertEqual(result.error, 'Invalid JSON format', 'Should have correct error');
  });

  await runTest('Import empty array', async () => {
    const result = importPresets(JSON.stringify({ version: 1, presets: [] }));
    // Empty array should succeed with 0 imported
    assert(result.success, 'Should succeed with empty import');
    assertEqual(result.imported, 0, 'Should import 0');
  });

  await runTest('Sensitivity slider boundary values', async () => {
    // Min value test
    showPresetModal();
    ui.presetNameInput.value = 'Boundary Min';
    ui.presetSensitivity.value = 0; // Use number, simulating slider

    let result = savePresetFromModal();
    assert(result.success, 'Should create with min sensitivity');
    let preset = getPresetById(result.id);
    assertEqual(preset.settings.sensitivity, 0, 'Should save 0');

    // Max value test
    showPresetModal();
    ui.presetNameInput.value = 'Boundary Max';
    ui.presetSensitivity.value = 100; // Use number, simulating slider

    result = savePresetFromModal();
    assert(result.success, 'Should create with max sensitivity');
    preset = getPresetById(result.id);
    assertEqual(preset.settings.sensitivity, 100, 'Should save 100');
  });

  await runTest('Threshold boundary values', async () => {
    showPresetModal();
    ui.presetNameInput.value = 'Threshold Test';
    ui.presetThreshold.value = '-60';

    const result = savePresetFromModal();
    const preset = getPresetById(result.id);
    assertEqual(preset.settings.threshold, -60, 'Should save -60');
  });
}

// =============================================================================
// PERFORMANCE TESTS
// =============================================================================

async function testPerformance() {
  console.log('\nâš¡ Performance Tests');
  console.log('=' .repeat(50));

  await runTest('Create 100 presets < 100ms', async () => {
    const start = Date.now();
    for (let i = 0; i < 100; i++) {
      showPresetModal();
      ui.presetNameInput.value = `Perf Preset ${i}`;
      ui.presetSensitivity.value = String(i % 100);
      savePresetFromModal();
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 100, `Should complete in <100ms (was ${elapsed}ms)`);

    const presets = getAllPresets();
    assertEqual(presets.length, 106, 'Should have 6 built-in + 100 custom');
  });

  await runTest('Refresh dropdown with 100 presets < 50ms', async () => {
    // Create 100 presets
    for (let i = 0; i < 100; i++) {
      createCustomPreset({ name: `Refresh Test ${i}` });
    }

    const start = Date.now();
    for (let i = 0; i < 100; i++) {
      refreshPresetDropdown();
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 50, `100 refreshes should complete in <50ms (was ${elapsed}ms)`);
  });

  await runTest('Render list with 100 presets < 50ms', async () => {
    for (let i = 0; i < 100; i++) {
      createCustomPreset({ name: `Render Test ${i}` });
    }

    const start = Date.now();
    for (let i = 0; i < 100; i++) {
      renderPresetsList();
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 50, `100 renders should complete in <50ms (was ${elapsed}ms)`);
  });

  await runTest('Duplicate 50 presets < 50ms', async () => {
    createCustomPreset({ name: 'Dup Source', settings: { sensitivity: 50 } });

    const start = Date.now();
    for (let i = 0; i < 50; i++) {
      duplicatePreset('dup-source');
    }
    const elapsed = Date.now() - start;
    assert(elapsed < 50, `50 duplicates should complete in <50ms (was ${elapsed}ms)`);
  });

  await runTest('Export 100 presets < 20ms', async () => {
    for (let i = 0; i < 100; i++) {
      createCustomPreset({ name: `Export Perf ${i}`, settings: { sensitivity: i } });
    }

    const start = Date.now();
    const result = exportPresets();
    const elapsed = Date.now() - start;

    assert(result.success, 'Should export');
    assert(elapsed < 20, `Export should complete in <20ms (was ${elapsed}ms)`);
  });
}

// =============================================================================
// STATE CONSISTENCY TESTS
// =============================================================================

async function testStateConsistency() {
  console.log('\nðŸ”’ State Consistency Tests');
  console.log('=' .repeat(50));

  await runTest('Dropdown stays in sync after CRUD', async () => {
    refreshPresetDropdown();
    const initial = getAllPresets().length;

    // Create
    createCustomPreset({ name: 'Sync Test' });
    refreshPresetDropdown();
    assertEqual(getAllPresets().length, initial + 1, 'Should add 1');

    // Update
    updateCustomPreset('sync-test', { name: 'Sync Updated' });
    const updated = getPresetById('sync-test');
    assertEqual(updated.name, 'Sync Updated', 'Should be updated');

    // Delete
    deleteCustomPreset('sync-test');
    refreshPresetDropdown();
    assertEqual(getAllPresets().length, initial, 'Should be back to initial');
  });

  await runTest('Modal state resets between opens', async () => {
    // First open and partially fill
    showPresetModal();
    ui.presetNameInput.value = 'Partial';
    ui.presetSensitivity.value = '80';
    hidePresetModal();

    // Second open should be fresh
    showPresetModal();
    assertEqual(ui.presetNameInput.value, '', 'Name should be reset');
    assertEqual(ui.presetEditId.value, '', 'Edit ID should be reset');
  });

  await runTest('Settings persist through export/import', async () => {
    const original = {
      name: 'Persist Test',
      description: 'Full settings',
      icon: 'bolt',
      settings: {
        sensitivity: 77,
        threshold: -25,
        minSilenceLength: 0.3,
        paddingStart: 0.2,
        paddingEnd: 0.15
      }
    };

    createCustomPreset(original);
    const exported = exportPresets();

    storage.data = {};
    importPresets(exported.data);

    const reimported = getPresetById('persist-test');
    assertEqual(reimported.settings.sensitivity, 77, 'Sensitivity preserved');
    assertEqual(reimported.settings.threshold, -25, 'Threshold preserved');
    assertEqual(reimported.settings.minSilenceLength, 0.3, 'minSilenceLength preserved');
    assertEqual(reimported.description, 'Full settings', 'Description preserved');
    assertEqual(reimported.icon, 'bolt', 'Icon preserved');
  });

  await runTest('Order preserved after multiple operations', async () => {
    createCustomPreset({ name: 'Order A' });
    createCustomPreset({ name: 'Order B' });
    createCustomPreset({ name: 'Order C' });

    // Duplicate B
    duplicatePreset('order-b');

    // Delete A
    deleteCustomPreset('order-a');

    // Update C
    updateCustomPreset('order-c', { name: 'Order C Updated' });

    const presets = getAllPresets();
    const customPresets = presets.filter(p => !p.isBuiltIn);

    assertEqual(customPresets.length, 3, 'Should have 3 custom');
    assertEqual(customPresets[0].id, 'order-b', 'B should be first');
    assertEqual(customPresets[1].id, 'order-c', 'C should be second');
    assertEqual(customPresets[2].id, 'order-b-copy', 'Copy should be third');
  });
}

// =============================================================================
// MAIN TEST RUNNER
// =============================================================================

async function runAllTests() {
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ§ª Comprehensive UI E2E Tests');
  console.log('='.repeat(60));

  await testUIWiring();
  await testWorkflows();
  await testEdgeCases();
  await testPerformance();
  await testStateConsistency();

  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ“Š Test Summary');
  console.log('='.repeat(60));
  console.log(`  Total: ${testsPassed + testsFailed}`);
  console.log(`  Passed: ${testsPassed}`);
  console.log(`  Failed: ${testsFailed}`);
  console.log(`  Duration: ${Date.now() - startTime}ms`);

  // Performance analysis
  console.log('\nðŸ“ˆ Performance Analysis');
  console.log('-'.repeat(50));
  const slowTests = performanceMetrics.filter(m => m.elapsed > 5);
  if (slowTests.length > 0) {
    console.log('  Slow tests (>5ms):');
    slowTests.forEach(t => console.log(`    - ${t.name}: ${t.elapsed}ms`));
  } else {
    console.log('  All tests completed quickly (<5ms each)');
  }

  // Bottleneck analysis
  console.log('\nðŸ” Potential Bottlenecks');
  console.log('-'.repeat(50));
  const perfTests = performanceMetrics.filter(m => m.name.includes('Performance') || m.name.includes('100'));
  perfTests.forEach(t => {
    console.log(`  ${t.name}: ${t.elapsed}ms - ${t.status === 'pass' ? 'âœ“ OK' : 'âœ— SLOW'}`);
  });

  if (testsFailed > 0) {
    console.log('\nâŒ Some tests failed!');
    process.exit(1);
  } else {
    console.log('\nâœ… All tests passed!');
    process.exit(0);
  }
}

process.on('exit', () => {
  console.warn = originalWarn;
});

runAllTests().catch(err => {
  console.error('Test runner error:', err);
  process.exit(1);
});
