/**
 * Side Profile Normalization Utilities
 *
 * Normalizes side profile images and landmarks using rotation-based alignment.
 * Uses landmark indices 10, 26, 75 as rotation reference points for consistent
 * orientation across all side profile measurements.
 *
 * Rotation Algorithm:
 * - Uses landmark indices 10, 26, 75 for rotation calculation
 * - Left profile: rotate based on landmarks[75] → landmarks[26]
 * - Right profile: rotate based on landmarks[10] → landmarks[26]
 * - Pivot point: landmarks[10] for right, landmarks[26] for left
 * - Crops to 1024×1024 with 1.12 scale factor and 0.65 height ratio
 */

export interface Point2D {
    x: number;
    y: number;
}

export interface SideProfileNormalizationResult {
    /** Rotation angle applied (in radians) */
    rotationAngle: number;
    /** Rotation angle in degrees */
    rotationAngleDeg: number;
    /** Direction the face is pointing */
    direction: 'left' | 'right';
    /** Pivot point used for rotation */
    pivot: Point2D;
    /** Rotated landmarks */
    rotatedLandmarks: Array<{ id: string; x: number; y: number }>;
    /** Rotated image as data URL (if image provided) */
    rotatedImageUrl?: string;
    /** Crop info */
    cropInfo: {
        x: number;
        y: number;
        size: number;
        scale: number;
    };
}

/**
 * Landmark indices used for rotation calculation
 *
 * These correspond to face contour positions used as rotation reference points:
 * - Index 10: Upper face contour (forehead/temple area) - right anchor
 * - Index 26: Mid-face contour (jaw level) - common reference
 * - Index 75: Upper face contour (mirrored) - left anchor
 *
 * InsightFace 106 landmark mapping:
 * - Index 10 → InsightFace contour point ~9-10 (right side)
 * - Index 26 → InsightFace contour point ~25-26 (mid contour)
 * - Index 75 → InsightFace right eye area ~71-75
 */

/**
 * Calculate rotation angle for side profile normalization
 *
 * Uses landmark indices 10, 26, 75 to determine the rotation needed
 * to normalize the profile orientation.
 *
 * @param landmarks - Raw landmarks array from API
 * @param direction - Face direction ("left" or "right")
 * @returns Rotation angle in radians
 */
export function calculateRotationAngle(
    landmarks: Array<{ x: number; y: number }>,
    direction: 'left' | 'right'
): number {
    // Select anchor and reference points based on face direction
    // Left profile: landmarks[75] → landmarks[26]
    // Right profile: landmarks[10] → landmarks[26]
    const anchor = direction === 'left' ? landmarks[75] : landmarks[10];
    const reference = landmarks[26];

    if (!anchor || !reference) {
        console.warn('[Side Profile] Missing landmark indices 10, 26, or 75');
        return 0;
    }

    const angle = Math.atan2(reference.y - anchor.y, reference.x - anchor.x);
    return angle;
}

/**
 * Get the rotation pivot point for side profile normalization
 *
 * @param landmarks - Raw landmarks array
 * @param direction - Face direction
 * @returns Pivot point coordinates
 */
export function getRotationPivot(
    landmarks: Array<{ x: number; y: number }>,
    direction: 'left' | 'right'
): Point2D {
    // Right profile: pivot at landmarks[10]
    // Left profile: pivot at landmarks[26]
    const pivotLandmark = direction === 'right' ? landmarks[10] : landmarks[26];

    if (!pivotLandmark) {
        return { x: 0.5, y: 0.5 };
    }

    return { x: pivotLandmark.x, y: pivotLandmark.y };
}

/**
 * Rotate a point around a pivot point
 *
 * Uses standard 2D rotation matrix with negative angle to match
 * the expected orientation correction.
 *
 * @param point - Point to rotate
 * @param pivot - Pivot point for rotation
 * @param angleRad - Rotation angle in radians
 * @returns Rotated point coordinates
 */
export function rotatePoint(
    point: Point2D,
    pivot: Point2D,
    angleRad: number
): Point2D {
    // Rotate by negative angle for correct orientation
    const negAngle = -angleRad;
    const sin = Math.sin(negAngle);
    const cos = Math.cos(negAngle);

    const dx = point.x - pivot.x;
    const dy = point.y - pivot.y;

    return {
        x: pivot.x + dx * cos - dy * sin,
        y: pivot.y + dx * sin + dy * cos,
    };
}

/**
 * Calculate crop dimensions for side profile normalization
 *
 * Crop calculation:
 * - croppedHeight = bboxHeight * 1.12
 * - cropSize = croppedHeight / 0.65
 * - Constrained between 32 and 2 * max(width, height)
 *
 * @param bboxHeight - Bounding box height
 * @param imageWidth - Image width
 * @param imageHeight - Image height
 * @returns Calculated crop size
 */
export function calculateCropSize(
    bboxHeight: number,
    imageWidth: number,
    imageHeight: number
): number {
    const scaledHeight = bboxHeight * 1.12;
    const cropSize = scaledHeight / 0.65;

    // Apply size constraints
    const minSize = 32;
    const maxSize = 2 * Math.max(imageWidth, imageHeight);

    return Math.min(Math.max(minSize, cropSize), maxSize);
}

/**
 * Apply side profile normalization to named landmarks
 *
 * This function works with named landmark format and applies
 * rotation-based normalization.
 *
 * @param namedLandmarks - Landmarks as { id: string; x: number; y: number }[]
 * @param rawLandmarks - Raw landmark array (for indices 10, 26, 75)
 * @param direction - Face direction
 * @param bbox - Bounding box for crop calculation
 */
export function applySideProfileNormalization(
    namedLandmarks: Array<{ id: string; x: number; y: number }>,
    rawLandmarks: Array<{ x: number; y: number }>,
    direction: 'left' | 'right',
    bbox?: { x: number; y: number; width: number; height: number }
): SideProfileNormalizationResult {
    // Calculate rotation angle
    const rotationAngle = calculateRotationAngle(rawLandmarks, direction);
    const rotationAngleDeg = rotationAngle * (180 / Math.PI);

    // Get pivot point
    const pivot = getRotationPivot(rawLandmarks, direction);

    // Skip rotation if angle is very small (< 2 degrees)
    if (Math.abs(rotationAngleDeg) < 2) {
        return {
            rotationAngle: 0,
            rotationAngleDeg: 0,
            direction,
            pivot,
            rotatedLandmarks: namedLandmarks,
            cropInfo: {
                x: 0,
                y: 0,
                size: 1024,
                scale: 1,
            },
        };
    }

    // Rotate all named landmarks
    const rotatedLandmarks = namedLandmarks.map(landmark => {
        const rotated = rotatePoint(
            { x: landmark.x, y: landmark.y },
            pivot,
            rotationAngle
        );
        return {
            id: landmark.id,
            x: rotated.x,
            y: rotated.y,
        };
    });

    // Calculate crop info
    const cropSize = bbox
        ? calculateCropSize(bbox.height, 1, 1)  // Normalized
        : 1024;

    console.log(`[Side Profile] Direction: ${direction}, Rotation: ${rotationAngleDeg.toFixed(1)}°`);

    return {
        rotationAngle,
        rotationAngleDeg,
        direction,
        pivot,
        rotatedLandmarks,
        cropInfo: {
            x: pivot.x - cropSize / 2,
            y: pivot.y - cropSize / 2,
            size: cropSize,
            scale: 1024 / cropSize,
        },
    };
}

/**
 * Apply side profile rotation to landmarks
 *
 * This function requires raw landmarks and direction for accurate rotation.
 * Rotation is applied in pixel coordinates before normalization to preserve precision.
 *
 * @param landmarks - Named landmarks from detection (in pixel coordinates)
 * @param rawLandmarks - Raw landmark array (REQUIRED - must have 106 landmarks)
 * @param direction - Face direction (REQUIRED - 'left' or 'right')
 * @returns Normalized landmarks (still in pixel coordinates)
 * @throws Error if raw landmarks or direction missing
 */
export function applySideProfileRotation(
    landmarks: Array<{ id: string; x: number; y: number }>,
    rawLandmarks?: Array<{ x: number; y: number }>,
    direction?: 'left' | 'right'
): Array<{ id: string; x: number; y: number }> {
    // Raw landmarks required for rotation calculation
    if (!rawLandmarks || rawLandmarks.length < 76 || !direction) {
        console.error('[Side Profile] CRITICAL: Missing raw landmarks or direction');
        console.error('[Side Profile] rawLandmarks length:', rawLandmarks?.length);
        console.error('[Side Profile] direction:', direction);
        throw new Error(
            'Side profile normalization requires raw landmarks (106) and direction. ' +
            'Ensure InsightFace detection returned rawLandmarks array.'
        );
    }

    const result = applySideProfileNormalization(landmarks, rawLandmarks, direction);
    return result.rotatedLandmarks;
}

/**
 * Fallback to Frankfort plane-based correction
 * when raw landmark indices are not available
 */
function applyFrankfortCorrectionFallback(
    landmarks: Array<{ id: string; x: number; y: number }>
): Array<{ id: string; x: number; y: number }> {
    const orbitale = landmarks.find(l => l.id === 'orbitale');
    const porion = landmarks.find(l => l.id === 'porion');

    if (!orbitale || !porion) {
        return landmarks;
    }

    // Calculate Frankfort angle
    const dx = porion.x - orbitale.x;
    const dy = porion.y - orbitale.y;
    const angle = Math.atan2(dy, dx);

    if (Math.abs(angle) < 0.035) { // ~2 degrees
        return landmarks;
    }

    const pivot: Point2D = {
        x: (orbitale.x + porion.x) / 2,
        y: (orbitale.y + porion.y) / 2,
    };

    return landmarks.map(landmark => {
        const cos = Math.cos(-angle);
        const sin = Math.sin(-angle);
        const dx = landmark.x - pivot.x;
        const dy = landmark.y - pivot.y;

        return {
            id: landmark.id,
            x: pivot.x + dx * cos - dy * sin,
            y: pivot.y + dx * sin + dy * cos,
        };
    });
}

/**
 * Rotate image to match normalized landmarks
 *
 * Creates a 1024×1024 standardized output with the same rotation
 * applied to landmarks for consistent visualization.
 *
 * @param imageUrl - Source image URL
 * @param rawLandmarks - Raw landmark array (106 points)
 * @param direction - Face direction
 * @param bbox - Face bounding box
 * @returns Rotated image as data URL
 */
export async function rotateSideProfileImage(
    imageUrl: string,
    rawLandmarks: Array<{ x: number; y: number }>,
    direction: 'left' | 'right',
    bbox: { x: number; y: number; width: number; height: number }
): Promise<string> {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            if (!ctx) {
                reject(new Error('Canvas context unavailable'));
                return;
            }

            // Standardized 1024×1024 output
            const OUTPUT_SIZE = 1024;
            canvas.width = OUTPUT_SIZE;
            canvas.height = OUTPUT_SIZE;

            // Calculate rotation
            const rotationAngle = calculateRotationAngle(rawLandmarks, direction);
            const pivot = getRotationPivot(rawLandmarks, direction);

            // Calculate crop size
            const cropSize = calculateCropSize(
                bbox.height * img.height,
                img.width,
                img.height
            );

            const scale = OUTPUT_SIZE / cropSize;

            // Transform canvas
            ctx.translate(OUTPUT_SIZE / 2, OUTPUT_SIZE / 2);
            ctx.rotate(-rotationAngle);
            ctx.scale(scale, scale);
            ctx.translate(
                -pivot.x * img.width,
                -pivot.y * img.height
            );

            // Draw image
            ctx.drawImage(img, 0, 0);

            resolve(canvas.toDataURL('image/jpeg', 0.9));
        };

        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = imageUrl;
    });
}

// ============================================
// LEGACY EXPORTS FOR BACKWARD COMPATIBILITY
// ============================================

// Keep the old function name as an alias
export { applyFrankfortCorrectionFallback as applyFrankfortCorrection };

// Re-export with old names for compatibility
export function normalizeLandmarksToFrankfort(
    landmarks: Array<{ id: string; x: number; y: number }>
) {
    return {
        rotationAngle: 0,
        originalFrankfortAngle: 0,
        rotatedLandmarks: applyFrankfortCorrectionFallback(landmarks),
        rotationCenter: { x: 0.5, y: 0.5 },
    };
}
