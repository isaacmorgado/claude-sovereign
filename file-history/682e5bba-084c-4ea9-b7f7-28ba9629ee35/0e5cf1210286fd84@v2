#!/usr/bin/env node

/**
 * Unified Website Cloner - Intelligently chooses between Playwright and Python approaches
 *
 * - Playwright: For SPAs, JS-heavy sites, sites requiring interaction
 * - Python: For static sites, faster bulk downloading
 */

const { chromium } = require('playwright');
const { program } = require('commander');
const chalk = require('chalk');
const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs').promises;

const PYTHON_DOWNLOADER = path.join(__dirname, '..', '..', 'WEBSITE_DOWNLOADER', 'website-downloader.py');

class UnifiedCloner {
  constructor(options) {
    this.options = options;
    this.siteAnalysis = null;
  }

  log(message, type = 'info') {
    const prefix = {
      info: chalk.blue('[INFO]'),
      success: chalk.green('[OK]'),
      warn: chalk.yellow('[WARN]'),
      error: chalk.red('[ERROR]'),
      detect: chalk.magenta('[DETECT]'),
    };
    console.log(`${prefix[type] || prefix.info} ${message}`);
  }

  /**
   * Analyze the site to determine the best approach
   */
  async analyzeSite() {
    this.log('Analyzing site to determine best approach...', 'detect');

    const browser = await chromium.launch({ headless: true });
    const page = await browser.newPage();

    const analysis = {
      url: this.options.url,
      isSpa: false,
      hasReact: false,
      hasVue: false,
      hasAngular: false,
      hasNextJs: false,
      hasNuxt: false,
      requiresJs: false,
      hasInfiniteScroll: false,
      hasModals: false,
      hasDynamicContent: false,
      hasCookieConsent: false,
      jsFramework: 'none',
      recommendedApproach: 'static',
      reasons: [],
    };

    try {
      // First, fetch with JS disabled to see if content loads
      await page.setJavaScriptEnabled(false);
      await page.goto(this.options.url, { waitUntil: 'domcontentloaded', timeout: 15000 });
      const noJsContent = await page.content();
      const noJsText = await page.evaluate(() => document.body?.innerText?.length || 0);

      // Then fetch with JS enabled
      await page.setJavaScriptEnabled(true);
      await page.goto(this.options.url, { waitUntil: 'networkidle', timeout: 30000 });
      await page.waitForTimeout(2000); // Wait for JS to render

      const withJsContent = await page.content();
      const withJsText = await page.evaluate(() => document.body?.innerText?.length || 0);

      // Compare content length - if much more with JS, site requires JS
      if (withJsText > noJsText * 1.5) {
        analysis.requiresJs = true;
        analysis.reasons.push('Content significantly increases with JavaScript enabled');
      }

      // Detect frameworks
      const frameworks = await page.evaluate(() => {
        return {
          react: !!(window.React || window.__REACT_DEVTOOLS_GLOBAL_HOOK__ || document.querySelector('[data-reactroot]')),
          vue: !!(window.Vue || window.__VUE__ || document.querySelector('[data-v-]')),
          angular: !!(window.angular || window.ng || document.querySelector('[ng-app]') || document.querySelector('[ng-controller]')),
          nextJs: !!window.__NEXT_DATA__,
          nuxt: !!window.__NUXT__,
          svelte: !!document.querySelector('[class*="svelte-"]'),
          ember: !!window.Ember,
        };
      });

      if (frameworks.react) { analysis.hasReact = true; analysis.jsFramework = 'React'; }
      if (frameworks.vue) { analysis.hasVue = true; analysis.jsFramework = 'Vue'; }
      if (frameworks.angular) { analysis.hasAngular = true; analysis.jsFramework = 'Angular'; }
      if (frameworks.nextJs) { analysis.hasNextJs = true; analysis.jsFramework = 'Next.js'; analysis.isSpa = true; }
      if (frameworks.nuxt) { analysis.hasNuxt = true; analysis.jsFramework = 'Nuxt.js'; analysis.isSpa = true; }
      if (frameworks.svelte) { analysis.jsFramework = 'Svelte'; }
      if (frameworks.ember) { analysis.jsFramework = 'Ember'; }

      if (analysis.jsFramework !== 'none') {
        analysis.reasons.push(`Detected ${analysis.jsFramework} framework`);
      }

      // Check for SPA indicators
      const spaIndicators = await page.evaluate(() => {
        return {
          hasRouterLinks: document.querySelectorAll('a[href^="#/"], [routerlink], [ng-href]').length > 0,
          hasAppRoot: !!(document.getElementById('app') || document.getElementById('root') || document.getElementById('__next')),
          hasHistoryApi: typeof history.pushState === 'function',
          linkCount: document.querySelectorAll('a[href]').length,
          internalLinkCount: Array.from(document.querySelectorAll('a[href]')).filter(a =>
            a.href.startsWith(window.location.origin) || a.href.startsWith('/')
          ).length,
        };
      });

      if (spaIndicators.hasRouterLinks) {
        analysis.isSpa = true;
        analysis.reasons.push('Uses client-side routing');
      }

      // Check for dynamic content patterns
      const dynamicPatterns = await page.evaluate(() => {
        return {
          infiniteScroll: !!(document.querySelector('[data-infinite]') || document.querySelector('.infinite-scroll') || document.querySelector('[class*="load-more"]')),
          modals: document.querySelectorAll('[data-toggle="modal"], [data-bs-toggle="modal"], .modal, [role="dialog"]').length > 0,
          dropdowns: document.querySelectorAll('.dropdown, [data-toggle="dropdown"], [aria-haspopup="true"]').length > 0,
          tabs: document.querySelectorAll('[role="tab"], .nav-tabs').length > 0,
          accordion: document.querySelectorAll('.accordion, [data-toggle="collapse"]').length > 0,
          cookieConsent: !!(document.querySelector('[class*="cookie"]') || document.querySelector('[class*="consent"]') || document.querySelector('[class*="gdpr"]')),
        };
      });

      analysis.hasInfiniteScroll = dynamicPatterns.infiniteScroll;
      analysis.hasModals = dynamicPatterns.modals;
      analysis.hasCookieConsent = dynamicPatterns.cookieConsent;
      analysis.hasDynamicContent = dynamicPatterns.dropdowns || dynamicPatterns.tabs || dynamicPatterns.accordion;

      if (analysis.hasInfiniteScroll) analysis.reasons.push('Has infinite scroll');
      if (analysis.hasModals) analysis.reasons.push('Has modal dialogs');
      if (analysis.hasDynamicContent) analysis.reasons.push('Has interactive elements (dropdowns/tabs/accordions)');

      // Determine recommendation
      const playwrightScore =
        (analysis.isSpa ? 3 : 0) +
        (analysis.requiresJs ? 2 : 0) +
        (analysis.hasReact || analysis.hasVue || analysis.hasAngular ? 2 : 0) +
        (analysis.hasInfiniteScroll ? 1 : 0) +
        (analysis.hasModals ? 1 : 0) +
        (analysis.hasDynamicContent ? 1 : 0);

      if (playwrightScore >= 2) {
        analysis.recommendedApproach = 'playwright';
      }

    } catch (error) {
      this.log(`Analysis error: ${error.message}`, 'warn');
      // Default to playwright on error (safer for unknown sites)
      analysis.recommendedApproach = 'playwright';
      analysis.reasons.push('Could not fully analyze site - defaulting to Playwright');
    }

    await browser.close();
    this.siteAnalysis = analysis;
    return analysis;
  }

  /**
   * Run the Playwright-based cloner
   */
  async runPlaywright() {
    this.log('Using Playwright cloner for JS-heavy site...', 'info');

    const clonePath = path.join(__dirname, 'clone.js');
    const args = [
      clonePath,
      `--url=${this.options.url}`,
      `--depth=${this.options.depth}`,
      `--delay=${this.options.delay}`,
      `--output=${this.options.output}`,
      `--max-pages=${this.options.maxPages}`,
    ];

    if (this.options.interactive) args.push('--interactive');
    if (this.options.headed) args.push('--headed');
    if (this.options.screenshots) args.push('--screenshots');
    if (this.options.login) args.push(`--login=${this.options.login}`);
    if (this.options.exclude) args.push(`--exclude=${this.options.exclude}`);

    return new Promise((resolve, reject) => {
      const proc = spawn('node', args, {
        stdio: 'inherit',
        cwd: __dirname,
      });

      proc.on('close', (code) => {
        if (code === 0) resolve();
        else reject(new Error(`Playwright cloner exited with code ${code}`));
      });

      proc.on('error', reject);
    });
  }

  /**
   * Run the Python static downloader
   */
  async runPythonDownloader() {
    this.log('Using Python downloader for static site (faster)...', 'info');

    // Check if Python downloader exists
    try {
      await fs.access(PYTHON_DOWNLOADER);
    } catch {
      this.log('Python downloader not found, falling back to Playwright', 'warn');
      return this.runPlaywright();
    }

    const args = [
      PYTHON_DOWNLOADER,
      `--url=${this.options.url}`,
      `--destination=${this.options.output}`,
      `--max-pages=${this.options.maxPages}`,
      `--threads=${this.options.threads || 6}`,
    ];

    return new Promise((resolve, reject) => {
      const proc = spawn('python3', args, {
        stdio: 'inherit',
        cwd: __dirname,
      });

      proc.on('close', (code) => {
        if (code === 0) resolve();
        else reject(new Error(`Python downloader exited with code ${code}`));
      });

      proc.on('error', (err) => {
        this.log(`Python error: ${err.message}, falling back to Playwright`, 'warn');
        this.runPlaywright().then(resolve).catch(reject);
      });
    });
  }

  /**
   * Print site analysis results
   */
  printAnalysis() {
    const a = this.siteAnalysis;
    console.log(chalk.bold.cyan('\n========================================'));
    console.log(chalk.bold.cyan('  Site Analysis Results'));
    console.log(chalk.bold.cyan('========================================\n'));

    console.log(chalk.white(`  URL:              ${a.url}`));
    console.log(chalk.white(`  JS Framework:     ${a.jsFramework}`));
    console.log(chalk.white(`  Is SPA:           ${a.isSpa ? chalk.yellow('Yes') : 'No'}`));
    console.log(chalk.white(`  Requires JS:      ${a.requiresJs ? chalk.yellow('Yes') : 'No'}`));
    console.log(chalk.white(`  Infinite Scroll:  ${a.hasInfiniteScroll ? 'Yes' : 'No'}`));
    console.log(chalk.white(`  Has Modals:       ${a.hasModals ? 'Yes' : 'No'}`));
    console.log(chalk.white(`  Cookie Consent:   ${a.hasCookieConsent ? 'Yes' : 'No'}`));

    if (a.reasons.length > 0) {
      console.log(chalk.white('\n  Detection reasons:'));
      a.reasons.forEach(r => console.log(chalk.gray(`    - ${r}`)));
    }

    console.log(chalk.bold.green(`\n  Recommended:      ${a.recommendedApproach.toUpperCase()}`));
    console.log('');
  }

  /**
   * Main entry point
   */
  async clone() {
    console.log(chalk.bold.cyan('\n========================================'));
    console.log(chalk.bold.cyan('  Unified Website Cloner'));
    console.log(chalk.bold.cyan('========================================\n'));

    // Force mode if specified
    if (this.options.mode === 'playwright') {
      this.log('Forcing Playwright mode', 'info');
      return this.runPlaywright();
    }

    if (this.options.mode === 'static') {
      this.log('Forcing static (Python) mode', 'info');
      return this.runPythonDownloader();
    }

    // Auto-detect
    if (!this.options.skipAnalysis) {
      const analysis = await this.analyzeSite();
      this.printAnalysis();

      if (this.options.analyzeOnly) {
        return;
      }

      if (analysis.recommendedApproach === 'playwright') {
        return this.runPlaywright();
      } else {
        return this.runPythonDownloader();
      }
    }

    // Default to Playwright if analysis skipped
    return this.runPlaywright();
  }
}

// CLI
program
  .name('unified-cloner')
  .description('Unified website cloner - auto-selects best approach')
  .version('1.0.0')
  .requiredOption('-u, --url <url>', 'Starting URL to clone')
  .option('-d, --depth <number>', 'Maximum crawl depth', '3')
  .option('-D, --delay <ms>', 'Delay between requests', '500')
  .option('-o, --output <dir>', 'Output directory', './site-clone')
  .option('-m, --max-pages <number>', 'Maximum pages to crawl', '100')
  .option('-t, --threads <number>', 'Threads for static downloader', '6')
  .option('--mode <mode>', 'Force mode: playwright or static')
  .option('-i, --interactive', 'Interactive mode (Playwright only)')
  .option('-H, --headed', 'Show browser (Playwright only)')
  .option('-s, --screenshots', 'Take screenshots (Playwright only)')
  .option('-l, --login <creds>', 'Login credentials (Playwright only)')
  .option('-e, --exclude <patterns>', 'URL patterns to exclude')
  .option('--analyze-only', 'Only analyze site, don\'t clone')
  .option('--skip-analysis', 'Skip analysis, use Playwright')
  .parse();

const options = program.opts();

// Validate URL
try {
  new URL(options.url);
} catch {
  console.error(chalk.red('Error: Invalid URL provided'));
  process.exit(1);
}

// Run
const cloner = new UnifiedCloner(options);
cloner.clone().catch(error => {
  console.error(chalk.red(`Error: ${error.message}`));
  process.exit(1);
});
