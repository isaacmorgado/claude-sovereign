/**
 * JavaScript Deobfuscator - Pure JS implementation using Babel
 *
 * Handles common obfuscation patterns:
 * - String array decoding (obfuscator.io style)
 * - Hex/unicode escape sequences
 * - Dead code elimination
 * - Constant folding
 * - Control flow unflattening (basic)
 * - eval() unpacking
 */

const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;
const t = require('@babel/types');

class Deobfuscator {
  constructor(options = {}) {
    this.options = {
      maxIterations: options.maxIterations || 5,
      decodeStrings: options.decodeStrings !== false,
      simplifyExpressions: options.simplifyExpressions !== false,
      removeDeadCode: options.removeDeadCode !== false,
      ...options
    };
    this.stats = {
      stringsDecoded: 0,
      expressionsSimplified: 0,
      deadCodeRemoved: 0,
      hexDecoded: 0,
    };
  }

  /**
   * Main deobfuscation entry point
   */
  deobfuscate(code) {
    let result = code;
    let changed = true;
    let iterations = 0;

    while (changed && iterations < this.options.maxIterations) {
      const before = result;
      result = this.runTransforms(result);
      changed = result !== before;
      iterations++;
    }

    return {
      code: result,
      stats: this.stats,
      iterations
    };
  }

  /**
   * Run all transformation passes
   */
  runTransforms(code) {
    let ast;
    try {
      ast = parser.parse(code, {
        sourceType: 'unambiguous',
        allowReturnOutsideFunction: true,
        allowAwaitOutsideFunction: true,
        plugins: ['jsx', 'typescript', 'decorators-legacy'],
        errorRecovery: true,
      });
    } catch (e) {
      // If parsing fails, return original code
      return code;
    }

    // Apply transformations
    this.decodeHexStrings(ast);
    this.decodeUnicodeStrings(ast);
    this.foldConstants(ast);
    this.simplifyBinaryExpressions(ast);
    this.decodeStringArray(ast);
    this.removeDeadCode(ast);
    this.simplifyConditionals(ast);
    this.inlineConstants(ast);

    try {
      return generate(ast, {
        comments: false,
        compact: false,
        concise: false,
      }).code;
    } catch (e) {
      return code;
    }
  }

  /**
   * Decode hex escape sequences: "\x48\x65\x6c\x6c\x6f" -> "Hello"
   */
  decodeHexStrings(ast) {
    traverse(ast, {
      StringLiteral: (path) => {
        const { value } = path.node;
        if (/\\x[0-9a-fA-F]{2}/.test(path.node.extra?.raw || '')) {
          try {
            const decoded = value; // Babel already decodes it
            if (decoded !== value) {
              path.node.value = decoded;
              this.stats.hexDecoded++;
            }
          } catch (e) {}
        }
      }
    });
  }

  /**
   * Decode unicode escape sequences: "\u0048\u0065\u006c\u006c\u006f" -> "Hello"
   */
  decodeUnicodeStrings(ast) {
    traverse(ast, {
      StringLiteral: (path) => {
        const raw = path.node.extra?.raw || '';
        if (/\\u[0-9a-fA-F]{4}/.test(raw)) {
          // Babel already decodes unicode, just mark as decoded
          this.stats.stringsDecoded++;
        }
      }
    });
  }

  /**
   * Fold constant expressions: 1 + 2 -> 3, "a" + "b" -> "ab"
   */
  foldConstants(ast) {
    traverse(ast, {
      BinaryExpression: (path) => {
        const { left, right, operator } = path.node;

        // String concatenation
        if (operator === '+' && t.isStringLiteral(left) && t.isStringLiteral(right)) {
          path.replaceWith(t.stringLiteral(left.value + right.value));
          this.stats.expressionsSimplified++;
          return;
        }

        // Numeric operations
        if (t.isNumericLiteral(left) && t.isNumericLiteral(right)) {
          let result;
          switch (operator) {
            case '+': result = left.value + right.value; break;
            case '-': result = left.value - right.value; break;
            case '*': result = left.value * right.value; break;
            case '/': result = left.value / right.value; break;
            case '%': result = left.value % right.value; break;
            case '**': result = left.value ** right.value; break;
            case '|': result = left.value | right.value; break;
            case '&': result = left.value & right.value; break;
            case '^': result = left.value ^ right.value; break;
            case '<<': result = left.value << right.value; break;
            case '>>': result = left.value >> right.value; break;
            case '>>>': result = left.value >>> right.value; break;
            default: return;
          }
          if (typeof result === 'number' && isFinite(result)) {
            path.replaceWith(t.numericLiteral(result));
            this.stats.expressionsSimplified++;
          }
        }
      }
    });
  }

  /**
   * Simplify binary expressions with known patterns
   */
  simplifyBinaryExpressions(ast) {
    traverse(ast, {
      UnaryExpression: (path) => {
        const { operator, argument } = path.node;

        // !0 -> true, !1 -> false, !"" -> true
        if (operator === '!') {
          if (t.isNumericLiteral(argument)) {
            path.replaceWith(t.booleanLiteral(!argument.value));
            this.stats.expressionsSimplified++;
          } else if (t.isStringLiteral(argument)) {
            path.replaceWith(t.booleanLiteral(!argument.value));
            this.stats.expressionsSimplified++;
          }
        }

        // void 0 -> undefined
        if (operator === 'void' && t.isNumericLiteral(argument) && argument.value === 0) {
          path.replaceWith(t.identifier('undefined'));
          this.stats.expressionsSimplified++;
        }
      },

      // typeof "string" -> "string"
      UnaryExpression: (path) => {
        if (path.node.operator === 'typeof' && t.isStringLiteral(path.node.argument)) {
          path.replaceWith(t.stringLiteral('string'));
          this.stats.expressionsSimplified++;
        }
      }
    });
  }

  /**
   * Detect and decode string array patterns (obfuscator.io style)
   * var _0x1234 = ["Hello", "World"]; ... _0x1234[0] -> "Hello"
   */
  decodeStringArray(ast) {
    const stringArrays = new Map();

    // First pass: find string arrays
    traverse(ast, {
      VariableDeclarator: (path) => {
        if (t.isIdentifier(path.node.id) && t.isArrayExpression(path.node.init)) {
          const elements = path.node.init.elements;
          if (elements.length > 0 && elements.every(el => t.isStringLiteral(el))) {
            stringArrays.set(path.node.id.name, elements.map(el => el.value));
          }
        }
      }
    });

    // Second pass: replace array accesses with actual strings
    if (stringArrays.size > 0) {
      traverse(ast, {
        MemberExpression: (path) => {
          if (
            t.isIdentifier(path.node.object) &&
            stringArrays.has(path.node.object.name) &&
            t.isNumericLiteral(path.node.property)
          ) {
            const arr = stringArrays.get(path.node.object.name);
            const index = path.node.property.value;
            if (index >= 0 && index < arr.length) {
              path.replaceWith(t.stringLiteral(arr[index]));
              this.stats.stringsDecoded++;
            }
          }
        },

        // Also handle _0x1234['push'], _0x1234['shift'] style access
        CallExpression: (path) => {
          if (
            t.isMemberExpression(path.node.callee) &&
            t.isIdentifier(path.node.callee.object) &&
            stringArrays.has(path.node.callee.object.name)
          ) {
            // Skip - this is array manipulation, not access
          }
        }
      });
    }
  }

  /**
   * Remove dead code (unreachable statements)
   */
  removeDeadCode(ast) {
    traverse(ast, {
      // if (false) { ... } -> remove
      IfStatement: (path) => {
        if (t.isBooleanLiteral(path.node.test)) {
          if (path.node.test.value === false) {
            if (path.node.alternate) {
              path.replaceWith(path.node.alternate);
            } else {
              path.remove();
            }
            this.stats.deadCodeRemoved++;
          } else if (path.node.test.value === true) {
            path.replaceWith(path.node.consequent);
            this.stats.deadCodeRemoved++;
          }
        }
      },

      // while (false) { ... } -> remove
      WhileStatement: (path) => {
        if (t.isBooleanLiteral(path.node.test) && path.node.test.value === false) {
          path.remove();
          this.stats.deadCodeRemoved++;
        }
      },

      // Remove empty statements
      EmptyStatement: (path) => {
        path.remove();
      }
    });
  }

  /**
   * Simplify conditional expressions
   */
  simplifyConditionals(ast) {
    traverse(ast, {
      // condition ? a : a -> a
      ConditionalExpression: (path) => {
        const { consequent, alternate } = path.node;
        if (generate(consequent).code === generate(alternate).code) {
          path.replaceWith(consequent);
          this.stats.expressionsSimplified++;
        }
      },

      // true ? a : b -> a, false ? a : b -> b
      ConditionalExpression: (path) => {
        if (t.isBooleanLiteral(path.node.test)) {
          path.replaceWith(path.node.test.value ? path.node.consequent : path.node.alternate);
          this.stats.expressionsSimplified++;
        }
      }
    });
  }

  /**
   * Inline simple constants
   */
  inlineConstants(ast) {
    const constants = new Map();

    // Find const declarations with literal values
    traverse(ast, {
      VariableDeclarator: (path) => {
        if (
          path.parent.kind === 'const' &&
          t.isIdentifier(path.node.id) &&
          (t.isStringLiteral(path.node.init) || t.isNumericLiteral(path.node.init) || t.isBooleanLiteral(path.node.init))
        ) {
          constants.set(path.node.id.name, path.node.init);
        }
      }
    });

    // Replace references (simple cases only)
    if (constants.size > 0) {
      traverse(ast, {
        Identifier: (path) => {
          if (
            constants.has(path.node.name) &&
            !path.parentPath.isVariableDeclarator({ id: path.node }) &&
            !path.parentPath.isAssignmentExpression({ left: path.node }) &&
            !path.parentPath.isMemberExpression({ property: path.node }) &&
            !path.parentPath.isObjectProperty({ key: path.node })
          ) {
            const literal = constants.get(path.node.name);
            path.replaceWith(t.cloneNode(literal));
            this.stats.expressionsSimplified++;
          }
        }
      });
    }
  }

  /**
   * Check if code appears to be obfuscated
   */
  static isObfuscated(code) {
    const indicators = [
      /var _0x[a-f0-9]+\s*=/i,                    // obfuscator.io variable names
      /_0x[a-f0-9]+\[['"]push['"]\]/i,           // array manipulation
      /\['\\x[0-9a-f]{2}/i,                       // hex string access
      /eval\s*\(\s*function\s*\(\s*\w+\s*,\s*\w+\s*,\s*\w+/i, // packed eval
      /String\s*\.\s*fromCharCode\s*\(\s*parseInt/i, // char code obfuscation
      /while\s*\(\s*!!\s*\[\s*\]\s*\)/,           // infinite loop pattern
      /\}\s*\(\s*this\s*,\s*function\s*\(\s*\)\s*\{/i, // IIFE wrapper
    ];

    let score = 0;
    for (const pattern of indicators) {
      if (pattern.test(code)) score++;
    }

    // Check for high ratio of hex/unicode escapes
    const hexMatches = (code.match(/\\x[0-9a-f]{2}/gi) || []).length;
    const unicodeMatches = (code.match(/\\u[0-9a-f]{4}/gi) || []).length;
    if (hexMatches > 20 || unicodeMatches > 20) score++;

    // Check for very long single lines (minified + obfuscated)
    const lines = code.split('\n');
    const longLines = lines.filter(l => l.length > 1000).length;
    if (longLines > 0) score++;

    return score >= 2;
  }

  /**
   * Detect bundler type
   */
  static detectBundler(code) {
    if (code.includes('webpackJsonp') || code.includes('__webpack_require__')) {
      return 'webpack';
    }
    if (code.includes('__BROWSERIFY__') || /require\s*\(\s*\d+\s*\)/.test(code)) {
      return 'browserify';
    }
    if (code.includes('System.register')) {
      return 'systemjs';
    }
    if (code.includes('define(') && code.includes('require(')) {
      return 'amd';
    }
    return null;
  }
}

module.exports = Deobfuscator;
