/**
 * Smart Features - Handles cookie consent, infinite scroll, popups, and other smart behaviors
 */

class SmartFeatures {
  constructor() {
    this.dismissedBanners = new Set();
    this.detectedFeatures = {
      cookieConsent: false,
      infiniteScroll: false,
      lazyLoading: false,
      spa: false,
      serviceWorker: false,
    };
  }

  /**
   * Detect site features
   */
  async detectFeatures(page) {
    const features = await page.evaluate(() => {
      return {
        // Cookie consent detection
        cookieConsent: !!(
          document.querySelector('[class*="cookie"]') ||
          document.querySelector('[id*="cookie"]') ||
          document.querySelector('[class*="consent"]') ||
          document.querySelector('[class*="gdpr"]')
        ),

        // Infinite scroll detection
        infiniteScroll: !!(
          document.querySelector('[data-infinite]') ||
          document.querySelector('.infinite-scroll') ||
          document.querySelector('[class*="infinite"]') ||
          window.IntersectionObserver
        ),

        // Lazy loading detection
        lazyLoading: !!(
          document.querySelector('img[loading="lazy"]') ||
          document.querySelector('[data-src]') ||
          document.querySelector('.lazy')
        ),

        // SPA detection
        spa: !!(
          window.__NEXT_DATA__ ||
          window.__NUXT__ ||
          document.querySelector('#__next') ||
          document.querySelector('#app') ||
          document.querySelector('[ng-app]') ||
          window.React ||
          window.Vue ||
          window.angular
        ),

        // Service worker detection
        serviceWorker: 'serviceWorker' in navigator,

        // Framework detection
        framework: (function() {
          if (window.__NEXT_DATA__) return 'Next.js';
          if (window.__NUXT__) return 'Nuxt.js';
          if (window.React) return 'React';
          if (window.Vue) return 'Vue';
          if (window.angular) return 'Angular';
          if (window.Ember) return 'Ember';
          if (window.Svelte) return 'Svelte';
          return 'Unknown';
        })(),
      };
    });

    this.detectedFeatures = { ...this.detectedFeatures, ...features };
    return features;
  }

  /**
   * Handle cookie consent banners
   */
  async handleCookieConsent(page) {
    const consentSelectors = [
      // Accept buttons
      { selector: '#onetrust-accept-btn-handler', action: 'click' },
      { selector: '.cc-accept', action: 'click' },
      { selector: '.cc-allow', action: 'click' },
      { selector: '.gdpr-accept', action: 'click' },
      { selector: '[class*="cookie"] button[class*="accept"]', action: 'click' },
      { selector: '[class*="consent"] button[class*="accept"]', action: 'click' },
      { selector: 'button:has-text("Accept All")', action: 'click' },
      { selector: 'button:has-text("Accept Cookies")', action: 'click' },
      { selector: 'button:has-text("Accept all cookies")', action: 'click' },
      { selector: 'button:has-text("I Accept")', action: 'click' },
      { selector: 'button:has-text("I Agree")', action: 'click' },
      { selector: 'button:has-text("Got it")', action: 'click' },
      { selector: 'button:has-text("OK")', action: 'click' },
      { selector: '[aria-label="Accept cookies"]', action: 'click' },
      { selector: '[data-testid="cookie-accept"]', action: 'click' },

      // Close buttons
      { selector: '.cookie-banner .close', action: 'click' },
      { selector: '[class*="cookie"] [class*="close"]', action: 'click' },
      { selector: '[class*="consent"] [class*="close"]', action: 'click' },
    ];

    for (const { selector, action } of consentSelectors) {
      try {
        const element = await page.$(selector);
        if (element && await element.isVisible()) {
          if (action === 'click') {
            await element.click();
            this.dismissedBanners.add('cookie-consent');
            await page.waitForTimeout(500);
            return true;
          }
        }
      } catch {
        // Selector not found or not interactable
      }
    }

    return false;
  }

  /**
   * Handle newsletter/subscription popups
   */
  async handleNewsletterPopups(page) {
    const popupSelectors = [
      '.newsletter-popup .close',
      '.subscribe-popup .close',
      '[class*="newsletter"] [class*="close"]',
      '[class*="popup"] [class*="close"]',
      '.modal [class*="close"]',
      '[aria-label="Close"]',
      'button:has-text("No thanks")',
      'button:has-text("Not now")',
      'button:has-text("Maybe later")',
    ];

    for (const selector of popupSelectors) {
      try {
        const element = await page.$(selector);
        if (element && await element.isVisible()) {
          await element.click();
          this.dismissedBanners.add('newsletter-popup');
          await page.waitForTimeout(300);
          return true;
        }
      } catch {
        // Continue to next selector
      }
    }

    // Try pressing Escape as fallback
    await page.keyboard.press('Escape').catch(() => {});
    return false;
  }

  /**
   * Handle age verification gates
   */
  async handleAgeGates(page) {
    const ageGateSelectors = [
      'button:has-text("I am over 18")',
      'button:has-text("I am 18+")',
      'button:has-text("Yes, I am")',
      'button:has-text("Enter")',
      '[class*="age-gate"] button',
      '[class*="age-verification"] button',
    ];

    for (const selector of ageGateSelectors) {
      try {
        const element = await page.$(selector);
        if (element && await element.isVisible()) {
          await element.click();
          await page.waitForTimeout(500);
          return true;
        }
      } catch {
        // Continue
      }
    }

    return false;
  }

  /**
   * Handle infinite scroll
   */
  async handleInfiniteScroll(page, options = {}) {
    const {
      maxScrolls = 10,
      scrollDelay = 1000,
      waitForSelector = null,
    } = options;

    let previousHeight = 0;
    let currentHeight = await page.evaluate(() => document.body.scrollHeight);
    let scrollCount = 0;
    let newContentLoaded = true;

    while (scrollCount < maxScrolls && newContentLoaded) {
      previousHeight = currentHeight;

      // Scroll to bottom
      await page.evaluate(() => {
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: 'smooth'
        });
      });

      // Wait for new content
      await page.waitForTimeout(scrollDelay);

      // Wait for network idle
      await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => {});

      // Wait for specific selector if provided
      if (waitForSelector) {
        await page.waitForSelector(waitForSelector, { timeout: 5000 }).catch(() => {});
      }

      currentHeight = await page.evaluate(() => document.body.scrollHeight);
      newContentLoaded = currentHeight > previousHeight;
      scrollCount++;
    }

    return {
      scrollCount,
      finalHeight: currentHeight,
      contentLoaded: scrollCount > 0,
    };
  }

  /**
   * Handle lazy-loaded images
   */
  async triggerLazyLoading(page) {
    // Scroll through the page to trigger lazy loading
    const viewportHeight = await page.evaluate(() => window.innerHeight);
    const pageHeight = await page.evaluate(() => document.body.scrollHeight);

    const scrollSteps = Math.ceil(pageHeight / viewportHeight);

    for (let i = 0; i < scrollSteps; i++) {
      await page.evaluate((step, vh) => {
        window.scrollTo(0, step * vh);
      }, i, viewportHeight);
      await page.waitForTimeout(200);
    }

    // Scroll back to top
    await page.evaluate(() => window.scrollTo(0, 0));

    // Count loaded images
    const loadedImages = await page.$$eval('img', imgs =>
      imgs.filter(img => img.complete && img.naturalHeight > 0).length
    );

    return loadedImages;
  }

  /**
   * Handle single-page app navigation
   */
  async handleSpaNavigation(page, callback) {
    // Listen for URL changes
    let lastUrl = page.url();

    page.on('framenavigated', async (frame) => {
      if (frame === page.mainFrame()) {
        const newUrl = page.url();
        if (newUrl !== lastUrl) {
          lastUrl = newUrl;
          if (callback) {
            await callback(newUrl);
          }
        }
      }
    });

    // Also listen for history state changes
    await page.evaluate(() => {
      const originalPushState = history.pushState;
      const originalReplaceState = history.replaceState;

      history.pushState = function() {
        originalPushState.apply(history, arguments);
        window.dispatchEvent(new Event('pushstate'));
        window.dispatchEvent(new Event('locationchange'));
      };

      history.replaceState = function() {
        originalReplaceState.apply(history, arguments);
        window.dispatchEvent(new Event('replacestate'));
        window.dispatchEvent(new Event('locationchange'));
      };

      window.addEventListener('popstate', () => {
        window.dispatchEvent(new Event('locationchange'));
      });
    });
  }

  /**
   * Wait for SPA content to load
   */
  async waitForSpaContent(page, options = {}) {
    const {
      timeout = 10000,
      waitForSelector = null,
    } = options;

    // Wait for network idle
    await page.waitForLoadState('networkidle', { timeout }).catch(() => {});

    // Wait for common loading indicators to disappear
    const loadingSelectors = [
      '.loading',
      '.spinner',
      '[class*="loading"]',
      '[class*="spinner"]',
      '.skeleton',
      '[aria-busy="true"]',
    ];

    for (const selector of loadingSelectors) {
      try {
        await page.waitForSelector(selector, { state: 'hidden', timeout: 5000 });
      } catch {
        // Loading indicator not found or already hidden
      }
    }

    // Wait for specific selector if provided
    if (waitForSelector) {
      await page.waitForSelector(waitForSelector, { timeout }).catch(() => {});
    }

    // Small delay for any final rendering
    await page.waitForTimeout(500);
  }

  /**
   * Dismiss all overlays and popups
   */
  async dismissAllOverlays(page) {
    let dismissed = 0;

    // Handle cookie consent
    if (await this.handleCookieConsent(page)) dismissed++;

    // Handle newsletter popups
    if (await this.handleNewsletterPopups(page)) dismissed++;

    // Handle age gates
    if (await this.handleAgeGates(page)) dismissed++;

    // Generic overlay dismissal
    const overlaySelectors = [
      '.overlay .close',
      '.modal .close',
      '.popup .close',
      '[class*="overlay"] [class*="close"]',
      '[class*="modal"] [class*="close"]',
    ];

    for (const selector of overlaySelectors) {
      try {
        const element = await page.$(selector);
        if (element && await element.isVisible()) {
          await element.click();
          dismissed++;
          await page.waitForTimeout(300);
        }
      } catch {
        // Continue
      }
    }

    // Press Escape as a final fallback
    await page.keyboard.press('Escape').catch(() => {});

    return dismissed;
  }

  /**
   * Get detected features summary
   */
  getFeaturesSummary() {
    return {
      ...this.detectedFeatures,
      dismissedBanners: Array.from(this.dismissedBanners),
    };
  }
}

module.exports = SmartFeatures;
