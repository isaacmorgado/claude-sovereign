/**
 * Interaction Handler - Handles clicking, hovering, and interacting with page elements
 */

class InteractionHandler {
  constructor() {
    this.interactedElements = new Set();
    this.discoveredContent = [];
  }

  /**
   * Generate a unique identifier for an element
   */
  async getElementId(element) {
    try {
      return await element.evaluate(el => {
        const id = el.id ? `#${el.id}` : '';
        const classes = el.className ? `.${el.className.split(' ').join('.')}` : '';
        const tag = el.tagName.toLowerCase();
        const text = el.textContent?.trim().substring(0, 30) || '';
        return `${tag}${id}${classes}[${text}]`;
      });
    } catch {
      return null;
    }
  }

  /**
   * Check if element is visible and interactable
   */
  async isInteractable(element) {
    try {
      const box = await element.boundingBox();
      if (!box || box.width === 0 || box.height === 0) return false;

      const isVisible = await element.isVisible();
      if (!isVisible) return false;

      const isEnabled = await element.isEnabled();
      return isEnabled;
    } catch {
      return false;
    }
  }

  /**
   * Click all navigation-like elements
   */
  async clickNavigationElements(page) {
    const navigationSelectors = [
      'nav a',
      'header a',
      '[role="navigation"] a',
      '.navbar a',
      '.nav-link',
      '.menu-item a',
      '.navigation a',
    ];

    const clickedLinks = [];

    for (const selector of navigationSelectors) {
      try {
        const elements = await page.$$(selector);
        for (const element of elements) {
          const href = await element.getAttribute('href');
          if (href && !href.startsWith('#') && !href.startsWith('javascript:')) {
            clickedLinks.push(href);
          }
        }
      } catch {
        // Selector might not match anything
      }
    }

    return clickedLinks;
  }

  /**
   * Handle dropdown menus
   */
  async handleDropdowns(page) {
    const dropdownSelectors = [
      '.dropdown-toggle',
      '[data-toggle="dropdown"]',
      '[data-bs-toggle="dropdown"]',
      'button[aria-haspopup="true"]',
      'button[aria-haspopup="menu"]',
      '[role="menubutton"]',
      '.has-dropdown > a',
      '.menu-item-has-children > a',
    ];

    const discoveredLinks = [];

    for (const selector of dropdownSelectors) {
      try {
        const triggers = await page.$$(selector);

        for (const trigger of triggers) {
          const elementId = await this.getElementId(trigger);
          if (this.interactedElements.has(elementId)) continue;

          if (!(await this.isInteractable(trigger))) continue;

          try {
            // Hover first (some dropdowns are hover-triggered)
            await trigger.hover();
            await page.waitForTimeout(300);

            // Then click (for click-triggered dropdowns)
            await trigger.click();
            await page.waitForTimeout(500);

            // Capture any newly visible links
            const dropdownLinks = await page.$$eval(
              '.dropdown-menu a, [role="menu"] a, .submenu a',
              elements => elements.map(el => ({
                href: el.href,
                text: el.textContent?.trim(),
              }))
            );

            discoveredLinks.push(...dropdownLinks);
            this.interactedElements.add(elementId);

            // Close dropdown
            await page.keyboard.press('Escape');
            await page.waitForTimeout(200);
          } catch {
            // Element may have changed or not be interactable
          }
        }
      } catch {
        // Selector error
      }
    }

    return discoveredLinks;
  }

  /**
   * Handle accordion/collapsible sections
   */
  async handleAccordions(page) {
    const accordionSelectors = [
      '[data-toggle="collapse"]',
      '[data-bs-toggle="collapse"]',
      '.accordion-header',
      '.accordion-button',
      '.collapsible-header',
      '.expandable-header',
      'details > summary',
      '[aria-expanded="false"]',
    ];

    const discoveredContent = [];

    for (const selector of accordionSelectors) {
      try {
        const elements = await page.$$(selector);

        for (const element of elements) {
          const elementId = await this.getElementId(element);
          if (this.interactedElements.has(elementId)) continue;

          if (!(await this.isInteractable(element))) continue;

          try {
            await element.click();
            await page.waitForTimeout(500);

            // Get any newly visible content
            const expandedContent = await page.evaluate(() => {
              const expanded = document.querySelectorAll(
                '.accordion-collapse.show, .collapse.show, details[open], [aria-expanded="true"] + *'
              );
              return Array.from(expanded).map(el => ({
                html: el.innerHTML?.substring(0, 1000),
                links: Array.from(el.querySelectorAll('a')).map(a => a.href),
              }));
            });

            discoveredContent.push(...expandedContent);
            this.interactedElements.add(elementId);
          } catch {
            // Element interaction failed
          }
        }
      } catch {
        // Selector error
      }
    }

    return discoveredContent;
  }

  /**
   * Handle tab navigation
   */
  async handleTabs(page) {
    const tabSelectors = [
      '[role="tab"]',
      '.nav-tabs .nav-link',
      '.tab-button',
      '.tabs-header button',
      '[data-toggle="tab"]',
      '[data-bs-toggle="tab"]',
    ];

    const tabContent = [];

    for (const selector of tabSelectors) {
      try {
        const tabs = await page.$$(selector);

        for (const tab of tabs) {
          const elementId = await this.getElementId(tab);
          if (this.interactedElements.has(elementId)) continue;

          if (!(await this.isInteractable(tab))) continue;

          try {
            await tab.click();
            await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => {});

            // Capture tab panel content
            const panelContent = await page.evaluate(() => {
              const activePanel = document.querySelector(
                '[role="tabpanel"]:not([hidden]), .tab-pane.active, .tab-content.active'
              );
              if (activePanel) {
                return {
                  html: activePanel.innerHTML?.substring(0, 2000),
                  links: Array.from(activePanel.querySelectorAll('a')).map(a => a.href),
                };
              }
              return null;
            });

            if (panelContent) {
              tabContent.push(panelContent);
            }

            this.interactedElements.add(elementId);
          } catch {
            // Tab interaction failed
          }
        }
      } catch {
        // Selector error
      }
    }

    return tabContent;
  }

  /**
   * Handle pagination
   */
  async handlePagination(page, maxPages = 5) {
    const paginationSelectors = [
      '.pagination a',
      '.pager a',
      '[rel="next"]',
      'a[aria-label="Next"]',
      '.page-link',
      '.next-page',
      'button:has-text("Next")',
      'button:has-text("Load More")',
      '.load-more',
    ];

    const paginatedContent = [];
    let pagesTraversed = 0;

    while (pagesTraversed < maxPages) {
      let foundNext = false;

      for (const selector of paginationSelectors) {
        try {
          const nextButton = await page.$(selector);
          if (nextButton && (await this.isInteractable(nextButton))) {
            // Get current page content before navigating
            const currentContent = await page.content();
            paginatedContent.push(currentContent);

            await nextButton.click();
            await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});
            await page.waitForTimeout(1000);

            foundNext = true;
            pagesTraversed++;
            break;
          }
        } catch {
          // Selector or click failed
        }
      }

      if (!foundNext) break;
    }

    return paginatedContent;
  }

  /**
   * Handle "Load More" buttons for dynamic content
   */
  async handleLoadMore(page, maxClicks = 10) {
    const loadMoreSelectors = [
      'button:has-text("Load More")',
      'button:has-text("Show More")',
      'button:has-text("View More")',
      '.load-more',
      '.show-more',
      '[data-action="load-more"]',
      '.infinite-scroll-component button',
    ];

    let clicks = 0;

    for (const selector of loadMoreSelectors) {
      while (clicks < maxClicks) {
        try {
          const button = await page.$(selector);
          if (!button || !(await this.isInteractable(button))) break;

          await button.click();
          await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => {});
          await page.waitForTimeout(500);

          clicks++;
        } catch {
          break;
        }
      }
    }

    return clicks;
  }

  /**
   * Handle carousels/sliders
   */
  async handleCarousels(page) {
    const carouselSelectors = [
      '.carousel-control-next',
      '.slick-next',
      '.swiper-button-next',
      '[data-slide="next"]',
      '.carousel-next',
      '.slider-next',
    ];

    const carouselContent = [];

    for (const selector of carouselSelectors) {
      try {
        const nextBtn = await page.$(selector);
        if (!nextBtn) continue;

        // Click through carousel slides
        for (let i = 0; i < 10; i++) {
          if (!(await this.isInteractable(nextBtn))) break;

          await nextBtn.click();
          await page.waitForTimeout(500);

          // Capture current slide content
          const slideContent = await page.evaluate(() => {
            const activeSlide = document.querySelector(
              '.carousel-item.active, .slick-current, .swiper-slide-active'
            );
            return activeSlide?.innerHTML?.substring(0, 1000);
          });

          if (slideContent && !carouselContent.includes(slideContent)) {
            carouselContent.push(slideContent);
          }
        }
      } catch {
        // Carousel interaction failed
      }
    }

    return carouselContent;
  }

  /**
   * Get all unique links found through interactions
   */
  getAllDiscoveredLinks() {
    const allLinks = new Set();

    for (const content of this.discoveredContent) {
      if (content.links) {
        content.links.forEach(link => allLinks.add(link));
      }
    }

    return Array.from(allLinks);
  }

  /**
   * Run all interaction handlers
   */
  async runAll(page) {
    const results = {
      dropdowns: await this.handleDropdowns(page),
      accordions: await this.handleAccordions(page),
      tabs: await this.handleTabs(page),
      carousels: await this.handleCarousels(page),
      loadMoreClicks: await this.handleLoadMore(page),
    };

    // Collect all discovered links
    const allLinks = [];

    for (const item of results.dropdowns) {
      if (item.href) allLinks.push(item.href);
    }

    for (const item of results.accordions) {
      if (item.links) allLinks.push(...item.links);
    }

    for (const item of results.tabs) {
      if (item.links) allLinks.push(...item.links);
    }

    return {
      ...results,
      discoveredLinks: [...new Set(allLinks)],
    };
  }
}

module.exports = InteractionHandler;
