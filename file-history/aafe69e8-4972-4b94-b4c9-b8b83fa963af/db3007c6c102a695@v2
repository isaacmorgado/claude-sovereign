#!/bin/bash
# Memory System Edge Case Tests
# Based on research from:
# - Linux kernel race conditions (CVE-2025-38352, CVE-2025-8941)
# - Persistent memory bugs research
# - GitHub patterns from gluster, TDengine, byobu, etc.

set -uo pipefail

MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
TEST_DIR="/tmp/memory-test-$$"
RESULTS_FILE="/tmp/memory-test-results-$$.txt"
FAILURES=0
TESTS_RUN=0

# Colors for output
RED='\033[0:31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_test() {
    local test_name="$1"
    local status="$2"
    local message="${3:-}"

    TESTS_RUN=$((TESTS_RUN + 1))

    if [[ "$status" == "PASS" ]]; then
        echo -e "${GREEN}âœ“${NC} $test_name"
        echo "PASS: $test_name" >> "$RESULTS_FILE"
    elif [[ "$status" == "FAIL" ]]; then
        echo -e "${RED}âœ—${NC} $test_name${NC}"
        echo "  Error: $message"
        echo "FAIL: $test_name - $message" >> "$RESULTS_FILE"
        FAILURES=$((FAILURES + 1))
    elif [[ "$status" == "SKIP" ]]; then
        echo -e "${YELLOW}âŠ˜${NC} $test_name (skipped: $message)"
        echo "SKIP: $test_name - $message" >> "$RESULTS_FILE"
    fi
}

cleanup() {
    rm -rf "$TEST_DIR" 2>/dev/null || true
}

setup() {
    mkdir -p "$TEST_DIR"
    echo "=== Memory System Edge Case Tests ===" > "$RESULTS_FILE"
    echo "Started: $(date)" >> "$RESULTS_FILE"
    echo "" >> "$RESULTS_FILE"
}

# ============================================================================
# Category 1: RACE CONDITION TESTS
# ============================================================================

test_concurrent_writes_same_file() {
    local test_name="Concurrent writes to same file"
    local test_file="$TEST_DIR/concurrent_test.json"

    # Write to the same file from 5 parallel processes
    for i in {1..5}; do
        (
            $MEMORY_MANAGER add-context "test-$i" 5 2>/dev/null
        ) &
    done

    wait

    # Check if file is corrupted (should be valid JSON)
    if jq empty "$HOME/.claude/projects/-Users-imorgado/aafe69e8-4972-4b94-b4c9-b8b83fa963af/memory/master/working.json" 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "File corrupted after concurrent writes"
    fi
}

test_toctou_race() {
    local test_name="TOCTOU (Time-Of-Check-Time-Of-Use) race condition"

    # Simulate TOCTOU: check file existence then write
    # Multiple processes doing this simultaneously can cause issues
    local toctou_file="$TEST_DIR/toctou_test.txt"

    for i in {1..10}; do
        (
            if [[ ! -f "$toctou_file" ]]; then
                echo "Process $i" >> "$toctou_file"
            fi
        ) &
    done

    wait

    # All 10 should have written (TOCTOU vulnerability)
    local line_count=$(wc -l < "$toctou_file")
    if [[ "$line_count" -gt 1 ]]; then
        log_test "$test_name" "FAIL" "TOCTOU race detected: $line_count writes instead of 1"
    else
        log_test "$test_name" "PASS"
    fi
}

test_symlink_race() {
    local test_name="Symbolic link manipulation race"

    local target_file="$TEST_DIR/target.txt"
    local symlink="$TEST_DIR/symlink"

    echo "original" > "$target_file"

    # Create symlink
    ln -s "$target_file" "$symlink"

    # Try to exploit: change symlink while reading
    (
        for i in {1..100}; do
            echo "exploit" > "/tmp/exploit-$$"
            ln -sf "/tmp/exploit-$$" "$symlink" 2>/dev/null
        done
    ) &
    local exploit_pid=$!

    # Try to write securely
    local secure_write_failed=0
    for i in {1..100}; do
        if [[ -L "$symlink" ]]; then
            echo "test" > "$symlink" 2>/dev/null || secure_write_failed=$((secure_write_failed + 1))
        fi
    done

    kill $exploit_pid 2>/dev/null
    wait $exploit_pid 2>/dev/null

    if [[ "$secure_write_failed" -gt 50 ]]; then
        log_test "$test_name" "PASS" "Symlink manipulation detected and blocked"
    else
        log_test "$test_name" "FAIL" "Symlink race not properly handled"
    fi

    rm -f "/tmp/exploit-$$" 2>/dev/null
}

# ============================================================================
# Category 2: ATOMIC OPERATION TESTS
# ============================================================================

test_atomic_file_creation() {
    local test_name="Atomic file creation with mktemp"

    # Test if mktemp creates unique files atomically
    local temp_files=()
    for i in {1..20}; do
        (
            temp_file=$(mktemp "$TEST_DIR/atomic-XXXXXX")
            echo "$temp_file"
        ) &
    done | sort > "$TEST_DIR/temp_list.txt"

    wait

    # Check for duplicates
    local unique_count=$(sort -u "$TEST_DIR/temp_list.txt" | wc -l)
    local total_count=$(wc -l < "$TEST_DIR/temp_list.txt")

    if [[ "$unique_count" -eq "$total_count" ]]; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Duplicate temp files created"
    fi
}

test_flock_exclusive_access() {
    local test_name="flock exclusive access for concurrent writes"

    local lock_file="$TEST_DIR/flock_test.lock"
    local data_file="$TEST_DIR/flock_data.txt"
    echo "0" > "$data_file"

    # Multiple processes increment counter with flock
    for i in {1..50}; do
        (
            flock -x 200
            current=$(cat "$data_file")
            new=$((current + 1))
            echo "$new" > "$data_file"
        ) 200>"$lock_file" &
    done

    wait

    local final_value=$(cat "$data_file")
    if [[ "$final_value" -eq 50 ]]; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Expected 50, got $final_value (race condition detected)"
    fi
}

test_mv_atomic_replace() {
    local test_name="Atomic file replacement with mv"

    local target="$TEST_DIR/target.txt"
    local temp="$TEST_DIR/temp.txt"

    echo "original" > "$target"

    # Atomic replacement pattern
    echo "new" > "$temp"
    mv -f "$temp" "$target"

    local content=$(cat "$target")
    if [[ "$content" == "new" ]]; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Atomic replacement failed"
    fi
}

# ============================================================================
# Category 3: MEMORY CORRUPTION TESTS
# ============================================================================

test_null_byte_injection() {
    local test_name="Null byte injection handling"

    # Try to inject null bytes into memory
    if $MEMORY_MANAGER add-context "test$(printf '\x00')injection" 5 2>/dev/null; then
        # Check if it corrupted the JSON
        if jq empty "$HOME/.claude/projects/-Users-imorgado/aafe69e8-4972-4b94-b4c9-b8b83fa963af/memory/master/working.json" 2>/dev/null; then
            log_test "$test_name" "PASS"
        else
            log_test "$test_name" "FAIL" "Null byte corrupted JSON"
        fi
    else
        log_test "$test_name" "PASS" "Null byte rejected"
    fi
}

test_special_characters() {
    local test_name="Special character handling"

    local special_chars='"\\ $ ` \n \t \r'

    if $MEMORY_MANAGER add-context "$special_chars" 5 2>/dev/null; then
        if jq empty "$HOME/.claude/projects/-Users-imorgado/aafe69e8-4972-4b94-b4c9-b8b83fa963af/memory/master/working.json" 2>/dev/null; then
            log_test "$test_name" "PASS"
        else
            log_test "$test_name" "FAIL" "Special characters corrupted JSON"
        fi
    else
        log_test "$test_name" "FAIL" "Special characters rejected (should be escaped)"
    fi
}

test_very_large_input() {
    local test_name="Very large input handling"

    # Create 1MB string
    local large_string=$(dd if=/dev/zero bs=1024 count=1024 2>/dev/null | tr '\0' 'a')

    if $MEMORY_MANAGER add-context "$large_string" 5 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "PASS" "Large input rejected (acceptable)"
    fi
}

test_unicode_handling() {
    local test_name="Unicode and emoji handling"

    local unicode_text="Test with ä¸­æ–‡, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©, ðŸ”¥, ðŸ’», ðŸš€"

    if $MEMORY_MANAGER add-context "$unicode_text" 5 2>/dev/null; then
        if jq empty "$HOME/.claude/projects/-Users-imorgado/aafe69e8-4972-4b94-b4c9-b8b83fa963af/memory/master/working.json" 2>/dev/null; then
            log_test "$test_name" "PASS"
        else
            log_test "$test_name" "FAIL" "Unicode corrupted JSON"
        fi
    else
        log_test "$test_name" "FAIL" "Unicode rejected"
    fi
}

# ============================================================================
# Category 4: BOUNDARY CONDITION TESTS
# ============================================================================

test_empty_input() {
    local test_name="Empty input handling"

    if $MEMORY_MANAGER add-context "" 5 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "PASS" "Empty input rejected (acceptable)"
    fi
}

test_zero_importance() {
    local test_name="Zero importance value"

    if $MEMORY_MANAGER add-context "test" 0 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Zero importance should be valid"
    fi
}

test_negative_importance() {
    local test_name="Negative importance value"

    if $MEMORY_MANAGER add-context "test" -5 2>/dev/null; then
        log_test "$test_name" "PASS" "Negative importance rejected (correct)"
    else
        log_test "$test_name" "FAIL" "Negative importance accepted (should reject)"
    fi
}

test_very_high_importance() {
    local test_name="Very high importance value"

    if $MEMORY_MANAGER add-context "test" 1000000 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "PASS" "Very high importance rejected (acceptable)"
    fi
}

# ============================================================================
# Category 5: FILE SYSTEM EDGE CASES
# ============================================================================

test_disk_full_simulation() {
    local test_name="Disk full simulation"
    log_test "$test_name" "SKIP" "Requires root or special setup"
}

test_readonly_filesystem() {
    local test_name="Read-only filesystem handling"

    # Try to write to a read-only location
    if $MEMORY_MANAGER add-context "test" 5 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "SKIP" "Cannot test without special setup"
    fi
}

test_missing_parent_directory() {
    local test_name="Missing parent directory handling"

    local missing_dir="/tmp/nonexistent-$$/subdir/memory"

    # The memory manager should create parent directories
    # This tests if it handles mkdir -p correctly
    log_test "$test_name" "SKIP" "Requires memory manager modification"
}

test_permission_denied() {
    local test_name="Permission denied handling"

    local restricted_file="$TEST_DIR/restricted.txt"
    touch "$restricted_file"
    chmod 000 "$restricted_file"

    if echo "test" > "$restricted_file" 2>/dev/null; then
        log_test "$test_name" "FAIL" "Wrote to restricted file"
    else
        log_test "$test_name" "PASS"
    fi

    chmod 644 "$restricted_file"
}

# ============================================================================
# Category 6: CRASH/RECOVERY TESTS
# ============================================================================

test_interrupted_write() {
    local test_name="Interrupted write recovery"

    # Simulate interrupted write (kill process mid-write)
    (
        $MEMORY_MANAGER add-context "test before interrupt" 5 2>/dev/null &
        local pid=$!
        sleep 0.001
        kill -9 $pid 2>/dev/null
    )

    # Check if JSON is still valid
    if jq empty "$HOME/.claude/projects/-Users-imorgado/aafe69e8-4972-4b94-b4c9-b8b83fa963af/memory/master/working.json" 2>/dev/null; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "JSON corrupted after interrupted write"
    fi
}

test_partial_write_detection() {
    local test_name="Partial write detection"

    local test_file="$TEST_DIR/partial.json"

    # Write partial JSON
    echo '{"incomplete":' > "$test_file"

    if jq empty "$test_file" 2>/dev/null; then
        log_test "$test_name" "FAIL" "Partial JSON not detected"
    else
        log_test "$test_name" "PASS"
    fi
}

# ============================================================================
# Category 7: SUBSHELL AND SCOPE TESTS
# ============================================================================

test_subshell_variable_scope() {
    local test_name="Subshell variable scope"

    local outer_var="outer"
    (
        outer_var="inner"
        local inner_var="local"
    )

    if [[ "$outer_var" == "outer" ]]; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Subshell modified outer variable"
    fi
}

test_trap_cleanup_in_subshell() {
    local test_name="Trap cleanup in subshell"

    local cleanup_file="$TEST_DIR/cleanup_test.txt"

    (
        trap "echo 'cleaned' > '$cleanup_file'" EXIT
        exit 0
    )

    if [[ -f "$cleanup_file" ]] && [[ "$(cat "$cleanup_file")" == "cleaned" ]]; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Trap cleanup not executed"
    fi
}

# ============================================================================
# Category 8: MEMORY-SPECIFIC TESTS
# ============================================================================

test_duplicate_key_handling() {
    local test_name="Duplicate key handling in memory"

    # Add same key twice
    $MEMORY_MANAGER add-fact "test_category" "test_key" "value1" 0.8 2>/dev/null
    $MEMORY_MANAGER add-fact "test_category" "test_key" "value2" 0.9 2>/dev/null

    # Should handle gracefully (either reject or overwrite)
    log_test "$test_name" "PASS"
}

test_memory_retrieval_accuracy() {
    local test_name="Memory retrieval accuracy"

    # Add known data
    $MEMORY_MANAGER add-context "unique_test_string_12345" 9 2>/dev/null

    # Retrieve it
    local result=$($MEMORY_MANAGER get-working 2>/dev/null | grep -c "unique_test_string_12345" || echo 0)

    if [[ "$result" -gt 0 ]]; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Failed to retrieve stored memory"
    fi
}

test_memory_scoring_consistency() {
    local test_name="Memory scoring consistency"

    # Add multiple items with different scores
    $MEMORY_MANAGER add-context "low_priority" 1 2>/dev/null
    $MEMORY_MANAGER add-context "high_priority" 10 2>/dev/null

    # Retrieve with scoring
    local scored_result=$($MEMORY_MANAGER remember-scored "priority" 2>/dev/null || echo "{}")

    if echo "$scored_result" | jq -e '.results' >/dev/null 2>&1; then
        log_test "$test_name" "PASS"
    else
        log_test "$test_name" "FAIL" "Scoring function failed"
    fi
}

# ============================================================================
# RUN ALL TESTS
# ============================================================================

echo "Starting Memory System Edge Case Tests..."
echo "=========================================="
echo ""

setup

echo "Category 1: Race Condition Tests"
echo "---------------------------------"
test_concurrent_writes_same_file
test_toctou_race
test_symlink_race
echo ""

echo "Category 2: Atomic Operation Tests"
echo "-----------------------------------"
test_atomic_file_creation
test_flock_exclusive_access
test_mv_atomic_replace
echo ""

echo "Category 3: Memory Corruption Tests"
echo "------------------------------------"
test_null_byte_injection
test_special_characters
test_very_large_input
test_unicode_handling
echo ""

echo "Category 4: Boundary Condition Tests"
echo "-------------------------------------"
test_empty_input
test_zero_importance
test_negative_importance
test_very_high_importance
echo ""

echo "Category 5: File System Edge Cases"
echo "-----------------------------------"
test_disk_full_simulation
test_readonly_filesystem
test_missing_parent_directory
test_permission_denied
echo ""

echo "Category 6: Crash/Recovery Tests"
echo "---------------------------------"
test_interrupted_write
test_partial_write_detection
echo ""

echo "Category 7: Subshell and Scope Tests"
echo "-------------------------------------"
test_subshell_variable_scope
test_trap_cleanup_in_subshell
echo ""

echo "Category 8: Memory-Specific Tests"
echo "----------------------------------"
test_duplicate_key_handling
test_memory_retrieval_accuracy
test_memory_scoring_consistency
echo ""

# Summary
echo "=========================================="
echo "Test Results Summary"
echo "=========================================="
echo "Total tests run: $TESTS_RUN"
echo "Failures: $FAILURES"
echo "Success rate: $(( (TESTS_RUN - FAILURES) * 100 / TESTS_RUN ))%"
echo ""
echo "Detailed results saved to: $RESULTS_FILE"

cleanup

if [[ "$FAILURES" -gt 0 ]]; then
    echo -e "${RED}Some tests failed. Review results above.${NC}"
    exit 1
else
    echo -e "${GREEN}All tests passed!${NC}"
    exit 0
fi
