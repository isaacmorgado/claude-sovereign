/**
 * MultiAgent Browser Bridge - Popup Script
 *
 * Handles the popup UI for connecting to VS Code extension.
 */

document.addEventListener("DOMContentLoaded", async () => {
	// Elements
	const statusBadge = document.getElementById("status-badge")
	const statusText = document.getElementById("status-text")
	const serverUrlInput = document.getElementById("server-url")
	const connectBtn = document.getElementById("connect-btn")
	const disconnectBtn = document.getElementById("disconnect-btn")
	const connectedInfo = document.getElementById("connected-info")
	const networkToggle = document.getElementById("network-toggle")
	const consoleToggle = document.getElementById("console-toggle")

	// Get bridge state from background
	async function getBridgeState() {
		try {
			const response = await chrome.runtime.sendMessage({ type: "get_state" })
			return response
		} catch (error) {
			console.error("Failed to get bridge state:", error)
			return null
		}
	}

	// Update UI based on connection state
	function updateUI(state) {
		if (!state) {
			state = { connectionState: "disconnected" }
		}

		const { connectionState, serverUrl, networkMonitoringEnabled, consoleMonitoringEnabled } = state

		// Update status badge
		statusBadge.className = `status-badge status-${connectionState}`

		switch (connectionState) {
			case "disconnected":
				statusText.textContent = "Disconnected"
				connectBtn.disabled = false
				disconnectBtn.disabled = true
				connectedInfo.style.display = "none"
				break

			case "connecting":
				statusText.textContent = "Connecting..."
				connectBtn.disabled = true
				disconnectBtn.disabled = false
				connectedInfo.style.display = "none"
				break

			case "connected":
				statusText.textContent = "Connected to VS Code"
				connectBtn.disabled = true
				disconnectBtn.disabled = false
				connectedInfo.style.display = "block"
				break

			case "error":
				statusText.textContent = "Connection Error"
				connectBtn.disabled = false
				disconnectBtn.disabled = true
				connectedInfo.style.display = "none"
				break
		}

		// Update server URL input
		if (serverUrl) {
			serverUrlInput.value = serverUrl
		}

		// Update monitoring toggles
		if (networkMonitoringEnabled !== undefined) {
			networkToggle.checked = networkMonitoringEnabled
		}
		if (consoleMonitoringEnabled !== undefined) {
			consoleToggle.checked = consoleMonitoringEnabled
		}
	}

	// Connect button handler
	connectBtn.addEventListener("click", async () => {
		const serverUrl = serverUrlInput.value.trim()
		if (!serverUrl) {
			alert("Please enter a server URL")
			return
		}

		try {
			await chrome.runtime.sendMessage({
				type: "connect",
				payload: { serverUrl },
			})
		} catch (error) {
			console.error("Failed to connect:", error)
		}
	})

	// Disconnect button handler
	disconnectBtn.addEventListener("click", async () => {
		try {
			await chrome.runtime.sendMessage({ type: "disconnect" })
		} catch (error) {
			console.error("Failed to disconnect:", error)
		}
	})

	// Network monitoring toggle
	networkToggle.addEventListener("change", async () => {
		try {
			await chrome.runtime.sendMessage({
				type: networkToggle.checked ? "enable_network" : "disable_network",
			})
		} catch (error) {
			console.error("Failed to toggle network monitoring:", error)
		}
	})

	// Console monitoring toggle
	consoleToggle.addEventListener("change", async () => {
		try {
			await chrome.runtime.sendMessage({
				type: consoleToggle.checked ? "enable_console" : "disable_console",
			})
		} catch (error) {
			console.error("Failed to toggle console monitoring:", error)
		}
	})

	// Listen for state changes from background
	chrome.runtime.onMessage.addListener((message) => {
		if (message.type === "connection_state") {
			getBridgeState().then(updateUI)
		}
	})

	// Initial state load
	const initialState = await getBridgeState()
	updateUI(initialState)
})
